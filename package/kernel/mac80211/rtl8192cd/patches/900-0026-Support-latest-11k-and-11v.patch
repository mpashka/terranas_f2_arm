From 1f60ab022eb3c701e8e3c1fdbbd410510ae1b679 Mon Sep 17 00:00:00 2001
From: ywchen <ywchen@realtek.com>
Date: Mon, 10 Jul 2017 20:38:35 +0800
Subject: [PATCH] Support latest 11k and 11v

---
 8192cd.h                     |   70 ++-
 8192cd_11h.c                 |   27 +
 8192cd_11v.c                 | 1109 ++++++++++++++++++++++++++++++++++++++++++
 8192cd_11v.h                 |   74 +++
 8192cd_cfg.h                 |   15 +-
 8192cd_headers.h             |   39 +-
 8192cd_hw.c                  |   44 +-
 8192cd_ioctl.c               |   61 +--
 8192cd_osdep.c               |   26 +-
 8192cd_proc.c                |  181 ++++++-
 8192cd_sme.c                 | 1039 +++++++++++----------------------------
 8192cd_util.c                |    2 +-
 Makefile                     |    0
 dot11k/8192cd_11k_beacon.c   |    4 +-
 dot11k/8192cd_11k_neighbor.c |   12 +-
 ieee802_mib.h                |   39 +-
 wifi.h                       |   11 +-
 17 files changed, 1831 insertions(+), 922 deletions(-)
 create mode 100644 8192cd_11v.c
 create mode 100644 8192cd_11v.h

Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd.h
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/8192cd.h
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd.h
@@ -1556,11 +1556,17 @@ struct err_access_list {
 #endif
 
 #ifdef CONFIG_IEEE80211V
+//set bss transition client
+struct target_transition_list
+{
+    unsigned char addr[MACADDRLEN];
+};
+// set neighbor report parameter
 struct bss_transition_para
 {
     unsigned char addr[MACADDRLEN];
     unsigned char chan_until;
-    unsigned char isFromUser;	
+    unsigned char FomUser;	
 };
 
 struct dot11v_bss_candidate_subelement {
@@ -1786,8 +1792,21 @@ struct dot11k_stat_info
 
 #endif
 
+#ifdef CONFIG_IEEE80211V_CLI
+struct dot11v_stat_info {
+	unsigned char dialog_token;
+	unsigned char reply;
+	unsigned char num_neighbor_report; 
+	unsigned char req_mode;
+	unsigned short dissoc_timer;
+	unsigned char bss_termination_duration[12];
+	unsigned char target_bssid[MACADDRLEN];
+	unsigned int candidate_valid_time;
+	struct dot11k_neighbor_report neighbor_report[MAX_NEIGHBOR_REPORT];
+};
+#endif
 
-#ifdef CONFIG_IEEE80211R
+#if defined(CONFIG_IEEE80211R)
 struct r0_key_holder {
 	struct list_head list;
 	unsigned char sta_addr[MACADDRLEN];
@@ -2059,6 +2078,9 @@ struct stat_info {
 #ifdef DOT11K
     struct dot11k_stat_info rm;
 #endif
+#ifdef CONFIG_IEEE80211V_CLI
+   struct	dot11v_stat_info wnm;
+#endif
 
 #ifdef TCP_ACK_ACC
 	struct list_head	tcp_ses_list;
@@ -2217,6 +2239,10 @@ struct stat_info {
 	unsigned int		cur_tx_retry_cnt;
 	unsigned int		total_tx_retry_pkts;
 	unsigned int		total_tx_retry_cnt;
+	unsigned int		txretry_ratio;
+	unsigned int		prev_tx_pkts;
+	unsigned int		prev_tx_retry_pkts;
+
 #endif
 
 #ifdef PREVENT_BROADCAST_STORM
@@ -2338,11 +2364,12 @@ struct stat_info {
 	unsigned char			ft_auth_expire_to;
 #endif
 #ifdef CONFIG_IEEE80211V
+	int 				bssTransStatusCode;
 	unsigned char 		bssTransSupport;	
-	unsigned char 		rcvNeighborReport;
-#ifdef CONFIG_IEEE80211V_DB	
-	unsigned int 		bssTransReqCount;
-#endif
+	unsigned char 		bssTransRejectionCount;
+	unsigned char 		bssTransExpiredTime;
+	unsigned char		bssTransTriggered;
+	unsigned char 		rcvNeighborReport;	
 #endif
 #ifdef P2P_SUPPORT
 	unsigned char is_p2p_client;
@@ -2390,6 +2417,12 @@ struct stat_info {
 	unsigned int rx_time_total;
 	unsigned int rx_byte_last;
 #endif
+#ifdef CH_LOAD_CAL
+	unsigned int total_tx_time;
+	unsigned int prev_tx_byte;
+	unsigned int total_rx_time;
+	unsigned int prev_rx_byte;
+#endif
 #if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
 	unsigned long sleep_time;
 #endif
@@ -2476,7 +2509,11 @@ struct extra_stats {
 	unsigned long		rx_crc_by_rate[256];
 	unsigned long		rx_packets_by_rate[256];
 #endif
-
+#ifdef CH_LOAD_CAL
+	unsigned long		ch_utilization;
+	unsigned long		tx_time;
+	unsigned long		rx_time;
+#endif
 	unsigned long		tx_byte_cnt;
 	unsigned long		tx_avarage;
 	unsigned long		rx_byte_cnt;
@@ -3694,7 +3731,7 @@ struct mclone_sta_info {
 #endif
 
 
-#if defined(HS2_SUPPORT) || defined(DOT11K)
+#if 0//defined(HS2_SUPPORT) || defined(DOT11K) || defined(CH_LOAD_CAL)
 struct channel_utilization_info {
     unsigned char           cu_enable;
     unsigned char           channel_utilization;
@@ -4389,7 +4426,7 @@ struct priv_shared_info {
 #endif
 
 #if defined(HS2_SUPPORT) || defined(DOT11K)
-    struct channel_utilization_info      cu_info;
+//    struct channel_utilization_info      cu_info;
 #endif
 
 #if defined(STA_CONTROL) && defined(STA_CONTROL_AIPC)
@@ -5279,16 +5316,9 @@ typedef struct rtl8192cd_priv {
 #endif
 #ifdef CONFIG_IEEE80211V
 	struct bss_transition_para bssTransPara;
+	struct target_transition_list transition_list[MAX_TRANS_LIST_NUM];
+	unsigned char transition_list_bitmask[(MAX_TRANS_LIST_NUM + 7)/8];
 	bool 				startCounting;
-#ifdef CONFIG_IEEE80211V_DB
-	unsigned int		dot11DbCounter; 
-
-#ifdef CONFIG_IEEE80211V_DB_BS
-	unsigned int		BssDbBsDiassocCounter; 
-	struct list_head 	BssTransDbBsBlockList;
-	spinlock_t			BssTransDbBsBlockNodeLock;
-#endif
-#endif
 #endif
 #ifdef SUPPORT_MONITOR
 	struct timer_list		chan_switch_timer;
@@ -6124,7 +6154,7 @@ typedef struct rtl8192cd_priv {
 	unsigned int			proxy_arp;
 //#endif
 
-#if defined(HS2_SUPPORT) || defined(DOT11K)
+#if defined(HS2_SUPPORT) || defined(DOT11K) || defined(CH_LOAD_CAL)
     unsigned char           cu_enable; /*channel utilization calculated enable/disable*/
 #endif
 
@@ -6567,6 +6597,7 @@ typedef struct _sta_info_2_web {
 
 #ifdef CONFIG_IEEE80211V
 #define WNM_ENABLE				(priv->pmib->wnmEntry.dot11vBssTransEnable)
+#define EVENT_TIMEOUT			(priv->pmib->wnmEntry.bssTransExpiredTime)
 #endif
 
 #if defined(CONFIG_IEEE80211R) || defined(DOT11K)
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_11h.c
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/8192cd_11h.c
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_11h.c
@@ -169,6 +169,33 @@ static const COUNTRY_IE_ELEMENT countryI
 	{716,"ZW ", 3, 3}, /*ZIMBABWE*/
 };
 
+int  map_country_to_reg(struct rtl8192cd_priv *priv)
+{
+	int found = 0, i;
+	int country_num = sizeof(countryIEArray)/sizeof(COUNTRY_IE_ELEMENT);
+	char *CStringPtr =  priv->pmib->dot11dCountry.dot11CountryString ;
+
+	if ((GET_MIB(priv))->dot11dCountry.dot11CountryCodeToRegDomain) {
+		for (i=0; i < country_num; i++)  {
+			if (!memcmp(CStringPtr, countryIEArray[i].countryA2, 2)) {
+				found = 1;
+				break;
+			}
+		}
+
+		if (found == 0)
+			printk("can't found country code(%s),use default region\n",CStringPtr);
+
+		if ( found )
+			priv->pmib->dot11StationConfigEntry.dot11RegDomain = countryIEArray[i].G_Band_Region;
+
+		printk("acli: domain:%d cn: %s found: %d\n",
+		priv->pmib->dot11StationConfigEntry.dot11RegDomain, 
+		priv->pmib->dot11dCountry.dot11CountryString, found); 
+	}
+
+	return 0;   
+}
 
 static const BAND_TABLE_ELEMENT country_ie_channel_2_4g[] = {
     /* number of channel set | array of channel sets{first channel, num of channel,  tx power} 
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_11v.c
===================================================================
--- /dev/null
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_11v.c
@@ -0,0 +1,1109 @@
+
+
+#ifdef __KERNEL__
+#include <linux/module.h>
+#include <asm/byteorder.h>
+#elif defined(__ECOS)
+#include <cyg/io/eth/rltk/819x/wrapper/sys_support.h>
+#include <cyg/io/eth/rltk/819x/wrapper/skbuff.h>
+#include <cyg/io/eth/rltk/819x/wrapper/timer.h>
+#include <cyg/io/eth/rltk/819x/wrapper/wrapper.h>
+#endif
+
+#if !defined(__KERNEL__) && !defined(__ECOS)
+#include "../sys-support.h"
+#endif
+
+#include "./8192cd_headers.h"
+
+#ifdef __KERNEL__
+#include "../ieee802_mib.h"
+#elif defined(__ECOS)
+#include <cyg/io/eth/rltk/819x/wlan/ieee802_mib.h>
+#endif
+
+#include "./8192cd_debug.h"
+#include "./8192cd.h"
+#include "./8192cd_cfg.h"
+#include "./8192cd_11v.h"
+
+
+extern void qsort (void  *base, int nel, int width, int (*comp)(const void *, const void *));
+extern unsigned int issue_assocreq(struct rtl8192cd_priv *priv);
+
+#define _8192CD_11V_C_
+
+
+
+//++++++++ customized functions 
+typedef enum _PREFERENCE_ALGO_ {
+	ALGORITHM_0	= 0,
+	ALGORITHM_1	= 1
+} PREFERENCE_ALGO;
+
+inline unsigned char calculation_method0(bool excluded, unsigned char channel_utilization)
+{
+	if(excluded)
+		return 0;
+	return (MAX_PREFERRED_VAL - channel_utilization);
+}
+
+unsigned char getPreferredVal(struct rtl8192cd_priv *priv, unsigned char channel_utilization, unsigned char rcpi, bool excluded)
+{
+	unsigned char retval = 0;
+	if(!priv->bssTransPara.FomUser) {
+		switch(priv->pmib->wnmEntry.algoType)
+		{	
+			case ALGORITHM_0:
+				retval = calculation_method0(0, channel_utilization);
+				break;
+			default:
+				panic_printk("Undefined Algorithm Type! \n");
+				break;
+		}
+		
+		return retval;
+	}
+}
+
+#ifdef CONFIG_IEEE80211V_CLI
+
+static int validate_target_bssid(struct rtl8192cd_priv *priv, struct stat_info *pstat)
+{
+	int i = 0;
+
+	for(i=priv->join_index+1; i<priv->site_survey->count_target; i++) {
+		if(!memcmp(pstat->wnm.target_bssid, priv->site_survey->bss_target[i].bssid, MACADDRLEN)) {
+			return 0;
+		}
+	}
+	return -1;
+}
+
+#endif
+
+//--------- customized functions 
+
+#ifdef CONFIG_RTL_PROC_NEW
+int rtl8192cd_proc_transition_list_read(struct seq_file *s, void *data)
+#else
+int rtl8192cd_proc_transition_list_read(char *buf, char **start, off_t offset,
+        int length, int *eof, void *data)
+#endif
+{
+	struct net_device *dev = PROC_GET_DEV();
+	struct rtl8192cd_priv *priv = GET_DEV_PRIV(dev);
+	int pos = 0;
+	int i,j;
+	struct stat_info *pstat;
+
+	if((OPMODE & WIFI_AP_STATE) == 0) {
+	    panic_printk("\nwarning: invalid command!\n");
+	    return pos;
+	}
+
+	PRINT_ONE(" --Target Transition List  -- ", "%s", 1);
+	j = 1;
+	for (i = 0 ; i < MAX_TRANS_LIST_NUM; i++) 
+	{
+	    if((priv->transition_list_bitmask[i>>3] & (1<<(i&7))) == 0) 
+		continue;
+
+	    pstat = get_stainfo(priv, priv->transition_list[i].addr);
+	    if(pstat) {
+		    PRINT_ONE(j, "  [%d]", 0);
+	   	    PRINT_ARRAY_ARG("STA:", priv->transition_list[i].addr, "%02x", MACADDRLEN);
+		    PRINT_ONE("    BSS Trans Rejection Count:", "%s", 0);
+	           PRINT_ONE(pstat->bssTransRejectionCount, "%d", 1);
+	           PRINT_ONE("    BSS Trans Trans Expired Time:", "%s", 0);
+	           PRINT_ONE(pstat->bssTransExpiredTime, "%d", 1);
+	    }
+	    j++;
+	}
+	
+    	return pos;
+}
+
+#ifdef __ECOS
+int rtl8192cd_proc_transition_list_write(char *tmp, void *data)
+#else
+int rtl8192cd_proc_transition_list_write(struct file *file, const char *buffer,
+        unsigned long count, void *data)
+#endif
+{
+#ifdef __ECOS
+	return 0;
+#else
+	struct net_device *dev = (struct net_device *)data;
+	struct rtl8192cd_priv *priv = GET_DEV_PRIV(dev);
+	unsigned char error_code = 0;
+	char * tokptr;
+	int command = 0;
+	int empty_slot;
+	int i;
+	char tmp[TRANS_LIST_PROC_LEN];
+	char *tmpptr;
+	struct target_transition_list list;
+
+	if((OPMODE & WIFI_AP_STATE) == 0) {
+	    error_code = 1;
+	    goto end;
+	}
+	if (count < 2 || count >= TRANS_LIST_PROC_LEN) {
+	    return -EFAULT;
+	}
+
+	if (buffer == NULL || copy_from_user(tmp, buffer, count))
+	    return -EFAULT;
+
+	tmp[count] = 0;
+	tmpptr = tmp;
+	tmpptr = strsep((char **)&tmpptr, "\n");
+	tokptr = strsep((char **)&tmpptr, " ");
+	if(!memcmp(tokptr, "add", 3))
+		command = 1;
+	else if (!memcmp(tokptr, "delall", 6)) 
+	   	command = 3;
+	else if(!memcmp(tokptr, "del", 3))
+       	command = 2;
+
+	if(command) 
+	{        
+	    if(command == 1 || command == 2) {
+	        tokptr = strsep((char **)&tmpptr," ");
+	        if(tokptr)
+	            get_array_val(list.addr, tokptr, 12);
+	        else {
+	            error_code = 1;
+	            goto end;
+	        }
+	    }
+	    
+	    if(command == 1)   /*add*/
+	    {	  
+			for(i = 0, empty_slot = -1; i < MAX_TRANS_LIST_NUM; i++)
+		       {
+		            if((priv->transition_list_bitmask[i>>3] & (1<<(i&7))) == 0) {
+		            	if(empty_slot == -1)
+		            		empty_slot = i;
+		            }else if(0 == memcmp(list.addr, priv->transition_list[i].addr, MACADDRLEN)) {
+		            	break;
+		            }	
+		        }
+				
+		       if(i == MAX_TRANS_LIST_NUM && empty_slot != -1) {/*not found, and has empty slot*/
+		        	i = empty_slot;
+		        }		
+			memcpy(&priv->transition_list[i], &list, sizeof(struct target_transition_list));
+		     	priv->transition_list_bitmask[i>>3] |= (1<<(i&7));  
+	    }
+	    else if(command == 3)   /*delete all*/
+	    {
+	        	memset(priv->transition_list_bitmask, 0x00, sizeof(priv->transition_list_bitmask));
+	    }
+	   else if(command == 2)  /*delete*/
+	   {
+			for (i = 0 ; i < MAX_TRANS_LIST_NUM; i++) {
+			        if((priv->transition_list_bitmask[i>>3] & (1<<(i&7))) == 0)
+			        	continue;
+			    
+			        if(0 == memcmp(list.addr, priv->transition_list[i].addr, MACADDRLEN)) {
+			        	priv->transition_list_bitmask[i>>3] &= ~(1<<(i&7));
+			        	break;
+			        }
+			}
+	    }
+	}
+	else {
+		    error_code = 1;
+		    goto end;
+	}
+
+	end:
+	if(error_code == 1)
+	    panic_printk("\nwarning: invalid command!\n");
+	else if(error_code == 2)
+	    panic_printk("\nwarning: neighbor report table full!\n");
+	return count;
+#endif
+}
+
+void send_bss_trans_event(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char i)
+{
+	if (priv->pmib->wnmEntry.dot11vDiassocDeadline)
+		pstat->expire_to = priv->pmib->wnmEntry.dot11vDiassocDeadline;
+	else
+		pstat->expire_to = MAX_FTREASSOC_DEADLINE;
+
+	if(issue_BSS_Trans_Req(priv, priv->transition_list[i].addr, NULL) == SUCCESS) {
+		pstat->bssTransExpiredTime = 0;
+		pstat->bssTransTriggered = TRUE;
+		priv->startCounting = TRUE;
+
+		DOT11VDEBUG("Send BSS Trans Req to STA [SUCCESS]:[%02x][%02x][%02x][%02x][%02x][%02x] \n", 
+				priv->transition_list[i].addr[0], priv->transition_list[i].addr[1], priv->transition_list[i].addr[2], 
+				priv->transition_list[i].addr[3], priv->transition_list[i].addr[4], priv->transition_list[i].addr[5]);
+	}
+}
+
+void process_BssTransReq(struct rtl8192cd_priv *priv)
+{
+	struct stat_info *pstat;
+	int i, j = 0;
+    	unsigned long flags;
+
+	SAVE_INT_AND_CLI(flags);
+	for (i = 0; i < MAX_TRANS_LIST_NUM; i++) {
+		if((priv->transition_list_bitmask[i>>3] & (1<<(i&7))) == 0) {
+			j++;
+			continue;
+		}
+		
+		pstat = get_stainfo(priv, priv->transition_list[i].addr);		
+		if(pstat) {
+			if(priv->pmib->wnmEntry.Is11kDaemonOn) {			//collect neighbor report by dot11k daemon
+				if(pstat->rcvNeighborReport) 
+					send_bss_trans_event(priv, pstat, i);
+				else
+					panic_printk("Target clients may not Ready yet!!\n");
+			}else
+				send_bss_trans_event(priv, pstat, i);
+		}else
+			panic_printk("No such station(%d):[%02x][%02x][%02x][%02x][%02x][%02x] \n", i,
+							priv->transition_list[i].addr[0], priv->transition_list[i].addr[1], priv->transition_list[i].addr[2], 
+							priv->transition_list[i].addr[3], priv->transition_list[i].addr[4], priv->transition_list[i].addr[5]);
+		
+	}
+	RESTORE_INT(flags);
+
+	if(j == MAX_TRANS_LIST_NUM)
+		panic_printk("Transition List is empty !!\n");
+	
+}
+
+void BssTrans_ExpiredTimer(struct rtl8192cd_priv *priv)
+{
+	int i;
+	unsigned long flags;
+	struct stat_info *pstat;
+
+	SAVE_INT_AND_CLI(flags);
+	for (i = 0; i < MAX_TRANS_LIST_NUM; i++) {
+		if((priv->transition_list_bitmask[i>>3] & (1<<(i&7))) == 0) 
+			continue;
+
+		pstat = get_stainfo(priv, priv->transition_list[i].addr);
+		if(pstat) {
+			if(pstat->bssTransTriggered) 	// client does not reply bss trans request
+				pstat->bssTransExpiredTime++;
+
+			if(pstat->bssTransExpiredTime == EVENT_TIMEOUT)	
+				pstat->bssTransStatusCode = _TIMEOUT_STATUS_CODE_;
+		}
+	}
+	RESTORE_INT(flags);
+}
+
+void BssTrans_DiassocTimer(struct rtl8192cd_priv *priv)
+{
+	int i;
+	struct stat_info *pstat;
+	unsigned long flags;
+	
+	if(!priv->pmib->wnmEntry.dot11vDiassocDeadline) 
+		priv->startCounting  = FALSE;
+	
+	if(priv->startCounting  == TRUE && priv->pmib->wnmEntry.dot11vDiassocDeadline) {
+		priv->pmib->wnmEntry.dot11vDiassocDeadline--;
+		DOT11VDEBUG("Counting down= %d\n", priv->pmib->wnmEntry.dot11vDiassocDeadline);
+		if(!priv->pmib->wnmEntry.dot11vDiassocDeadline) {
+			SAVE_INT_AND_CLI(flags);
+			for (i = 0; i < MAX_TRANS_LIST_NUM; i++) {
+				if((priv->transition_list_bitmask[i>>3] & (1<<(i&7))) == 0) 
+					continue;
+
+				pstat = get_stainfo(priv, priv->transition_list[i].addr);
+				if(!pstat) {
+					panic_printk("Cant find associated STA (%02x%02x%02x%02x%02x%02x)\n",
+						priv->transition_list[i].addr[0], priv->transition_list[i].addr[1], priv->transition_list[i].addr[2]
+						,priv->transition_list[i].addr[3], priv->transition_list[i].addr[4], priv->transition_list[i].addr[5]);
+				} else {
+					panic_printk("issue diassoc to trigger bss transition!!\n");
+					issue_disassoc(priv, priv->transition_list[i].addr, _RSON_DISASSOC_DUE_BSS_TRANSITION);
+					del_station(priv, pstat, 0);		
+				}
+				priv->startCounting  = FALSE;
+			}   
+			RESTORE_INT(flags);
+		}
+	}
+}
+
+void reset_staBssTransStatus(struct stat_info *pstat)
+{
+	pstat->bssTransRejectionCount = 0;
+	pstat->bssTransExpiredTime = 0;
+	pstat->rcvNeighborReport = 0;
+	pstat->bssTransTriggered = 0;
+	pstat->bssTransStatusCode = _DEFAULT_STATUS_CODE_;
+}
+
+void set_staBssTransCap(struct stat_info *pstat, unsigned char *pframe, int frameLen, unsigned short ie_offset)
+{
+	int ie_len = 0;
+	unsigned char *ext_cap = NULL;
+	unsigned char *p = get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _EXTENDED_CAP_IE_, &ie_len,  frameLen);
+
+	ext_cap = (unsigned char *)kmalloc(ie_len, GFP_ATOMIC);
+	
+	if(p != NULL) {
+		memcpy(ext_cap, p+2, ie_len);
+		if(ext_cap[2] & _WNM_BSS_TRANS_SUPPORT_) {
+			pstat->bssTransSupport = TRUE;
+		}else {	// when there are 2 extended Capabilities IE (IOT issue with Fujitsu)
+			p = p + ie_len + 2;
+			if(*p == _EXTENDED_CAP_IE_){
+				ie_len = *(p+1);
+				memcpy(ext_cap, p+2, ie_len);
+				if(ext_cap[2] & _WNM_BSS_TRANS_SUPPORT_)
+					pstat->bssTransSupport = TRUE;
+			}
+		}
+	}
+	pstat->bssTransStatusCode = _DEFAULT_STATUS_CODE_;
+	kfree(ext_cap);
+	DOT11VDEBUG("pstat->dot11v_support  %d\n", pstat->bssTransSupport);
+}
+
+void set_BssTransPara(struct rtl8192cd_priv *priv, unsigned char *tmpbuf)
+{
+	int i, empty_slot;
+
+	priv->bssTransPara.FomUser = TRUE;
+	
+	memcpy(priv->bssTransPara.addr, tmpbuf, MACADDRLEN);
+	priv->bssTransPara.chan_until = tmpbuf[MACADDRLEN];
+
+       for(i = 0, empty_slot = -1; i < MAX_NEIGHBOR_REPORT; i++) {
+                if((priv->rm_neighbor_bitmask[i>>3] & (1<<(i&7))) == 0) {
+                    if(empty_slot == -1)
+                        empty_slot = i;
+                } else if(0 == memcmp(priv->bssTransPara.addr, priv->rm_neighbor_report[i].bssid, MACADDRLEN)) {
+                    break;
+                }
+        }
+        if(i == MAX_NEIGHBOR_REPORT && empty_slot != -1)   /*not found, and has empty slot*/
+        {
+                i = empty_slot;
+        }
+	
+   	DOT11VTRACE("(%s)line=%d, i = %d\n", __FUNCTION__, __LINE__, i);
+}
+
+int issue_BSS_Trans_Req(struct rtl8192cd_priv *priv, unsigned char *da, unsigned char dialog_token)
+{	
+	int ret;
+	unsigned char  *pbuf;
+    	unsigned int frlen = 0;
+	int neighbor_size = 0, i =0;
+	
+	unsigned char req_mode = priv->pmib->wnmEntry.dot11vReqMode;
+	unsigned short diassoc_time = priv->pmib->wnmEntry.dot11vDiassocDeadline;
+	struct stat_info *pstat = get_stainfo(priv, da);
+	DECLARE_TXINSN(txinsn);
+
+	DOT11VTRACE("Req mode=%x, diassoc_time = %d, %x\n", req_mode, diassoc_time, cpu_to_le16(diassoc_time));
+	
+	txinsn.q_num = MANAGE_QUE_NUM;
+	txinsn.fr_type = _PRE_ALLOCMEM_;
+	txinsn.tx_rate = find_rate(priv, NULL, 0, 1);
+#ifndef TX_LOWESTRATE	
+	txinsn.lowest_tx_rate = txinsn.tx_rate;
+#endif
+	txinsn.fixed_rate = 1;
+
+#ifdef CONFIG_IEEE80211W	
+	 if(pstat)
+		 txinsn.isPMF = pstat->isPMF;
+	 else
+		 txinsn.isPMF = 0;
+#endif
+	pbuf = txinsn.pframe = get_mgtbuf_from_poll(priv);
+	if (pbuf == NULL)
+	    goto issue_wnm_bss_trans_fail;
+
+	txinsn.phdr = get_wlanhdr_from_poll(priv);
+	if (txinsn.phdr == NULL)
+	    goto issue_wnm_bss_trans_fail;
+
+	memset((void *)(txinsn.phdr), 0, sizeof(struct wlan_hdr));
+
+	pbuf[frlen++]= _WNM_CATEGORY_ID_; 
+	pbuf[frlen++] = _BSS_TSMREQ_ACTION_ID_;
+
+	if (!(++pstat->dialog_token))	// dialog token set to a non-zero value
+       	pstat->dialog_token++;	
+	
+	//dialog_token(1): require mode field(1): dissoc timer(2): validity interval(1)
+	if(req_mode & (_WNM_PREFERRED_CANDIDATE_LIST_|_WNM_ABRIDGED_)) {
+		pbuf[frlen++] = pstat->dialog_token;
+		pbuf[frlen++]  = req_mode; 	
+		 *(unsigned short *)(pbuf + frlen) = cpu_to_le16(diassoc_time);
+		frlen += 2;
+		pbuf[frlen++]  = 200;	//validity interval
+		pbuf += frlen;
+#ifdef DOT11K
+		neighbor_size = sizeof(struct dot11k_neighbor_report);
+		for(i = 0; i < MAX_NEIGHBOR_REPORT; i++) {
+	   		if((priv->rm_neighbor_bitmask[i>>3] & (1<<(i&7))) == 0)
+	    			continue;
+	    		if(frlen + neighbor_size > MAX_REPORT_FRAME_SIZE)
+	    			break;
+	    		
+			pbuf = construct_neighbor_report_ie(pbuf, &frlen, &priv->rm_neighbor_report[i]);
+	    	}
+#endif
+	}else {
+		panic_printk("Type2 : Bss Trans Req with no neighbor report \n"); 	
+		pbuf[frlen++] = pstat->dialog_token;			
+		pbuf[frlen++]  = 0; 				
+		 *(unsigned short *)(pbuf + frlen) = cpu_to_le16(0);	
+		frlen += 2;
+		pbuf[frlen++]  = 1;					
+		pbuf += frlen;
+	}
+	
+	txinsn.fr_len = frlen;
+    	SetFrameSubType((txinsn.phdr), WIFI_WMM_ACTION);
+#ifdef CONFIG_IEEE80211W	
+	if (txinsn.isPMF)
+		*(unsigned char*)(txinsn.phdr+1) |= BIT(6); // enable privacy 
+#endif
+   	memcpy((void *)GetAddr1Ptr((txinsn.phdr)), da, MACADDRLEN);
+    	memcpy((void *)GetAddr2Ptr((txinsn.phdr)), GET_MY_HWADDR, MACADDRLEN);
+   	memcpy((void *)GetAddr3Ptr((txinsn.phdr)), BSSID, MACADDRLEN);
+	
+#if defined(WIFI_WMM)
+   	ret = check_dz_mgmt(priv, pstat, &txinsn);
+    
+    if (ret < 0)
+        goto issue_wnm_bss_trans_fail;
+    else if (ret==1)
+        return 0;
+    else
+#endif
+	if ((rtl8192cd_firetx(priv, &txinsn)) == SUCCESS) 
+		return 0;
+	
+issue_wnm_bss_trans_fail:
+
+	if (txinsn.phdr)
+		release_wlanhdr_to_poll(priv, txinsn.phdr);
+	if (txinsn.pframe)
+		release_mgtbuf_to_poll(priv, txinsn.pframe);
+	return -1;
+}
+
+#ifdef CONFIG_IEEE80211V_CLI
+static void reset_nieghbor_list_pref_val(struct rtl8192cd_priv *priv, struct stat_info *pstat)
+{
+	int i = 0;
+	struct dot11k_neighbor_report *report;
+
+	if(pstat->wnm.num_neighbor_report == 0) {
+		panic_printk("(%s)line=%d, Table is empty!! No need to update!! \n", __FUNCTION__, __LINE__); 
+		return;
+	}
+	
+	DOT11VTRACE(" Candidate List valid timeout !!\n");
+	for (i = 0 ; i < pstat->wnm.num_neighbor_report; i++) {
+		report = &pstat->wnm.neighbor_report[i];
+		report->subelemnt.preference = priv->pmib->wnmEntry.defaultPrefVal;
+	}
+}
+
+void BssTrans_ValidatePrefListTimer(struct rtl8192cd_priv *priv)
+{
+	struct stat_info *pstat;
+	pstat = get_stainfo(priv, priv->pmib->dot11StationConfigEntry.dot11Bssid);
+	if(pstat) {
+		if(pstat->wnm.candidate_valid_time > 0) {
+			DOT11VTRACE("candidate_valid_time = %d\n", pstat->wnm.candidate_valid_time);
+			pstat->wnm.candidate_valid_time--;
+			
+			if(pstat->wnm.candidate_valid_time == 0) 
+				reset_nieghbor_list_pref_val(priv, pstat);
+		}	
+    	}
+}
+
+void BssTrans_TerminationTimer(struct rtl8192cd_priv *priv)
+{
+	struct stat_info *pstat;
+	pstat = get_stainfo(priv, priv->pmib->dot11StationConfigEntry.dot11Bssid);
+	if(pstat) {
+		if(pstat->wnm.dissoc_timer > 0) {
+			DOT11VTRACE("bss_termination_duration = %d\n", pstat->wnm.dissoc_timer);
+			pstat->wnm.dissoc_timer--;
+			
+			if(pstat->wnm.candidate_valid_time == 0) {
+				DOT11VDEBUG("bss_termination_duration is time up, diassoc to current AP \n");
+				//Assume the termination from the AP is collided, so client send diassoc to connecting AP
+				issue_disassoc(priv, pstat->hwaddr, _RSON_DISASSOC_DUE_BSS_TRANSITION);
+				del_station(priv, pstat, 0);
+			}	
+		}	
+    	}
+}
+
+// optional: can use function call this API. At present, it's useless
+int  issue_BSS_Trans_Query(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char reason)
+{
+	int ret;
+    	unsigned char *pbuf;
+    	unsigned int frlen = 0;	
+
+	DECLARE_TXINSN(txinsn);
+	txinsn.q_num = MANAGE_QUE_NUM;
+	txinsn.fr_type = _PRE_ALLOCMEM_;
+	txinsn.tx_rate = find_rate(priv, NULL, 0, 1);
+#ifndef TX_LOWESTRATE	
+	txinsn.lowest_tx_rate = txinsn.tx_rate;
+#endif
+	txinsn.fixed_rate = 1;
+
+#ifdef CONFIG_IEEE80211W	
+	 if(pstat)
+		 txinsn.isPMF = pstat->isPMF;
+	 else
+		 txinsn.isPMF = 0;
+#endif
+	pbuf = txinsn.pframe = get_mgtbuf_from_poll(priv);
+	if (pbuf == NULL)
+	    goto issue_bss_trans_query_fail;
+
+	txinsn.phdr = get_wlanhdr_from_poll(priv);
+	if (txinsn.phdr == NULL)
+	    goto issue_bss_trans_query_fail;
+
+	memset((void *)(txinsn.phdr), 0, sizeof(struct wlan_hdr));
+
+	if (!(++pstat->dialog_token))	// dialog token set to a non-zero value
+       	pstat->dialog_token++;	
+	
+	pbuf[frlen++] = _WNM_CATEGORY_ID_;
+    	pbuf[frlen++] = _WNM_TSMQUERY_ACTION_ID_;
+	pbuf[frlen++] = pstat->dialog_token;
+	pbuf[frlen++] = reason;
+		
+	txinsn.fr_len += frlen;
+	SetFrameSubType((txinsn.phdr), WIFI_WMM_ACTION);
+#ifdef CONFIG_IEEE80211W
+    	if (txinsn.isPMF)
+		*(unsigned char*)(txinsn.phdr+1) |= BIT(6); // enable privacy 
+#endif
+	memcpy((void *)GetAddr1Ptr((txinsn.phdr)), pstat->hwaddr, MACADDRLEN);
+	memcpy((void *)GetAddr2Ptr((txinsn.phdr)), GET_MY_HWADDR, MACADDRLEN);
+	memcpy((void *)GetAddr3Ptr((txinsn.phdr)), BSSID, MACADDRLEN);
+
+#if defined(WIFI_WMM)
+    	ret = check_dz_mgmt(priv, pstat, &txinsn);
+    	if (ret < 0)
+       	 goto issue_bss_trans_query_fail;
+    	else if (ret==1)
+       	 return 0;
+    	else
+#endif
+    	if ((rtl8192cd_firetx(priv, &txinsn)) == SUCCESS)
+        	return 0;
+		
+issue_bss_trans_query_fail:
+	if (txinsn.phdr)
+       	 release_wlanhdr_to_poll(priv, txinsn.phdr);
+    	if (txinsn.pframe)
+        	release_mgtbuf_to_poll(priv, txinsn.pframe);
+
+	return -1;
+}
+
+int issue_BSS_Trans_Rsp(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char dialog_token, enum bss_trans_mgmt_status_code status)
+{
+	int ret;
+    	unsigned char *pbuf;
+    	unsigned int frlen = 0;
+    	
+	DECLARE_TXINSN(txinsn);
+	txinsn.q_num = MANAGE_QUE_NUM;
+	txinsn.fr_type = _PRE_ALLOCMEM_;
+	txinsn.tx_rate = find_rate(priv, NULL, 0, 1);
+#ifndef TX_LOWESTRATE	
+	txinsn.lowest_tx_rate = txinsn.tx_rate;
+#endif
+	txinsn.fixed_rate = 1;
+
+#ifdef CONFIG_IEEE80211W	
+	 if(pstat)
+		 txinsn.isPMF = pstat->isPMF;
+	 else
+		 txinsn.isPMF = 0;
+#endif
+	pbuf = txinsn.pframe = get_mgtbuf_from_poll(priv);
+	if (pbuf == NULL)
+	    goto issue_bss_trans_rsp_fail;
+
+	txinsn.phdr = get_wlanhdr_from_poll(priv);
+	if (txinsn.phdr == NULL)
+	    goto issue_bss_trans_rsp_fail;
+
+	memset((void *)(txinsn.phdr), 0, sizeof(struct wlan_hdr));
+
+	pbuf[frlen++] = _WNM_CATEGORY_ID_;
+    	pbuf[frlen++] = _BSS_TSMRSP_ACTION_ID_;
+    	pbuf[frlen++] = dialog_token;
+	pbuf[frlen++] = status;
+	pbuf[frlen++] = 0;	// BSS Termination Delay
+
+	if(pstat->wnm.target_bssid) {
+		memcpy(pbuf+frlen, pstat->wnm.target_bssid, MACADDRLEN);
+	}else if(status == WNM_BSS_TM_ACCEPT) {
+		/*
+		 * P802.11-REVmc clarifies that the Target BSSID field is always
+		 * present when status code is zero, so use a fake value here if
+		 * no BSSID is yet known.
+		 */
+		memset(pbuf+frlen, 0, MACADDRLEN);
+	}
+	
+	DOT11VDEBUG("Target bssid:[%02x]:[%02x]:[%02x]:[%02x]:[%02x]:[%02x] \n",  
+				pstat->wnm.target_bssid[0], pstat->wnm.target_bssid[1], pstat->wnm.target_bssid[2], 
+				pstat->wnm.target_bssid[3], pstat->wnm.target_bssid[4], pstat->wnm.target_bssid[5]);
+
+	frlen += MACADDRLEN;
+	txinsn.fr_len += frlen;
+	SetFrameSubType((txinsn.phdr), WIFI_WMM_ACTION);
+#ifdef CONFIG_IEEE80211W
+    	if (txinsn.isPMF)
+		*(unsigned char*)(txinsn.phdr+1) |= BIT(6); // enable privacy 
+#endif
+	memcpy((void *)GetAddr1Ptr((txinsn.phdr)), pstat->hwaddr, MACADDRLEN);
+	memcpy((void *)GetAddr2Ptr((txinsn.phdr)), GET_MY_HWADDR, MACADDRLEN);
+	memcpy((void *)GetAddr3Ptr((txinsn.phdr)), BSSID, MACADDRLEN);
+
+#if defined(WIFI_WMM)
+    	ret = check_dz_mgmt(priv, pstat, &txinsn);
+    	if (ret < 0)
+       	 goto issue_bss_trans_rsp_fail;
+    	else if (ret==1)
+       	 return 0;
+    	else
+#endif
+    	if ((rtl8192cd_firetx(priv, &txinsn)) == SUCCESS)
+        	return 0;
+		
+issue_bss_trans_rsp_fail:
+	if (txinsn.phdr)
+       	 release_wlanhdr_to_poll(priv, txinsn.phdr);
+    	if (txinsn.pframe)
+        	release_mgtbuf_to_poll(priv, txinsn.pframe);
+
+	return -1;
+}
+
+static int cand_pref_compar(const void *a, const void *b)
+{
+	const struct dot11k_neighbor_report *aa = a;
+	const struct dot11k_neighbor_report *bb = b;
+
+	if (!aa->subelemnt.preference && !bb->subelemnt.preference) {
+		return 0;
+	}
+	if (!aa->subelemnt.preference) {
+		return 1;
+	}
+	if (!bb->subelemnt.preference) {
+		return -1;
+	}
+	
+	if (bb->subelemnt.preference > aa->subelemnt.preference)
+		return 1;
+	if (bb->subelemnt.preference < aa->subelemnt.preference)
+		return -1;
+	
+	return 0;
+}
+
+static void update_neighbor_report(struct rtl8192cd_priv *priv, struct stat_info *pstat)
+{
+	int i = 0, num_empty_report = 0;
+	unsigned char null_mac[] = {0,0,0,0,0,0};
+	
+	if(pstat->wnm.num_neighbor_report == 0) {
+		panic_printk("(%s)line=%d, Table is empty!! No need to update!! \n", __FUNCTION__, __LINE__); 
+		return;
+	}
+
+	for(i = 0; i < pstat->wnm.num_neighbor_report; i++) {
+		if(!memcmp(pstat->wnm.neighbor_report[i].bssid, null_mac, MACADDRLEN)) {
+			num_empty_report++;		
+		}
+	}
+	
+	pstat->wnm.num_neighbor_report -= num_empty_report;
+	DOT11VTRACE("wnm.num_neighbor_report = %d,   num_empty_report = %d\n", pstat->wnm.num_neighbor_report, num_empty_report);
+}
+
+static void start_bss_transition(struct rtl8192cd_priv *priv, struct stat_info *pstat)
+{
+	if(!memcmp(pstat->wnm.target_bssid, pstat->hwaddr, MACADDRLEN)) {
+		DOT11VDEBUG("No need to roam!(The Same Bssid) \n"); 
+	} else {
+		if(validate_target_bssid(priv, pstat) == 0) {
+			DOT11VDEBUG("start bss transition!\n"); 
+
+			// diassoc the present connecting AP
+			issue_disassoc(priv, pstat->hwaddr, _RSON_DISASSOC_DUE_BSS_TRANSITION);
+			del_station(priv, pstat, 0);
+
+			// set the roaming target
+			memcpy(priv->pmib->dot11StationConfigEntry.dot11DesiredBssid ,pstat->wnm.target_bssid, MACADDRLEN);
+		}else
+			DOT11VDEBUG("Validate NG: Client couldn't find target !\n");
+	}
+}
+
+static void set_target_bssid(struct stat_info *pstat)
+{
+	if (pstat->wnm.num_neighbor_report == 0)
+		return;
+	
+	memcpy(pstat->wnm.target_bssid, pstat->wnm.neighbor_report[0].bssid, MACADDRLEN);	// preference highest one
+}
+
+// for debug usage
+static void dump_cand_list(struct rtl8192cd_priv *priv, struct stat_info *pstat)
+{
+	unsigned char i;
+	struct dot11k_neighbor_report *report;
+	
+	for(i = 0; i < pstat->wnm.num_neighbor_report; i++) {
+		report = &pstat->wnm.neighbor_report[i];
+		
+		panic_printk("(%d)=>[%02x][%02x][%02x][%02x][%02x][%02x], bssinfo=%u, op_class=%u chan=%u phy=%u, prf = %d \n", 
+		i, report->bssid[0], report->bssid[1], report->bssid[2], report->bssid[3], report->bssid[4], report->bssid[5],
+		report->bssinfo.value, report->op_class, report->channel, report->phytype, report->subelemnt.preference);
+	}
+}
+
+static void sort_candidate_list(struct rtl8192cd_priv *priv, struct stat_info *pstat)
+{
+	 DOT11VDEBUG("Candidate List num = %d\n",pstat->wnm.num_neighbor_report);	
+	if (pstat->wnm.num_neighbor_report == 0)
+		return;
+
+	qsort(pstat->wnm.neighbor_report, pstat->wnm.num_neighbor_report, sizeof(struct dot11k_neighbor_report), cand_pref_compar);
+	update_neighbor_report(priv, pstat);
+}
+
+static void parse_subelement(struct rtl8192cd_priv *priv, unsigned char id
+							,unsigned char *pos, unsigned char elen, struct dot11k_neighbor_report *report)
+{
+	report->subelemnt.subelement_id = id;
+	
+	switch(id) {
+		case _WNM_BSS_TRANS_CANDIDATE_PREFRENCE_:
+			if(elen < 1) {
+				panic_printk("Too short BSS transition candidate \n");
+				break;
+			}
+			report->subelemnt.len = elen;
+			report->subelemnt.preference = pos[0];
+			break;
+		default:			
+			panic_printk("Not implemented subelement id! \n");
+			break;
+	}
+}
+
+static void parse_neighbor_report(struct rtl8192cd_priv *priv, unsigned char *pos, unsigned char len, 
+									struct dot11k_neighbor_report *report)
+{
+	unsigned char left = len;
+	if(left < NEIGHBOR_REPORT_SIZE) {
+		panic_printk("Too short neighbor report \n");
+		return;
+	}
+
+	memcpy(report->bssid, pos, MACADDRLEN);
+	pos += MACADDRLEN;	
+	report->bssinfo.value = le32_to_cpu(*(unsigned int *)&pos[0]);
+	pos += sizeof(int);		
+	report->op_class = *pos;
+	pos++;				
+	report->channel = *pos;
+	pos++;				
+	report->phytype = *pos;
+	pos++;			
+
+	left -= 13; 
+	
+	DOT11VTRACE("[%02x][%02x][%02x][%02x][%02x][%02x], bssinfo=%u, op_class=%u chan=%u phy=%u \n",
+		report->bssid[0], report->bssid[1], report->bssid[2], report->bssid[3], report->bssid[4], report->bssid[5],
+		report->bssinfo.value, report->op_class, report->channel, report->phytype);
+	while(left >= 2) {
+		unsigned char id, elen;
+		id = *pos++;
+		elen = *pos++;
+		
+		left -= 2;	
+		if(elen > left) {
+			DOT11VDEBUG("Truncated neighbor report subelement \n");
+			break;
+		}
+		parse_subelement(priv, id, pos, elen, report);
+		left -= elen;
+		pos += elen;
+	}
+	
+}
+
+void OnBSSTransReq(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char *pframe, int frame_len)
+{
+	int frlen = 0;
+	enum bss_trans_mgmt_status_code status;
+	unsigned char valid_int;
+	unsigned int beacon_int = 100;	
+	unsigned char *pos = (pframe+2);
+
+	if(frame_len <5) {
+		panic_printk(" Ignore too short BSS Transition Management Request!\n"); 
+		return;
+	}
+
+	pstat->wnm.dialog_token = pos[0];
+	pstat->wnm.req_mode = pos[1];
+	pstat->wnm.dissoc_timer = le16_to_cpu(*(unsigned short *) &pos[2]); 
+	pstat->wnm.reply = TRUE;
+	valid_int = pos[4];
+	
+	DOT11VDEBUG("BSS Trans Req: dialog_token=%u, req_mode=0x%x, dissoc_timer=%u, valid_int=%u, frame_len = %d \n",
+		   			pstat->wnm.dialog_token, pstat->wnm.req_mode, pstat->wnm.dissoc_timer, valid_int, frame_len);
+
+	pos += 5;
+	frlen += 7;
+	if(pstat->wnm.req_mode & _WNM_BSS_TERMINATION_INCLUDED_) {
+		DOT11VTRACE("BSS termination included \n");
+		if(frlen + 12 > frame_len) {	//Bss Trans duration 0 or 12
+			panic_printk("Too short BSS TM Request \n");
+			return;
+		}
+		memcpy(pstat->wnm.bss_termination_duration, pos, BSS_TERMINATION_DURATION_LEN);
+		pos  += BSS_TERMINATION_DURATION_LEN;
+		frlen += BSS_TERMINATION_DURATION_LEN;
+	}
+
+	if(pstat->wnm.req_mode & _WNM_ESS_DIASSOC_IMMINENT_) {
+		unsigned char url[256];
+		if (frlen + 1 > frame_len || frlen + 1 + pos[1] > frame_len) {
+			panic_printk("Invalid BSS Transition Management Request (URL)");
+			return;
+		}
+		memcpy(url, pos+1, pos[0]); 
+		url[pos[0]] ='\0';
+		pos += 1 + pos[0];
+		frlen += 1 + pos[0];
+		DOT11VTRACE("ESS_DISASSOC_IMMINENT(disassoc_timer: %u, url: %s)", pstat->wnm.dissoc_timer * beacon_int * 128 / 125, url);
+	}
+
+	if(pstat->wnm.req_mode & _WNM_DIASSOC_IMMINENT_) {
+		DOT11VTRACE("Disassociation Imminent: dissoc_timer:%u\n", pstat->wnm.dissoc_timer);
+		if(pstat->wnm.dissoc_timer) {
+			start_clnt_lookup(priv, 1); //start rescan(needed to check)
+		}
+	}
+
+	if(pstat->wnm.req_mode & _WNM_PREFERRED_CANDIDATE_LIST_) {
+		DOT11VTRACE("PREFERRED_CANDIDATE_LIST: \n");
+		unsigned int valid_ms;
+		
+		int neighbor_size = sizeof(struct dot11k_neighbor_report);
+		memset(pstat->wnm.neighbor_report, 0, neighbor_size * MAX_NEIGHBOR_REPORT);	
+
+		while((frlen + 2 <= frame_len) &&
+		   	pstat->wnm.num_neighbor_report < MAX_NEIGHBOR_REPORT)
+		 {	
+	   		unsigned char tag = *pos++;
+			unsigned char len = *pos++;
+			frlen += 2;
+
+			if(frlen + len > frame_len) {
+				panic_printk("Truncated request size");
+				return;		
+			}
+
+			if(tag == _NEIGHBOR_REPORT_IE_) {
+				struct dot11k_neighbor_report *report;
+				report = &pstat->wnm.neighbor_report[pstat->wnm.num_neighbor_report];
+				parse_neighbor_report(priv, pos, len, report);
+			}
+				
+			pos += len;
+			frlen += len;
+			pstat->wnm.num_neighbor_report++;
+		 }
+		
+		 sort_candidate_list(priv, pstat);
+#ifdef DOT11V_DEBUG
+		 dump_cand_list(priv, pstat);
+#endif
+		 set_target_bssid(pstat);		 
+		 valid_ms = valid_int * beacon_int * 128 / 125;
+		 pstat->wnm.candidate_valid_time = (valid_ms)/1000; 
+		 DOT11VTRACE("Candidate list valid for (%d) ms/(%d) sec\n", valid_ms, pstat->wnm.candidate_valid_time);				
+	}
+	
+	if(pstat->wnm.reply) {		
+		if(pstat->wnm.req_mode & _WNM_PREFERRED_CANDIDATE_LIST_)
+			status = WNM_BSS_TM_ACCEPT;
+		else {
+			DOT11VDEBUG("BSS Transition Request did not include candidates \n");
+			status = WNM_BSS_TM_REJECT_UNSPECIFIED;	
+		}
+
+		if(issue_BSS_Trans_Rsp(priv, pstat, pstat->wnm.dialog_token, status) == 0)
+			start_bss_transition(priv, pstat);
+	}
+	return;
+}
+
+#endif
+
+static void process_status_code( struct stat_info *pstat, unsigned char status_code)
+{
+	pstat->bssTransStatusCode = status_code;
+	
+	if(status_code)		
+		pstat->bssTransRejectionCount++;
+
+	switch(status_code) {
+		case WNM_BSS_TM_ACCEPT:
+			panic_printk("Accept: WNM_BSS_TM_ACCEPT![%02x][%02x][%02x][%02x][%02x][%02x] \n", 
+						pstat->hwaddr[0], pstat->hwaddr[1], pstat->hwaddr[2], pstat->hwaddr[3], pstat->hwaddr[4], pstat->hwaddr[5]); 
+			
+			pstat->bssTransRejectionCount = 0;
+			break;
+		case WNM_BSS_TM_REJECT_UNSPECIFIED:
+			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_UNSPECIFIED!\n"); 
+			break;
+		case WNM_BSS_TM_REJECT_INSUFFICIENT_BEACON: 
+			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_INSUFFICIENT_BEACON!\n"); 
+			break;
+		case WNM_BSS_TM_REJECT_INSUFFICIENT_CAPABITY:
+			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_INSUFFICIENT_CAPABITY!\n"); 
+			break;
+		case WNM_BSS_TM_REJECT_UNDESIRED :
+			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_UNDESIRED !\n"); 
+			break;
+		case WNM_BSS_TM_REJECT_DELAY_REQUEST : 
+			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_DELAY_REQUEST !\n"); 
+			break;
+		case WNM_BSS_TM_REJECT_STA_CANDIDATE_LIST_PROVIDED :
+			panic_printk("Reject: WNM_BSS_TM_REJECT_STA_CANDIDATE_LIST_PROVIDED !\n"); 
+			break;
+		case WNM_BSS_TM_REJECT_NO_SUITABLE_CANDIDATES: 
+			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_NO_SUITABLE_CANDIDATES  !\n"); 
+			break;
+		case WNM_BSS_TM_REJECT_LEAVING_ESS:
+			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_LEAVING_ESS  !\n"); 
+			break;
+		default:
+			DOT11VDEBUG("unknown type !\n"); 
+			break;
+	}
+}
+
+void OnBSSTransRsp(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char*pframe, int frame_len)
+{
+	int frlen = 0;
+
+	if(frame_len < 3) {		
+		panic_printk("Ignore too short BSS Trans Management RSP!\n"); 
+		return;
+	}
+	
+	unsigned char dialog_token = pframe[2];
+	unsigned char status_code = pframe[3];
+	unsigned char bss_termination_delay = pframe[4];	//mins
+	frlen = 5;
+
+	if((frame_len - frlen) > MAX_LIST_LEN)	
+		return;
+	
+	DOT11VTRACE("dialog_token = %d, bss_termination_delay = %d\n", dialog_token, bss_termination_delay);
+	process_status_code(pstat, status_code);
+	pstat->bssTransExpiredTime = 0;	
+	pstat->bssTransTriggered = 0;
+	
+	if((frame_len - frlen) > 0) {	
+		if(status_code == WNM_BSS_TM_ACCEPT) {
+			debug_out("Target BSSID: ", &pframe[frlen], MACADDRLEN);
+			frlen += MACADDRLEN;
+			debug_out("Bss Trans Candidate List: ", &pframe[frlen], frame_len - frlen);
+		}else if(status_code == WNM_BSS_TM_REJECT_DELAY_REQUEST){
+			priv->pmib->wnmEntry.dot11vDiassocDeadline = bss_termination_delay*60;
+		}else
+			debug_out("Bss Trans Candidate List: ", &pframe[frlen], frame_len - frlen);
+	}else {
+		DEBUG_ERR("WNM: no info in bss trans response!\n");
+	}
+	
+	return;
+}
+
+void OnBSSTransQuery(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char*pframe, int frame_len)
+{
+	int list_len;
+	
+	if(frame_len < 2) {
+		DEBUG_ERR("Ignore too short BSS Transition Management Query!\n"); 		
+		return;
+	}
+	
+	unsigned char dialog_token = pframe[2];
+	unsigned char reason  = pframe[3]; 
+
+	DOT11VTRACE("dialog_token = %d, reason = %d\n", dialog_token, reason); 
+	
+ 	if(reason == _WNM_PREFERED_BSS_TRANS_LIST_INCLUDED_) {
+		list_len =   frame_len - 4;
+		
+		if(list_len > MAX_LIST_LEN)
+			return;
+		debug_out("Bss List Len: ", &pframe[list_len], frame_len - list_len);
+	} else
+		panic_printk("WNM_PREFERED BSS TRANS LIST NOT INCLUDED!\n"); 
+
+	issue_BSS_Trans_Req(priv, pstat->hwaddr, dialog_token);
+}
+
+void WNM_ActionHandler(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char *pframe, int frame_len)
+{
+	unsigned char action_field = pframe[1];
+	
+	switch (action_field) {
+		case _WNM_TSMQUERY_ACTION_ID_: 
+			OnBSSTransQuery(priv, pstat, pframe, frame_len);
+			break;
+		case _BSS_TSMRSP_ACTION_ID_:
+			OnBSSTransRsp(priv, pstat, pframe, frame_len);
+			break;
+	#ifdef CONFIG_IEEE80211V_CLI
+		case _BSS_TSMREQ_ACTION_ID_:
+			OnBSSTransReq(priv, pstat, pframe, frame_len);
+			break;
+	#endif
+		default:
+			DEBUG_INFO("Other WNM action: %d:\n", action_field);
+			break;
+	}
+}
+
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_11v.h
===================================================================
--- /dev/null
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_11v.h
@@ -0,0 +1,74 @@
+
+#ifndef	_8192CD_11V_H_
+#define _8192CD_11V_H_
+
+
+
+#ifdef DOT11V_DEBUG
+#define DOT11VDEBUG(fmt, args...) panic_printk("[%s %d]"fmt,__FUNCTION__,__LINE__,## args)
+#else
+#define DOT11VDEBUG(fmt, args...)
+#endif
+
+//#define DOT11V_TRACE
+#ifdef DOT11V_TRACE
+#define DOT11VTRACE(fmt, args...) panic_printk("[%s %d]"fmt,__FUNCTION__,__LINE__,## args)
+#else
+#define DOT11VTRACE(fmt, args...)
+#endif
+
+#ifndef _8192CD_11V_C_
+#define EXTERN  extern
+#else
+#define EXTERN
+#endif
+
+#define _WNM_TSF_INFO_                         				1
+#define _WNM_CONDENSED_COUNTRY_STRING_ 			2
+#define _WNM_BSS_TRANS_CANDIDATE_PREFRENCE_   	3
+#define _WNM_BSS_TERMINATION_DURATION_  		4
+#define _WNM_BEARING_                     					5
+#define _WNM_MEASUREMENT_PILOT_          			66
+#define _WNM_RRM_ENABLED_CAPABILITIES_   			70
+#define _WNM_MULTIPLE_BSSID_             				71
+
+#define TRANS_LIST_PROC_LEN	50
+#define MAX_PREFERRED_VAL 		255
+#define NEIGHBOR_REPORT_SIZE 	13	 // size of neighbor report structure
+
+
+EXTERN unsigned char getPreferredVal(struct rtl8192cd_priv *priv, unsigned char channel_utilization, unsigned char rcpi, bool excluded);
+EXTERN void OnBSSTransQuery(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char *pframe, int frame_len);
+EXTERN void OnBSSTransRsp(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char *pframe, int frame_len);
+EXTERN int issue_BSS_Trans_Req(struct rtl8192cd_priv *priv, unsigned char *da, unsigned char dialog_token);
+EXTERN unsigned char * construct_neighbor_report_ie(unsigned char *pbuf, unsigned int *frlen, struct dot11k_neighbor_report * report);
+EXTERN void set_staBssTransCap(struct stat_info *pstat, unsigned char *pframe, int frameLen, unsigned short ie_offset);
+EXTERN void reset_staBssTransStatus(struct stat_info *pstat);
+EXTERN void WNM_ActionHandler(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char *pframe, int frame_len);
+EXTERN void set_BssTransPara(struct rtl8192cd_priv *priv, unsigned char *tmpbuf);
+EXTERN void send_bss_trans_event(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char i);
+EXTERN void process_BssTransReq(struct rtl8192cd_priv *priv);
+EXTERN void BssTrans_DiassocTimer(struct rtl8192cd_priv *priv);
+EXTERN void BssTrans_ExpiredTimer(struct rtl8192cd_priv *priv);
+EXTERN void BssTrans_ValidatePrefListTimer(struct rtl8192cd_priv *priv);
+EXTERN void BssTrans_TerminationTimer(struct rtl8192cd_priv *priv);
+
+
+#ifdef CONFIG_RTL_PROC_NEW
+EXTERN int rtl8192cd_proc_transition_list_read(struct seq_file *s, void *data);
+#else
+EXTERN int rtl8192cd_proc_transition_list_read(char *buf, char **start, off_t offset, int length, int *eof, void *data);
+#endif
+
+#ifdef __ECOS
+EXTERN int rtl8192cd_proc_transition_list_write(char *tmp, void *data)
+#else
+EXTERN int rtl8192cd_proc_transition_list_write(struct file *file, const char *buffer, unsigned long count, void *data);
+#endif
+
+#ifdef CONFIG_IEEE80211V_CLI
+EXTERN void OnBSSTransReq(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char *pframe, int frame_len);
+#endif
+
+
+#endif
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_cfg.h
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/8192cd_cfg.h
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_cfg.h
@@ -825,6 +825,11 @@
 #endif
 
 //-------------------------------------------------------------
+// Channel Loading Calculation
+//-------------------------------------------------------------
+#define CH_LOAD_CAL
+#define CLM_SAMPLE_NUM2 65535  /*  CLM sample num , 65535*4us = 256 ms*/
+//-------------------------------------------------------------
 // Hotspot 2.0 -R2(20141216 SYS logo pass)
 //-------------------------------------------------------------
 #ifdef CONFIG_RTL_HS2_SUPPORT
@@ -3006,8 +3011,8 @@
 
 #ifdef CONFIG_RTL_11V_SUPPORT
 #define CONFIG_IEEE80211V
-#define CONFIG_IEEE80211V_DB //Driver Based
-#define CONFIG_IEEE80211V_DB_BS //band steering
+//#define CONFIG_IEEE80211V_CLI	//client mode
+//#define DOT11V_DEBUG
 #endif
 
 #ifdef CONFIG_RTL_PMKCACHE_SUPPORT
@@ -3112,6 +3117,7 @@
 #define FT_PMK_LEN					32
 #define MAX_FTACTION_LEN			MAXDATALEN - 20
 #define MAX_FTREASSOC_DEADLINE		65535
+#define MAX_TRANS_LIST_NUM         	32
 #endif
 
 #define GKEY_ID_SECOND 	2
@@ -3627,13 +3633,16 @@
 //-------------------------------------------------------------
 #ifdef CONFIG_RTL_DOT11K_SUPPORT
 #define DOT11K
+#ifndef CH_LOAD_CAL
+#define CH_LOAD_CAL
+#endif
 #endif
 #ifdef DOT11K
 #define DOT11D
 #endif
 
 
-#if defined(HS2_SUPPORT) || defined(DOT11K) 
+#if 0//defined(HS2_SUPPORT) || defined(DOT11K) || defined(CH_LOAD_CAL)
 #define CU_TO           RTL_MILISECONDS_TO_JIFFIES(210)         // 200ms to calculate bbp channel load
 #define CU_Intval       200
 #endif
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_headers.h
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/8192cd_headers.h
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_headers.h
@@ -71,6 +71,12 @@
 #endif
 #endif
 
+#ifdef CONFIG_IEEE80211V
+#include "./8192cd_11v.h"
+#endif
+//#include "./8192cd_p2p.h"
+
+
 #ifdef P2P_DEBUGMSG
 #define P2P_DEBUG(fmt, args...)     (panic_printk("[%s %d][%s]:"fmt,__FUNCTION__ , __LINE__ ,priv->dev->name, ## args))
 #define P2P_DEBUG2(fmt, args...)	(panic_printk("[%s %d]:"fmt,__FUNCTION__ , __LINE__ , ## args))
@@ -126,22 +132,6 @@ extern unsigned int _HS2_debug_warn;	/*
 
 #endif
 
-#ifdef CONFIG_IEEE80211V
-//#define DOT11V_DEBUG	
-#ifdef DOT11V_DEBUG
-#define DOT11VDEBUG(fmt, args...) panic_printk("[%s %d]"fmt,__FUNCTION__,__LINE__,## args)
-#else
-#define DOT11VDEBUG(fmt, args...)
-#endif
-#ifdef CONFIG_IEEE80211V_DB
-//#define DOT11VDB_DEBUG	
-#ifdef DOT11VDB_DEBUG
-#define DOT11VDBDEBUG(fmt, args...) panic_printk("[%s %d]"fmt,__FUNCTION__,__LINE__,## args)
-#else
-#define DOT11VDBDEBUG(fmt, args...)
-#endif
-#endif
-#endif
 
 #ifdef PMF_DEBUGMSG
 #define PMFDEBUG(fmt, args...) panic_printk("[%s %d] "fmt,__FUNCTION__,__LINE__,## args)
@@ -546,7 +536,7 @@ EXTERN void ft_event_indicate(struct rtl
 EXTERN unsigned int mapPairwise(unsigned char enc);
 #endif
 
-#if defined(HS2_SUPPORT) || defined(DOT11K)
+#if 0	//defined(HS2_SUPPORT) || defined(DOT11K) || defined(CH_LOAD_CAL)
 EXTERN void rtl8192cd_cu_cntdwn_timer(unsigned long task_priv);
 EXTERN void rtl8192cd_cu_start(struct rtl8192cd_priv *priv);
 EXTERN void rtl8192cd_cu_stop(struct rtl8192cd_priv *priv);
@@ -1530,11 +1520,14 @@ EXTERN char is_ac2g(struct rtl8192cd_pri
 void one_path_cca_power_save(struct rtl8192cd_priv *priv, int enable);
 #endif
 
-#if defined(HS2_SUPPORT) || defined(RTK_NL80211)/*survey_dump*/ || defined(DOT11K)
+#if defined(HS2_SUPPORT) || defined(RTK_NL80211)/*survey_dump*/ || defined(DOT11K) || defined(CH_LOAD_CAL)
 EXTERN void start_bbp_ch_load(struct rtl8192cd_priv *priv, unsigned int units);
 EXTERN int read_bbp_ch_load(struct rtl8192cd_priv *priv);
 #endif
 
+EXTERN void phydm_CLMInit2(	struct rtl8192cd_priv *priv,	u2Byte	clm_sample_num);
+EXTERN unsigned short phydm_getCLMresult2(struct rtl8192cd_priv *priv);
+
 
 #undef EXTERN
 
@@ -1721,6 +1714,9 @@ EXTERN void __DOT11_Indicate_MIC_Failure
 EXTERN int __DOT11_Process_Disconnect_Req(struct net_device *dev, struct iw_point *data);
 #endif // CONFIG_USB_HCI || CONFIG_SDIO_HCI
 
+#if (defined(DOT11D) || defined(DOT11H) || defined(DOT11K))
+EXTERN int map_country_to_reg(struct rtl8192cd_priv *priv);
+#endif
 
 #undef EXTERN
 
@@ -1809,13 +1805,6 @@ EXTERN void rtl8192cd_sa_query_timer(uns
 
 #endif		
 
-#ifdef CONFIG_IEEE80211V
-EXTERN void OnBSSTransQuery(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char *pframe, int frame_len);
-EXTERN void OnBSSTransRsp(struct rtl8192cd_priv *priv, unsigned char *pframe, int frame_len);
-EXTERN int issue_BSS_Trans_Req(struct rtl8192cd_priv *priv, unsigned char *da, unsigned char dialog_token);
-EXTERN unsigned char * construct_neighbor_report_ie(unsigned char *pbuf, unsigned int *frlen, struct dot11k_neighbor_report * report);
-#endif
-
 #undef EXTERN
 
 
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_hw.c
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/8192cd_hw.c
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_hw.c
@@ -27116,7 +27116,7 @@ compareAvailableTXBD(
 #endif // CONFIG_WLAN_HAL && CONFIG_PCI_HCI
 
 /* Hotsport 2.0 Release 1 */
-#if defined(HS2_SUPPORT) || defined(RTK_NL80211) /*survey_dump*/ || defined(DOT11K)
+#if defined(HS2_SUPPORT) || defined(RTK_NL80211) /*survey_dump*/ || defined(DOT11K)|| defined(CH_LOAD_CAL)
 void start_bbp_ch_load(struct rtl8192cd_priv *priv, unsigned int units)
 {
     unsigned short chip_ver = GET_CHIP_VER(priv);
@@ -27163,6 +27163,48 @@ int read_bbp_ch_load(struct rtl8192cd_pr
 }
 #endif
 
+/*new version phydm hasn't phydm_CLMInit  replace here*/
+void
+phydm_CLMInit2(
+	struct rtl8192cd_priv *priv,
+	u2Byte	clm_sample_num
+)
+{
+
+#define 	ODM_REG_CLM_TIME_PERIOD_11AC		0x990
+#define	ODM_REG_CLM_TIME_PERIOD_11N		0x894
+
+	if (ODMPTR->support_ic_type & ODM_IC_11AC_SERIES) {
+
+		RTL_W16(ODM_REG_CLM_TIME_PERIOD_11AC, clm_sample_num); //set ch load period time units*4 usec		
+		RTL_W16(ODM_REG_CLM_11AC, 0x100); /*Enable CCX for CLM*/
+
+		
+	} else if (ODMPTR->support_ic_type & ODM_IC_11N_SERIES) {
+	
+		RTL_W16(ODM_REG_CLM_TIME_PERIOD_11N, clm_sample_num); //set ch load period time units*4 usec		
+		RTL_W16(ODM_REG_CLM_11N, 0x100); /*Enable CCX for CLM*/
+	
+	}
+
+}
+
+unsigned short
+phydm_getCLMresult2(struct rtl8192cd_priv *priv)
+{
+
+	u4Byte			value32 = 0;
+	u2Byte			results = 0;
+	
+	if (ODMPTR->support_ic_type & ODM_IC_11AC_SERIES)
+		value32 = RTL_R32(ODM_REG_CLM_RESULT_11AC);				/*read CLM calc result*/	
+	else if (ODMPTR->support_ic_type & ODM_IC_11N_SERIES)
+		value32 = RTL_R32(ODM_REG_CLM_RESULT_11N);				/*read CLM calc result*/		
+
+	return (u2Byte)(value32 & bMaskLWord);
+}
+
+
 #ifdef CONFIG_1RCCA_RF_POWER_SAVING
 void one_path_cca_power_save(struct rtl8192cd_priv *priv, int enable)
 {
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_ioctl.c
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/8192cd_ioctl.c
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_ioctl.c
@@ -1142,7 +1142,9 @@ static struct iwpriv_arg mib_table[] = {
 	// struct Dot11StationConfigEntry
 	{"ssid",		SSID_STRING_T,	_OFFSET(dot11StationConfigEntry.dot11DesiredSSID), _SIZE(dot11StationConfigEntry.dot11DesiredSSID), 0},
 	{"defssid",		DEF_SSID_STRING_T,	_OFFSET(dot11StationConfigEntry.dot11DefaultSSID), _SIZE(dot11StationConfigEntry.dot11DefaultSSID), 0},
+#ifndef CONFIG_IEEE80211V_CLI
 	{"bssid2join",	BYTE_ARRAY_T,	_OFFSET(dot11StationConfigEntry.dot11DesiredBssid), _SIZE(dot11StationConfigEntry.dot11DesiredBssid), 0},
+#endif
 	{"bcnint",		INT_T,		_OFFSET(dot11StationConfigEntry.dot11BeaconPeriod), _SIZE(dot11StationConfigEntry.dot11BeaconPeriod), 100},
 	{"dtimperiod",	INT_T,		_OFFSET(dot11StationConfigEntry.dot11DTIMPeriod), _SIZE(dot11StationConfigEntry.dot11DTIMPeriod), 1},
 	{"swcrypto",	INT_T,		_OFFSET(dot11StationConfigEntry.dot11swcrypto), _SIZE(dot11StationConfigEntry.dot11swcrypto), 0},
@@ -1174,7 +1176,7 @@ static struct iwpriv_arg mib_table[] = {
 	{"scan_interval",INT_T,		_OFFSET(dot11StationConfigEntry.scan_interval), _SIZE(dot11StationConfigEntry.scan_interval), 10000},
 	{"passive_scan",INT_T,		_OFFSET(dot11StationConfigEntry.passive_scan), _SIZE(dot11StationConfigEntry.passive_scan), 0},
 #endif
-#if defined(HS2_SUPPORT) || defined(DOT11K)	
+#if defined(HS2_SUPPORT) || defined(DOT11K) || defined(CH_LOAD_CAL)
     {"cubeaconintval",  INT_T,  _OFFSET(dot11StationConfigEntry.channel_utili_beaconIntval), _SIZE(dot11StationConfigEntry.channel_utili_beaconIntval), 10},
 #endif
 #ifdef CLIENT_MODE
@@ -1318,29 +1320,17 @@ static struct iwpriv_arg mib_table[] = {
 	{"tdls_prohibited",BYTE_T,	_OFFSET(dot11OperationEntry.tdls_prohibited), _SIZE(dot11OperationEntry.tdls_prohibited), 0},	
 	{"tdls_cs_prohibited",BYTE_T, 	_OFFSET(dot11OperationEntry.tdls_cs_prohibited), _SIZE(dot11OperationEntry.tdls_cs_prohibited), 0},
 #ifdef CONFIG_IEEE80211V	
-	{"wnmtest", 				BYTE_T,	_OFFSET(dot11StationConfigEntry.wnmtest), _SIZE(dot11StationConfigEntry.wnmtest), 0},		
+	{"wnmtest", 			BYTE_T,	_OFFSET(dot11StationConfigEntry.wnmtest), _SIZE(dot11StationConfigEntry.wnmtest), 0},		
 	{"BssTransEnable", 		BYTE_T, 	_OFFSET(wnmEntry.dot11vBssTransEnable), _SIZE(wnmEntry.dot11vBssTransEnable), 1},  	
 	{"BssReqMode",     		BYTE_T, 	_OFFSET(wnmEntry.dot11vReqMode), _SIZE(wnmEntry.dot11vReqMode), 3}, 	 	 	
-	{"BssDiassocImminent",     	BYTE_T, 	_OFFSET(wnmEntry.dot11vDiassocImminent), _SIZE(wnmEntry.dot11vDiassocImminent), 0}, 	 
-#ifndef CONFIG_IEEE80211V_DB_BS	
-	{"BssDiassocDeadline", 		INT_T, _OFFSET(wnmEntry.dot11vDiassocDeadline), _SIZE(wnmEntry.dot11vDiassocDeadline), 5},	
-#endif
-	{"bss_req_mac", 			BYTE_ARRAY_T,	_OFFSET(dot11StationConfigEntry.bss_req_mac), _SIZE(dot11StationConfigEntry.bss_req_mac), 0},
-#ifdef CONFIG_IEEE80211V_DB	
-	{"BssDbEnable",				BYTE_T, _OFFSET(wnmEntry.dot11vDriverBasedEnable), _SIZE(wnmEntry.dot11vDriverBasedEnable), 1},	
-	{"BssDbIntval",				INT_T, _OFFSET(wnmEntry.dot11vDbCheckInterval), _SIZE(wnmEntry.dot11vDbCheckInterval), 30}, 			
-	{"BssDbRedirMask",		BYTE_T, _OFFSET(wnmEntry.dot11vDbRedirectMask), _SIZE(wnmEntry.dot11vDbRedirectMask), 3}, 	 
-	{"BssDbApTxLoadThrd",		INT_T, _OFFSET(wnmEntry.dot11vDbApTxLoadThreshold), _SIZE(wnmEntry.dot11vDbApTxLoadThreshold), 200},
-	{"BssDbStaTxLoadThrd",		INT_T, _OFFSET(wnmEntry.dot11vDbStaTxLoadThreshold), _SIZE(wnmEntry.dot11vDbStaTxLoadThreshold), 1},
-	{"BssDbApRxLoadThrd",		INT_T, _OFFSET(wnmEntry.dot11vDbApRxLoadThreshold), _SIZE(wnmEntry.dot11vDbApRxLoadThreshold), 200},
-	{"BssDbStaRxLoadThrd",		INT_T, _OFFSET(wnmEntry.dot11vDbStaRxLoadThreshold), _SIZE(wnmEntry.dot11vDbStaRxLoadThreshold), 1},
-#ifdef CONFIG_IEEE80211V_DB_BS
-	{"BssDbBsEnable",				BYTE_T, _OFFSET(wnmEntry.dot11vDriverBasedBsEnable), _SIZE(wnmEntry.dot11vDriverBasedBsEnable), 1}, 
-	{"BsSupportNon11vSta",			BYTE_T, _OFFSET(wnmEntry.dot11vDriverBasedBsSupportNon11vSta), _SIZE(wnmEntry.dot11vDriverBasedBsSupportNon11vSta), 1}, 
-	{"BssDiassocDeadline",			INT_T, _OFFSET(wnmEntry.dot11vDiassocDeadline), _SIZE(wnmEntry.dot11vDiassocDeadline), 5},
-#endif
-#endif
-
+	{"BssDiassocImminent",  BYTE_T, 	_OFFSET(wnmEntry.dot11vDiassocImminent), _SIZE(wnmEntry.dot11vDiassocImminent), 0}, 	 
+	{"BssDiassocDeadline", 	WORD_T, _OFFSET(wnmEntry.dot11vDiassocDeadline), _SIZE(wnmEntry.dot11vDiassocDeadline), 0},	
+	{"BssTransExpiredTime", BYTE_T, _OFFSET(wnmEntry.bssTransExpiredTime), _SIZE(wnmEntry.bssTransExpiredTime), 10},	//10ms
+	{"Is11kDaemonOn", 		BYTE_T, _OFFSET(wnmEntry.Is11kDaemonOn), _SIZE(wnmEntry.Is11kDaemonOn), 0},	// construct neighbor repor-> 1:  by dot11k daemon;  0: manually
+	{"algoType", 			BYTE_T, _OFFSET(wnmEntry.algoType), _SIZE(wnmEntry.algoType), 0},	
+#ifdef CONFIG_IEEE80211V_CLI	
+	{"defaultPrefVal", 			BYTE_T, _OFFSET(wnmEntry.defaultPrefVal), _SIZE(wnmEntry.defaultPrefVal), 100},	
+#endif	
 #endif
 #ifdef CONFIG_POWER_SAVE
 	{"ps_level",INT_T,		_OFFSET(dot11OperationEntry.ps_level), _SIZE(dot11OperationEntry.ps_level), 2},
@@ -1683,6 +1673,7 @@ static struct iwpriv_arg mib_table[] = {
 #endif	
 #if defined(DOT11D) || defined(DOT11H) || defined(DOT11K)	
 	{"countrystr",	STRING_T,	_OFFSET(dot11dCountry.dot11CountryString), _SIZE(dot11dCountry.dot11CountryString), 0},
+	{"country2reg",		INT_T,	_OFFSET(dot11dCountry.dot11CountryCodeToRegDomain), _SIZE(dot11dCountry.dot11CountryCodeToRegDomain), 0},
 #endif
 
 #ifdef DOT11H
@@ -11610,32 +11601,6 @@ static void get_probe_info(struct rtl819
 }
 #endif
 
-#ifdef CONFIG_IEEE80211V
-void set_BssTransPara(struct rtl8192cd_priv *priv, unsigned char *tmpbuf)
-{
-	int i, empty_slot;
-	priv->bssTransPara.isFromUser = TRUE;
-
-	memcpy(priv->bssTransPara.addr, tmpbuf, MACADDRLEN);
-	priv->bssTransPara.chan_until = tmpbuf[MACADDRLEN];
-
-       for(i = 0, empty_slot = -1; i < MAX_NEIGHBOR_REPORT; i++) {
-                if((priv->rm_neighbor_bitmask[i>>3] & (1<<(i&7))) == 0) {
-                    if(empty_slot == -1)
-                        empty_slot = i;
-                } else if(0 == memcmp(priv->bssTransPara.addr, priv->rm_neighbor_report[i].bssid, MACADDRLEN)) {
-                    break;
-                }
-        }
-        if(i == MAX_NEIGHBOR_REPORT && empty_slot != -1)   /*not found, and has empty slot*/
-        {
-                i = empty_slot;
-        }
-	
-   	panic_printk("(%s)line=%d, i = %d\n", __FUNCTION__, __LINE__, i);
-}
-
-#endif
 
 
 int rtl8192cd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_osdep.c
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/8192cd_osdep.c
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_osdep.c
@@ -4988,18 +4988,6 @@ static int rtl8192cd_init_sw(struct rtl8
 #endif
 
 	priv->hiddenAP_backup = priv->pmib->dot11OperationEntry.hiddenAP;
-
-
-#ifdef CONFIG_IEEE80211V_DB
-		priv->dot11DbCounter=priv->pmib->wnmEntry.dot11vDbCheckInterval; 
-
-#ifdef CONFIG_IEEE80211V_DB_BS
-		INIT_LIST_HEAD(&priv->BssTransDbBsBlockList);
-		spin_lock_init(&priv->BssTransDbBsBlockNodeLock);
-#endif
-
-#endif
-
 	return 0;
 }
 
@@ -8807,14 +8795,12 @@ priv->drv_state |= DRV_STATE_OPEN;
 	}
 #endif
 
-#ifdef DOT11K
-    if(priv->pmib->dot11StationConfigEntry.dot11RadioMeasurementActivated) {
-        /*start channel utilization calculate*/
-        if(OPMODE & WIFI_AP_STATE)
-            rtl8192cd_cu_start(priv);
-    }
+#ifdef CH_LOAD_CAL
+#ifdef USE_OUT_SRC
+	//            rtl8192cd_cu_start(priv);
+	phydm_CLMInit2(priv, CLM_SAMPLE_NUM2);					
+#endif
 #endif
-
 
 #ifdef CONFIG_PCI_HCI
 	// to avoid add RAtid fail
@@ -9738,7 +9724,7 @@ int rtl8192cd_close(struct net_device *d
 	memset(priv->rtk->psd_fft_info, 0x0, sizeof(priv->rtk->psd_fft_info));
 #endif
 
-#if defined(HS2_SUPPORT) || defined(DOT11K)
+#if 0//defined(HS2_SUPPORT) || defined(DOT11K) || defined(CH_LOAD_CAL)
     rtl8192cd_cu_stop(priv);
 #endif
 
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_proc.c
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/8192cd_proc.c
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_proc.c
@@ -2021,6 +2021,156 @@ static int rtl8192cd_proc_mib_wds(char *
 #endif // WDS
 
 
+#ifdef CONFIG_IEEE80211V
+#ifdef CONFIG_RTL_PROC_NEW
+int rtl8192cd_proc_transition_read(struct seq_file *s, void *data)
+#else
+int rtl8192cd_proc_transition_read(char *buf, char **start, off_t offset,
+        int length, int *eof, void *data)
+#endif
+{
+	struct net_device *dev = PROC_GET_DEV();
+	struct rtl8192cd_priv *priv = GET_DEV_PRIV(dev);
+	int pos = 0;
+	int i,j;
+	struct stat_info *pstat;
+
+	if((OPMODE & WIFI_AP_STATE) == 0) {
+	    panic_printk("\nwarning: invalid command!\n");
+	    return pos;
+	}
+
+	PRINT_ONE(" --Target Transition List  -- ", "%s", 1);
+	j = 1;
+	for (i = 0 ; i < MAX_TRANS_LIST_NUM; i++) 
+	{
+	    if((priv->transition_list_bitmask[i>>3] & (1<<(i&7))) == 0) 
+		continue;
+
+	    pstat = get_stainfo(priv, priv->transition_list[i].addr);
+	    if(pstat) {
+		    PRINT_ONE(j, "  [%d]", 0);
+	   	    PRINT_ARRAY_ARG("STA:", priv->transition_list[i].addr, "%02x", MACADDRLEN);
+		    PRINT_ONE("    BSS Trans Rejection Count:", "%s", 0);
+	           PRINT_ONE(pstat->bssTransRejectionCount, "%d", 1);
+	           PRINT_ONE("    BSS Trans Trans Expired Time:", "%s", 0);
+	           PRINT_ONE(pstat->bssTransExpiredTime, "%d", 1);
+	    }
+	    j++;
+	}
+	
+    	return pos;
+}
+
+#define TRANS_LIST_PROC_LEN	50
+#ifdef __ECOS
+int rtl8192cd_proc_transition_write(char *tmp, void *data)
+#else
+int rtl8192cd_proc_transition_write(struct file *file, const char *buffer,
+        unsigned long count, void *data)
+#endif
+{
+#ifdef __ECOS
+	return 0;
+#else
+	struct net_device *dev = (struct net_device *)data;
+	struct rtl8192cd_priv *priv = GET_DEV_PRIV(dev);
+	unsigned char error_code = 0;
+	char * tokptr;
+	int command = 0;
+	int empty_slot;
+	int i;
+	char tmp[TRANS_LIST_PROC_LEN];
+	char *tmpptr;
+	int oldest_idx;
+	struct target_transition_list list;
+
+	if((OPMODE & WIFI_AP_STATE) == 0) {
+	    error_code = 1;
+	    goto end;
+	}
+	if (count < 2 || count >= TRANS_LIST_PROC_LEN) {
+	    return -EFAULT;
+	}
+
+	if (buffer == NULL || copy_from_user(tmp, buffer, count))
+	    return -EFAULT;
+
+	tmp[count] = 0;
+	tmpptr = tmp;
+	tmpptr = strsep((char **)&tmpptr, "\n");
+	tokptr = strsep((char **)&tmpptr, " ");
+	if(!memcmp(tokptr, "add", 3))
+		command = 1;
+	else if (!memcmp(tokptr, "delall", 6)) 
+	   	command = 3;
+	else if(!memcmp(tokptr, "del", 3))
+       	command = 2;
+
+	if(command) 
+	{        
+	    if(command == 1 || command == 2) {
+	        tokptr = strsep((char **)&tmpptr," ");
+	        if(tokptr)
+	            get_array_val(list.addr, tokptr, 12);
+	        else {
+	            error_code = 1;
+	            goto end;
+	        }
+	    }
+	    
+	    if(command == 1)   /*add*/
+	    {	  
+			for(i = 0, empty_slot = -1; i < MAX_TRANS_LIST_NUM; i++)
+		       {
+		            if((priv->transition_list_bitmask[i>>3] & (1<<(i&7))) == 0) {
+		            	if(empty_slot == -1)
+		            		empty_slot = i;
+		            }else if(0 == memcmp(list.addr, priv->transition_list[i].addr, MACADDRLEN)) {
+		            	break;
+		            }	
+		        }
+				
+		       if(i == MAX_TRANS_LIST_NUM && empty_slot != -1) {/*not found, and has empty slot*/
+		        	i = empty_slot;
+		        }		
+			memcpy(&priv->transition_list[i], &list, sizeof(struct target_transition_list));
+		     	priv->transition_list_bitmask[i>>3] |= (1<<(i&7));  
+	    }
+	    else if(command == 3)   /*delete all*/
+	    {
+	        	memset(priv->transition_list_bitmask, 0x00, sizeof(priv->transition_list_bitmask));
+	    }
+	   else if(command == 2)  /*delete*/
+	   {
+			for (i = 0 ; i < MAX_TRANS_LIST_NUM; i++) {
+			        if((priv->transition_list_bitmask[i>>3] & (1<<(i&7))) == 0)
+			        	continue;
+			    
+			        if(0 == memcmp(list.addr, priv->transition_list[i].addr, MACADDRLEN)) {
+			        	priv->transition_list_bitmask[i>>3] &= ~(1<<(i&7));
+			        	break;
+			        }
+			}
+	    }
+	}
+	else {
+		    error_code = 1;
+		    goto end;
+	}
+
+	end:
+	if(error_code == 1)
+	    panic_printk("\nwarning: invalid command!\n");
+	else if(error_code == 2)
+	    panic_printk("\nwarning: neighbor report table full!\n");
+	return count;
+#endif
+}
+
+#endif
+
+
 #ifdef RTK_BR_EXT
 #ifdef CONFIG_RTL_PROC_NEW
 static int rtl8192cd_proc_mib_brext(struct seq_file *s, void *data)
@@ -5325,8 +5475,13 @@ static int dump_one_stainfo(int num, str
 #endif
 #ifdef CONFIG_IEEE80211V
     if(WNM_ENABLE) {
-    		PRINT_SINGL_ARG("    BSS Trans Support: ", pstat->bssTransSupport, "%d");
-		PRINT_SINGL_ARG("    Rev Neighbor Report: ", pstat->rcvNeighborReport, "%d");
+    	PRINT_SINGL_ARG("    BSS Trans Support: ", pstat->bssTransSupport, "%d");
+		PRINT_SINGL_ARG("    BSS Trans Rsp Status Code: ", pstat->bssTransStatusCode, "%d");
+		PRINT_SINGL_ARG("    BSS Trans Rejection Count: ", pstat->bssTransRejectionCount, "%d");
+		PRINT_SINGL_ARG("    BSS Trans Expired  Time: ", pstat->bssTransExpiredTime, "%d");
+		PRINT_SINGL_ARG("    BSS Trans Event Triggered: ", pstat->bssTransTriggered, "%d");
+		if(priv->pmib->wnmEntry.Is11kDaemonOn)
+			PRINT_SINGL_ARG("    Rev Neighbor Report: ", pstat->rcvNeighborReport, "%d");
 	}
 #endif	
 
@@ -5870,11 +6025,13 @@ static int rtl8192cd_proc_stats(char *bu
 		print = 1;
 	}
 	idx += sprintf(tmp+idx, "%d sec ", n);
-	PRINT_SINGL_ARG("    up_time: ", tmp, "%s");
-#if 0/*def RTK_NL80211//survey_dump //eric-sync ??*/
-	PRINT_SINGL_ARG("    chbusytime:    ", priv->rtk->chbusytime, "%lu");
-	PRINT_SINGL_ARG("    tx_time:    ", priv->rtk->tx_time, "%lu");
-	PRINT_SINGL_ARG("    rx_time:    ", priv->rtk->rx_time, "%lu");
+	PRINT_SINGL_ARG("    up_time:       ", tmp, "%s");
+
+#ifdef CH_LOAD_CAL
+	/*reference IEEE,Std 802.11-2012,page567,use 0~255 to representing 0~100%*/
+	PRINT_SINGL_ARG("    ch_utilization:	", priv->ext_stats.ch_utilization, "%lu");
+	PRINT_SINGL_ARG("    tx_time:       ", priv->ext_stats.tx_time, "%lu");
+	PRINT_SINGL_ARG("    rx_time:       ", priv->ext_stats.rx_time, "%lu");
 #endif
 	PRINT_SINGL_ARG("    tx_packets:    ", priv->net_stats.tx_packets, "%lu");
 #ifdef TRX_DATA_LOG	
@@ -7081,6 +7238,10 @@ static int rtl8192cd_proc_thermal(char *
     RTK_DECLARE_READ_WRITE_PROC_FOPS(rtl8192cd_proc_ap_channel_report_read, rtl8192cd_proc_ap_channel_report_write);
     RTK_DECLARE_READ_WRITE_PROC_FOPS(rtl8192cd_proc_neighbor_read, rtl8192cd_proc_neighbor_write);
 #endif
+
+#ifdef CONFIG_IEEE80211V
+    RTK_DECLARE_READ_WRITE_PROC_FOPS(rtl8192cd_proc_transition_read, rtl8192cd_proc_transition_write);
+#endif
 	
 #if (BEAMFORMING_SUPPORT == 1)
 	RTK_DECLARE_READ_PROC_FOPS(rtl8192cd_proc_mib_txbf);
@@ -7309,6 +7470,9 @@ void MDL_DEVINIT rtl8192cd_proc_init(str
     RTK_CREATE_PROC_READ_WRITE_ENTRY(p, "rm_ap_channel_report", rtl8192cd_proc_ap_channel_report_read, rtl8192cd_proc_ap_channel_report_write);
     RTK_CREATE_PROC_READ_WRITE_ENTRY(p, "rm_neighbor_report", rtl8192cd_proc_neighbor_read, rtl8192cd_proc_neighbor_write);
 #endif
+#ifdef CONFIG_IEEE80211V
+     RTK_CREATE_PROC_READ_WRITE_ENTRY(p, "wnm_transition_list", rtl8192cd_proc_transition_read, rtl8192cd_proc_transition_write);              
+#endif
 #if (BEAMFORMING_SUPPORT == 1)
 	RTK_CREATE_PROC_READ_ENTRY(p, "mib_txbf", rtl8192cd_proc_mib_txbf);
 #endif
@@ -7549,6 +7713,10 @@ void /*__devexit*/MDL_EXIT rtl8192cd_pro
         remove_proc_entry( "mib_txbf", rtl8192cd_proc_root );
 #endif
 
+#ifdef CONFIG_IEEE80211V
+       remove_proc_entry( "wnm_transition_list", rtl8192cd_proc_root );
+#endif
+
 #ifdef DFS
         remove_proc_entry( "mib_dfs", rtl8192cd_proc_root );
 #endif
@@ -7792,7 +7960,9 @@ static struct _proc_table_ proc_table[]
     {"rm_ap_channel_report",      rtl8192cd_proc_ap_channel_report_read},    
     {"rm_neighbor_report",      rtl8192cd_proc_neighbor_read},
 #endif
-
+#ifdef CONFIG_IEEE80211V
+    {"wnm_transition_list",      rtl8192cd_proc_transition_read,NULL},
+#endif
 #ifdef ENABLE_RTL_SKB_STATS
     {"skb_info",			rtl8192cd_proc_skb_info},
 #endif
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_sme.c
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/8192cd_sme.c
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_sme.c
@@ -5251,408 +5251,41 @@ int is_intel_connected(struct rtl8192cd_
 }
 
 
-#ifdef CONFIG_IEEE80211V
-
-#ifdef CONFIG_IEEE80211V_DB
-#ifdef CONFIG_IEEE80211V_DB_BS
-
-#define DB_BS_BLOCK_TIME 20 // block this sta 20 sec
-
-static bool checkBssTransDbBsIsEnable(struct rtl8192cd_priv *priv);
-static void TriggerBssTransDbBs(struct rtl8192cd_priv *priv);
-bool bssTransDbBsCheckRequest(struct rtl8192cd_priv *priv, unsigned char *mac, int frame_type);
-static void bssTransDbBsTimer(struct rtl8192cd_priv *priv);
-#endif
-
-#define REDIRECT_AP_TX_LOAD 0x1
-#define REDIRECT_AP_RX_LOAD 0x2
-
-static void resetBssTransReqCount(struct rtl8192cd_priv *priv);
-static bool checkBssTransDbBitMask(struct rtl8192cd_priv *priv,int bitNum);
-static bool checkBssTransDbApTxLoad(struct rtl8192cd_priv *priv);
-static bool checkBssTransDbStaTxLoad(struct stat_info* pstatd,struct rtl8192cd_priv *priv);
-static bool checkBssTransDbApRxLoad(struct rtl8192cd_priv *priv);
-static bool checkBssTransDbStaRxLoad(struct stat_info* pstatd,struct rtl8192cd_priv *priv);
-static void chooseTargerSta(struct rtl8192cd_priv *priv);
-static void BssTransDriverBased(struct rtl8192cd_priv *priv);
-#endif
-
-
-
-
-#ifdef CONFIG_IEEE80211V_DB
-#ifdef CONFIG_IEEE80211V_DB_BS
-
-static bool checkBssTransDbBsIsEnable(struct rtl8192cd_priv *priv){
-
-	return ((priv->pmib->wnmEntry.dot11vDiassocImminent==0)&&(priv->pmib->wnmEntry.dot11vDriverBasedBsEnable==1));
-}
-
-static void TriggerBssTransDbBs(struct rtl8192cd_priv *priv){
-	
-	struct stat_info *pstat;
-	struct BssTransDbBsBlockNode *entry;
-	struct list_head *phead, *plist;
-	bool result=true;
-	unsigned long flags;
-
-	//add this STA to block list 
-	spin_lock_irqsave(&priv->BssTransDbBsBlockNodeLock, flags);
-
-	phead = &priv->BssTransDbBsBlockList;
-	if (!list_empty(phead)){
-
-		plist=phead->next;
-	
-		while(plist!=phead){
-			
-			entry = list_entry(plist, struct BssTransDbBsBlockNode, list);
-			plist = plist->next;
-	
-			if(0==memcmp(entry->mac, priv->pmib->dot11StationConfigEntry.bss_req_mac, MACADDRLEN)){
-				result=false;
-				break;
-			}
-		}
-}
-
-	if(result){
-		entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
-		if (NULL != entry)
-{
-			INIT_LIST_HEAD(&entry->list);
-			memcpy(entry->mac, priv->pmib->dot11StationConfigEntry.bss_req_mac, MACADDRLEN);
-			entry->counter=DB_BS_BLOCK_TIME;
-			list_add_tail(&entry->list, &priv->BssTransDbBsBlockList);
-			DOT11VDBDEBUG("%s(%d): add (%02x%02x%02x%02x%02x%02x) into list_head\n", __FUNCTION__, __LINE__
-                                   ,entry->mac[0]
-                                   ,entry->mac[1]
-                                   ,entry->mac[2]
-                                   ,entry->mac[3]
-                                   ,entry->mac[4]
-                                   ,entry->mac[5]);
-		}
-	}
-	
-	spin_unlock_irqrestore(&priv->BssTransDbBsBlockNodeLock, flags);
-
-	//deauth this STA
-	       DOT11VDBDEBUG("%s(%d): disassoc (%02x%02x%02x%02x%02x%02x) \n", __FUNCTION__, __LINE__
-                                   ,entry->mac[0]
-                                   ,entry->mac[1]
-                                   ,entry->mac[2]
-                                   ,entry->mac[3]
-                                   ,entry->mac[4]
-                                   ,entry->mac[5]);
-
-			pstat = get_stainfo(priv, priv->pmib->dot11StationConfigEntry.bss_req_mac);
-			 if(pstat){
-	//issue_disassoc(priv, priv->pmib->dot11StationConfigEntry.bss_req_mac, _RSON_DISASSOC_DUE_BSS_TRANSITION);
-	del_station(priv, pstat, 1);
-	}
-			}
-
-bool bssTransDbBsCheckRequest(struct rtl8192cd_priv *priv, unsigned char *mac, int frame_type){
-	//receiver packet
-
-	unsigned long flags;
-	bool result=false;
-	struct list_head *phead, *plist;
-	struct BssTransDbBsBlockNode *entry;	
-	
-	phead = &priv->BssTransDbBsBlockList;
-
-	if (list_empty(phead))
-		return false;
-	
-	spin_lock_irqsave(&priv->BssTransDbBsBlockNodeLock, flags);
-
-	plist=phead->next;
-
-	while(plist!=phead){
-		
-		entry = list_entry(plist, struct BssTransDbBsBlockNode, list);
-		plist = plist->next;
-
-		if(0==memcmp(entry->mac, mac, MACADDRLEN)){
-			result=true;
-			break;
-		}
-	}
-
-	if(result){
-		DOT11VDBDEBUG("%s(%d): reject this packet frame_type=%d\n", __FUNCTION__, __LINE__,frame_type);
-			}
-
-	spin_unlock_irqrestore(&priv->BssTransDbBsBlockNodeLock, flags);
-
-	return result;
-		}
-
-static void bssTransDbBsTimer(struct rtl8192cd_priv *priv){
-
-	//remove note from list and decline counter
-	struct list_head *phead, *plist;
-	struct BssTransDbBsBlockNode *entry;
-	unsigned long flags;
-
-	phead = &priv->BssTransDbBsBlockList;
-	
-	if (list_empty(phead))
-		return;
-
-	spin_lock_irqsave(&priv->BssTransDbBsBlockNodeLock, flags);
-
-	plist = phead->next;
-	
-	while (plist != phead) {
-		entry = list_entry(plist, struct BssTransDbBsBlockNode, list);
-		plist = plist->next;
-		
-		entry->counter--;
-		if (0 == entry->counter) {
-			DOT11VDBDEBUG("%s(%d): remove (%02x%02x%02x%02x%02x%02x) from list_head\n", __FUNCTION__, __LINE__
-                                           ,entry->mac[0]
-                                           ,entry->mac[1]
-                                           ,entry->mac[2]
-                                           ,entry->mac[3]
-                                           ,entry->mac[4]
-                                           ,entry->mac[5]);
-			list_del(&entry->list);
-			kfree(entry);
-	}
-}
-
-	spin_unlock_irqrestore(&priv->BssTransDbBsBlockNodeLock, flags);
-
-}
-
-#endif
-
-
-static void resetBssTransReqCount(struct rtl8192cd_priv *priv){
-	int idx=0;
-	struct stat_info* pstatdTmp=NULL;
-			struct stat_info* pstatd = findNextSTA(priv, &idx);
-			while(pstatd) {
-				pstatd->bssTransReqCount=0;
-				pstatd = findNextSTA(priv, &idx);
-			}
-
-}
-
-static bool checkBssTransDbBitMask(struct rtl8192cd_priv *priv,int bitNum){
-	return (priv->pmib->wnmEntry.dot11vDbRedirectMask & bitNum);
-}
+void check_NAV_for_intel_iot(struct rtl8192cd_priv *priv)
+{
+		int i = 0;
+		int only_intel_sta = 1;
 
+		/*
+			Because 8822 & 8197F can NOT issue CFE, this will cause Intel 6300 performance bad, 
+			below is work around solution.
+		*/
 
-static bool checkBssTransDbApTxLoad(struct rtl8192cd_priv *priv){
+		if((GET_CHIP_VER(priv)!=VERSION_8197F) && (GET_CHIP_VER(priv)!=VERSION_8822B))
+			return;
 		
-		return ((priv->ext_stats.tx_avarage>=((priv->pmib->wnmEntry.dot11vDbApTxLoadThreshold*1000000)>>3))&&(priv->pmib->wnmEntry.dot11vDbRedirectMask & REDIRECT_AP_TX_LOAD));
-			
-}
-
-static bool checkBssTransDbStaTxLoad(struct stat_info* pstatd,struct rtl8192cd_priv *priv){
-	return (!(priv->pmib->wnmEntry.dot11vDbRedirectMask & REDIRECT_AP_TX_LOAD))?
-true:(pstatd->tx_avarage < ((priv->pmib->wnmEntry.dot11vDbStaTxLoadThreshold*
-1000000)>>3));
-			
-}
-
-
-static bool checkBssTransDbApRxLoad(struct rtl8192cd_priv *priv){
-		return ((priv->ext_stats.rx_avarage>=((priv->pmib->wnmEntry.
-dot11vDbApRxLoadThreshold*1000000)>>3))&&(priv->pmib->wnmEntry.
-dot11vDbRedirectMask & REDIRECT_AP_RX_LOAD));
-			
-						
-}
-static bool checkBssTransDbStaRxLoad(struct stat_info* pstatd,struct rtl8192cd_priv *priv){
-	return (!(priv->pmib->wnmEntry.dot11vDbRedirectMask & REDIRECT_AP_RX_LOAD))?
-true:((pstatd->rx_avarage < ((priv->pmib->wnmEntry.dot11vDbStaRxLoadThreshold*
-1000000)>>3)));
-}
-
-static void chooseTargerSta(struct rtl8192cd_priv *priv){
-
-	if(checkBssTransDbApTxLoad(priv)||checkBssTransDbApRxLoad(priv)){
-
-		int idx = 0;
-		unsigned int tmpCoun=0;
-		char mark=0;
-		struct stat_info* pstatdTmp=NULL;
-		struct stat_info* pstatd = findNextSTA(priv, &idx);
-		while(pstatd) {
-			if(checkBssTransDbStaTxLoad(pstatd,priv) && checkBssTransDbStaRxLoad(pstatd,priv))
+		for(i=0; i<NUM_STAT; i++)
+		{
+			if (priv->pshare->aidarray[i] && (priv->pshare->aidarray[i]->used == TRUE)) 
 			{
-				if(mark=0){
-					tmpCoun=pstatd->bssTransReqCount;
-					mark=1;
-				}
-
-				if(pstatd->bssTransReqCount<=tmpCoun ){
-					tmpCoun=pstatd->bssTransReqCount;
-					pstatdTmp=pstatd;
+				if(priv->pshare->aidarray[i]->station.IOTPeer != HT_IOT_PEER_INTEL)
+				{	
+					only_intel_sta = 0;
+					break;
 				}
-
 			}
-			pstatd = findNextSTA(priv, &idx);
-		}
-
-		if(pstatdTmp!=NULL){
-			memcpy(priv->pmib->dot11StationConfigEntry.bss_req_mac,pstatdTmp->hwaddr,
-sizeof(pstatdTmp->hwaddr));
-			priv->pmib->dot11StationConfigEntry.wnmtest = 1;
-
-			DOT11VDBDEBUG("%s(%d): find STA (%02x%02x%02x%02x%02x%02x) (%d)\n", 
-__FUNCTION__, __LINE__
-                                           ,priv->pmib->
-dot11StationConfigEntry.bss_req_mac[0]
-                                           ,priv->pmib->
-dot11StationConfigEntry.bss_req_mac[1]
-                                           ,priv->pmib->
-dot11StationConfigEntry.bss_req_mac[2]
-                                           ,priv->pmib->
-dot11StationConfigEntry.bss_req_mac[3]
-                                           ,priv->pmib->
-dot11StationConfigEntry.bss_req_mac[4]
-                                           ,priv->pmib->
-dot11StationConfigEntry.bss_req_mac[5]
-					   , pstatdTmp->bssTransReqCount);
-
-			pstatdTmp->bssTransReqCount++;
-		}else{
-				DOT11VDBDEBUG("%s(%d): no victim\n", __FUNCTION__, __LINE__);
 		}
-		
-	}else{
-		resetBssTransReqCount(priv);
-	}
-}
-
-static void BssTransDriverBased(struct rtl8192cd_priv *priv){
-	struct stat_info *pstat;
 
-	if(WNM_ENABLE && priv->pmib->wnmEntry.dot11vDriverBasedEnable){
-		DOT11VDBDEBUG("dot11DbCounter= %d\n",priv->dot11DbCounter);
-		if(!(priv->dot11DbCounter)){
-			priv->dot11DbCounter=priv->pmib->wnmEntry.dot11vDbCheckInterval;
-			chooseTargerSta(priv);
-		}else{
-			priv->dot11DbCounter--;
-		}
-	}
-}
-#endif
-
-
-static void trigger_BssTransReq(struct rtl8192cd_priv *priv)
-{
-	struct stat_info *pstat = get_stainfo(priv, priv->pmib->dot11StationConfigEntry.bss_req_mac);
-	
-	if(pstat){
-		if(pstat->rcvNeighborReport) {
-			if (priv->pmib->wnmEntry.dot11vDiassocDeadline)
-				pstat->expire_to = priv->pmib->wnmEntry.dot11vDiassocDeadline;
-			else
-				pstat->expire_to = MAX_FTREASSOC_DEADLINE;
-			
-			panic_printk("Issue BSS Trans Request()! \n");
-			issue_BSS_Trans_Req(priv, priv->pmib->dot11StationConfigEntry.bss_req_mac , NULL);
-			priv->startCounting = TRUE;
-#ifdef CONFIG_IEEE80211V_DB_BS
-			priv->BssDbBsDiassocCounter= priv->pmib->wnmEntry.dot11vDiassocDeadline;
-#endif
+		if(only_intel_sta){
+			if(GET_CHIP_VER(priv) == VERSION_8197F)
+				RTL_W8(NAV_PROT_LEN, 0x14);
+			else if(GET_CHIP_VER(priv) == VERSION_8822B)
+				RTL_W8(NAV_PROT_LEN, 0x0);
 		}else
-			DOT11VDEBUG("Target client may not Ready yet!!\n");
-	}else
-		DOT11VDEBUG("(%s)line=%d, no such station \n", __FUNCTION__, __LINE__);
-	
-}
-
-#ifdef CONFIG_IEEE80211V_DB_BS
-static void BssTrans_DiassocTimer(struct rtl8192cd_priv *priv)
-{
-	struct stat_info *pstat;
-
-	if(!priv->BssDbBsDiassocCounter) 
-		priv->startCounting  = FALSE;
-
-	if(priv->startCounting  == TRUE &&  priv->BssDbBsDiassocCounter) {
-
-		priv->BssDbBsDiassocCounter--;
-
-		DOT11VDEBUG("Counting down= %d\n", priv->BssDbBsDiassocCounter);
-
-
-		if(!priv->BssDbBsDiassocCounter) {		
-		
-			priv->BssDbBsDiassocCounter= priv->pmib->wnmEntry.dot11vDiassocDeadline;
-
-			pstat = get_stainfo(priv, priv->pmib->dot11StationConfigEntry.bss_req_mac);
-			if(!pstat) {
-					DOT11VDEBUG("%s(%d) Cant find associated STA (%02x%02x%02x%02x%02x%02x)\n", __FUNCTION__, __LINE__
-											,priv->pmib->dot11StationConfigEntry.deauth_mac[0]
-											,priv->pmib->dot11StationConfigEntry.deauth_mac[1]
-											,priv->pmib->dot11StationConfigEntry.deauth_mac[2]
-											,priv->pmib->dot11StationConfigEntry.deauth_mac[3]
-											,priv->pmib->dot11StationConfigEntry.deauth_mac[4]
-											,priv->pmib->dot11StationConfigEntry.deauth_mac[5]);
-			} else {
-				if(checkBssTransDbBsIsEnable(priv)){
-					TriggerBssTransDbBs(priv);
-				}	
-			}
-			priv->startCounting  = FALSE;
-		}
-	}
+			RTL_W8(NAV_PROT_LEN, 0x40);
 }
 
-#else
-
-static void BssTrans_DiassocTimer(struct rtl8192cd_priv *priv)
-{
-	struct stat_info *pstat;
-
-	if(!priv->pmib->wnmEntry.dot11vDiassocDeadline) 
-		priv->startCounting  = FALSE;
-
-	if(priv->startCounting  == TRUE &&  priv->pmib->wnmEntry.dot11vDiassocDeadline) {
-
-		priv->pmib->wnmEntry.dot11vDiassocDeadline--;
-
-		DOT11VDEBUG("Counting down= %d\n", priv->pmib->wnmEntry.dot11vDiassocDeadline);
-
-
-		if(!priv->pmib->wnmEntry.dot11vDiassocDeadline) {
-
-			pstat = get_stainfo(priv, priv->pmib->dot11StationConfigEntry.bss_req_mac);
-			if(!pstat) {
-					DOT11VDEBUG("%s(%d) Cant find associated STA (%02x%02x%02x%02x%02x%02x)\n", __FUNCTION__, __LINE__
-											,priv->pmib->dot11StationConfigEntry.deauth_mac[0]
-											,priv->pmib->dot11StationConfigEntry.deauth_mac[1]
-											,priv->pmib->dot11StationConfigEntry.deauth_mac[2]
-											,priv->pmib->dot11StationConfigEntry.deauth_mac[3]
-											,priv->pmib->dot11StationConfigEntry.deauth_mac[4]
-											,priv->pmib->dot11StationConfigEntry.deauth_mac[5]);
-			} else {
-
-					panic_printk("(%s)line=%d, issue diassoc to trigger bss trans !\n", __FUNCTION__, __LINE__);
-					issue_disassoc(priv, priv->pmib->dot11StationConfigEntry.bss_req_mac, _RSON_DISASSOC_DUE_BSS_TRANSITION);
-					del_station(priv, pstat, 0);		
-				
-			}
-			priv->startCounting  = FALSE;
-		}
-	}
-}
-}
-
-#endif
-
-#endif
-
-#ifdef RTK_NL80211//survey_dump
+#if defined(RTK_NL80211) || defined(CH_LOAD_CAL)//survey_dump
 const int MCS_DATA_RATEFloat[2][2][16] =
 {
 	{{6.5, 13, 19.5, 26, 39, 52, 58.5, 65, 13, 26, 39, 52, 78, 104, 117, 130},						  // Long GI, 20MHz
@@ -5660,7 +5293,8 @@ const int MCS_DATA_RATEFloat[2][2][16] =
 	{{13.5, 27, 40.5, 54, 81, 108, 121.5, 135, 27, 54, 81, 108, 162, 216, 243, 270},                  // Long GI, 40MHz
 	 {15, 30, 45, 60, 90, 120, 135, 150, 30, 60, 90, 120, 180, 240, 270, 300}}                        // Short GI, 40MHz
 };
-
+#endif
+#ifdef RTK_NL80211
 void check_sta_throughput(struct rtl8192cd_priv *priv, unsigned int chan_idx)
 {
 	struct list_head *phead, *plist;
@@ -5808,6 +5442,91 @@ int read_noise_report(struct rtl8192cd_p
 }
 #endif
 
+#if defined(TXRETRY_CNT) || defined(CH_LOAD_CAL)
+void per_sta_cal(struct rtl8192cd_priv *priv)
+{
+	struct list_head *phead, *plist;
+	struct stat_info *pstat;
+	
+#ifdef CH_LOAD_CAL
+	int tx_rate=0, rx_rate=0;
+	int tx_time=0, rx_time=0;
+#endif
+
+	//calculate every sta tx/rx time and retry ratio
+	phead = &priv->asoc_list;
+	if (list_empty(phead))
+	{
+		return;
+	}
+	plist = phead->next;
+	
+	while (plist != phead)
+	{
+		pstat = list_entry(plist, struct stat_info, asoc_list);
+#ifdef CH_LOAD_CAL
+		pstat->total_tx_time=0;
+		pstat->total_rx_time=0;
+		//cal current tx rate
+#ifdef RTK_AC_SUPPORT  //vht rate , todo, dump vht rates in Mbps
+		if(pstat->current_tx_rate >= 0x90)
+		{
+			tx_rate = query_vht_rate(pstat);
+			rx_rate = query_vht_rate(pstat);
+		}
+		else
+#endif
+		if (is_MCS_rate(pstat->current_tx_rate)) 
+		{
+			tx_rate = MCS_DATA_RATEFloat[(pstat->ht_current_tx_info&BIT(0))?1:0][(pstat->ht_current_tx_info&BIT(1))?1:0][pstat->current_tx_rate&0xf];
+			rx_rate = MCS_DATA_RATEFloat[pstat->rx_bw&0x01][pstat->rx_splcp&0x01][pstat->rx_rate&0xf];
+		}
+		else
+		{
+			tx_rate = pstat->current_tx_rate/2;
+			rx_rate = pstat->rx_rate/2;
+		}
+		
+		//last tx/rx time
+		if(tx_rate != 0)
+			pstat->total_tx_time+= (((pstat->tx_bytes - pstat->prev_tx_byte)*8*1000)/(tx_rate*1024*1024));
+		if(rx_rate != 0)
+			pstat->total_rx_time+= (((pstat->rx_bytes - pstat->prev_rx_byte)*8*1000)/(rx_rate*1024*1024));
+
+		//tx/rx byte last
+		pstat->prev_tx_byte = pstat->tx_bytes;
+		pstat->prev_rx_byte = pstat->rx_bytes;
+
+		//count all traffic time
+		tx_time += pstat->total_tx_time;
+		rx_time += pstat->total_rx_time;
+#endif
+#ifdef TXRETRY_CNT
+		int tx_pkts = pstat->tx_pkts-pstat->prev_tx_pkts;
+		int retry_pkts = pstat->total_tx_retry_cnt-pstat->prev_tx_retry_pkts;
+	
+		if(tx_pkts>0 && retry_pkts>0)
+		{
+			pstat->txretry_ratio = (retry_pkts*100)/(tx_pkts);
+		}
+		else
+		{
+			pstat->txretry_ratio= 0;
+		}
+
+		pstat->prev_tx_pkts = pstat->tx_pkts;
+		pstat->prev_tx_retry_pkts = pstat->total_tx_retry_cnt;		
+#endif
+		plist = plist->next;
+	}
+		
+#ifdef CH_LOAD_CAL
+	priv->ext_stats.tx_time = tx_time;
+	priv->ext_stats.rx_time = rx_time;
+#endif
+
+}
+#endif
 
 #if defined(CLIENT_MODE) && defined(WIFI_11N_2040_COEXIST)
 void start_clnt_coexist_scan(struct rtl8192cd_priv *priv)
@@ -6013,28 +5732,7 @@ void issue_actionFrame(struct rtl8192cd_
 
 #ifdef CONFIG_IEEE80211V
 	  else if(WNM_ENABLE && priv->pmib->dot11StationConfigEntry.wnmtest == 1) { 
-		trigger_BssTransReq(priv);
-
-#ifdef CONFIG_IEEE80211V_DB_BS
-		//trigger band stearing directly if this STA never receiver neighbor report
-		struct stat_info *pstat = get_stainfo(priv, priv->pmib->dot11StationConfigEntry.bss_req_mac);
-
-       if(pstat){
-		if(checkBssTransDbBsIsEnable(priv)&& !pstat->rcvNeighborReport ){
-
-			if(!pstat->bssTransSupport || !(pstat->rm.rm_cap[0]|pstat->rm.rm_cap[1]|pstat->rm.rm_cap[2]|pstat->rm.rm_cap[3]|pstat->rm.rm_cap[4])){
-		 		//this STA never receive neighbor report because this STA doesn't support 11k 11v	
-		 		if(priv->pmib->wnmEntry.dot11vDriverBasedBsSupportNon11vSta){
-					TriggerBssTransDbBs(priv);
-				}
-			}else{
-				//this STA never receive neighbor report because this STA is still collecting neighbor info
-				TriggerBssTransDbBs(priv);
-			}
-				
-		}
-		}
-#endif
+		process_BssTransReq(priv);
 		priv->pmib->dot11StationConfigEntry.wnmtest = 0;		
 	}
 #endif
@@ -6073,7 +5771,10 @@ void rtl8192cd_expire_timer(unsigned lon
 #if defined(MBSSID) || defined(DOT11K)
 	int i;
 #endif
-
+#ifdef CH_LOAD_CAL
+	unsigned int clm_count=0;
+	unsigned int channel_utilization=0;
+#endif	
 	if (!(priv->drv_state & DRV_STATE_OPEN))
 		return;
 
@@ -6383,6 +6084,27 @@ void rtl8192cd_expire_timer(unsigned lon
 	priv->ext_stats.rx_avarage = (priv->ext_stats.rx_avarage/10)*7 + (priv->ext_stats.rx_byte_cnt/10)*3;
 	priv->ext_stats.rx_byte_cnt = 0;
 
+#ifdef CH_LOAD_CAL
+#ifdef USE_OUT_SRC
+	/* -----------Getting CLM info previous time---------------*/
+	if (phydm_checkCLMready(ODMPTR) ) {			
+		clm_count = phydm_getCLMresult2(priv);	
+	}
+
+	if(clm_count >0 ) {
+		/*IEEE,Std 802.11-2012,page567,use 0~255 to representing 0~100%*/
+		channel_utilization= (clm_count * 255) /CLM_SAMPLE_NUM2  ;	       
+		priv->ext_stats.ch_utilization=channel_utilization	;					
+	}	   
+	/* -----------Getting CLM info previous time---------------*/
+
+	/* trigger next time CLM */	
+	phydm_clm_trigger(ODMPTR);
+#endif	
+#endif
+#if defined(TXRETRY_CNT) || defined(CH_LOAD_CAL)
+	per_sta_cal(priv);
+#endif
 #ifdef RTK_NL80211
 #if 0 //brian, collect channel load information during sitesurvey in stead of here to make sure freshness
 	//survey_dump
@@ -7231,25 +6953,17 @@ if(!IS_OUTSRC_CHIP(priv))
 #endif
 
 #if defined(CONFIG_IEEE80211W) || defined(CONFIG_IEEE80211V)
-#ifdef CONFIG_IEEE80211V_DB	
-	if(WNM_ENABLE){
-		BssTransDriverBased(priv);
-#ifdef CONFIG_IEEE80211V_DB_BS
-		if(checkBssTransDbBsIsEnable(priv)){
-			bssTransDbBsTimer(priv);
-		}
-#endif
-	}
-#endif	
 	issue_actionFrame(priv);
-#endif //CONFIG_IEEE80211W
-
-#ifdef CONFIG_IEEE80211V
-	if(WNM_ENABLE){
+#endif 
+#ifdef CONFIG_IEEE80211V 
+	if(WNM_ENABLE) {
+		BssTrans_ExpiredTimer(priv);
 		BssTrans_DiassocTimer(priv);
-}
-
-
+	#ifdef CONFIG_IEEE80211V_CLI
+		BssTrans_ValidatePrefListTimer(priv);
+		BssTrans_TerminationTimer(priv);
+	#endif
+	}
 #endif
 
 #ifdef SW_TX_QUEUE
@@ -10249,7 +9963,7 @@ static __inline__ unsigned char *update_
 static unsigned char * construct_BSS_load_ie(struct rtl8192cd_priv *priv, unsigned char	*pbuf, unsigned int *frlen)
 {
     *(unsigned short *)priv->pmib->hs2Entry.bssload_ie = cpu_to_le16((unsigned short)priv->assoc_num);
-    priv->pmib->hs2Entry.bssload_ie[2] = priv->pshare->cu_info.channel_utilization;
+    priv->pmib->hs2Entry.bssload_ie[2] = priv->ext_stats.ch_utilization;
     priv->pmib->hs2Entry.bssload_ie[3] = 0;
     priv->pmib->hs2Entry.bssload_ie[4] = 0;
     pbuf = set_ie(pbuf, _BSS_LOAD_IE_, 5, priv->pmib->hs2Entry.bssload_ie, frlen);
@@ -11258,25 +10972,6 @@ void update_beacon(struct rtl8192cd_priv
 // beacon
 #ifdef RTK_AC_SUPPORT //for 11ac logo
     if (priv->pmib->dot11BssType.net_work_type & WIRELESS_11AC) {
-        // 41
-        {
-				extended_cap_ie[7] |= 0x40;		
-			#ifdef TDLS_SUPPORT
-				if(priv->pmib->dot11OperationEntry.tdls_prohibited){ 
-					extended_cap_ie[4] |= 0x40;		// bit 38(tdls_prohibited)
-				}else{
-					if(priv->pmib->dot11OperationEntry.tdls_cs_prohibited){ 
-						extended_cap_ie[4] |= 0x80;	// bit 39(tdls_cs_prohibited)
-					}
-				}
-			#endif
-			#ifdef CONFIG_IEEE80211V
-				if(priv->pmib->wnmEntry.dot11vBssTransEnable)
-					extended_cap_ie[2] |= 0x08;		//bit 19
-			#endif
-
-        }
-        // 60, 61
 #ifdef MCR_WIRELESS_EXTEND
 		construct_vht_ie_mcr(priv, priv->pshare->working_channel, pstat);
 #else
@@ -11464,22 +11159,6 @@ void update_beacon(struct rtl8192cd_priv
         pbuf = construct_ecm_tvm_ie(priv, pbuf, &frlen, i);
 #endif //defined(TV_MODE) || defined(A4_STA)
 
-
-
-#ifdef TDLS_SUPPORT 
-	if(priv->pmib->dot11OperationEntry.tdls_prohibited){ 
-		extended_cap_ie[4] |= 0x40;	// bit 38(tdls_prohibited)
-	}else{
-		if(priv->pmib->dot11OperationEntry.tdls_cs_prohibited){ 
-			extended_cap_ie[4] |= 0x80;	// bit 39(tdls_cs_prohibited)
-		}
-	}
-#endif
-#ifdef CONFIG_IEEE80211V
-	if(priv->pmib->wnmEntry.dot11vBssTransEnable)
-		extended_cap_ie[2] |= 0x08;		//bit 19
-#endif 	
-
 	if (priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) {
 		/*
 			2008-12-16, For Buffalo WLI_CB_AG54L 54Mbps NIC interoperability issue.
@@ -11615,16 +11294,27 @@ void update_beacon(struct rtl8192cd_priv
 	}
 #endif
 
+#ifdef TDLS_SUPPORT 
+	if(priv->pmib->dot11OperationEntry.tdls_prohibited){ 
+		extended_cap_ie[4] |= _TDLS_PROHIBITED_;	// bit 38(tdls_prohibited)
+	}else{
+		if(priv->pmib->dot11OperationEntry.tdls_cs_prohibited){ 
+			extended_cap_ie[4] |= _TDLS_CS_PROHIBITED_;	// bit 39(tdls_cs_prohibited)
+		}
+	}
+#endif
+#ifdef CONFIG_IEEE80211V
+	if(WNM_ENABLE)
+		extended_cap_ie[2] |= _BSS_TRANSITION_ ; // bit 19
+#endif 	
+
 	#ifdef HS2_SUPPORT		/*process ext cap IE(IE ID=107) for HS2*/
 	if (priv->pmib->hs2Entry.interworking_ielen)
 	{	
 		// byte0
 		if (priv->proxy_arp){
 			extended_cap_ie[1] |=_PROXY_ARP_ ;
-		}
-
-		extended_cap_ie[2] |=_BSS_TRANSITION_ ; // byte2
-		
+		}		
 
 		if ((priv->pmib->hs2Entry.timezone_ielen!=0) && (priv->pmib->hs2Entry.timeadvt_ielen)){
 			extended_cap_ie[3] |= _UTC_TSF_OFFSET_ ;
@@ -14289,9 +13979,7 @@ void issue_asocrsp(struct rtl8192cd_priv
 		if (priv->proxy_arp){
 			extended_cap_ie[1] |=_PROXY_ARP_ ;
 		}
-	
-		extended_cap_ie[2] |=_BSS_TRANSITION_ ; // byte2
-	
+		
 		if ((priv->pmib->hs2Entry.timezone_ielen!=0) && (priv->pmib->hs2Entry.timeadvt_ielen)){
 			extended_cap_ie[3] |= _UTC_TSF_OFFSET_ ;
 		}
@@ -14304,6 +13992,19 @@ void issue_asocrsp(struct rtl8192cd_priv
 			
 	}
 	#endif
+#ifdef TDLS_SUPPORT 
+	if(priv->pmib->dot11OperationEntry.tdls_prohibited){ 
+		extended_cap_ie[4] |= _TDLS_PROHIBITED_;	// bit 38
+	}else{
+		if(priv->pmib->dot11OperationEntry.tdls_cs_prohibited){ 
+			extended_cap_ie[4] |= _TDLS_CS_PROHIBITED_;	// bit 39
+		}
+	}
+#endif
+#ifdef CONFIG_IEEE80211V
+	if(WNM_ENABLE)
+		extended_cap_ie[2] |=_BSS_TRANSITION_ ; // bit 19
+#endif
 	/*===========ext cap IE all in here! so far (HS2, AC,TDLS )!!=================*/	
 	pbuf = set_ie(pbuf, _EXTENDED_CAP_IE_, 8, extended_cap_ie, &txinsn.fr_len);
 	/*===========ext cap IE all in here!!!=================*/
@@ -14789,9 +14490,7 @@ int fill_probe_rsp_content(struct rtl819
 		if (priv->proxy_arp){
 			extended_cap_ie[1] |=_PROXY_ARP_ ;
 		}
-	
-		extended_cap_ie[2] |=_BSS_TRANSITION_ ; // byte2			
-	
+		
 		if ((priv->pmib->hs2Entry.timezone_ielen!=0) && (priv->pmib->hs2Entry.timeadvt_ielen)){
 			extended_cap_ie[3] |= _UTC_TSF_OFFSET_ ;
 		}
@@ -14803,6 +14502,20 @@ int fill_probe_rsp_content(struct rtl819
 		extended_cap_ie[5] |= _WNM_NOTIFY_; //WNM notification, Bit46			
 	}
 	#endif	
+#ifdef TDLS_SUPPORT 
+	if(priv->pmib->dot11OperationEntry.tdls_prohibited){ 
+		extended_cap_ie[4] |= _TDLS_PROHIBITED_;	// bit 38
+	}else{
+		if(priv->pmib->dot11OperationEntry.tdls_cs_prohibited){ 
+			extended_cap_ie[4] |= _TDLS_CS_PROHIBITED_;	// bit 39
+		}
+	}
+#endif	
+ #ifdef CONFIG_IEEE80211V
+	if(WNM_ENABLE)
+		extended_cap_ie[2] |=_BSS_TRANSITION_ ; // bit 19	
+#endif
+
 	/*===========fill ext cap IE here! so far (HS2, AC,TDLS )*/		
 	pbuf = set_ie(pbuf, _EXTENDED_CAP_IE_, 8, extended_cap_ie, &fr_len);
 	/*===========ext cap IE all in here!!!=================*/
@@ -14992,7 +14705,10 @@ void issue_probereq_MP(struct rtl8192cd_
     if (priv->pshare->rf_ft_var.mp_specific)
         return;
 #endif
-
+#ifdef CONFIG_IEEE80211V_CLI
+	unsigned char extended_cap_ie[8];	
+	memset(extended_cap_ie, 0, 8);
+#endif	
 
 #if	0	/*def DFS*/
 #ifdef UNIVERSAL_REPEATER
@@ -15157,6 +14873,13 @@ void issue_probereq_MP(struct rtl8192cd_
 #endif
 /*cfg p2p cfg p2p*/
 
+#ifdef CONFIG_IEEE80211V_CLI
+		if(WNM_ENABLE) {
+			extended_cap_ie[2] |= _WNM_BSS_TRANS_SUPPORT_ ;
+			pbuf = set_ie(pbuf, _EXTENDED_CAP_IE_, 8, extended_cap_ie, &txinsn.fr_len);
+		 }
+#endif
+
 #ifdef HS2_SUPPORT
 #ifdef HS2_CLIENT_TEST
 	if (priv->pshare->rf_ft_var.swq_dbg == 30)
@@ -16980,231 +16703,6 @@ int check_dz_mgmt(struct rtl8192cd_priv
 #endif
 #endif
 
-#ifdef CONFIG_IEEE80211V
-void WNM_ActionHandler(struct rtl8192cd_priv *priv, struct stat_info *pstat,
-                              unsigned char *pframe, unsigned char Action_field, int frame_len)
-{
-	switch (Action_field) {
-		case _WNM_TSMQUERY_ACTION_ID_: 
-			OnBSSTransQuery(priv, pstat, pframe, frame_len);
-			break;
-		case _BSS_TSMRSP_ACTION_ID_: 
-			OnBSSTransRsp(priv, pframe, frame_len);
-			break;
-		default:
-			DEBUG_INFO("Other WNM action: %d:\n", Action_field);
-			break;
-	}
-}
-
-int issue_BSS_Trans_Req(struct rtl8192cd_priv *priv, unsigned char *da, unsigned char dialog_token)
-{	
-	int ret;
-	unsigned char  *pbuf;
-    	unsigned int frlen = 0;
-	int neighbor_size = 0, i =0;
-	unsigned char req_mode = priv->pmib->wnmEntry.dot11vReqMode;
-	unsigned short diassoc_time = priv->pmib->wnmEntry.dot11vDiassocDeadline;
-	struct stat_info *pstat = get_stainfo(priv, da);
-
-	DOT11VDEBUG("Req mode=%x, diassoc_time = %d, %x\n", req_mode, diassoc_time, cpu_to_le16(diassoc_time));
-
-	DECLARE_TXINSN(txinsn);
-	txinsn.q_num = MANAGE_QUE_NUM;
-	txinsn.fr_type = _PRE_ALLOCMEM_;
-	txinsn.tx_rate = find_rate(priv, NULL, 0, 1);
-#ifndef TX_LOWESTRATE	
-	txinsn.lowest_tx_rate = txinsn.tx_rate;
-#endif
-	txinsn.fixed_rate = 1;
-
-#ifdef CONFIG_IEEE80211W	
-	 if(pstat)
-		 txinsn.isPMF = pstat->isPMF;
-	 else
-		 txinsn.isPMF = 0;
-#endif
-	pbuf = txinsn.pframe = get_mgtbuf_from_poll(priv);
-	if (pbuf == NULL)
-	    goto issue_wnm_bss_trans_fail;
-
-	txinsn.phdr = get_wlanhdr_from_poll(priv);
-	if (txinsn.phdr == NULL)
-	    goto issue_wnm_bss_trans_fail;
-
-	memset((void *)(txinsn.phdr), 0, sizeof(struct wlan_hdr));
-
-	pbuf[frlen++]= _WNM_CATEGORY_ID_; 
-	pbuf[frlen++] = _BSS_TSMREQ_ACTION_ID_;
-
-	//dialog_token(1): require mode field(1): dissoc timer(2): validity interval(1)
-	if(req_mode & (_WNM_PREFERRED_CANDIDATE_LIST_|_WNM_ABRIDGED_)) {
-		pbuf[frlen++] = 1;
-		pbuf[frlen++]  = req_mode; 	
-		 *(unsigned short *)(pbuf + frlen) = cpu_to_le16(diassoc_time);
-		frlen += 2;
-		pbuf[frlen++]  = 200;	//validity interval
-		pbuf += frlen;
-#ifdef DOT11K
-		neighbor_size = sizeof(struct dot11k_neighbor_report);
-		for(i = 0; i < MAX_NEIGHBOR_REPORT; i++) {
-	   		if((priv->rm_neighbor_bitmask[i>>3] & (1<<(i&7))) == 0)
-	    			continue;
-	    		if(frlen + neighbor_size > MAX_REPORT_FRAME_SIZE)
-	    			break;
-	    		
-			pbuf = construct_neighbor_report_ie(pbuf, &frlen, &priv->rm_neighbor_report[i]);
-	    	}
-#endif
-	}else {
-		panic_printk("Type2 : Bss Trans Req \n"); 	
-		pbuf[frlen++] = dialog_token;			
-		pbuf[frlen++]  = 0; 				
-		 *(unsigned short *)(pbuf + frlen) = cpu_to_le16(0);	
-		frlen += 2;
-		pbuf[frlen++]  = 1;					
-		pbuf += frlen;
-	}
-	
-	txinsn.fr_len = frlen;
-    	SetFrameSubType((txinsn.phdr), WIFI_WMM_ACTION);
-#ifdef CONFIG_IEEE80211W	
-	if (txinsn.isPMF)
-		*(unsigned char*)(txinsn.phdr+1) |= BIT(6); // enable privacy 
-#endif
-   	memcpy((void *)GetAddr1Ptr((txinsn.phdr)), da, MACADDRLEN);
-    	memcpy((void *)GetAddr2Ptr((txinsn.phdr)), GET_MY_HWADDR, MACADDRLEN);
-   	memcpy((void *)GetAddr3Ptr((txinsn.phdr)), BSSID, MACADDRLEN);
-
-	if (pstat == NULL)
-		goto issue_wnm_bss_trans_fail;
-		
-	txinsn.pstat = pstat;
-#if defined(WIFI_WMM)
-    	ret = check_dz_mgmt(priv, pstat, &txinsn);
-    	if (ret < 0)
-       	 goto issue_wnm_bss_trans_fail;
-    	else if (ret==1)
-       	 return 0;
-   	else
-#endif	
-	if ((rtl8192cd_firetx(priv, &txinsn)) == SUCCESS) {
-		return SUCCESS;
-	}
-
-issue_wnm_bss_trans_fail:
-
-	if (txinsn.phdr)
-		release_wlanhdr_to_poll(priv, txinsn.phdr);
-	if (txinsn.pframe)
-		release_mgtbuf_to_poll(priv, txinsn.pframe);
-	return FAIL;
-}
-
-static void showReason(unsigned char status_code)
-{
-	switch(status_code) {
-		case WNM_BSS_TM_ACCEPT:
-			DOT11VDEBUG("Accept: WNM_BSS_TM_ACCEPT!\n"); 
-			break;
-		case WNM_BSS_TM_REJECT_UNSPECIFIED:
-			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_UNSPECIFIED!\n"); 
-			break;
-		case WNM_BSS_TM_REJECT_INSUFFICIENT_BEACON: 
-			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_INSUFFICIENT_BEACON!\n"); 
-			break;
-		case WNM_BSS_TM_REJECT_INSUFFICIENT_CAPABITY:
-			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_INSUFFICIENT_CAPABITY!\n"); 
-			break;
-		case WNM_BSS_TM_REJECT_UNDESIRED :
-			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_UNDESIRED !\n"); 
-			break;
-		case WNM_BSS_TM_REJECT_DELAY_REQUEST : 
-			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_DELAY_REQUEST !\n"); 
-			break;
-		case WNM_BSS_TM_REJECT_STA_CANDIDATE_LIST_PROVIDED :
-			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_STA_CANDIDATE_LIST_PROVIDED !\n"); 
-			break;
-		case WNM_BSS_TM_REJECT_NO_SUITABLE_CANDIDATES  : 
-			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_NO_SUITABLE_CANDIDATES  !\n"); 
-			break;
-		case WNM_BSS_TM_REJECT_LEAVING_ESS  :
-			DOT11VDEBUG("Reject: WNM_BSS_TM_REJECT_LEAVING_ESS  !\n"); 
-			break;
-		default:
-			DOT11VDEBUG("unknown type  !\n"); 
-			break;
-	}
-}
-
-void OnBSSTransRsp(struct rtl8192cd_priv *priv, unsigned char *pframe, int frame_len)
-{
-	if(frame_len < 3) {
-		DEBUG_ERR("Ignore too short BSS Trans Management RSP!\n"); 
-		return;
-	}
-	int frlen = 0;
-	unsigned char dialog_token = pframe[2];
-	unsigned char status_code = pframe[3];
-	unsigned char bss_termination_delay = pframe[4];	//mins
-	frlen = 5;
-
-	DOT11VDEBUG("dialog_token = %d, bss_termination_delay = %d\n", dialog_token, bss_termination_delay);
-	showReason(status_code);
-
-#ifdef CONFIG_IEEE80211V_DB_BS
-	if(status_code!=WNM_BSS_TM_ACCEPT && checkBssTransDbBsIsEnable(priv)){
-		TriggerBssTransDbBs(priv);
-	}
-#endif
-
-	if((frame_len - frlen) > MAX_LIST_LEN)
-		return;
-	
-	if((frame_len - frlen) > 0) {
-		if(status_code == WNM_BSS_TM_ACCEPT) {
-			debug_out("Target BSSID: ", &pframe[frlen], MACADDRLEN);
-			frlen += MACADDRLEN;
-			
-			debug_out("Bss Trans Candidate List: ", &pframe[frlen], frame_len - frlen);
-		}else if(status_code == WNM_BSS_TM_REJECT_DELAY_REQUEST){
-#ifndef CONFIG_IEEE80211V_DB_BS
-			priv->pmib->wnmEntry.dot11vDiassocDeadline = bss_termination_delay*60;
-#endif
-		}else
-			debug_out("Bss Trans Candidate List: ", &pframe[frlen], frame_len - frlen);
-	}else {
-		DEBUG_ERR("WNM: no info in bss trans response!\n"); 
-		return;
-	}
-	
-}
-
-void OnBSSTransQuery(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char *pframe, int frame_len)
-{
-	if(frame_len < 2) {
-		DEBUG_ERR("Ignore too short BSS Transition Management Query!\n"); 
-		return;
-	}
-	
-	unsigned char dialog_token = pframe[2];
-	unsigned char reason  = pframe[3]; 
-	int list_len;
-	DOT11VDEBUG("dialog_token = %d, reason = %d\n", dialog_token, reason); 
-	
-	if(reason == _WNM_PREFERED_BSS_TRANS_LIST_INCLUDED_){
-		list_len =   frame_len - 4;
-		if(list_len > MAX_LIST_LEN)
-			return;
-
-		debug_out("Bss List Len: ", &pframe[list_len], frame_len - list_len);
-	}else
-		panic_printk("WNM_PREFERED BSS TRANS LIST NOT INCLUDED!\n"); 
-	
-	issue_BSS_Trans_Req(priv, pstat->hwaddr, dialog_token);
-}
-#endif
-
 #ifdef CONFIG_IEEE80211W
 
 void stop_sa_query(struct stat_info *pstat)
@@ -18194,9 +17692,13 @@ static void ProfileSort (struct rtl8192c
 	}
 }
 
-
+#if defined(CONFIG_IEEE80211V_CLI) ||defined(CONFIG_IEEE80211R_CLI)
+void qsort (void  *base, int nel, int width,
+				int (*comp)(const void *, const void *))
+#else
 static void qsort (void  *base, int nel, int width,
 				int (*comp)(const void *, const void *))
+#endif
 {
 	int wgap, i, j, k;
 	unsigned char tmp;
@@ -21254,6 +20756,21 @@ collect_this_bss:
 	}
 #endif
 
+#ifdef CONFIG_IEEE80211V_CLI
+	if(WNM_ENABLE) {
+		unsigned char ext_cap[8];
+		memset(ext_cap, 0, 8);
+		p = get_ie(pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_, _EXTENDED_CAP_IE_, &len,
+				pfrinfo->pktlen - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_);
+		if(p != NULL) {
+			memcpy(ext_cap, p+2, 8);
+			if(ext_cap[2] & _WNM_BSS_TRANS_SUPPORT_) {
+				priv->site_survey->bss[index].t_stamp[1] |= BSS_TRANS_SUPPORT;	
+			}
+		}
+	} 
+#endif
+
 #if defined(WIFI_WPAS) || defined(RTK_NL80211) || defined(CONFIG_RTL_COMAPI_WLTOOLS)
 			priv->site_survey->bss[index].rsn_ie_len = 0;			/*cfg p2p cfg p2p*/
 			priv->site_survey->bss[index].wpa_ie_len = 0;			/*cfg p2p cfg p2p*/
@@ -21829,9 +21346,6 @@ unsigned int OnAssocReq(struct rtl8192cd
 	unsigned char *p2pIEPtr = ReAssem_p2pie ;
 	int p2pIElen;
 #endif
-#ifdef CONFIG_IEEE80211V
-	unsigned char ext_cap[8] = {0};
-#endif
 	pmib = GET_MIB(priv);
 	pframe = get_pframe(pfrinfo);
 	pstat = get_stainfo(priv, GetAddr2Ptr(pframe));
@@ -21968,15 +21482,7 @@ unsigned int OnAssocReq(struct rtl8192cd
 
 #ifdef CONFIG_IEEE80211V
 	if(WNM_ENABLE) {
-		p = get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _EXTENDED_CAP_IE_, &len, 
-               	pfrinfo->pktlen - WLAN_HDR_A3_LEN - ie_offset);
-		if(p != NULL) {
-			memcpy(ext_cap, p+2, 8);
-			if(ext_cap[2] & _WNM_BSS_TRANS_SUPPORT_)
-				pstat->bssTransSupport = TRUE;
-
-			panic_printk("pstat->dot11v_support  %d\n", pstat->bssTransSupport); 	
-		}
+		set_staBssTransCap(pstat, pframe, (pfrinfo->pktlen - WLAN_HDR_A3_LEN - ie_offset), ie_offset);
 	}
 #endif
 
@@ -22167,18 +21673,6 @@ unsigned int OnAssocReq(struct rtl8192cd
         release_brsc_cache(GetAddr2Ptr(pframe));
         #endif
 
-#ifdef CONFIG_IEEE80211V_DB_BS
-
-if( checkBssTransDbBsIsEnable(priv)&& bssTransDbBsCheckRequest(priv, GetAddr2Ptr(pframe), WIFI_ASSOCREQ)){
-	DOT11VDBDEBUG("%s(%d): ignore WIFI_ASSOCREQ  because 11v band steering\n", __FUNCTION__, __LINE__);
-	 /* ignore */
-	 status = _STATS_ASSOC_REJ_TEMP_;
-			goto OnAssocReqFail;
-//	 return FAIL;
-}
-
-#endif		
-
 #ifdef WIFI_WMM
 	// check if there is WMM IE
 	if (QOS_ENABLE) {
@@ -23756,18 +23250,6 @@ normal_probe_req:
 	
 send_rsp:
 
-
-#ifdef CONFIG_IEEE80211V_DB_BS
-
-if( checkBssTransDbBsIsEnable(priv)&& bssTransDbBsCheckRequest(priv, GetAddr2Ptr(pframe), WIFI_PROBEREQ)){
-	 /* ignore */
-	 	 DOT11VDBDEBUG("%s(%d): ignore WIFI_PROBEREQ  because 11v band steering\n", __FUNCTION__, __LINE__);
-	 goto OnProbeReqFail;
-}
-
-#endif				
-
-
 #ifdef STA_CONTROL
 #ifdef STA_CONTROL_AIPC
     if(STACTRL_SHM_SUPPORT)
@@ -24335,7 +23817,12 @@ unsigned int OnDisassoc(struct rtl8192cd
 #ifdef CONFIG_IEEE80211W
 	if(pstat->isPMF) {
 		pstat->isPMF = 0; // transmit unprotected mgmt frame
-		// issue_disassoc(priv, sa, 7);
+	}
+#endif
+
+#ifdef CONFIG_IEEE80211V
+	if(WNM_ENABLE) {
+		reset_staBssTransStatus(pstat);
 	}
 #endif
 
@@ -24849,13 +24336,6 @@ unsigned int OnAuth(struct rtl8192cd_pri
 			del_station(priv_del, pstat_del, 0);
 	}
 
-#ifdef CONFIG_IEEE80211V_DB_BS
-	if( checkBssTransDbBsIsEnable(priv)&& bssTransDbBsCheckRequest(priv, GetAddr2Ptr(pframe), WIFI_AUTH)){
-		 /* ignore */
-		  DOT11VDBDEBUG("%s(%d): ignore WIFI_AUTH  because 11v band steering\n", __FUNCTION__, __LINE__);
-		 return FAIL;
-	}
-#endif
 	// (below, share with Mesh) due to the free_statinfo in AUTH_TO, we should enter critical section here!
 	SAVE_INT_AND_CLI(flags);
 
@@ -25308,7 +24788,12 @@ unsigned int OnDeAuth(struct rtl8192cd_p
 #ifdef CONFIG_IEEE80211W
 	if(pstat->isPMF) {
 		pstat->isPMF = 0;
-		// issue_deauth(priv, sa, 6);
+	}
+#endif
+
+#ifdef CONFIG_IEEE80211V
+	if(WNM_ENABLE) {
+		reset_staBssTransStatus(pstat);
 	}
 #endif
 #ifdef RTK_WOW
@@ -25915,7 +25400,7 @@ ACTIVE_NOT_11S:
 #ifdef CONFIG_IEEE80211V
 				case _WNM_CATEGORY_ID_:
 					if(WNM_ENABLE && pstat->bssTransSupport)
-						WNM_ActionHandler(priv, pstat, pframe, Action_field, pfrinfo->pktlen - WLAN_HDR_A3_LEN);
+						WNM_ActionHandler(priv, pstat, pframe, (pfrinfo->pktlen - WLAN_HDR_A3_LEN));
 					else
 						DOT11VDEBUG("Warning: !WNM_ENABLE or !bssTransSupport. \n");
 				break;	
@@ -26268,6 +25753,10 @@ unsigned int issue_assocreq(struct rtl81
 	unsigned char	supportRateSet[32];
 	int		i, j, idx=0, supportRateSetLen=0, match=0;
 	unsigned int	retval=0;
+
+	unsigned char extended_cap_ie[8];	
+	memset(extended_cap_ie, 0, 8);
+	
 #ifdef WIFI_WMM
 	int		k;
 #endif
@@ -26542,16 +26031,16 @@ unsigned int issue_assocreq(struct rtl81
 						construct_vht_ie(priv, priv->pshare->working_channel);
 						pbuf = set_ie(pbuf, EID_VHTCapability, priv->vht_cap_len, (unsigned char *)&priv->vht_cap_buf, &txinsn.fr_len);
 						pbuf = set_ie(pbuf, EID_VHTOperation, priv->vht_oper_len, (unsigned char *)&priv->vht_oper_buf, &txinsn.fr_len);
-						if(priv->pshare->rf_ft_var.opmtest&1) {	
-							char tmp[8];
-							memset(tmp, 0, 8);
-							tmp[7] = 0x40;
-							pbuf = set_ie(pbuf, _EXTENDED_CAP_IE_, 8, tmp, &txinsn.fr_len);
-						}
+						extended_cap_ie[7] = 0x40;
 					}
 #endif
+		#ifdef CONFIG_IEEE80211V_CLI
+					if(WNM_ENABLE) {
+						extended_cap_ie[2] |= _WNM_BSS_TRANS_SUPPORT_ ;							
+					}
+		#endif
+					pbuf = set_ie(pbuf, _EXTENDED_CAP_IE_, 8, extended_cap_ie, &txinsn.fr_len);
 				}
-
 				break;
 			}
 		}
@@ -28243,6 +27732,12 @@ void calculate_rx_beacon(struct rtl8192c
 				if ((priv->rxBeaconPercentage < ROAMING_THRESHOLD || fast_roaming_triggered) && !rx_data_delta) {
 					DEBUG_INFO("Roaming...\n");
 					LOG_MSG("Roaming...\n");
+			#ifdef CONFIG_IEEE80211V_CLI
+					if(WNM_ENABLE && (OPMODE & WIFI_STATION_STATE)) {
+						memset(priv->pmib->dot11StationConfigEntry.dot11DesiredBssid, 0, MACADDRLEN);	
+						DOT11VDEBUG("Reset dot11DesiredBssid!!\n");//if target AP is disappeared
+					}
+			#endif
 #if defined(CONFIG_RTL8196B_TR) || defined(CONFIG_RTL865X_SC) || defined(CONFIG_RTL865X_AC) || defined(CONFIG_RTL865X_KLD) || defined(CONFIG_RTL8196B_KLD) || defined(CONFIG_RTL8196C_KLD) || defined(CONFIG_RTL8196C_EC)
 					LOG_MSG_NOTICE("Roaming...;note:\n");
 #endif
@@ -28587,7 +28082,9 @@ unsigned int OnAssocRsp(struct rtl8192cd
 	int if_idx = -1;
 #endif
 
-
+#ifdef CONFIG_IEEE80211V_CLI
+	unsigned char ext_cap[8];
+#endif
 
 	if (!(OPMODE & WIFI_STATION_STATE))
 		return SUCCESS;
@@ -29001,6 +28498,19 @@ unsigned int OnAssocRsp(struct rtl8192cd
 		}
 	}
 
+#ifdef CONFIG_IEEE80211V_CLI
+	if(WNM_ENABLE)  {
+		p = get_ie(pframe + WLAN_HDR_A3_LEN + _ASOCRSP_IE_OFFSET_, _EXTENDED_CAP_IE_, &len,
+				pfrinfo->pktlen - WLAN_HDR_A3_LEN - _ASOCRSP_IE_OFFSET_);
+		if (p != NULL) {
+			memcpy(ext_cap, p+2, 8);
+			if(ext_cap[2] & _WNM_BSS_TRANS_SUPPORT_) {
+				pstat->bssTransSupport = TRUE;
+				reset_staBssTransStatus(pstat);
+			}
+		}
+	}
+#endif
 
 //8812_client add pstat vht ie
 #ifdef RTK_AC_SUPPORT
@@ -29066,6 +28576,19 @@ unsigned int OnAssocRsp(struct rtl8192cd
 		}
 	}
 #endif
+#ifdef CONFIG_IEEE80211V_CLI
+	if(WNM_ENABLE && (OPMODE & WIFI_STATION_STATE))  {
+		p = get_ie(pframe + WLAN_HDR_A3_LEN + _ASOCRSP_IE_OFFSET_, _EXTENDED_CAP_IE_, &len,
+				pfrinfo->pktlen - WLAN_HDR_A3_LEN - _ASOCRSP_IE_OFFSET_);
+		if (p != NULL) {
+			memcpy(ext_cap, p+2, 8);
+			if(ext_cap[2] & _WNM_BSS_TRANS_SUPPORT_) {
+				pstat->bssTransSupport = TRUE;
+				reset_staBssTransStatus(pstat);
+			}
+		}
+	}
+#endif
 
 #ifdef WIFI_WMM  //  WMM STA
 	if (QOS_ENABLE) {
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_util.c
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/8192cd_util.c
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/8192cd_util.c
@@ -8636,7 +8636,7 @@ INT32 rtl_isPassthruFrame(UINT8 *data)
 }
 #endif
 
-#if defined(HS2_SUPPORT) || defined(DOT11K)
+#if 0	//defined(HS2_SUPPORT) || defined(DOT11K) || defined(CH_LOAD_CAL)
 void rtl8192cd_cu_stop(struct rtl8192cd_priv *priv) {
     unsigned char stop_cu = 1;
     int i;
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/dot11k/8192cd_11k_beacon.c
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/dot11k/8192cd_11k_beacon.c
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/dot11k/8192cd_11k_beacon.c
@@ -1034,7 +1034,9 @@ int rm_get_beacon_report(struct rtl8192c
                 memcpy(result_buf + len, pstat->rm.beacon_report, pstat->rm.beacon_report_num * sizeof(struct dot11k_beacon_measurement_report));
                 len += pstat->rm.beacon_report_num * sizeof(struct dot11k_beacon_measurement_report);
 	#ifdef CONFIG_IEEE80211V
-		  if(WNM_ENABLE && pstat->bssTransSupport)
+		  if(WNM_ENABLE && 
+		  	pstat->bssTransSupport &&
+		 	priv->pmib->wnmEntry.Is11kDaemonOn)
 		  	pstat->rcvNeighborReport = TRUE;
 	#endif		
             }
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/dot11k/8192cd_11k_neighbor.c
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/dot11k/8192cd_11k_neighbor.c
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/dot11k/8192cd_11k_neighbor.c
@@ -39,13 +39,7 @@
 #include "../8192cd_debug.h"
 
 #ifdef CONFIG_IEEE80211V
-#define MAX_PREFERRED_VAL 255
-
-inline unsigned char getPreferredVal(struct rtl8192cd_priv *priv, unsigned char channel_utilization, unsigned short sta_count, bool excluded)
-{
-	if(!priv->bssTransPara.isFromUser)
-		return (channel_utilization && !excluded) ? (MAX_PREFERRED_VAL - channel_utilization) : 0;	
-}
+#include "../8192cd_11v.h"
 #endif
 
 #ifdef DOT11K
@@ -322,7 +316,7 @@ int rm_construct_neighbor_report(struct
     if(WNM_ENABLE) {
    		priv->rm_neighbor_report[i].subelemnt.subelement_id = _WNM_BSS_TRANS_CANDIDATE_PREFRENCE_;
    		priv->rm_neighbor_report[i].subelemnt.len = 1;
-   		priv->rm_neighbor_report[i].subelemnt.preference = getPreferredVal(priv, channel_utilization, sta_count, 0);
+   		priv->rm_neighbor_report[i].subelemnt.preference = getPreferredVal(priv, channel_utilization, pfrinfo->rssi<<1, 0);
     }
 #endif		
 
@@ -762,7 +756,7 @@ int rtl8192cd_proc_neighbor_write(struct
 	   	if(WNM_ENABLE) {
 	   		priv->rm_neighbor_report[i].subelemnt.subelement_id = _WNM_BSS_TRANS_CANDIDATE_PREFRENCE_;
 	   		priv->rm_neighbor_report[i].subelemnt.len = 1;
-	   		priv->rm_neighbor_report[i].subelemnt.preference = getPreferredVal(priv, channel_utilization, sta_count, 0);
+	   		priv->rm_neighbor_report[i].subelemnt.preference = getPreferredVal(priv, channel_utilization, 0, 0);
    		}
 #endif		
             if(ssid_ptr)
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/ieee802_mib.h
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/ieee802_mib.h
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/ieee802_mib.h
@@ -161,7 +161,6 @@ struct Dot11StationConfigEntry {
 	unsigned int	limit_rxloop;
 	//CONFIG_IEEE80211V
 	unsigned char	wnmtest;				    
-	unsigned char	bss_req_mac[MACADDRLEN]; 
 
 	unsigned char	deauth_mac[MACADDRLEN]; //CONFIG_IEEE80211W
 	unsigned char	sa_req_mac[MACADDRLEN]; //CONFIG_IEEE80211W_CLI
@@ -190,6 +189,7 @@ struct Dot11StationConfigEntry {
 struct Dot1180211CountryCodeEntry {
 	unsigned int	dot11CountryCodeSwitch;	// 1=enabled; 0=disabled
 	unsigned char   dot11CountryString[3];
+	unsigned int	dot11CountryCodeToRegDomain;
 };
 
 // Detect STA for disappearing; added by Annie, 2010-08-10.
@@ -1006,32 +1006,17 @@ struct ATMConfigEntry {
 	struct atm_stainfo atm_sta[64];			//64 client list, clietn dmoe
 };
 
-#ifdef CONFIG_IEEE80211V
 struct Dot11WNMEntry {
 	unsigned char dot11vBssTransEnable; 		
 	unsigned char dot11vReqMode;	   
 	unsigned char dot11vDiassocImminent;   		
-	unsigned char  sta_mac[MACADDRLEN];
-	unsigned int dot11vDiassocDeadline;
-#ifdef CONFIG_IEEE80211V_DB
-	/*dot11 driver based - basic mib*/
-	unsigned char dot11vDriverBasedEnable;
-#ifdef CONFIG_IEEE80211V_DB_BS
-	unsigned char  dot11vDriverBasedBsEnable;
-	unsigned char  dot11vDriverBasedBsSupportNon11vSta;
-#endif
-	unsigned int dot11vDbCheckInterval;
-	unsigned char dot11vDbRedirectMask; 
-	/*dot11 driver based -reason for redirection (bit mask: 0x1) - AP TX load*/
-	unsigned int dot11vDbApTxLoadThreshold;
-	unsigned long dot11vDbStaTxLoadThreshold;
-	/*dot11 driver based -reason for redirection (bit mask: 0x2) - AP RX load*/
-	unsigned int dot11vDbApRxLoadThreshold;
-	unsigned int dot11vDbStaRxLoadThreshold;
-
-#endif
+	unsigned char sta_mac[MACADDRLEN];
+	unsigned short dot11vDiassocDeadline;
+	unsigned char bssTransExpiredTime;
+	unsigned char Is11kDaemonOn;
+	unsigned char algoType;
+	unsigned char defaultPrefVal;
 };
-#endif
 
 // driver mib
 struct wifi_mib {
@@ -1072,9 +1057,7 @@ struct wifi_mib {
     struct HotSpotConfigEntry		hs2Entry;	// add for HS2_SUPPORT, Hotspot 2.0 Release 1
     struct Dot11FastBSSTransitionEntry	dot11FTEntry;
 	struct StaControl			    staControl;	// add for sta control
-#ifdef CONFIG_IEEE80211V
-	struct Dot11WNMEntry 		    wnmEntry;
-#endif
+	struct Dot11WNMEntry 		    wnmEntry;	
 };
 
 #endif // _IEEE802_MIB_H_
Index: compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/wifi.h
===================================================================
--- compat-wireless-2016-01-10.orig/drivers/net/wireless/realtek/rtl8192cd/wifi.h
+++ compat-wireless-2016-01-10/drivers/net/wireless/realtek/rtl8192cd/wifi.h
@@ -843,7 +843,14 @@ enum MEASUREMENT_TYPE {
 				Below is for 11v BSS Transition related definition
 ------------------------------------------------------------------------------*/
 #ifdef CONFIG_IEEE80211V
-#define _WNM_BSS_TRANS_CANDIDATE_PREFRENCE_ 	3	//subelement
+#ifdef CONFIG_IEEE80211V_CLI
+#define	BSS_TRANS_SUPPORT				BIT(29)		//if add ext_cap in struct bss_desc, it will "caught SIGSEGV, dumping core in /tmp".
+#define	BSS_TERMINATION_DURATION_LEN	12
+#endif
+
+#define _DEFAULT_STATUS_CODE_					-1	// for initializing status code
+#define _TIMEOUT_STATUS_CODE_					99	// for no response after time out
+
 #define _WNM_PREFERED_BSS_TRANS_LIST_INCLUDED_	19
 
 #define _WNM_BSS_TRANS_SUPPORT_			BIT(3)		//capabilities BIT(19)
@@ -990,6 +997,8 @@ enum bss_trans_mgmt_status_code {
 #define _DLS_RSP_ACTION_ID_			1	
 #define _TDLS_CATEGORY_ID_ 			12
 
+#define	_TDLS_PROHIBITED_			BIT(6)
+#define	_TDLS_CS_PROHIBITED_		BIT(7)
 /*-----------------------------------------------------------------------------
             Below is for HS2.0 related definition
 ------------------------------------------------------------------------------*/
