--- a/drivers/net/wireless/realtek/rtl8192cd/8192cd.h
+++ b/drivers/net/wireless/realtek/rtl8192cd/8192cd.h
@@ -934,7 +934,22 @@ enum _H2C_CMD_ID_ {
 	H2C_CMD_INFO_PKT = 13,
 	H2C_CMD_SMCC = 14,
 	H2C_PS_SOFTAP = 38,
-	H2C_CMD_AP_WPS_CTRL = 64
+	H2C_CMD_AP_WPS_CTRL = 64,
+
+#ifdef CONFIG_BT_COEXIST
+	/* BT Class: 011 */
+	H2C_BT_TYPE_TDMA = 0x60,
+	H2C_BT_INFO = 0x61,
+	H2C_FORCE_BT_TXPWR = 0x62,
+	H2C_BT_IGNORE_WLANACT = 0x63,
+	H2C_DAC_SWING_VALUE = 0x64,
+	H2C_ANT_SEL_RSV = 0x65,
+	H2C_WL_OPMODE = 0x66,
+	H2C_BT_MP_OPER = 0x67,
+	H2C_BT_CONTROL = 0x68,
+	H2C_BT_WIFI_CTRL = 0x69,
+	H2C_BT_FW_PATCH = 0x6A
+#endif
 };
 
 enum _ANTENNA_ {
@@ -3226,6 +3241,9 @@ struct rf_finetune_var {
 #endif
 	unsigned char		print_table;
 	unsigned char		curr_ther;
+#if defined(CONFIG_BT_COEXIST)
+	unsigned char		bt_coex_ant;
+#endif
 	unsigned char 		cv_ch1;
 #ifdef WIFI_SIMPLE_CONFIG
 	int			prefer_2g;			// 0: disable, 1: prefer 2g band
@@ -3712,6 +3730,24 @@ typedef struct _sta_bitmap_{
     #endif
 } STA_BITMAP, *PSTA_BITMAP;
 
+#ifdef CONFIG_BT_COEXIST
+typedef struct _BT_COEXIST
+{
+	u8 bBtExist;
+	u8 btTotalAntNum;
+	u8 btChipType;
+	u8 bInitlized;
+	u8 btAntisolation;
+	u8 bBusyTraffic;
+	unsigned long		tx_data_pkts;
+	unsigned long		tx_data_pkts_pre;
+	unsigned long		NumTxOkInPeriod;
+	unsigned long		rx_data_pkts;
+	unsigned long		rx_data_pkts_pre;
+	unsigned long		NumRxOkInPeriod;
+} BT_COEXIST, *PBT_COEXIST;
+#endif
+
 struct propietaryIE {
 	unsigned int id;
 	unsigned char length;
@@ -4214,6 +4250,8 @@ struct priv_shared_info {
 	spinlock_t				lock_io_129x;
 	int                     lock_io_129x_owner;
 #endif
+	spinlock_t                              lock_h2c;
+	int                     lock_h2c_owner;
 	int                     lock_owner;
 	int                     lock_recv_owner;
 	int                     lock_xmit_owner;
@@ -4340,6 +4378,10 @@ struct priv_shared_info {
 	unsigned char		use_outsrc;
 #endif
 
+#ifdef CONFIG_BT_COEXIST
+	BT_COEXIST		bt_coexist;
+#endif
+
 #ifdef TPT_THREAD
 	struct task_struct		*tpt_task;	// Tx Power Tracking task
 	atomic_t				do_tpt; 				// Do Tx Power Tracking function
@@ -5086,6 +5128,10 @@ struct priv_shared_info {
 #ifdef MCR_WIRELESS_EXTEND
 	unsigned int		cmw_link;
 #endif
+
+#if defined(CONFIG_BT_COEXIST)
+	unsigned char		curr_bt_coex_ant;
+#endif
 	unsigned long		no_sta_link_tick;			// tick value when no sta connect
 	unsigned char		acs_for_adaptivity_flag;	// Set for hold TXPAUSE during NHM-ACS
 	unsigned char		reg_tapause_bak;
--- a/drivers/net/wireless/realtek/rtl8192cd/8192cd_cfg.h
+++ b/drivers/net/wireless/realtek/rtl8192cd/8192cd_cfg.h
@@ -169,6 +169,10 @@
 #undef CONFIG_RTL_8197F
 #endif
 
+#ifdef CONFIG_BT_COEXIST
+#define BTCOEX_DISABLE_ANT_CTRL
+#endif
+
 #endif //RTK_129X_PLATFORM
 
 /*
--- a/drivers/net/wireless/realtek/rtl8192cd/8192cd_debug.h
+++ b/drivers/net/wireless/realtek/rtl8192cd/8192cd_debug.h
@@ -37,6 +37,16 @@ extern char tmp_log[128];
 
 #endif
 
+#ifdef BT_COEXIST
+#define DEBUG_BT(fmt, args...) 											\
+	do { 																\
+		if (priv->pshare->rf_ft_var.bt_dump)							\
+			printk("[%s %d] " fmt "\n", __func__, __LINE__, ## args);	\
+	} while(0)
+#else
+#define DEBUG_BT(fmt, args...)
+#endif
+
 #ifdef _DEBUG_RTL8192CD_
 
 extern unsigned long rtl8192cd_debug_err;		/* err flag */
--- a/drivers/net/wireless/realtek/rtl8192cd/8192cd_headers.h
+++ b/drivers/net/wireless/realtek/rtl8192cd/8192cd_headers.h
@@ -900,6 +900,10 @@ EXTERN unsigned char *construct_fast_bss
 EXTERN unsigned char *construct_timeout_interval_ie(struct rtl8192cd_priv *priv, unsigned char *pbuf, unsigned int *frlen, int type, int value);
 EXTERN void issue_ft_action(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char *data, unsigned int len);
 #endif
+#if defined(CONFIG_BT_COEXIST) || defined(BT_COEXIST)
+bool is_if_exec_btcoex(struct rtl8192cd_priv *priv);
+bool is_btcoex_chip(struct rtl8192cd_priv *priv);
+#endif
 #ifdef STA_ASSOC_STATISTIC
 EXTERN void add_sta_assoc_status(struct rtl8192cd_priv *priv,unsigned char* addr, unsigned char rssi, unsigned char status);
 #endif
@@ -1658,6 +1662,10 @@ EXTERN int check_bss_encrypt(struct rtl8
 EXTERN void rtl8192cd_init_one_cfg80211(struct rtknl *rtk);
 #endif
 
+#if defined(BT_COEXIST) || defined(CONFIG_BT_COEXIST)		
+int btc_h2c(struct rtl8192cd_priv *priv, unsigned char *data);
+#endif
+
 EXTERN int rtl8192cd_autochannel_sel(struct rtl8192cd_priv *priv);
 
 #undef EXTERN
@@ -3078,6 +3086,9 @@ EXTERN int rtl8192cd_proc_neighbor_write
 #include "phydm/phydm_precomp.h"
 #endif
 
+#ifdef CONFIG_BT_COEXIST
+#include "OUTSRC-BTCoexist/hal_btcoex.h"
+#endif
 
 #if defined(CONFIG_RTL_8812_SUPPORT) || defined(CONFIG_WLAN_HAL_8881A) || defined(CONFIG_WLAN_HAL_8814AE) || defined(CONFIG_RTL_8723B_SUPPORT) || defined(CONFIG_WLAN_HAL_8822BE)
 
--- a/drivers/net/wireless/realtek/rtl8192cd/8192cd_hw.c
+++ b/drivers/net/wireless/realtek/rtl8192cd/8192cd_hw.c
@@ -4558,7 +4558,7 @@ int PHY_ConfigTXPwrTrackingWithParaFile(
 #endif
 
 #ifdef BT_COEXIST
-int c2h_bt_cnt =0;
+unsigned char c2h_bt_cnt =0;
 int bt_state;
 
 
@@ -6645,7 +6645,7 @@ void SwChnl(struct rtl8192cd_priv *priv,
 #ifdef BT_COEXIST	
 	if(GET_CHIP_VER(priv) == VERSION_8192E && priv->pshare->rf_ft_var.btc == 1){
 		extern int bt_state;
-		if(bt_state){ /* BT enable, set channel for BT*/
+		if(is_if_exec_btcoex(priv) && bt_state){ /* BT enable, set channel for BT*/
 			unsigned char H2CCommand[3]={0};
 			unsigned int center_ch;
 			if(priv->pshare->rf_ft_var.bt_dump)
@@ -12050,6 +12050,9 @@ void bt_coex_init(struct rtl8192cd_priv
 {
 
 	unsigned char H2CCommand[6]={0};
+	extern int bt_state;
+	extern unsigned char c2h_bt_cnt;
+
 	PHY_SetBBReg(priv, 0x6c0, bMaskDWord, 0x5ddd5ddd);
 	PHY_SetBBReg(priv, 0x6c4, bMaskDWord, 0x5fdb5fdb);
 	PHY_SetBBReg(priv, 0x6c8, bMaskDWord, 0xffffff);
@@ -12065,6 +12068,7 @@ void bt_coex_init(struct rtl8192cd_priv
 
 	FillH2CCmd88XX(priv, 0x71, 6, H2CCommand);
 
+	bt_state = c2h_bt_cnt = 0;
 	/* TDMA on 
 	H2CCommand[0] = 0xe3;
 	H2CCommand[1] = 0x12;
@@ -15183,11 +15187,22 @@ int rtl8192cd_init_hw_PCI(struct rtl8192
 	*/
 
 #ifdef BT_COEXIST
-	if(GET_CHIP_VER(priv) == VERSION_8192E && priv->pshare->rf_ft_var.btc == 1){
+	if (is_if_exec_btcoex(priv) == TRUE) {
 			bt_coex_init(priv);
 	}
 #endif
 
+#if 0 /*def CONFIG_BT_COEXIST*/
+	if (is_if_exec_btcoex(priv) == TRUE) {
+		hal_btcoex_Initialize(priv);
+		hal_btcoex_SetBTCoexist(priv, 1);
+		hal_btcoex_SetChipType(priv, BT_RTL8192E);
+		hal_btcoex_SetPgAntNum(priv, 2);	// (EEPROMBluetoothAntNum==Ant_x2)?2:1
+		hal_btcoex_SetAntIsolationType(priv, 0);
+		hal_btcoex_InitHwConfig(priv, 1);
+	}
+#endif
+
 #ifdef CONFIG_WLAN_HAL
 	if (IS_HAL_CHIP(priv)) {
 #if defined(CONFIG_WLAN_HAL_8881A) || defined(CONFIG_WLAN_HAL_8814AE) || defined(CONFIG_WLAN_HAL_8197F) 
--- a/drivers/net/wireless/realtek/rtl8192cd/8192cd_ioctl.c
+++ b/drivers/net/wireless/realtek/rtl8192cd/8192cd_ioctl.c
@@ -152,7 +152,7 @@
 #define SIORXANTSELECT	0x8B5E
 #endif
 #endif
-#ifdef BT_COEXIST
+#if defined(BT_COEXIST) || defined(CONFIG_BT_COEXIST)
 #define SIOBTCH2C 		0x8B60
 #endif
 #ifdef MP_TEST
@@ -641,7 +641,7 @@ struct iw_priv_args privtab[] = {
         { MP_RESET_RX, IW_PRIV_TYPE_NONE, 0, "mp_reset_rx"},
 #endif
 #endif // MP_TEST
-#ifdef BT_COEXIST
+#if defined(BT_COEXIST) || defined(CONFIG_BT_COEXIST)
 	{ SIOBTCH2C, IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 40, "test" },
 #endif
 
@@ -2457,7 +2457,14 @@ static struct iwpriv_arg mib_table[] = {
 #endif
 #ifdef CONFIG_WLAN_HAL_8814AE
 	{"bf_sup_val",		RFFT_T, _OFFSET_RFFT(bf_sup_val), _SIZE_RFFT(bf_sup_val), 0},
-#endif 
+#endif
+#if defined(CONFIG_BT_COEXIST)
+	{"bt_coex_ant", 	RFFT_T, _OFFSET_RFFT(bt_coex_ant), _SIZE_RFFT(bt_coex_ant), 0},
+#endif
+#ifdef BT_COEXIST	
+	{"bt_dbg", RFFT_T, _OFFSET_RFFT(bt_dump), _SIZE_RFFT(bt_dump), 0},
+	{"bt_enable", RFFT_T, _OFFSET_RFFT(btc), _SIZE_RFFT(btc), 1},
+#endif
 	{"load_fw",		RFFT_T,	_OFFSET_RFFT(load_fw), _SIZE_RFFT(load_fw), 1},
 	{"bcn_dont_ignore_edcca", RFFT_T, _OFFSET_RFFT(bcn_dont_ignore_edcca), _SIZE_RFFT(bcn_dont_ignore_edcca), 0},
 };
@@ -4470,7 +4477,7 @@ static int read_rf_reg(struct rtl8192cd_
 }
 
 
-#ifdef BT_COEXIST		
+#if defined(BT_COEXIST) || defined(CONFIG_BT_COEXIST)
 int btc_h2c(struct rtl8192cd_priv *priv, unsigned char *data)
 {
 	unsigned char h2c_id, h2c_data, H2CCommand[6] = {0}, buf[10];
@@ -13006,10 +13013,26 @@ int rtl8192cd_ioctl(struct net_device *d
 		wrq->u.data.length = i;
 		ret = 0;
 		break;
-#ifdef BT_COEXIST		
+#if defined(BT_COEXIST) || defined(CONFIG_BT_COEXIST)
 	case SIOBTCH2C:
 		if(ioctl_copy_from_user(tmpbuf, (void *)wrq->u.data.pointer, wrq->u.data.length))
 			break;
+
+#if defined(CONFIG_BT_COEXIST)
+		if (!strncmp(tmpbuf, "btoff", 5))
+		{
+			hal_btcoex_SetManualControl(priv, 1);
+			ret = 0;
+			break;
+		}
+		else if (!strncmp(tmpbuf, "bton", 4))
+		{
+			hal_btcoex_SetManualControl(priv, 0);
+			ret = 0;
+			break;
+		}
+#endif
+
 		i = btc_h2c(priv, tmpbuf);
 		if (i > 0) {
 			if (ioctl_copy_to_user((void *)wrq->u.data.pointer, tmpbuf, i))
--- a/drivers/net/wireless/realtek/rtl8192cd/8192cd_osdep.c
+++ b/drivers/net/wireless/realtek/rtl8192cd/8192cd_osdep.c
@@ -8403,6 +8403,18 @@ do_hw_init:
 	}
 #endif
 
+#ifdef CONFIG_BT_COEXIST
+	if (is_if_exec_btcoex(priv) == TRUE) {
+		hal_btcoex_Initialize(priv);
+		hal_btcoex_SetAntIsolationType(priv, 0);
+		hal_btcoex_InitHwConfig(priv, 1);
+
+		if(OPMODE & WIFI_AP_STATE) {
+			rtw_hal_set_fw_rsvd_page(priv);
+		}
+	}
+#endif
+
 #ifdef SDIO_2_PORT
 	if (IS_VXD_INTERFACE(priv)) {
 		unsigned long reg;
@@ -9079,8 +9091,16 @@ priv->drv_state |= DRV_STATE_OPEN;
 #endif
 				{
 #ifdef CHECK_HANGUP
-					if (is_reset)
+					if (is_reset) {
 						OPMODE_VAL(OPMODE & ~WIFI_SITE_MONITOR);
+#ifdef CONFIG_BT_COEXIST
+						if ((GET_CHIP_VER(priv) == VERSION_8192E) 
+							&& (OPMODE&WIFI_STATION_STATE) 
+							&& (OPMODE&WIFI_SITE_MONITOR)) {
+							hal_btcoex_ScanNotify(priv, 0);
+						}
+#endif
+					}
 #endif
 
 #if !defined(WIFI_WPAS_CLI) && !defined(RTK_NL80211)
@@ -10142,6 +10162,11 @@ int rtl8192cd_close(struct net_device *d
                 reset_dmdp_peer(priv);
 #endif
 
+#ifdef CONFIG_BT_COEXIST
+	if (is_if_exec_btcoex(priv) == TRUE)
+		hal_btcoex_HaltNotify(priv, 1);
+#endif
+
 	RESTORE_INT(flags);
 	SMP_UNLOCK(flags);
 
@@ -11866,6 +11891,8 @@ void *rtl8192cd_init_one(struct sdio_fun
 		spin_lock_init(&priv->pshare->lock_io_129x);
 		priv->pshare->lock_io_129x_owner=-1;
 #endif
+		spin_lock_init(&priv->pshare->lock_h2c);
+		priv->pshare->lock_h2c_owner=-1;
 		priv->pshare->lock_owner=-1;
 		priv->pshare->lock_recv_owner=-1;
 		priv->pshare->lock_xmit_owner=-1;
@@ -12619,6 +12646,13 @@ void *rtl8192cd_init_one(struct sdio_fun
 		rtl8192cd_ePhyInit(priv);
 */
 
+
+#ifdef CONFIG_BT_COEXIST
+	if (IS_ROOT_INTERFACE(priv) && (GET_CHIP_VER(priv) == VERSION_8192E)) {
+		RTL_W8(0x64, RTL_R8(0x64)|BIT2);
+	}
+#endif
+
 #ifdef CONFIG_NET_PCI
 	if (((wdev->type >> TYPE_SHIFT) & TYPE_MASK) == TYPE_PCI_BIOS) {
 		dev->irq = pdev->irq;
--- a/drivers/net/wireless/realtek/rtl8192cd/8192cd_proc.c
+++ b/drivers/net/wireless/realtek/rtl8192cd/8192cd_proc.c
@@ -5927,6 +5927,12 @@ static int rtl8192cd_proc_stats(char *bu
 	PRINT_SINGL_ARG("    beacon_ok:     ", priv->ext_stats.beacon_ok, "%lu");
 	PRINT_SINGL_ARG("    beacon_er:     ", priv->ext_stats.beacon_er, "%lu");
 	PRINT_SINGL_ARG("    beacon_dma_err:", priv->ext_stats.beacon_dma_err, "%lu");
+#ifdef CONFIG_BT_COEXIST
+	PRINT_SINGL_ARG("    tx_data_pkts:	", priv->pshare->bt_coexist.tx_data_pkts, "%lu");
+	PRINT_SINGL_ARG("    rx_data_pkts:	", priv->pshare->bt_coexist.rx_data_pkts, "%lu");
+	PRINT_SINGL_ARG("    tx_data_pkts_diff:  ", priv->pshare->bt_coexist.NumTxOkInPeriod, "%lu");
+	PRINT_SINGL_ARG("    rx_data_pkts_diff:  ", priv->pshare->bt_coexist.NumRxOkInPeriod, "%lu");
+#endif
 
 	PRINT_SINGL_ARG("    freeskb_err:   ", priv->ext_stats.freeskb_err, "%lu");
 #ifdef CONFIG_PCI_HCI
@@ -6715,6 +6721,151 @@ static int rtl8192cd_proc_gpio_ctrl_writ
 }
 #endif
 
+#ifdef CONFIG_BT_COEXIST
+#ifdef CONFIG_RTL_PROC_NEW
+static int proc_get_btcoex_dbg(struct seq_file *s, void *data)
+#else
+static int proc_get_btcoex_dbg(char *buf, char **start, off_t offset, int length, int *eof, void *data)
+#endif
+{
+	struct net_device *dev = PROC_GET_DEV();
+	struct rtl8192cd_priv *padapter = GET_DEV_PRIV(dev);
+	char buffer[512] = {0};
+	int pos = 0;
+
+	hal_btcoex_GetDBG(padapter, buffer, 512);
+
+	//DBG_871X_SEL(m, "%s", buf);
+	PRINT_ONE(buffer, "%s", 1);
+
+	return pos;
+}
+
+ssize_t proc_set_btcoex_dbg(struct file *file, const char __user *buffer, size_t count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtl8192cd_priv *padapter = GET_DEV_PRIV(dev);
+	u8 tmp[80] = {0};
+	u32 module[2] = {0};
+	u32 num;
+
+//	DBG_871X("+" FUNC_ADPT_FMT "\n", FUNC_ADPT_ARG(padapter));
+
+	if (NULL == buffer)
+	{
+		//DBG_871X(FUNC_ADPT_FMT ": input buffer is NULL!\n",
+		//	FUNC_ADPT_ARG(padapter));
+		
+		return -EFAULT;
+	}
+
+	if (count < 1)
+	{
+		//DBG_871X(FUNC_ADPT_FMT ": input length is 0!\n",
+		//	FUNC_ADPT_ARG(padapter));
+
+		return -EFAULT;
+	}
+
+	num = count;
+	if (num > (sizeof(tmp) - 1))
+		num = (sizeof(tmp) - 1);
+
+	if (copy_from_user(tmp, buffer, num))
+	{
+		//DBG_871X(FUNC_ADPT_FMT ": copy buffer from user space FAIL!\n",
+		//	FUNC_ADPT_ARG(padapter));
+
+		return -EFAULT;
+	}
+
+	num = sscanf(tmp, "%x %x", module, module+1);
+	if (1 == num)
+	{
+		if (0 == module[0])
+			memset(module, 0, sizeof(module));
+		else
+			memset(module, 0xFF, sizeof(module));
+	}
+	else if (2 != num)
+	{
+		//DBG_871X(FUNC_ADPT_FMT ": input(\"%s\") format incorrect!\n",
+		//	FUNC_ADPT_ARG(padapter), tmp);
+
+		if (0 == num)
+			return -EFAULT;
+	}
+
+	//DBG_871X(FUNC_ADPT_FMT ": input 0x%08X 0x%08X\n",
+	//	FUNC_ADPT_ARG(padapter), module[0], module[1]);
+	printk("[%s:%d] input 0x%08X 0x%08X\n", __func__, __LINE__, module[0], module[1]);
+	hal_btcoex_SetDBG(padapter, module);
+
+	return count;
+}
+
+#ifdef CONFIG_RTL_PROC_NEW
+static int proc_get_btcoex_info(struct seq_file *s, void *data)
+#else
+static int proc_get_btcoex_info(char *buf, char **start, off_t offset, int length, int *eof, void *data)
+#endif
+{
+	struct net_device *dev = PROC_GET_DEV();
+	struct rtl8192cd_priv *padapter = GET_DEV_PRIV(dev);
+	const u32 bufsize = 30*100;
+	u8 *pbuf = NULL;
+	int pos = 0;
+
+	pbuf = rtw_zmalloc(bufsize);
+	if (NULL == pbuf) {
+		return -ENOMEM;
+	}
+
+	hal_btcoex_DisplayBtCoexInfo(padapter, pbuf, bufsize);
+
+	//DBG_871X_SEL(m, "%s\n", pbuf);
+	PRINT_ONE(pbuf, "%s", 1);
+	
+	rtw_mfree(pbuf, bufsize);
+
+	return pos;
+}
+static int proc_get_dummy(struct seq_file *s, void *data)
+{
+	return 0;
+}
+
+ssize_t proc_set_btinfo_evt(struct file *file, const char __user *buffer, size_t count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtl8192cd_priv *padapter = GET_DEV_PRIV(dev);
+	char tmp[32];
+	u8 btinfo[8];
+
+	if (count < 6)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+		int num = 0;
+
+		memset(btinfo, 0, 8);
+		
+		num = sscanf(tmp, "%hhx %hhx %hhx %hhx %hhx %hhx %hhx %hhx"
+			, &btinfo[0], &btinfo[1], &btinfo[2], &btinfo[3]
+			, &btinfo[4], &btinfo[5], &btinfo[6], &btinfo[7]);
+
+		if (num < 6)
+			return -EINVAL;
+
+		btinfo[1] = num-2;
+
+//tmp		rtw_btinfo_cmd(padapter, btinfo, btinfo[1]+2);
+	}
+	
+	return count;
+}
+#endif // CONFIG_BT_COEXIST
+
 #ifdef RTK_NL80211//openwrt_psd
 #ifdef CONFIG_RTL_PROC_NEW
 static int rtl8192cd_proc_psd_scan_read(struct seq_file *s, void *data)
@@ -7123,7 +7274,11 @@ static int rtl8192cd_proc_thermal(char *
 #ifdef CLIENT_MODE
 	RTK_DECLARE_READ_WRITE_PROC_FOPS(rtl8192cd_proc_up_read, rtl8192cd_proc_up_write);
 #endif
-
+#ifdef CONFIG_BT_COEXIST
+	RTK_DECLARE_READ_WRITE_PROC_FOPS(proc_get_btcoex_dbg, proc_set_btcoex_dbg);
+	RTK_DECLARE_READ_PROC_FOPS(proc_get_btcoex_info);
+	RTK_DECLARE_READ_WRITE_PROC_FOPS(proc_get_dummy, proc_set_btinfo_evt);
+#endif /* CONFIG_BT_COEXIST */
 #if defined(CONFIG_PCI_HCI)
 	RTK_DECLARE_READ_PROC_FOPS(rtl8192cd_proc_rxdesc_info);
 	RTK_DECLARE_READ_PROC_FOPS(rtl8192cd_proc_desc_info);
@@ -7410,6 +7565,12 @@ void MDL_DEVINIT rtl8192cd_proc_init(str
 
     }
 
+#ifdef CONFIG_BT_COEXIST
+    RTK_CREATE_PROC_READ_WRITE_ENTRY(p, "btcoex_dbg", proc_get_btcoex_dbg, proc_set_btcoex_dbg);
+    RTK_CREATE_PROC_READ_ENTRY(p, "btcoex", proc_get_btcoex_info);
+    RTK_CREATE_PROC_READ_WRITE_ENTRY(p, "btinfo_evt", proc_get_dummy, proc_set_btinfo_evt);
+#endif /* CONFIG_BT_COEXIST */
+
 #ifdef STA_CONTROL
     RTK_CREATE_PROC_READ_WRITE_ENTRY(p, "stactrl_info", stactrl_info_read, stactrl_info_write);
 #endif
@@ -7629,6 +7790,12 @@ void /*__devexit*/MDL_EXIT rtl8192cd_pro
 
         }
 
+#ifdef CONFIG_BT_COEXIST
+        remove_proc_entry( "btcoex_dbg", rtl8192cd_proc_root );
+        remove_proc_entry( "btcoex", rtl8192cd_proc_root );
+        remove_proc_entry( "btinfo_evt", rtl8192cd_proc_root );
+#endif /* CONFIG_BT_COEXIST */
+
 #ifdef STA_CONTROL
         remove_proc_entry( "stactrl_info", rtl8192cd_proc_root );
 #endif
@@ -7682,7 +7849,9 @@ void /*__devexit*/MDL_EXIT rtl8192cd_pro
 #ifdef RTK_NL80211
         remove_proc_entry( "psd_scan", rtl8192cd_proc_root );
 #endif
-
+#ifdef BT_COEXIST
+        remove_proc_entry( "bt_coexist", rtl8192cd_proc_root );
+#endif
 #ifdef CONFIG_IEEE80211R
 		remove_proc_entry( "ft_info", rtl8192cd_proc_root );	
 #endif
--- a/drivers/net/wireless/realtek/rtl8192cd/8192cd_rx.c
+++ b/drivers/net/wireless/realtek/rtl8192cd/8192cd_rx.c
@@ -4921,6 +4921,14 @@ static int rtl8192cd_rx_dispatch_fromDs(
 				SMP_UNLOCK_RX_DATA(x);
 				}
 #endif
+#ifdef CONFIG_BT_COEXIST
+				if(is_btcoex_chip(priv))
+					priv->pshare->bt_coexist.rx_data_pkts++;
+#endif
+#ifdef CONFIG_BT_COEXIST
+				if(is_btcoex_chip(priv))
+					priv->pshare->bt_coexist.rx_data_pkts++;
+#endif
 			}
 		}
 	}
@@ -5035,6 +5043,10 @@ static inline int rtl8192cd_rx_dispatch_
 			}
 #endif
 			reuse = 0;
+#ifdef CONFIG_BT_COEXIST
+			if(is_btcoex_chip(priv))
+				priv->pshare->bt_coexist.rx_data_pkts++;
+#endif
 		}
 	}
 #ifdef UNIVERSAL_REPEATER
@@ -5058,6 +5070,10 @@ static inline int rtl8192cd_rx_dispatch_
 			}
 #endif
 			reuse = 0;
+#ifdef CONFIG_BT_COEXIST
+			if(is_btcoex_chip(priv))
+				priv->pshare->bt_coexist.rx_data_pkts++;
+#endif
 		}
 	}
 #endif
--- a/drivers/net/wireless/realtek/rtl8192cd/8192cd_sme.c
+++ b/drivers/net/wireless/realtek/rtl8192cd/8192cd_sme.c
@@ -6063,6 +6063,52 @@ static void keep_pkts_pre_expire(struct
 	}
 }
 
+#if defined(CONFIG_BT_COEXIST) || defined(BT_COEXIST)
+bool is_if_exec_btcoex(struct rtl8192cd_priv *priv)
+{
+	bool ret = FALSE;
+
+	if (GET_CHIP_VER(priv) == VERSION_8192E)
+	{
+#if defined(CONFIG_BT_COEXIST)
+		if (IS_ROOT_INTERFACE(priv))
+		{
+			if (OPMODE & WIFI_STATION_STATE)
+				ret = TRUE;
+			else if((OPMODE & WIFI_AP_STATE)
+#if defined(UNIVERSAL_REPEATER)
+				&& !IS_DRV_OPEN(GET_VXD_PRIV(priv))
+#endif
+			)
+				ret = TRUE;
+		}
+#if defined(UNIVERSAL_REPEATER)  
+		else if (IS_VXD_INTERFACE(priv))
+		{
+			if (OPMODE & WIFI_STATION_STATE)
+				ret = TRUE;
+		}
+#endif	/* UNIVERSAL_REPEATER */
+#elif defined(BT_COEXIST)
+		if (IS_ROOT_INTERFACE(priv) && (OPMODE & WIFI_AP_STATE) && priv->pshare->rf_ft_var.btc)
+			ret = TRUE;
+#endif
+	}
+	return ret;
+}
+
+bool is_btcoex_chip(struct rtl8192cd_priv *priv)
+{
+	if(GET_CHIP_VER(priv) == VERSION_8192E){
+		return TRUE;
+	}
+	else {
+		return FALSE;
+	}
+
+}
+#endif
+
 void rtl8192cd_expire_timer(unsigned long task_priv)
 {
 	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)task_priv;
@@ -7609,11 +7655,9 @@ hs_break:
 	}
 #endif
 #ifdef BT_COEXIST
-	if(GET_CHIP_VER(priv) == VERSION_8192E && priv->pshare->rf_ft_var.btc == 1
-#if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
-		&& IS_ROOT_INTERFACE(priv)
-#endif
-			){
+	extern unsigned char c2h_bt_cnt;
+	extern unsigned char bt_state;
+	if (is_if_exec_btcoex(priv) == TRUE) {
 		/* 
 		*	BT coexist dynamic mechanism 
 		*/
@@ -7648,11 +7692,61 @@ hs_break:
 			panic_printk("0x774: lp rx:%d,",PHY_QueryBBReg(priv, 0x774, bMaskHWord));
 			panic_printk("	 tx:%d\n",PHY_QueryBBReg(priv, 0x774, bMaskLWord));
 			panic_printk("--------------------------------------------------------------------\n");
+			printk("bt_state:%d,", bt_state);
+			printk("		c2h_bt_cnt:%d\n", c2h_bt_cnt);
 		}
 		PHY_SetBBReg(priv, 0x76c, 0x00ff0000, 0x0c); /* reset BT counter*/
 	}	
 #endif
 
+#ifdef CONFIG_BT_COEXIST
+	if(is_if_exec_btcoex(priv) == TRUE)
+	{
+		if(priv->up_time % 1 == 0) {
+			if (priv->pshare->rf_ft_var.bt_coex_ant != priv->pshare->curr_bt_coex_ant) {
+				static char cmdBuf[5]={0x8, 0, 0, 0, 0};
+				RTL_W16(0x40, 0x220);
+				RTL_W8(0x778, 0x1);
+				RTL_W32(0x6c0, 0x55555555);
+				RTL_W32(0x6c4, 0x55555555);
+				RTL_W32(0x6c8, 0xffffff);
+				RTL_W8(0x6cc, 0x3);
+
+				switch (priv->pshare->rf_ft_var.bt_coex_ant)
+				{
+					case 0:  // HW control
+						hal_btcoex_SetManualControl(priv, 0);
+						RTL_W32(0x930, 0x00660540);
+						RTL_W8(0x92c, 0x0);
+						break;
+
+					case 1:  // switch to BT
+						hal_btcoex_SetManualControl(priv, 1);
+						rtw_hal_fill_h2c_cmd(priv, 0x60, 5, cmdBuf);
+						delay_ms(10);
+						RTL_W32(0x930, 0x00770540);
+						RTL_W8(0x92c, 0x20);
+						break;
+
+					case 2:  // switch to WIFI
+						hal_btcoex_SetManualControl(priv, 1);
+						rtw_hal_fill_h2c_cmd(priv, 0x60, 5, cmdBuf);
+						delay_ms(10);
+						RTL_W32(0x930, 0x00770540);
+						RTL_W8(0x92c, 0x0);
+						break;
+				}
+
+				priv->pshare->curr_bt_coex_ant = priv->pshare->rf_ft_var.bt_coex_ant;
+			}
+		}
+
+		if (priv->up_time % 2 == 0) {
+			hal_btcoex_Hanlder(priv);
+		}
+	}
+#endif //CONFIG_BT_COEXIST
+
 #ifdef CONFIG_IEEE80211R
 	if (FT_ENABLE && priv->pmib->dot11FTEntry.dot11FTR0KeyLifetime) {
 		check_r0key_expire(priv);
@@ -17949,6 +18043,10 @@ void start_clnt_ss(struct rtl8192cd_priv
     }
 #endif	
     OPMODE_VAL(OPMODE | WIFI_SITE_MONITOR);
+#ifdef CONFIG_BT_COEXIST
+    if (is_if_exec_btcoex(priv) == TRUE)
+        hal_btcoex_ScanNotify(priv, 1);
+#endif
     RESTORE_INT(flags);
 
 #ifdef DOT11K
@@ -18915,6 +19013,10 @@ abort_scan:
 #endif
             // scan end			
             OPMODE_VAL(OPMODE & ~WIFI_SITE_MONITOR);
+#ifdef CONFIG_BT_COEXIST
+            if (is_if_exec_btcoex(priv) == TRUE)
+                        hal_btcoex_ScanNotify(priv, 0);
+#endif
             //STADEBUG("End of scan\n"); 
 			if(priv->site_survey->pptyIE) {
 				if(priv->site_survey->pptyIE->content) {
@@ -27048,6 +27150,13 @@ void clean_for_join(struct rtl8192cd_pri
 	}
 
 	priv->assoc_num = 0;
+#ifdef CONFIG_BT_COEXIST
+	if (is_if_exec_btcoex(priv) == TRUE) {
+		unsigned char H2CCommand[3]={0, 0, 0};
+		rtw_btcoex_LPS_Leave(priv);
+		FillH2CCmd88XX(priv, H2C_88XX_MSRRPT, 3, H2CCommand);
+	}
+#endif
 
 	memset(BSSID, 0, MACADDRLEN);
     /*cfg p2p cfg p2p ; remove*/
@@ -29547,6 +29656,12 @@ unsigned int OnAssocRsp(struct rtl8192cd
 	}
 #endif
 
+#ifdef CONFIG_BT_COEXIST
+	if (is_if_exec_btcoex(priv) == TRUE) {
+		RTL_W32(REG_PCIE_CTRL, RTL_R32(REG_PCIE_CTRL) & (~BIT_STOP_BCNQ));
+		rtw_hal_set_fw_rsvd_page(priv);
+	}
+#endif
 
 	return SUCCESS;
 
--- a/drivers/net/wireless/realtek/rtl8192cd/8192cd_tx.c
+++ b/drivers/net/wireless/realtek/rtl8192cd/8192cd_tx.c
@@ -11118,6 +11118,10 @@ int __rtl8192cd_start_xmit_out(struct sk
 #ifndef TX_LOWESTRATE
 				txcfg->lowest_tx_rate = get_lowest_tx_rate(priv, pstat, txcfg->tx_rate);
 #endif			
+#ifdef CONFIG_BT_COEXIST
+			if (is_btcoex_chip(priv) && GetFrameType(txcfg->phdr) == WIFI_DATA_TYPE)
+				priv->pshare->bt_coexist.tx_data_pkts++;
+#endif
 			// log tx statistics...
 			tx_sum_up(priv, pstat, txcfg);
 
@@ -12169,6 +12173,10 @@ int __rtl8192cd_usb_start_xmit(struct rt
 #ifndef TX_LOWESTRATE
 			txcfg->lowest_tx_rate = get_lowest_tx_rate(priv, pstat, txcfg->tx_rate);
 #endif			
+#ifdef CONFIG_BT_COEXIST
+			if (is_btcoex_chip(priv) && GetFrameType(txcfg->phdr) == WIFI_DATA_TYPE)
+				priv->pshare->bt_coexist.tx_data_pkts++;
+#endif
 			// log tx statistics...
 			tx_sum_up(priv, pstat, txcfg);
 
@@ -14264,6 +14272,10 @@ int __rtl8192cd_firetx(struct rtl8192cd_
 	}
 #endif
 
+#ifdef CONFIG_BT_COEXIST
+	if (is_btcoex_chip(priv) && GetFrameType(txcfg->phdr) == WIFI_DATA_TYPE)
+		priv->pshare->bt_coexist.tx_data_pkts++;
+#endif
 	// log tx statistics...
 	tx_sum_up(priv, txcfg->pstat, txcfg);
 
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/hal_btcoex.c
@@ -0,0 +1,4778 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define __HAL_BTCOEX_C__
+
+#ifdef CONFIG_BT_COEXIST
+
+//#include <hal_data.h>
+//#include <hal_btcoex.h>
+//#include <Mp_Precomp.h>
+#include "hal_btcoex.h"
+#include "OUTSRC-BTCoexist/mp_precomp.h"
+#include "osdep_service.h"
+
+#define PADAPTER PRTL8192CD_PRIV
+#define PHAL_DATA_TYPE struct priv_shared_info *
+#define GET_HAL_DATA(x) ((x)->pshare)
+
+/* ************************************
+ *		Global variables
+ * ************************************ */
+const char *const BtProfileString[] = {
+	"NONE",
+	"A2DP",
+	"PAN",
+	"HID",
+	"SCO",
+};
+
+const char *const BtSpecString[] = {
+	"1.0b",
+	"1.1",
+	"1.2",
+	"2.0+EDR",
+	"2.1+EDR",
+	"3.0+HS",
+	"4.0",
+};
+
+const char *const BtLinkRoleString[] = {
+	"Master",
+	"Slave",
+};
+
+const char *const h2cStaString[] = {
+	"successful",
+	"h2c busy",
+	"rf off",
+	"fw not read",
+};
+
+const char *const ioStaString[] = {
+	"success",
+	"can not IO",
+	"rf off",
+	"fw not read",
+	"wait io timeout",
+	"invalid len",
+	"idle Q empty",
+	"insert waitQ fail",
+	"unknown fail",
+	"wrong level",
+	"h2c stopped",
+};
+
+const char *const GLBtcWifiBwString[] = {
+	"11bg",
+	"HT20",
+	"HT40",
+	"HT80",
+	"HT160"
+};
+
+const char *const GLBtcWifiFreqString[] = {
+	"2.4G",
+	"5G"
+};
+
+const char *const GLBtcIotPeerString[] = {
+	"UNKNOWN",
+	"REALTEK",
+	"REALTEK_92SE",
+	"BROADCOM",
+	"RALINK",
+	"ATHEROS",
+	"CISCO",
+	"MERU",
+	"MARVELL",
+	"REALTEK_SOFTAP", /* peer is RealTek SOFT_AP, by Bohn, 2009.12.17 */
+	"SELF_SOFTAP", /* Self is SoftAP */
+	"AIRGO",
+	"INTEL",
+	"RTK_APCLIENT",
+	"REALTEK_81XX",
+	"REALTEK_WOW",
+	"REALTEK_JAGUAR_BCUTAP",
+	"REALTEK_JAGUAR_CCUTAP"
+};
+
+const char *const coexOpcodeString[] = {
+	"Wifi status notify",
+	"Wifi progress",
+	"Wifi info",
+	"Power state",
+	"Set Control",
+	"Get Control"
+};
+
+const char *const coexIndTypeString[] = {
+	"bt info",
+	"pstdma",
+	"limited tx/rx",
+	"coex table",
+	"request"
+};
+
+const char *const coexH2cResultString[] = {
+	"ok",
+	"unknown",
+	"un opcode",
+	"opVer MM",
+	"par Err",
+	"par OoR",
+	"reqNum MM",
+	"halMac Fail",
+	"h2c TimeOut",
+	"Invalid c2h Len",
+	"data overflow"
+};
+
+#define HALBTCOUTSRC_AGG_CHK_WINDOW_IN_MS	8000
+
+struct btc_coexist GLBtCoexist;
+BTC_OFFLOAD gl_coex_offload;
+u8 GLBtcWiFiInScanState;
+u8 GLBtcWiFiInIQKState;
+u8 GLBtcWiFiInIPS;
+u8 GLBtcWiFiInLPS;
+u8 GLBtcBtCoexAliveRegistered;
+
+/*
+ * BT control H2C/C2H
+ */
+/* EXT_EID */
+typedef enum _bt_ext_eid {
+	C2H_WIFI_FW_ACTIVE_RSP	= 0,
+	C2H_TRIG_BY_BT_FW
+} BT_EXT_EID;
+
+/* C2H_STATUS */
+typedef enum _bt_c2h_status {
+	BT_STATUS_OK = 0,
+	BT_STATUS_VERSION_MISMATCH,
+	BT_STATUS_UNKNOWN_OPCODE,
+	BT_STATUS_ERROR_PARAMETER
+} BT_C2H_STATUS;
+
+/* C2H BT OP CODES */
+typedef enum _bt_op_code {
+	BT_OP_GET_BT_VERSION					= 0x00,
+	BT_OP_WRITE_REG_ADDR					= 0x0c,
+	BT_OP_WRITE_REG_VALUE					= 0x0d,
+
+	BT_OP_READ_REG							= 0x11,
+
+	BT_LO_OP_GET_AFH_MAP_L					= 0x1e,
+	BT_LO_OP_GET_AFH_MAP_M					= 0x1f,
+	BT_LO_OP_GET_AFH_MAP_H					= 0x20,
+
+	BT_OP_GET_BT_COEX_SUPPORTED_FEATURE		= 0x2a,
+	BT_OP_GET_BT_COEX_SUPPORTED_VERSION		= 0x2b,
+	BT_OP_GET_BT_ANT_DET_VAL				= 0x2c,
+	BT_OP_GET_BT_BLE_SCAN_PARA				= 0x2d,
+	BT_OP_GET_BT_BLE_SCAN_TYPE				= 0x2e,
+	BT_OP_MAX
+} BT_OP_CODE;
+
+#define BTC_MPOPER_TIMEOUT	50	/* unit: ms */
+
+#define C2H_MAX_SIZE		16
+u8 GLBtcBtMpOperSeq;
+_mutex GLBtcBtMpOperLock;
+_timer GLBtcBtMpOperTimer;
+_sema GLBtcBtMpRptSema;
+u8 GLBtcBtMpRptSeq;
+u8 GLBtcBtMpRptStatus;
+u8 GLBtcBtMpRptRsp[C2H_MAX_SIZE];
+u8 GLBtcBtMpRptRspSize;
+u8 GLBtcBtMpRptWait;
+u8 GLBtcBtMpRptWiFiOK;
+u8 GLBtcBtMpRptBTOK;
+
+/*
+ * Debug
+ */
+u32 GLBtcDbgType[COMP_MAX];
+u8 GLBtcDbgBuf[BT_TMP_BUF_SIZE];
+u1Byte	gl_btc_trace_buf[BT_TMP_BUF_SIZE];
+
+typedef struct _btcoexdbginfo {
+	u8 *info;
+	u32 size; /* buffer total size */
+	u32 len; /* now used length */
+} BTCDBGINFO, *PBTCDBGINFO;
+
+BTCDBGINFO GLBtcDbgInfo;
+
+#define	BT_Operation(Adapter)						_FALSE
+
+#define H2C_BTMP_OPER_LEN			5
+
+static void DBG_BT_INFO_INIT(PBTCDBGINFO pinfo, u8 *pbuf, u32 size)
+{
+	if (NULL == pinfo)
+		return;
+
+	_rtw_memset(pinfo, 0, sizeof(BTCDBGINFO));
+
+	if (pbuf && size) {
+		pinfo->info = pbuf;
+		pinfo->size = size;
+	}
+}
+
+void DBG_BT_INFO(u8 *dbgmsg)
+{
+	PBTCDBGINFO pinfo;
+	u32 msglen, buflen;
+	u8 *pbuf;
+
+
+	pinfo = &GLBtcDbgInfo;
+
+	if (NULL == pinfo->info)
+		return;
+
+	msglen = strlen(dbgmsg);
+	if (pinfo->len + msglen > pinfo->size)
+		return;
+
+	pbuf = pinfo->info + pinfo->len;
+	_rtw_memcpy(pbuf, dbgmsg, msglen);
+	pinfo->len += msglen;
+}
+
+/* ************************************
+ *		Debug related function
+ * ************************************ */
+static u8 halbtcoutsrc_IsBtCoexistAvailable(PBTC_COEXIST pBtCoexist)
+{
+	if (!pBtCoexist->bBinded ||
+	    NULL == pBtCoexist->Adapter)
+		return _FALSE;
+	return _TRUE;
+}
+
+static void halbtcoutsrc_DbgInit(void)
+{
+	u8	i;
+
+	for (i = 0; i < COMP_MAX; i++)
+		GLBtcDbgType[i] = 0;
+}
+
+static u8 halbtcoutsrc_IsCsrBtCoex(PBTC_COEXIST pBtCoexist)
+{
+	if (pBtCoexist->board_info.bt_chip_type == BTC_CHIP_CSR_BC4
+	    || pBtCoexist->board_info.bt_chip_type == BTC_CHIP_CSR_BC8
+	   )
+		return _TRUE;
+	return _FALSE;
+}
+
+static u8 halbtcoutsrc_IsHwMailboxExist(PBTC_COEXIST pBtCoexist)
+{
+	if (pBtCoexist->board_info.bt_chip_type == BTC_CHIP_CSR_BC4
+	    || pBtCoexist->board_info.bt_chip_type == BTC_CHIP_CSR_BC8
+	   )
+		return _FALSE;
+	else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter))
+		return _FALSE;
+	else
+		return _TRUE;
+}
+
+static void halbtcoutsrc_LeaveLps(PBTC_COEXIST pBtCoexist)
+{
+	PADAPTER padapter;
+
+
+	padapter = pBtCoexist->Adapter;
+
+	pBtCoexist->bt_info.bt_ctrl_lps = _TRUE;
+	pBtCoexist->bt_info.bt_lps_on = _FALSE;
+
+	rtw_btcoex_LPS_Leave(padapter);
+}
+
+void halbtcoutsrc_EnterLps(PBTC_COEXIST pBtCoexist)
+{
+	PADAPTER padapter;
+
+
+	padapter = pBtCoexist->Adapter;
+
+	if (pBtCoexist->bdontenterLPS == _FALSE) {
+		pBtCoexist->bt_info.bt_ctrl_lps = _TRUE;
+		pBtCoexist->bt_info.bt_lps_on = _TRUE;
+
+		rtw_btcoex_LPS_Enter(padapter);
+	}
+}
+
+void halbtcoutsrc_NormalLps(PBTC_COEXIST pBtCoexist)
+{
+	PADAPTER padapter;
+
+
+
+	padapter = pBtCoexist->Adapter;
+
+	if (pBtCoexist->bt_info.bt_ctrl_lps) {
+		pBtCoexist->bt_info.bt_lps_on = _FALSE;
+		rtw_btcoex_LPS_Leave(padapter);
+		pBtCoexist->bt_info.bt_ctrl_lps = _FALSE;
+
+		/* recover the LPS state to the original */
+#if 0
+		padapter->hal_func.UpdateLPSStatusHandler(
+			padapter,
+			pPSC->RegLeisurePsMode,
+			pPSC->RegPowerSaveMode);
+#endif
+	}
+}
+
+/*
+ *  Constraint:
+ *	   1. this function will request pwrctrl->lock
+ */
+void halbtcoutsrc_LeaveLowPower(PBTC_COEXIST pBtCoexist)
+{
+#ifdef CONFIG_LPS_LCLK
+	PADAPTER padapter;
+	PHAL_DATA_TYPE pHalData;
+	struct pwrctrl_priv *pwrctrl;
+	s32 ready;
+	u32 stime;
+	s32 utime;
+	u32 timeout; /* unit: ms */
+
+
+	padapter = pBtCoexist->Adapter;
+	pHalData = GET_HAL_DATA(padapter);
+	pwrctrl = adapter_to_pwrctl(padapter);
+	ready = _FAIL;
+#ifdef LPS_RPWM_WAIT_MS
+	timeout = LPS_RPWM_WAIT_MS;
+#else /* !LPS_RPWM_WAIT_MS */
+	timeout = 30;
+#endif /* !LPS_RPWM_WAIT_MS */
+
+	if (GLBtcBtCoexAliveRegistered == _TRUE)
+		return;
+
+	stime = rtw_get_current_time();
+	do {
+		ready = rtw_register_task_alive(padapter, BTCOEX_ALIVE);
+		if (_SUCCESS == ready)
+			break;
+
+		utime = rtw_get_passing_time_ms(stime);
+		if (utime > timeout)
+			break;
+
+		rtw_msleep_os(1);
+	} while (1);
+
+	GLBtcBtCoexAliveRegistered = _TRUE;
+#endif /* CONFIG_LPS_LCLK */
+}
+
+/*
+ *  Constraint:
+ *	   1. this function will request pwrctrl->lock
+ */
+void halbtcoutsrc_NormalLowPower(PBTC_COEXIST pBtCoexist)
+{
+#ifdef CONFIG_LPS_LCLK
+	PADAPTER padapter;
+
+	if (GLBtcBtCoexAliveRegistered == _FALSE)
+		return;
+
+	padapter = pBtCoexist->Adapter;
+	rtw_unregister_task_alive(padapter, BTCOEX_ALIVE);
+
+	GLBtcBtCoexAliveRegistered = _FALSE;
+#endif /* CONFIG_LPS_LCLK */
+}
+
+void halbtcoutsrc_DisableLowPower(PBTC_COEXIST pBtCoexist, u8 bLowPwrDisable)
+{
+	pBtCoexist->bt_info.bt_disable_low_pwr = bLowPwrDisable;
+	if (bLowPwrDisable)
+		halbtcoutsrc_LeaveLowPower(pBtCoexist);		/* leave 32k low power. */
+	else
+		halbtcoutsrc_NormalLowPower(pBtCoexist);	/* original 32k low power behavior. */
+}
+
+void halbtcoutsrc_AggregationCheck(PBTC_COEXIST pBtCoexist)
+{
+	PADAPTER padapter;
+	BOOLEAN bNeedToAct = _FALSE;
+	static u32 preTime = 0;
+	u32 curTime = 0;
+
+	padapter = pBtCoexist->Adapter;
+
+	/* ===================================== */
+	/* To void continuous deleteBA=>addBA=>deleteBA=>addBA */
+	/* This function is not allowed to continuous called. */
+	/* It can only be called after 8 seconds. */
+	/* ===================================== */
+
+	curTime = rtw_systime_to_ms(rtw_get_current_time());
+	if ((curTime - preTime) < HALBTCOUTSRC_AGG_CHK_WINDOW_IN_MS)	/* over 8 seconds you can execute this function again. */
+		return;
+	else
+		preTime = curTime;
+
+	if (pBtCoexist->bt_info.reject_agg_pkt) {
+		bNeedToAct = _TRUE;
+		pBtCoexist->bt_info.pre_reject_agg_pkt = pBtCoexist->bt_info.reject_agg_pkt;
+	} else {
+		if (pBtCoexist->bt_info.pre_reject_agg_pkt) {
+			bNeedToAct = _TRUE;
+			pBtCoexist->bt_info.pre_reject_agg_pkt = pBtCoexist->bt_info.reject_agg_pkt;
+		}
+
+		if (pBtCoexist->bt_info.pre_bt_ctrl_agg_buf_size !=
+		    pBtCoexist->bt_info.bt_ctrl_agg_buf_size) {
+			bNeedToAct = _TRUE;
+			pBtCoexist->bt_info.pre_bt_ctrl_agg_buf_size = pBtCoexist->bt_info.bt_ctrl_agg_buf_size;
+		}
+
+		if (pBtCoexist->bt_info.bt_ctrl_agg_buf_size) {
+			if (pBtCoexist->bt_info.pre_agg_buf_size !=
+			    pBtCoexist->bt_info.agg_buf_size)
+				bNeedToAct = _TRUE;
+			pBtCoexist->bt_info.pre_agg_buf_size = pBtCoexist->bt_info.agg_buf_size;
+		}
+	}
+
+//tmp	if (bNeedToAct)
+//tmp		rtw_btcoex_rx_ampdu_apply(padapter);
+}
+
+u8 halbtcoutsrc_is_autoload_fail(PBTC_COEXIST pBtCoexist)
+{
+#if 0
+	PADAPTER padapter;
+	PHAL_DATA_TYPE pHalData;
+
+	padapter = pBtCoexist->Adapter;
+	pHalData = GET_HAL_DATA(padapter);
+
+	return pHalData->bautoload_fail_flag;
+#else
+	return FAIL;
+#endif
+}
+
+u8 halbtcoutsrc_is_fw_ready(PBTC_COEXIST pBtCoexist)
+{
+	PADAPTER padapter;
+
+	padapter = pBtCoexist->Adapter;
+#if 0
+	return padapter->bFWReady;
+#else
+	return _GET_HAL_DATA(padapter)->bFWReady;
+#endif
+}
+
+u8 halbtcoutsrc_IsWifiBusy(PADAPTER padapter)
+{
+#if 0
+	if (rtw_mi_check_status(padapter, MI_AP_MODE))
+		return _TRUE;
+	if (rtw_mi_busy_traffic_check(padapter, _FALSE))
+		return _TRUE;
+
+	return _FALSE;
+#else
+	return padapter->pshare->bt_coexist.bBusyTraffic;	
+#endif
+}
+
+static u32 _halbtcoutsrc_GetWifiLinkStatus(PADAPTER padapter)
+{
+	u32 portConnectedStatus;
+	int i;
+
+	portConnectedStatus = 0;
+
+	if(padapter->pmib->dot11OperationEntry.opmode & WIFI_AP_STATE) {
+		for (i = 0; i < NUM_STAT; i++) {
+			if (padapter->pshare->aidarray[i] && (padapter->pshare->aidarray[i]->used == TRUE) && (padapter->pshare->aidarray[i]->station.state & WIFI_ASOC_STATE)) {
+				portConnectedStatus |= WIFI_AP_CONNECTED;
+				break;
+			}
+		}
+	} else if ((padapter->pmib->dot11OperationEntry.opmode & WIFI_ASOC_STATE) &&
+		(padapter->pmib->dot11OperationEntry.opmode & WIFI_STATION_STATE)) {
+		portConnectedStatus |= WIFI_STA_CONNECTED;
+	}
+
+	return portConnectedStatus;
+}
+
+u32 halbtcoutsrc_GetWifiLinkStatus(PBTC_COEXIST pBtCoexist)
+{
+	/* ================================= */
+	/* return value: */
+	/* [31:16]=> connected port number */
+	/* [15:0]=> port connected bit define */
+	/* ================================ */
+
+	PADAPTER padapter;
+	u32 retVal;
+	u32 portConnectedStatus, numOfConnectedPort;
+
+
+	padapter = pBtCoexist->Adapter;
+	retVal = 0;
+	portConnectedStatus = 0;
+	numOfConnectedPort = 0;
+
+	retVal = _halbtcoutsrc_GetWifiLinkStatus(padapter);
+	if (retVal)
+	{
+		portConnectedStatus |= retVal;
+		numOfConnectedPort++;
+	}
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->pbuddy_adapter)
+	{
+		retVal = _halbtcoutsrc_GetWifiLinkStatus(padapter->pbuddy_adapter);
+		if (retVal)
+		{
+			portConnectedStatus |= retVal;
+			numOfConnectedPort++;
+		}
+	}
+#endif // CONFIG_CONCURRENT_MODE
+
+	retVal = (numOfConnectedPort << 16) | portConnectedStatus;
+
+	return retVal;
+}
+
+static void _btmpoper_timer_hdl(void *p)
+{
+	if (GLBtcBtMpRptWait == _TRUE) {
+		GLBtcBtMpRptWait = _FALSE;
+		_rtw_up_sema(&GLBtcBtMpRptSema);
+	}
+}
+
+/*
+ * !IMPORTANT!
+ *	Before call this function, caller should acquire "GLBtcBtMpOperLock"!
+ *	Othrewise there will be racing problem and something may go wrong.
+ */
+static u8 _btmpoper_cmd(PBTC_COEXIST pBtCoexist, u8 opcode, u8 opcodever, u8 *cmd, u8 size)
+{
+	PADAPTER padapter;
+	u8 buf[H2C_BTMP_OPER_LEN] = {0};
+	u8 buflen;
+	u8 seq;
+	u8 timer_cancelled;
+	s32 ret;
+
+
+	if (!cmd && size)
+		size = 0;
+	if ((size + 2) > H2C_BTMP_OPER_LEN)
+		return BT_STATUS_H2C_LENGTH_EXCEEDED;
+	buflen = size + 2;
+
+	seq = GLBtcBtMpOperSeq & 0xF;
+	GLBtcBtMpOperSeq++;
+
+	buf[0] = (opcodever & 0xF) | (seq << 4);
+	buf[1] = opcode;
+	if (cmd && size)
+		_rtw_memcpy(buf + 2, cmd, size);
+
+	GLBtcBtMpRptWait = _TRUE;
+	GLBtcBtMpRptWiFiOK = _FALSE;
+	GLBtcBtMpRptBTOK = _FALSE;
+	GLBtcBtMpRptStatus = 0;
+	padapter = pBtCoexist->Adapter;
+	_set_timer(&GLBtcBtMpOperTimer, BTC_MPOPER_TIMEOUT);
+	if (rtw_hal_fill_h2c_cmd(padapter, H2C_BT_MP_OPER, buflen, buf) == _FAIL) {
+		_cancel_timer(&GLBtcBtMpOperTimer, &timer_cancelled);
+		ret = BT_STATUS_H2C_FAIL;
+		goto exit;
+	}
+
+	_rtw_down_sema(&GLBtcBtMpRptSema);
+	/* GLBtcBtMpRptWait should be _FALSE here*/
+
+	if (GLBtcBtMpRptWiFiOK == _FALSE) {
+		RTW_ERR("%s: Didn't get H2C Rsp Event!\n", __FUNCTION__);
+		ret = BT_STATUS_H2C_TIMTOUT;
+		goto exit;
+	}
+	if (GLBtcBtMpRptBTOK == _FALSE) {
+		RTW_DBG("%s: Didn't get BT response!\n", __FUNCTION__);
+		ret = BT_STATUS_H2C_BT_NO_RSP;
+		goto exit;
+	}
+
+	if (seq != GLBtcBtMpRptSeq) {
+		RTW_ERR("%s: Sequence number not match!(%d!=%d)!\n",
+			 __FUNCTION__, seq, GLBtcBtMpRptSeq);
+		ret = BT_STATUS_C2H_REQNUM_MISMATCH;
+		goto exit;
+	}
+
+	switch (GLBtcBtMpRptStatus) {
+	/* Examine the status reported from C2H */
+	case BT_STATUS_OK:
+		ret = BT_STATUS_BT_OP_SUCCESS;
+		RTW_DBG("%s: C2H status = BT_STATUS_BT_OP_SUCCESS\n", __FUNCTION__);
+		break;
+	case BT_STATUS_VERSION_MISMATCH:
+		ret = BT_STATUS_OPCODE_L_VERSION_MISMATCH;
+		RTW_DBG("%s: C2H status = BT_STATUS_OPCODE_L_VERSION_MISMATCH\n", __FUNCTION__);
+		break;
+	case BT_STATUS_UNKNOWN_OPCODE:
+		ret = BT_STATUS_UNKNOWN_OPCODE_L;
+		RTW_DBG("%s: C2H status = MP_BT_STATUS_UNKNOWN_OPCODE_L\n", __FUNCTION__);
+		break;
+	case BT_STATUS_ERROR_PARAMETER:
+		ret = BT_STATUS_PARAMETER_FORMAT_ERROR_L;
+		RTW_DBG("%s: C2H status = MP_BT_STATUS_PARAMETER_FORMAT_ERROR_L\n", __FUNCTION__);
+		break;
+	default:
+		ret = BT_STATUS_UNKNOWN_STATUS_L;
+		RTW_DBG("%s: C2H status = MP_BT_STATUS_UNKNOWN_STATUS_L\n", __FUNCTION__);
+		break;
+	}
+
+exit:
+	return ret;
+}
+
+u32 halbtcoutsrc_GetBtPatchVer(PBTC_COEXIST pBtCoexist)
+{
+	if (pBtCoexist->bt_info.get_bt_fw_ver_cnt <= 5) {
+		if (halbtcoutsrc_IsHwMailboxExist(pBtCoexist) == _TRUE) {
+			_irqL irqL;
+			u8 ret;
+
+			_enter_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+			ret = _btmpoper_cmd(pBtCoexist, BT_OP_GET_BT_VERSION, 0, NULL, 0);
+			if (BT_STATUS_BT_OP_SUCCESS == ret) {
+				pBtCoexist->bt_info.bt_real_fw_ver = le16_to_cpu(*(u16 *)GLBtcBtMpRptRsp);
+				pBtCoexist->bt_info.bt_fw_ver = *(GLBtcBtMpRptRsp + 2);
+				pBtCoexist->bt_info.get_bt_fw_ver_cnt++;
+			}
+
+			_exit_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+		} else {
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+			u1Byte dataLen = 2;
+			u1Byte buf[4] = {0};
+
+			buf[0] = 0x0;	/* OP_Code */
+			buf[1] = 0x0;	/* OP_Code_Length */
+			BT_SendEventExtBtCoexControl(pBtCoexist->Adapter, _FALSE, dataLen, &buf[0]);
+#endif /* !CONFIG_BT_COEXIST_SOCKET_TRX */
+		}
+	}
+
+exit:
+	return pBtCoexist->bt_info.bt_real_fw_ver;
+}
+
+s32 halbtcoutsrc_GetWifiRssi(PADAPTER padapter)
+{
+	PHAL_DATA_TYPE pHalData;
+	s32 undecorated_smoothed_pwdb = 0;
+	struct stat_info *pstat=NULL;
+	struct list_head *plist;
+
+	pHalData = GET_HAL_DATA(padapter);
+
+	//undecorated_smoothed_pwdb = pHalData->entry_min_undecorated_smoothed_pwdb;
+	if (padapter->assoc_num)
+	{
+		plist = (&padapter->asoc_list)->next;
+		pstat = list_entry(plist, struct stat_info, asoc_list);
+		if (pstat)
+			undecorated_smoothed_pwdb = pstat->rssi;
+	}
+	return undecorated_smoothed_pwdb;
+}
+
+u32 halbtcoutsrc_GetBtCoexSupportedFeature(void *pBtcContext)
+{
+	PBTC_COEXIST pBtCoexist;
+	u32 ret = BT_STATUS_BT_OP_SUCCESS;
+	u32 data = 0;
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+
+	if (halbtcoutsrc_IsHwMailboxExist(pBtCoexist) == _TRUE) {
+		u8 buf[3] = {0};
+		_irqL irqL;
+		u8 op_code;
+		u8 status;
+
+		_enter_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+		op_code = BT_OP_GET_BT_COEX_SUPPORTED_FEATURE;
+		status = _btmpoper_cmd(pBtCoexist, op_code, 0, buf, 0);
+		if (status == BT_STATUS_BT_OP_SUCCESS)
+			data = le16_to_cpu(*(u16 *)GLBtcBtMpRptRsp);
+		else
+			ret = SET_BT_MP_OPER_RET(op_code, status);
+
+		_exit_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+	} else
+		ret = BT_STATUS_NOT_IMPLEMENT;
+
+	return data;
+}
+
+u32 halbtcoutsrc_GetBtCoexSupportedVersion(void *pBtcContext)
+{
+	PBTC_COEXIST pBtCoexist;
+	u32 ret = BT_STATUS_BT_OP_SUCCESS;
+	u32 data = 0xFFFF;
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+
+	if (halbtcoutsrc_IsHwMailboxExist(pBtCoexist) == _TRUE) {
+		u8 buf[3] = {0};
+		_irqL irqL;
+		u8 op_code;
+		u8 status;
+
+		_enter_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+		op_code = BT_OP_GET_BT_COEX_SUPPORTED_VERSION;
+		status = _btmpoper_cmd(pBtCoexist, op_code, 0, buf, 0);
+		if (status == BT_STATUS_BT_OP_SUCCESS)
+			data = le16_to_cpu(*(u16 *)GLBtcBtMpRptRsp);
+		else
+			ret = SET_BT_MP_OPER_RET(op_code, status);
+
+		_exit_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+	} else
+		ret = BT_STATUS_NOT_IMPLEMENT;
+
+	return data;
+}
+
+static u8 halbtcoutsrc_GetWifiScanAPNum(PADAPTER padapter)
+{
+	static u8 scan_AP_num = 0;
+
+	if (GLBtcWiFiInScanState == _FALSE) {
+		if (padapter->site_survey->count_target > 0xFF)
+			scan_AP_num = 0xFF;
+		else
+			scan_AP_num = (u8)padapter->site_survey->count_target;
+	}
+
+	return scan_AP_num;
+}
+
+u8 halbtcoutsrc_Get(void *pBtcContext, u8 getType, void *pOutBuf)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+	PHAL_DATA_TYPE pHalData;
+	struct mlme_ext_priv *mlmeext;
+	u8 bSoftApExist, bVwifiExist;
+	u8 *pu8;
+	s32 *pS4Tmp;
+	u32 *pU4Tmp;
+	u8 *pU1Tmp;
+	u8 ret;
+	struct stat_info *pstat=NULL;
+	struct list_head *plist;
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return _FALSE;
+
+	padapter = pBtCoexist->Adapter;
+	pHalData = GET_HAL_DATA(padapter);
+	bSoftApExist = _FALSE;
+	bVwifiExist = _FALSE;
+	pu8 = (u8 *)pOutBuf;
+	pS4Tmp = (s32 *)pOutBuf;
+	pU4Tmp = (u32 *)pOutBuf;
+	pU1Tmp = (u8 *)pOutBuf;
+	ret = _TRUE;
+	if (padapter->assoc_num)
+	{
+		plist = (&padapter->asoc_list)->next;
+		pstat = list_entry(plist, struct stat_info, asoc_list);
+	}
+
+	switch (getType) {
+	case BTC_GET_BL_HS_OPERATION:
+		*pu8 = _FALSE;
+		ret = _FALSE;
+		break;
+
+	case BTC_GET_BL_HS_CONNECTING:
+		*pu8 = _FALSE;
+		ret = _FALSE;
+		break;
+
+	case BTC_GET_BL_WIFI_FW_READY:
+		*pu8 = halbtcoutsrc_is_fw_ready(pBtCoexist);
+		break;
+
+	case BTC_GET_BL_WIFI_CONNECTED:
+		*pu8 = (padapter->pmib->dot11OperationEntry.opmode & (WIFI_ASOC_STATE|WIFI_AP_STATE) );
+		break;
+
+	case BTC_GET_BL_WIFI_BUSY:
+		*pu8 = halbtcoutsrc_IsWifiBusy(padapter);
+		break;
+
+	case BTC_GET_BL_WIFI_SCAN:
+#if 0
+		*pu8 = (rtw_mi_check_fwstate(padapter, WIFI_SITE_MONITOR)) ? _TRUE : _FALSE;
+#else
+		/* Use the value of the new variable GLBtcWiFiInScanState to judge whether WiFi is in scan state or not, since the originally used flag
+			WIFI_SITE_MONITOR in fwstate may not be cleared in time */
+		*pu8 = GLBtcWiFiInScanState;
+#endif
+		break;
+
+	case BTC_GET_BL_WIFI_LINK:
+		//tmp *pu8 = (rtw_mi_check_status(padapter, MI_STA_LINKING)) ? _TRUE : _FALSE;
+		break;
+
+	case BTC_GET_BL_WIFI_ROAM:
+		//tmp *pu8 = (rtw_mi_check_status(padapter, MI_STA_LINKING)) ? _TRUE : _FALSE;
+		break;
+
+	case BTC_GET_BL_WIFI_4_WAY_PROGRESS:
+		*pu8 = _FALSE;
+		break;
+
+	case BTC_GET_BL_WIFI_UNDER_5G:
+		*pu8 = (padapter->pshare->curr_band == BAND_5G)? _TRUE : _FALSE;
+		break;
+
+	case BTC_GET_BL_WIFI_AP_MODE_ENABLE:
+		*pu8 = (padapter->pmib->dot11OperationEntry.opmode & WIFI_AP_STATE);
+		break;
+
+	case BTC_GET_BL_WIFI_ENABLE_ENCRYPTION:
+		*pu8 = padapter->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm == 0? _FALSE: _TRUE;
+		break;
+
+	case BTC_GET_BL_WIFI_UNDER_B_MODE:
+		if (padapter->pmib->dot11BssType.net_work_type == WIRELESS_11B)
+			*pu8 = _TRUE;
+		else
+			*pu8 = _FALSE;
+		break;
+
+	case BTC_GET_BL_WIFI_IS_IN_MP_MODE:
+		if (padapter->pmib->dot11OperationEntry.opmode & WIFI_MP_STATE)
+			*pu8 = _FALSE;
+		else
+			*pu8 = _TRUE;
+		break;
+
+	case BTC_GET_BL_EXT_SWITCH:
+		*pu8 = _FALSE;
+		break;
+	case BTC_GET_BL_IS_ASUS_8723B:
+		/* Always return FALSE in linux driver since this case is added only for windows driver */
+		*pu8 = _FALSE;
+		break;
+
+	case BTC_GET_BL_RF4CE_CONNECTED:
+#ifdef CONFIG_RF4CE_COEXIST
+		if (hal_btcoex_get_rf4ce_link_state() == 0)
+			*pu8 = FALSE;
+		else
+			*pu8 = TRUE;
+#else
+		*pu8 = FALSE;
+#endif
+		break;
+
+	case BTC_GET_S4_WIFI_RSSI:
+		*pS4Tmp = halbtcoutsrc_GetWifiRssi(padapter);
+		break;
+
+	case BTC_GET_S4_HS_RSSI:
+		*pS4Tmp = 0;
+		ret = _FALSE;
+		break;
+
+	case BTC_GET_U4_WIFI_BW:
+		if (!(padapter->pmib->dot11BssType.net_work_type & WIRELESS_11N))
+			*pU4Tmp = BTC_WIFI_BW_LEGACY;
+		else {
+			switch (padapter->pshare->CurrentChannelBW) {
+			case HT_CHANNEL_WIDTH_20:
+				*pU4Tmp = BTC_WIFI_BW_HT20;
+				break;
+			case HT_CHANNEL_WIDTH_20_40:
+				*pU4Tmp = BTC_WIFI_BW_HT40;
+				break;
+			case HT_CHANNEL_WIDTH_80:
+				*pU4Tmp = BTC_WIFI_BW_HT80;
+				break;
+			case HT_CHANNEL_WIDTH_160:
+				*pU4Tmp = BTC_WIFI_BW_HT160;
+				break;
+			default:
+				//RTW_INFO("[BTCOEX] unknown bandwidth(%d)\n", pHalData->current_channel_bw);
+				*pU4Tmp = BTC_WIFI_BW_HT40;
+				break;
+			}
+
+		}
+		break;
+
+	case BTC_GET_U4_WIFI_TRAFFIC_DIRECTION: {
+		if (padapter->pshare->bt_coexist.NumTxOkInPeriod > padapter->pshare->bt_coexist.NumRxOkInPeriod)
+			*pU4Tmp = BTC_WIFI_TRAFFIC_TX;
+		else
+			*pU4Tmp = BTC_WIFI_TRAFFIC_RX;
+	}
+		break;
+
+	case BTC_GET_U4_WIFI_FW_VER:
+			*pU4Tmp = padapter->pshare->fw_version << 16;
+			*pU4Tmp |= padapter->pshare->fw_sub_version;
+		break;
+
+	case BTC_GET_U4_WIFI_LINK_STATUS:
+		*pU4Tmp = halbtcoutsrc_GetWifiLinkStatus(pBtCoexist);
+		break;
+
+	case BTC_GET_U4_BT_PATCH_VER:
+		*pU4Tmp = halbtcoutsrc_GetBtPatchVer(pBtCoexist);
+		break;
+
+	case BTC_GET_U4_VENDOR:
+		*pU4Tmp = BTC_VENDOR_OTHER;
+		break;
+
+	case BTC_GET_U4_SUPPORTED_VERSION:
+		*pU4Tmp = halbtcoutsrc_GetBtCoexSupportedVersion(pBtCoexist);
+		break;
+	case BTC_GET_U4_SUPPORTED_FEATURE:
+		*pU4Tmp = halbtcoutsrc_GetBtCoexSupportedFeature(pBtCoexist);
+		break;
+
+	case BTC_GET_U4_WIFI_IQK_TOTAL:
+		*pU4Tmp =  padapter->pshare->IQK_total_cnt;
+		break;
+
+	case BTC_GET_U4_WIFI_IQK_OK:
+		*pU4Tmp =  padapter->pshare->IQK_total_cnt - padapter->pshare->IQK_fail_cnt;
+		break;
+
+	case BTC_GET_U4_WIFI_IQK_FAIL:
+		*pU4Tmp =  padapter->pshare->IQK_fail_cnt;
+		break;
+
+	case BTC_GET_U1_WIFI_DOT11_CHNL:
+		*pU1Tmp = padapter->pmib->dot11RFEntry.dot11channel;
+		break;
+
+	case BTC_GET_U1_WIFI_CENTRAL_CHNL:
+		*pU1Tmp = padapter->pshare->working_channel;
+		break;
+
+	case BTC_GET_U1_WIFI_HS_CHNL:
+		*pU1Tmp = 0;
+		ret = _FALSE;
+		break;
+#if 0
+	case BTC_GET_U1_WIFI_P2P_CHNL:
+#ifdef CONFIG_P2P
+		{
+			struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
+			
+			*pU1Tmp = pwdinfo->operating_channel;
+		}
+#else
+		*pU1Tmp = 0;
+#endif
+		break;
+#endif
+	case BTC_GET_U1_MAC_PHY_MODE:
+		/*			*pU1Tmp = BTC_SMSP;
+		 *			*pU1Tmp = BTC_DMSP;
+		 *			*pU1Tmp = BTC_DMDP;
+		 *			*pU1Tmp = BTC_MP_UNKNOWN; */
+		break;
+
+	case BTC_GET_U1_AP_NUM:
+		*pU1Tmp = halbtcoutsrc_GetWifiScanAPNum(padapter);
+		break;
+	case BTC_GET_U1_ANT_TYPE:
+		switch (pHalData->bt_coexist.btAntisolation) {
+		case 0:
+			*pU1Tmp = (u1Byte)BTC_ANT_TYPE_0;
+			pBtCoexist->board_info.ant_type = (u1Byte)BTC_ANT_TYPE_0;
+			break;
+		case 1:
+			*pU1Tmp = (u1Byte)BTC_ANT_TYPE_1;
+			pBtCoexist->board_info.ant_type = (u1Byte)BTC_ANT_TYPE_1;
+			break;
+		case 2:
+			*pU1Tmp = (u1Byte)BTC_ANT_TYPE_2;
+			pBtCoexist->board_info.ant_type = (u1Byte)BTC_ANT_TYPE_2;
+			break;
+		case 3:
+			*pU1Tmp = (u1Byte)BTC_ANT_TYPE_3;
+			pBtCoexist->board_info.ant_type = (u1Byte)BTC_ANT_TYPE_3;
+			break;
+		case 4:
+			*pU1Tmp = (u1Byte)BTC_ANT_TYPE_4;
+			pBtCoexist->board_info.ant_type = (u1Byte)BTC_ANT_TYPE_4;
+			break;
+		}
+		break;
+	case BTC_GET_U1_IOT_PEER:
+			if (pstat)
+				*pU1Tmp = pstat->IOTPeer;
+			else
+				*pU1Tmp = HT_IOT_PEER_UNKNOWN;
+		break;
+
+	/* =======1Ant=========== */
+	case BTC_GET_U1_LPS_MODE:
+		*pU1Tmp = GLBtcWiFiInLPS;
+		break;
+
+	default:
+		ret = _FALSE;
+		break;
+	}
+
+	return ret;
+}
+
+u8 halbtcoutsrc_Set(void *pBtcContext, u8 setType, void *pInBuf)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+	u8 *pu8;
+	u8 *pU1Tmp;
+	u32	*pU4Tmp;
+	u8 ret;
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	padapter = pBtCoexist->Adapter;
+	pu8 = (u8*)pInBuf;
+	pU1Tmp = (u8*)pInBuf;
+	pU4Tmp = (u32*)pInBuf;
+	ret = _TRUE;
+
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return _FALSE;
+
+	switch (setType) {
+	/* set some u8 type variables. */
+	case BTC_SET_BL_BT_DISABLE:
+		pBtCoexist->bt_info.bt_disabled = *pu8;
+		break;
+
+	case BTC_SET_BL_BT_ENABLE_DISABLE_CHANGE:
+		pBtCoexist->bt_info.bt_enable_disable_change = *pu8;
+		break;
+
+	case BTC_SET_BL_BT_TRAFFIC_BUSY:
+		pBtCoexist->bt_info.bt_busy = *pu8;
+		break;
+
+	case BTC_SET_BL_BT_LIMITED_DIG:
+		pBtCoexist->bt_info.limited_dig = *pu8;
+		break;
+
+	case BTC_SET_BL_FORCE_TO_ROAM:
+		pBtCoexist->bt_info.force_to_roam = *pu8;
+		break;
+
+	case BTC_SET_BL_TO_REJ_AP_AGG_PKT:
+		pBtCoexist->bt_info.reject_agg_pkt = *pu8;
+		break;
+
+	case BTC_SET_BL_BT_CTRL_AGG_SIZE:
+		pBtCoexist->bt_info.bt_ctrl_agg_buf_size = *pu8;
+		break;
+
+	case BTC_SET_BL_INC_SCAN_DEV_NUM:
+		pBtCoexist->bt_info.increase_scan_dev_num = *pu8;
+		break;
+
+	case BTC_SET_BL_BT_TX_RX_MASK:
+		pBtCoexist->bt_info.bt_tx_rx_mask = *pu8;
+		break;
+
+	case BTC_SET_BL_MIRACAST_PLUS_BT:
+		pBtCoexist->bt_info.miracast_plus_bt = *pu8;
+		break;
+
+	/* set some u8 type variables. */
+	case BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON:
+		pBtCoexist->bt_info.rssi_adjust_for_agc_table_on = *pU1Tmp;
+		break;
+
+	case BTC_SET_U1_AGG_BUF_SIZE:
+		pBtCoexist->bt_info.agg_buf_size = *pU1Tmp;
+		break;
+
+	/* the following are some action which will be triggered */
+	case BTC_SET_ACT_GET_BT_RSSI:
+#if 0
+		BT_SendGetBtRssiEvent(padapter);
+#else
+		ret = _FALSE;
+#endif
+		break;
+
+	case BTC_SET_ACT_AGGREGATE_CTRL:
+		halbtcoutsrc_AggregationCheck(pBtCoexist);
+		break;
+
+	/* =======1Ant=========== */
+	/* set some u8 type variables. */
+	case BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE:
+		pBtCoexist->bt_info.rssi_adjust_for_1ant_coex_type = *pU1Tmp;
+		break;
+
+	case BTC_SET_U1_LPS_VAL:
+		pBtCoexist->bt_info.lps_val = *pU1Tmp;
+		break;
+
+	case BTC_SET_U1_RPWM_VAL:
+		pBtCoexist->bt_info.rpwm_val = *pU1Tmp;
+		break;
+
+	/* the following are some action which will be triggered */
+	case BTC_SET_ACT_LEAVE_LPS:
+		halbtcoutsrc_LeaveLps(pBtCoexist);
+		break;
+
+	case BTC_SET_ACT_ENTER_LPS:
+		halbtcoutsrc_EnterLps(pBtCoexist);
+		break;
+
+	case BTC_SET_ACT_NORMAL_LPS:
+		halbtcoutsrc_NormalLps(pBtCoexist);
+		break;
+
+	case BTC_SET_ACT_DISABLE_LOW_POWER:
+		halbtcoutsrc_DisableLowPower(pBtCoexist, *pu8);
+		break;
+
+	case BTC_SET_ACT_UPDATE_RAMASK:
+		pBtCoexist->bt_info.ra_mask = *pU4Tmp;
+
+		if (padapter->pmib->dot11OperationEntry.opmode & WIFI_ASOC_STATE) {
+			struct stat_info *psta;
+			psta = get_stainfo(padapter, padapter->pmib->dot11StationConfigEntry.dot11Bssid);
+			UpdateHalRAMask88XX(padapter, psta, 0);
+		}
+		break;
+
+	case BTC_SET_ACT_SEND_MIMO_PS:
+#if 0
+		{
+		u8 newMimoPsMode = 3;
+		struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
+		struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+		/* *pU1Tmp = 0 use SM_PS static type */
+		/* *pU1Tmp = 1 disable SM_PS */
+		if (*pU1Tmp == 0)
+			newMimoPsMode = WLAN_HT_CAP_SM_PS_STATIC;
+		else if (*pU1Tmp == 1)
+			newMimoPsMode = WLAN_HT_CAP_SM_PS_DISABLED;
+
+		if (padapter->pmib->dot11OperationEntry.opmode & WIFI_ASOC_STATE) {
+			/* issue_action_SM_PS(padapter, get_my_bssid(&(pmlmeinfo->network)), newMimoPsMode); */
+			issue_action_SM_PS_wait_ack(padapter , get_my_bssid(&(pmlmeinfo->network)) , newMimoPsMode, 3 , 1);
+		}
+	}
+#endif
+	break;
+
+	case BTC_SET_ACT_CTRL_BT_INFO:
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+		{
+			u8 dataLen = *pU1Tmp;
+			u8 tmpBuf[BTC_TMP_BUF_SHORT];
+			if (dataLen)
+				_rtw_memcpy(tmpBuf, pU1Tmp + 1, dataLen);
+			BT_SendEventExtBtInfoControl(padapter, dataLen, &tmpBuf[0]);
+		}
+#else /* !CONFIG_BT_COEXIST_SOCKET_TRX */
+		ret = _FALSE;
+#endif /* CONFIG_BT_COEXIST_SOCKET_TRX */
+		break;
+
+	case BTC_SET_ACT_CTRL_BT_COEX:
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+		{
+			u8 dataLen = *pU1Tmp;
+			u8 tmpBuf[BTC_TMP_BUF_SHORT];
+			if (dataLen)
+				_rtw_memcpy(tmpBuf, pU1Tmp + 1, dataLen);
+			BT_SendEventExtBtCoexControl(padapter, _FALSE, dataLen, &tmpBuf[0]);
+		}
+#else /* !CONFIG_BT_COEXIST_SOCKET_TRX */
+		ret = _FALSE;
+#endif /* CONFIG_BT_COEXIST_SOCKET_TRX */
+		break;
+	case BTC_SET_ACT_CTRL_8723B_ANT:
+#if 0
+		{
+			u1Byte	dataLen = *pU1Tmp;
+			u1Byte	tmpBuf[BTC_TMP_BUF_SHORT];
+			if (dataLen)
+				PlatformMoveMemory(&tmpBuf[0], pU1Tmp + 1, dataLen);
+			BT_Set8723bAnt(Adapter, dataLen, &tmpBuf[0]);
+		}
+#else
+		ret = _FALSE;
+#endif
+		break;
+	/* ===================== */
+	default:
+		ret = _FALSE;
+		break;
+	}
+
+	return ret;
+}
+
+u8 halbtcoutsrc_UnderIps(PBTC_COEXIST pBtCoexist)
+{
+#if 0
+	PADAPTER padapter;
+	struct pwrctrl_priv *pwrpriv;
+	u8 bMacPwrCtrlOn;
+
+	padapter = pBtCoexist->Adapter;
+	pwrpriv = &padapter->dvobj->pwrctl_priv;
+	bMacPwrCtrlOn = _FALSE;
+
+	if ((_TRUE == pwrpriv->bips_processing)
+	    && (IPS_NONE != pwrpriv->ips_mode_req)
+	   )
+		return _TRUE;
+
+	if (rf_off == pwrpriv->rf_pwrstate)
+		return _TRUE;
+
+	rtw_hal_get_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);
+	if (_FALSE == bMacPwrCtrlOn)
+		return _TRUE;
+#endif
+	return _FALSE;
+}
+
+u8 halbtcoutsrc_UnderLps(PBTC_COEXIST pBtCoexist)
+{
+	return GLBtcWiFiInLPS;
+}
+
+u8 halbtcoutsrc_Under32K(PBTC_COEXIST pBtCoexist)
+{
+	/* todo: the method to check whether wifi is under 32K or not */
+	return _FALSE;
+}
+
+void halbtcoutsrc_DisplayCoexStatistics(PBTC_COEXIST pBtCoexist)
+{
+#if 0
+	PADAPTER padapter = (PADAPTER)pBtCoexist->Adapter;
+	PBT_MGNT pBtMgnt = &padapter->MgntInfo.BtInfo.BtMgnt;
+	PHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);
+	u8 *cliBuf = pBtCoexist->cliBuf;
+	u1Byte			i, j;
+	u1Byte			tmpbuf[BTC_TMP_BUF_SHORT];
+
+
+	if (gl_coex_offload.cnt_h2c_sent) {
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Coex h2c notify]============");
+		CL_PRINTF(cliBuf);
+
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = H2c(%d)/Ack(%d)", "Coex h2c/c2h overall statistics",
+			gl_coex_offload.cnt_h2c_sent, gl_coex_offload.cnt_c2h_ack);
+		for (j = 0; j < COL_STATUS_MAX; j++) {
+			if (gl_coex_offload.status[j]) {
+				CL_SPRINTF(tmpbuf, BTC_TMP_BUF_SHORT, ", %s:%d", coexH2cResultString[j], gl_coex_offload.status[j]);
+				CL_STRNCAT(cliBuf, BT_TMP_BUF_SIZE, tmpbuf, BTC_TMP_BUF_SHORT);
+			}
+		}
+		CL_PRINTF(cliBuf);
+	}
+	for (i = 0; i < COL_OP_WIFI_OPCODE_MAX; i++) {
+		if (gl_coex_offload.h2c_record[i].count) {
+			/*==========================================*/
+			/*	H2C result statistics*/
+			/*==========================================*/
+			CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = total:%d", coexOpcodeString[i], gl_coex_offload.h2c_record[i].count);
+			for (j = 0; j < COL_STATUS_MAX; j++) {
+				if (gl_coex_offload.h2c_record[i].status[j]) {
+					CL_SPRINTF(tmpbuf, BTC_TMP_BUF_SHORT, ", %s:%d", coexH2cResultString[j], gl_coex_offload.h2c_record[i].status[j]);
+					CL_STRNCAT(cliBuf, BT_TMP_BUF_SIZE, tmpbuf, BTC_TMP_BUF_SHORT);
+				}
+			}
+			CL_PRINTF(cliBuf);
+			/*==========================================*/
+			/*	H2C/C2H content*/
+			/*==========================================*/
+			CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = ", "H2C / C2H content");
+			for (j = 0; j < gl_coex_offload.h2c_record[i].h2c_len; j++) {
+				CL_SPRINTF(tmpbuf, BTC_TMP_BUF_SHORT, "%02x ", gl_coex_offload.h2c_record[i].h2c_buf[j]);
+				CL_STRNCAT(cliBuf, BT_TMP_BUF_SIZE, tmpbuf, 3);
+			}
+			if (gl_coex_offload.h2c_record[i].c2h_ack_len) {
+				CL_STRNCAT(cliBuf, BT_TMP_BUF_SIZE, "/ ", 2);
+				for (j = 0; j < gl_coex_offload.h2c_record[i].c2h_ack_len; j++) {
+					CL_SPRINTF(tmpbuf, BTC_TMP_BUF_SHORT, "%02x ", gl_coex_offload.h2c_record[i].c2h_ack_buf[j]);
+					CL_STRNCAT(cliBuf, BT_TMP_BUF_SIZE, tmpbuf, 3);
+				}
+			}
+			CL_PRINTF(cliBuf);
+			/*==========================================*/
+		}
+	}
+
+	if (gl_coex_offload.cnt_c2h_ind) {
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Coex c2h indication]============");
+		CL_PRINTF(cliBuf);
+
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = Ind(%d)", "C2H indication statistics",
+			   gl_coex_offload.cnt_c2h_ind);
+		for (j = 0; j < COL_STATUS_MAX; j++) {
+			if (gl_coex_offload.c2h_ind_status[j]) {
+				CL_SPRINTF(tmpbuf, BTC_TMP_BUF_SHORT, ", %s:%d", coexH2cResultString[j], gl_coex_offload.c2h_ind_status[j]);
+				CL_STRNCAT(cliBuf, BT_TMP_BUF_SIZE, tmpbuf, BTC_TMP_BUF_SHORT);
+			}
+		}
+		CL_PRINTF(cliBuf);
+	}
+	for (i = 0; i < COL_IND_MAX; i++) {
+		if (gl_coex_offload.c2h_ind_record[i].count) {
+			/*==========================================*/
+			/*	H2C result statistics*/
+			/*==========================================*/
+			CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = total:%d", coexIndTypeString[i], gl_coex_offload.c2h_ind_record[i].count);
+			for (j = 0; j < COL_STATUS_MAX; j++) {
+				if (gl_coex_offload.c2h_ind_record[i].status[j]) {
+					CL_SPRINTF(tmpbuf, BTC_TMP_BUF_SHORT, ", %s:%d", coexH2cResultString[j], gl_coex_offload.c2h_ind_record[i].status[j]);
+					CL_STRNCAT(cliBuf, BT_TMP_BUF_SIZE, tmpbuf, BTC_TMP_BUF_SHORT);
+				}
+			}
+			CL_PRINTF(cliBuf);
+			/*==========================================*/
+			/*	content*/
+			/*==========================================*/
+			CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = ", "C2H indication content");
+			for (j = 0; j < gl_coex_offload.c2h_ind_record[i].ind_len; j++) {
+				CL_SPRINTF(tmpbuf, BTC_TMP_BUF_SHORT, "%02x ", gl_coex_offload.c2h_ind_record[i].ind_buf[j]);
+				CL_STRNCAT(cliBuf, BT_TMP_BUF_SIZE, tmpbuf, 3);
+			}
+			CL_PRINTF(cliBuf);
+			/*==========================================*/
+		}
+	}
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Statistics]============");
+	CL_PRINTF(cliBuf);
+
+#if (H2C_USE_IO_THREAD != 1)
+	for (i = 0; i < H2C_STATUS_MAX; i++) {
+		if (pHalData->h2cStatistics[i]) {
+			CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s] = %d", "H2C statistics", \
+				   h2cStaString[i], pHalData->h2cStatistics[i]);
+			CL_PRINTF(cliBuf);
+		}
+	}
+#else
+	for (i = 0; i < IO_STATUS_MAX; i++) {
+		if (Adapter->ioComStr.ioH2cStatistics[i]) {
+			CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s] = %d", "H2C statistics", \
+				ioStaString[i], Adapter->ioComStr.ioH2cStatistics[i]);
+			CL_PRINTF(cliBuf);
+		}
+	}
+#endif
+#if 0
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "lastHMEBoxNum", \
+		   pHalData->LastHMEBoxNum);
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x / 0x%x", "LastOkH2c/FirstFailH2c(fwNotRead)", \
+		   pHalData->lastSuccessH2cEid, pHalData->firstFailedH2cEid);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d", "c2hIsr/c2hIntr/clr1AF/noRdy/noBuf", \
+		pHalData->InterruptLog.nIMR_C2HCMD, DBG_Var.c2hInterruptCnt, DBG_Var.c2hClrReadC2hCnt,
+		   DBG_Var.c2hNotReadyCnt, DBG_Var.c2hBufAlloFailCnt);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "c2hPacket", \
+		   DBG_Var.c2hPacketCnt);
+	CL_PRINTF(cliBuf);
+#endif
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Periodical/ DbgCtrl", \
+		pBtCoexist->statistics.cntPeriodical, pBtCoexist->statistics.cntDbgCtrl);
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d", "PowerOn/InitHw/InitCoexDm/RfStatus", \
+		pBtCoexist->statistics.cntPowerOn, pBtCoexist->statistics.cntInitHwConfig, pBtCoexist->statistics.cntInitCoexDm,
+		   pBtCoexist->statistics.cntRfStatusNotify);
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d", "Ips/Lps/Scan/Connect/Mstatus", \
+		pBtCoexist->statistics.cntIpsNotify, pBtCoexist->statistics.cntLpsNotify,
+		pBtCoexist->statistics.cntScanNotify, pBtCoexist->statistics.cntConnectNotify,
+		   pBtCoexist->statistics.cntMediaStatusNotify);
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d", "Special pkt/Bt info/ bind",
+		pBtCoexist->statistics.cntSpecialPacketNotify, pBtCoexist->statistics.cntBtInfoNotify,
+		   pBtCoexist->statistics.cntBind);
+	CL_PRINTF(cliBuf);
+#endif
+#if 0
+	PADAPTER		padapter = pBtCoexist->Adapter;
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(padapter);
+	u8				*cliBuf = pBtCoexist->cli_buf;
+
+	if (pHalData->EEPROMBluetoothCoexist == 1) {
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Coex Status]============");
+		CL_PRINTF(cliBuf);
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ", "IsBtDisabled", rtw_btcoex_IsBtDisabled(padapter));
+		CL_PRINTF(cliBuf);
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ", "IsBtControlLps", rtw_btcoex_IsBtControlLps(padapter));
+		CL_PRINTF(cliBuf);
+	}
+#endif
+}
+
+void halbtcoutsrc_DisplayBtLinkInfo(PBTC_COEXIST pBtCoexist)
+{
+#if 0
+	PADAPTER padapter = (PADAPTER)pBtCoexist->Adapter;
+	PBT_MGNT pBtMgnt = &padapter->MgntInfo.BtInfo.BtMgnt;
+	u8 *cliBuf = pBtCoexist->cliBuf;
+	u8 i;
+
+
+	if (pBtCoexist->stack_info.profile_notified) {
+		for (i = 0; i < pBtMgnt->ExtConfig.NumberOfACL; i++) {
+			if (pBtMgnt->ExtConfig.HCIExtensionVer >= 1) {
+				CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s", "Bt link type/spec/role", \
+					BtProfileString[pBtMgnt->ExtConfig.aclLink[i].BTProfile],
+					BtSpecString[pBtMgnt->ExtConfig.aclLink[i].BTCoreSpec],
+					BtLinkRoleString[pBtMgnt->ExtConfig.aclLink[i].linkRole]);
+				CL_PRINTF(cliBuf);
+			} else {
+				CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s", "Bt link type/spec", \
+					BtProfileString[pBtMgnt->ExtConfig.aclLink[i].BTProfile],
+					BtSpecString[pBtMgnt->ExtConfig.aclLink[i].BTCoreSpec]);
+				CL_PRINTF(cliBuf);
+			}
+		}
+	}
+#endif
+}
+
+void halbtcoutsrc_DisplayWifiStatus(PBTC_COEXIST pBtCoexist)
+{
+	PADAPTER	padapter = pBtCoexist->Adapter;
+	//struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	u8			*cliBuf = pBtCoexist->cli_buf;
+	s32			wifiRssi = 0, btHsRssi = 0;
+	BOOLEAN	bScan = _FALSE, bLink = _FALSE, bRoam = _FALSE, bWifiBusy = _FALSE, bWifiUnderBMode = _FALSE;
+	u32			wifiBw = BTC_WIFI_BW_HT20, wifiTrafficDir = BTC_WIFI_TRAFFIC_TX, wifiFreq = BTC_FREQ_2_4G;
+	u32			wifiLinkStatus = 0x0;
+	BOOLEAN	bBtHsOn = _FALSE, bLowPower = _FALSE;
+	u8			wifiChnl = 0, wifiP2PChnl = 0, nScanAPNum = 0, FwPSState;
+	u32			iqk_cnt_total = 0, iqk_cnt_ok = 0, iqk_cnt_fail = 0;
+
+	wifiLinkStatus = halbtcoutsrc_GetWifiLinkStatus(pBtCoexist);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d", "STA/vWifi/HS/p2pGo/p2pGc", \
+		((wifiLinkStatus & WIFI_STA_CONNECTED) ? 1 : 0), ((wifiLinkStatus & WIFI_AP_CONNECTED) ? 1 : 0),
+		((wifiLinkStatus & WIFI_HS_CONNECTED) ? 1 : 0), ((wifiLinkStatus & WIFI_P2P_GO_CONNECTED) ? 1 : 0),
+		   ((wifiLinkStatus & WIFI_P2P_GC_CONNECTED) ? 1 : 0));
+	CL_PRINTF(cliBuf);
+
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Link/ Roam/ Scan", \
+		bLink, bRoam, bScan);
+	CL_PRINTF(cliBuf);	
+
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_U4_WIFI_IQK_TOTAL, &iqk_cnt_total);
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_U4_WIFI_IQK_OK, &iqk_cnt_ok);
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_U4_WIFI_IQK_FAIL, &iqk_cnt_fail);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d %s %s",
+		"IQK All/ OK/ Fail/AutoLoad/FWDL", iqk_cnt_total, iqk_cnt_ok, iqk_cnt_fail,
+		((halbtcoutsrc_is_autoload_fail(pBtCoexist) == _TRUE) ? "fail":"ok"), ((halbtcoutsrc_is_fw_ready(pBtCoexist) == _TRUE) ? "ok":"fail"));
+	CL_PRINTF(cliBuf);
+	
+	if (wifiLinkStatus & WIFI_STA_CONNECTED) {
+		//CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "IOT Peer", GLBtcIotPeerString[padapter->mlmeextpriv.mlmext_info.assoc_AP_vendor]);
+		//CL_PRINTF(cliBuf);
+	}
+
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiChnl);
+	if ((wifiLinkStatus & WIFI_P2P_GO_CONNECTED) || (wifiLinkStatus & WIFI_P2P_GC_CONNECTED)) 
+		pBtCoexist->btc_get(pBtCoexist, BTC_GET_U1_WIFI_P2P_CHNL, &wifiP2PChnl);	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d dBm/ %d/ %d", "RSSI/ STA_Chnl/ P2P_Chnl", \
+		wifiRssi -100, wifiChnl, wifiP2PChnl);
+	CL_PRINTF(cliBuf);
+
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifiFreq);
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_BL_WIFI_UNDER_B_MODE, &bWifiUnderBMode);
+	pBtCoexist->btc_get(pBtCoexist, BTC_GET_U1_AP_NUM, &nScanAPNum);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s/ %d ", "Band/ BW/ Traffic/ APCnt", \
+		GLBtcWifiFreqString[wifiFreq], ((bWifiUnderBMode) ? "11b" : GLBtcWifiBwString[wifiBw]),
+		((!bWifiBusy) ? "idle" : ((BTC_WIFI_TRAFFIC_TX == wifiTrafficDir) ? "uplink" : "downlink")),
+		   nScanAPNum);
+	CL_PRINTF(cliBuf);
+
+	/* power status */
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s%s%s", "Power Status", \
+		((halbtcoutsrc_UnderIps(pBtCoexist) == _TRUE) ? "IPS ON" : "IPS OFF"),
+		((halbtcoutsrc_UnderLps(pBtCoexist) == _TRUE) ? ", LPS ON" : ", LPS OFF"),
+		((halbtcoutsrc_Under32K(pBtCoexist) == _TRUE) ? ", 32k" : ""));
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x %02x %02x %02x (0x%x/0x%x)", "Power mode cmd(lps/rpwm)", \
+		   pBtCoexist->pwrModeVal[0], pBtCoexist->pwrModeVal[1],
+		   pBtCoexist->pwrModeVal[2], pBtCoexist->pwrModeVal[3],
+		   pBtCoexist->pwrModeVal[4], pBtCoexist->pwrModeVal[5],
+		   pBtCoexist->bt_info.lps_val,
+		   pBtCoexist->bt_info.rpwm_val);
+	CL_PRINTF(cliBuf);
+}
+
+void halbtcoutsrc_DisplayDbgMsg(void *pBtcContext, u8 dispType)
+{
+	PBTC_COEXIST pBtCoexist;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	switch (dispType) {
+	case BTC_DBG_DISP_COEX_STATISTICS:
+		halbtcoutsrc_DisplayCoexStatistics(pBtCoexist);
+		break;
+	case BTC_DBG_DISP_BT_LINK_INFO:
+		halbtcoutsrc_DisplayBtLinkInfo(pBtCoexist);
+		break;
+	case BTC_DBG_DISP_WIFI_STATUS:
+		halbtcoutsrc_DisplayWifiStatus(pBtCoexist);
+		break;
+	default:
+		break;
+	}
+}
+
+/* ************************************
+ *		IO related function
+ * ************************************ */
+u8 halbtcoutsrc_Read1Byte(void *pBtcContext, u32 RegAddr)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	padapter = pBtCoexist->Adapter;
+
+	return rtw_read8(padapter, RegAddr);
+}
+
+u16 halbtcoutsrc_Read2Byte(void *pBtcContext, u32 RegAddr)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	padapter = pBtCoexist->Adapter;
+
+	return	rtw_read16(padapter, RegAddr);
+}
+
+u32 halbtcoutsrc_Read4Byte(void *pBtcContext, u32 RegAddr)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	padapter = pBtCoexist->Adapter;
+
+	return	rtw_read32(padapter, RegAddr);
+}
+
+void halbtcoutsrc_Write1Byte(void *pBtcContext, u32 RegAddr, u8 Data)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	padapter = pBtCoexist->Adapter;
+
+	rtw_write8(padapter, RegAddr, Data);
+}
+
+void halbtcoutsrc_BitMaskWrite1Byte(void *pBtcContext, u32 regAddr, u8 bitMask, u8 data1b)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+	u8 originalValue, bitShift;
+	u8 i;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	padapter = pBtCoexist->Adapter;
+	originalValue = 0;
+	bitShift = 0;
+
+	if (bitMask != 0xff) {
+		originalValue = rtw_read8(padapter, regAddr);
+
+		for (i = 0; i <= 7; i++) {
+			if ((bitMask >> i) & 0x1)
+				break;
+		}
+		bitShift = i;
+
+		data1b = (originalValue & ~bitMask) | ((data1b << bitShift) & bitMask);
+	}
+
+	rtw_write8(padapter, regAddr, data1b);
+}
+
+void halbtcoutsrc_Write2Byte(void *pBtcContext, u32 RegAddr, u16 Data)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	padapter = pBtCoexist->Adapter;
+
+	rtw_write16(padapter, RegAddr, Data);
+}
+
+void halbtcoutsrc_Write4Byte(void *pBtcContext, u32 RegAddr, u32 Data)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	padapter = pBtCoexist->Adapter;
+
+	rtw_write32(padapter, RegAddr, Data);
+}
+
+void halbtcoutsrc_WriteLocalReg1Byte(void *pBtcContext, u32 RegAddr, u8 Data)
+{
+	PBTC_COEXIST		pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	PADAPTER			Adapter = pBtCoexist->Adapter;
+
+	/*if (BTC_INTF_SDIO == pBtCoexist->chip_interface)
+		rtw_write8(Adapter, SDIO_LOCAL_BASE | RegAddr, Data);
+	else*/
+		rtw_write8(Adapter, RegAddr, Data);
+}
+
+void halbtcoutsrc_SetBbReg(void *pBtcContext, u32 RegAddr, u32 BitMask, u32 Data)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	padapter = pBtCoexist->Adapter;
+
+	PHY_SetBBReg(padapter, RegAddr, BitMask, Data);
+}
+
+
+u32 halbtcoutsrc_GetBbReg(void *pBtcContext, u32 RegAddr, u32 BitMask)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	padapter = pBtCoexist->Adapter;
+
+	return PHY_QueryBBReg(padapter, RegAddr, BitMask);
+}
+
+void halbtcoutsrc_SetRfReg(void *pBtcContext, u8 eRFPath, u32 RegAddr, u32 BitMask, u32 Data)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	padapter = pBtCoexist->Adapter;
+
+	PHY_SetRFReg(padapter, eRFPath, RegAddr, BitMask, Data);
+}
+
+u32 halbtcoutsrc_GetRfReg(void *pBtcContext, u8 eRFPath, u32 RegAddr, u32 BitMask)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	padapter = pBtCoexist->Adapter;
+
+	return PHY_QueryRFReg(padapter, eRFPath, RegAddr, BitMask, 1);
+}
+
+u16 halbtcoutsrc_SetBtReg(void *pBtcContext, u8 RegType, u32 RegAddr, u32 Data)
+{
+	PBTC_COEXIST pBtCoexist;
+	u16 ret = BT_STATUS_BT_OP_SUCCESS;
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+
+	if (halbtcoutsrc_IsHwMailboxExist(pBtCoexist) == _TRUE) {
+		u8 buf[3] = {0};
+		_irqL irqL;
+		u8 op_code;
+		u8 status;
+
+		_enter_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+		Data = cpu_to_le32(Data);
+		op_code = BT_OP_WRITE_REG_VALUE;
+		status = _btmpoper_cmd(pBtCoexist, op_code, 0, (u8 *)&Data, 3);
+		if (status != BT_STATUS_BT_OP_SUCCESS)
+			ret = SET_BT_MP_OPER_RET(op_code, status);
+		else {
+			buf[0] = RegType;
+			*(u16 *)(buf + 1) = cpu_to_le16((u16)RegAddr);
+			op_code = BT_OP_WRITE_REG_ADDR;
+			status = _btmpoper_cmd(pBtCoexist, op_code, 0, buf, 3);
+			if (status != BT_STATUS_BT_OP_SUCCESS)
+				ret = SET_BT_MP_OPER_RET(op_code, status);
+		}
+
+		_exit_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+	} else
+		ret = BT_STATUS_NOT_IMPLEMENT;
+
+	return ret;
+}
+
+u8 halbtcoutsrc_SetBtAntDetection(void *pBtcContext, u8 txTime, u8 btChnl)
+{
+	/* Always return _FALSE since we don't implement this yet */
+#if 0
+	PBTC_COEXIST		pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	PADAPTER			Adapter = pBtCoexist->Adapter;
+	u1Byte				btCanTx = 0;
+	BOOLEAN			bStatus = FALSE;
+
+	bStatus = NDBG_SetBtAntDetection(Adapter, txTime, btChnl, &btCanTx);
+	if (bStatus && btCanTx)
+		return _TRUE;
+	else
+		return _FALSE;
+#else
+	return _FALSE;
+#endif
+}
+
+BOOLEAN
+halbtcoutsrc_SetBtTRXMASK(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			bt_trx_mask
+	)
+{
+	/* Always return _FALSE since we don't implement this yet */
+#if 0
+	struct btc_coexist *pBtCoexist = (struct btc_coexist *)pBtcContext;
+	PADAPTER			Adapter = pBtCoexist->Adapter;
+	BOOLEAN				bStatus = FALSE;
+	u1Byte				btCanTx = 0;
+
+	if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter) || IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)
+			|| IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+
+	if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter))
+		bStatus = NDBG_SetBtTRXMASK(Adapter, 1, bt_trx_mask, &btCanTx);
+	else
+		bStatus = NDBG_SetBtTRXMASK(Adapter, 2, bt_trx_mask, &btCanTx);
+	}
+
+	
+	if (bStatus)
+		return TRUE;
+	else
+		return FALSE;
+#else
+	return _FALSE;
+#endif
+}
+
+u16 halbtcoutsrc_GetBtReg_with_status(void *pBtcContext, u8 RegType, u32 RegAddr, u32 *data)
+{
+	PBTC_COEXIST pBtCoexist;
+	u16 ret = BT_STATUS_BT_OP_SUCCESS;
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+
+	if (halbtcoutsrc_IsHwMailboxExist(pBtCoexist) == _TRUE) {
+		u8 buf[3] = {0};
+		_irqL irqL;
+		u8 op_code;
+		u8 status;
+
+		buf[0] = RegType;
+		*(u16 *)(buf + 1) = cpu_to_le16((u16)RegAddr);
+
+		_enter_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+		op_code = BT_OP_READ_REG;
+		status = _btmpoper_cmd(pBtCoexist, op_code, 0, buf, 3);
+		if (status == BT_STATUS_BT_OP_SUCCESS)
+			*data = le16_to_cpu(*(u16 *)GLBtcBtMpRptRsp);
+		else
+			ret = SET_BT_MP_OPER_RET(op_code, status);
+
+		_exit_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+	} else
+		ret = BT_STATUS_NOT_IMPLEMENT;
+
+	return ret;
+}
+
+u32 halbtcoutsrc_GetBtReg(void *pBtcContext, u8 RegType, u32 RegAddr)
+{
+	u32 regVal;
+	
+	return (BT_STATUS_BT_OP_SUCCESS == halbtcoutsrc_GetBtReg_with_status(pBtcContext, RegType, RegAddr, &regVal)) ? regVal : 0xffffffff;
+}
+
+void halbtcoutsrc_FillH2cCmd(void *pBtcContext, u8 elementId, u32 cmdLen, u8 *pCmdBuffer)
+{
+	PBTC_COEXIST pBtCoexist;
+	PADAPTER padapter;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	padapter = pBtCoexist->Adapter;
+
+	rtw_hal_fill_h2c_cmd(padapter, elementId, cmdLen, pCmdBuffer);
+}
+
+static void halbtcoutsrc_coex_offload_init(void)
+{
+	u1Byte	i;
+
+	gl_coex_offload.h2c_req_num = 0;
+	gl_coex_offload.cnt_h2c_sent = 0;
+	gl_coex_offload.cnt_c2h_ack = 0;
+	gl_coex_offload.cnt_c2h_ind = 0;
+
+	for (i = 0; i < COL_MAX_H2C_REQ_NUM; i++)
+		init_completion(&gl_coex_offload.c2h_event[i]);
+}
+
+static COL_H2C_STATUS halbtcoutsrc_send_h2c(PADAPTER Adapter, PCOL_H2C pcol_h2c, u16 h2c_cmd_len)
+{
+	COL_H2C_STATUS		h2c_status = COL_STATUS_C2H_OK;
+	u8				i;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0))
+	reinit_completion(&gl_coex_offload.c2h_event[pcol_h2c->req_num]);		/* set event to un signaled state */
+#else
+	INIT_COMPLETION(gl_coex_offload.c2h_event[pcol_h2c->req_num]);
+#endif
+
+	if (TRUE) {
+#if 0	/*(USE_HAL_MAC_API == 1) */
+		if (RT_STATUS_SUCCESS == HAL_MAC_Send_BT_COEX(&GET_HAL_MAC_INFO(Adapter), (pu1Byte)(pcol_h2c), (u4Byte)h2c_cmd_len, 1)) {
+			if (!wait_for_completion_timeout(&gl_coex_offload.c2h_event[pcol_h2c->req_num], 20)) {
+				h2c_status = COL_STATUS_H2C_TIMTOUT;
+			}
+		} else {
+			h2c_status = COL_STATUS_H2C_HALMAC_FAIL;
+		}
+#endif
+	}
+
+	return h2c_status;
+}
+
+static COL_H2C_STATUS halbtcoutsrc_check_c2h_ack(PADAPTER Adapter, PCOL_SINGLE_H2C_RECORD pH2cRecord)
+{
+	COL_H2C_STATUS	c2h_status = COL_STATUS_C2H_OK;
+	PCOL_H2C		p_h2c_cmd = (PCOL_H2C)&pH2cRecord->h2c_buf[0];
+	u8			req_num = p_h2c_cmd->req_num;
+	PCOL_C2H_ACK	p_c2h_ack = (PCOL_C2H_ACK)&gl_coex_offload.c2h_ack_buf[req_num];
+
+
+	if ((COL_C2H_ACK_HDR_LEN + p_c2h_ack->ret_len) > gl_coex_offload.c2h_ack_len[req_num]) {
+		c2h_status = COL_STATUS_COEX_DATA_OVERFLOW;
+		return c2h_status;
+	}
+	/* else */
+	{
+		_rtw_memmove(&pH2cRecord->c2h_ack_buf[0], &gl_coex_offload.c2h_ack_buf[req_num], gl_coex_offload.c2h_ack_len[req_num]);
+		pH2cRecord->c2h_ack_len = gl_coex_offload.c2h_ack_len[req_num];
+	}
+
+
+	if (p_c2h_ack->req_num != p_h2c_cmd->req_num) {
+		c2h_status = COL_STATUS_C2H_REQ_NUM_MISMATCH;
+	} else if (p_c2h_ack->opcode_ver != p_h2c_cmd->opcode_ver) {
+		c2h_status = COL_STATUS_C2H_OPCODE_VER_MISMATCH;
+	} else {
+		c2h_status = p_c2h_ack->status;
+	}
+
+	return c2h_status;
+}
+
+COL_H2C_STATUS halbtcoutsrc_CoexH2cProcess(void *pBtCoexist,
+		u8 opcode, u8 opcode_ver, u8 *ph2c_par, u8 h2c_par_len)
+{
+	PADAPTER			Adapter = ((struct btc_coexist *)pBtCoexist)->Adapter;
+	u8				H2C_Parameter[BTC_TMP_BUF_SHORT] = {0};
+	PCOL_H2C			pcol_h2c = (PCOL_H2C)&H2C_Parameter[0];
+	u16				paraLen = 0;
+	COL_H2C_STATUS		h2c_status = COL_STATUS_C2H_OK, c2h_status = COL_STATUS_C2H_OK;
+	COL_H2C_STATUS		ret_status = COL_STATUS_C2H_OK;
+	u16				i, col_h2c_len = 0;
+
+	pcol_h2c->opcode = opcode;
+	pcol_h2c->opcode_ver = opcode_ver;
+	pcol_h2c->req_num = gl_coex_offload.h2c_req_num;
+	gl_coex_offload.h2c_req_num++;
+	gl_coex_offload.h2c_req_num %= 16;
+
+	_rtw_memmove(&pcol_h2c->buf[0], ph2c_par, h2c_par_len);
+
+
+	col_h2c_len = h2c_par_len + 2;	/* 2=sizeof(OPCode, OPCode_version and  Request number) */
+	BT_PrintData(Adapter, "[COL], H2C cmd: ", col_h2c_len, H2C_Parameter);
+
+	gl_coex_offload.cnt_h2c_sent++;
+
+	gl_coex_offload.h2c_record[opcode].count++;
+	gl_coex_offload.h2c_record[opcode].h2c_len = col_h2c_len;
+	_rtw_memmove((PVOID)&gl_coex_offload.h2c_record[opcode].h2c_buf[0], (PVOID)pcol_h2c, col_h2c_len);
+
+	h2c_status = halbtcoutsrc_send_h2c(Adapter, pcol_h2c, col_h2c_len);
+
+	gl_coex_offload.h2c_record[opcode].c2h_ack_len = 0;
+
+	if (COL_STATUS_C2H_OK == h2c_status) {
+		/* if reach here, it means H2C get the correct c2h response, */
+		c2h_status = halbtcoutsrc_check_c2h_ack(Adapter, &gl_coex_offload.h2c_record[opcode]);
+		ret_status = c2h_status;
+	} else {
+		/* check h2c status error, return error status code to upper layer. */
+		ret_status = h2c_status;
+	}
+	gl_coex_offload.h2c_record[opcode].status[ret_status]++;
+	gl_coex_offload.status[ret_status]++;
+
+	return ret_status;
+}
+
+u8 halbtcoutsrc_GetAntDetValFromBt(void *pBtcContext)
+{
+	/* Always return 0 since we don't implement this yet */
+#if 0
+	struct btc_coexist *pBtCoexist = (struct btc_coexist *)pBtcContext;
+	PADAPTER			Adapter = pBtCoexist->Adapter;
+	u1Byte				AntDetVal = 0x0;
+	u1Byte				opcodeVer = 1;
+	BOOLEAN				status = false;
+
+	status = NDBG_GetAntDetValFromBt(Adapter, opcodeVer, &AntDetVal);
+
+	RT_TRACE(COMP_DBG, DBG_LOUD, ("$$$ halbtcoutsrc_GetAntDetValFromBt(): status = %d, feature = %x\n", status, AntDetVal));
+
+	return AntDetVal;
+#else
+	return 0;
+#endif
+}
+
+u8 halbtcoutsrc_GetBleScanTypeFromBt(void *pBtcContext)
+{
+	PBTC_COEXIST pBtCoexist;
+	u32 ret = BT_STATUS_BT_OP_SUCCESS;
+	u8 data = 0;
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+
+	if (halbtcoutsrc_IsHwMailboxExist(pBtCoexist) == _TRUE) {
+		u8 buf[3] = {0};
+		_irqL irqL;
+		u8 op_code;
+		u8 status;
+
+
+		_enter_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+		op_code = BT_OP_GET_BT_BLE_SCAN_TYPE;
+		status = _btmpoper_cmd(pBtCoexist, op_code, 0, buf, 0);
+		if (status == BT_STATUS_BT_OP_SUCCESS)
+			data = *(u8 *)GLBtcBtMpRptRsp;
+		else
+			ret = SET_BT_MP_OPER_RET(op_code, status);
+
+		_exit_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+	} else
+		ret = BT_STATUS_NOT_IMPLEMENT;
+
+	return data;
+}
+
+u32 halbtcoutsrc_GetBleScanParaFromBt(void *pBtcContext, u8 scanType)
+{
+	PBTC_COEXIST pBtCoexist;
+	u32 ret = BT_STATUS_BT_OP_SUCCESS;
+	u32 data = 0;
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+
+	if (halbtcoutsrc_IsHwMailboxExist(pBtCoexist) == _TRUE) {
+		u8 buf[3] = {0};
+		_irqL irqL;
+		u8 op_code;
+		u8 status;
+		
+
+		_enter_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+		op_code = BT_OP_GET_BT_BLE_SCAN_PARA;
+		status = _btmpoper_cmd(pBtCoexist, op_code, 0, buf, 0);
+		if (status == BT_STATUS_BT_OP_SUCCESS)
+			data = le32_to_cpu(*(u32 *)GLBtcBtMpRptRsp);
+		else
+			ret = SET_BT_MP_OPER_RET(op_code, status);
+
+		_exit_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+	} else
+		ret = BT_STATUS_NOT_IMPLEMENT;
+
+	return data;
+}
+
+u8 halbtcoutsrc_GetBtAFHMapFromBt(void *pBtcContext, u8 mapType, u8 *afhMap)
+{
+	struct btc_coexist *pBtCoexist = (struct btc_coexist *)pBtcContext;
+	u8 buf[2] = {0};
+	_irqL irqL;
+	u8 op_code;
+	u32 *AfhMapL = (u32 *)&(afhMap[0]);
+	u32 *AfhMapM = (u32 *)&(afhMap[4]);
+	u16 *AfhMapH = (u16 *)&(afhMap[8]);
+	u8 status;
+	u32 ret = BT_STATUS_BT_OP_SUCCESS;
+
+	if (halbtcoutsrc_IsHwMailboxExist(pBtCoexist) == _FALSE)
+		return _FALSE;
+
+	buf[0] = 0;
+	buf[1] = mapType;
+
+	_enter_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+	op_code = BT_LO_OP_GET_AFH_MAP_L;
+	status = _btmpoper_cmd(pBtCoexist, op_code, 0, buf, 0);
+	if (status == BT_STATUS_BT_OP_SUCCESS)
+		*AfhMapL = le32_to_cpu(*(u32 *)GLBtcBtMpRptRsp);
+	else {
+		ret = SET_BT_MP_OPER_RET(op_code, status);
+		goto exit;
+	}
+
+	op_code = BT_LO_OP_GET_AFH_MAP_M;
+	status = _btmpoper_cmd(pBtCoexist, op_code, 0, buf, 0);
+	if (status == BT_STATUS_BT_OP_SUCCESS)
+		*AfhMapM = le32_to_cpu(*(u32 *)GLBtcBtMpRptRsp);
+	else {
+		ret = SET_BT_MP_OPER_RET(op_code, status);
+		goto exit;
+	}
+
+	op_code = BT_LO_OP_GET_AFH_MAP_H;
+	status = _btmpoper_cmd(pBtCoexist, op_code, 0, buf, 0);
+	if (status == BT_STATUS_BT_OP_SUCCESS)
+		*AfhMapH = le16_to_cpu(*(u16 *)GLBtcBtMpRptRsp);
+	else {
+		ret = SET_BT_MP_OPER_RET(op_code, status);
+		goto exit;
+	}
+
+exit:
+
+	_exit_critical_mutex(&GLBtcBtMpOperLock, &irqL);
+
+	return (ret == BT_STATUS_BT_OP_SUCCESS) ? _TRUE : _FALSE;
+}
+
+u32 halbtcoutsrc_GetPhydmVersion(void *pBtcContext)
+{
+	struct btc_coexist *pBtCoexist = (struct btc_coexist *)pBtcContext;
+	PADAPTER		Adapter = pBtCoexist->Adapter;
+
+#ifdef CONFIG_RTL8192E
+	return RELEASE_VERSION_8192E;
+#endif
+
+#ifdef CONFIG_RTL8821A
+	return RELEASE_VERSION_8821A;
+#endif
+
+#ifdef CONFIG_RTL8723B
+	return RELEASE_VERSION_8723B;
+#endif
+
+#ifdef CONFIG_RTL8812A
+	return RELEASE_VERSION_8812A;
+#endif
+
+#ifdef CONFIG_RTL8703B
+	return RELEASE_VERSION_8703B;
+#endif
+
+#ifdef CONFIG_RTL8822B
+	return RELEASE_VERSION_8822B;
+#endif
+
+#ifdef CONFIG_RTL8723D
+	return RELEASE_VERSION_8723D;
+#endif
+
+#ifdef CONFIG_RTL8821C
+	return RELEASE_VERSION_8821C;
+#endif
+}
+
+void halbtcoutsrc_phydm_modify_RA_PCR_threshold(void *pBtcContext, u8 RA_offset_direction, u8 RA_threshold_offset)
+{
+	struct btc_coexist *pBtCoexist = (struct btc_coexist *)pBtcContext;
+
+/* switch to #if 0 in case the phydm version does not provide the function */
+#if 1
+	phydm_modify_RA_PCR_threshold(pBtCoexist->odm_priv, RA_offset_direction, RA_threshold_offset);
+#endif
+}
+
+u32 halbtcoutsrc_phydm_query_PHY_counter(void *pBtcContext, u8 info_type)
+{
+	struct btc_coexist *pBtCoexist = (struct btc_coexist *)pBtcContext;
+
+/* switch to #if 0 in case the phydm version does not provide the function */
+#if 0
+	return phydm_cmn_info_query((struct PHY_DM_STRUCT *)pBtCoexist->odm_priv, (enum phydm_info_query_e)info_type);
+#else
+	return 0;
+#endif
+}
+
+#if 0
+static void BT_CoexOffloadRecordErrC2hAck(PADAPTER	Adapter)
+{
+	PADAPTER		pDefaultAdapter = GetDefaultAdapter(Adapter);
+
+	if (pDefaultAdapter != Adapter)
+		return;
+
+	if (!hal_btcoex_IsBtExist(Adapter))
+		return;
+
+	gl_coex_offload.cnt_c2h_ack++;
+
+	gl_coex_offload.status[COL_STATUS_INVALID_C2H_LEN]++;
+}
+
+static void BT_CoexOffloadC2hAckCheck(PADAPTER	Adapter, u8 *tmpBuf, u8 length)
+{
+	PADAPTER		pDefaultAdapter = GetDefaultAdapter(Adapter);
+	PCOL_C2H_ACK	p_c2h_ack = NULL;
+	u8			req_num = 0xff;
+
+	if (pDefaultAdapter != Adapter)
+		return;
+
+	if (!hal_btcoex_IsBtExist(Adapter))
+		return;
+
+	gl_coex_offload.cnt_c2h_ack++;
+
+	if (length < COL_C2H_ACK_HDR_LEN) {		/* c2h ack length must >= 3 (status, opcode_ver, req_num and ret_len) */
+		gl_coex_offload.status[COL_STATUS_INVALID_C2H_LEN]++;
+	} else {
+		BT_PrintData(Adapter, "[COL], c2h ack:", length, tmpBuf);
+
+		p_c2h_ack = (PCOL_C2H_ACK)tmpBuf;
+		req_num = p_c2h_ack->req_num;
+
+		_rtw_memmove(&gl_coex_offload.c2h_ack_buf[req_num][0], tmpBuf, length);
+		gl_coex_offload.c2h_ack_len[req_num] = length;
+
+		complete(&gl_coex_offload.c2h_event[req_num]);
+	}
+}
+
+static void BT_CoexOffloadC2hIndCheck(PADAPTER Adapter, u8 *tmpBuf, u8 length)
+{
+	PADAPTER		pDefaultAdapter = GetDefaultAdapter(Adapter);
+	PCOL_C2H_IND	p_c2h_ind = NULL;
+	u8			ind_type = 0, ind_version = 0, ind_length = 0;
+
+	if (pDefaultAdapter != Adapter)
+		return;
+
+	if (!hal_btcoex_IsBtExist(Adapter))
+		return;
+
+	gl_coex_offload.cnt_c2h_ind++;
+
+	if (length < COL_C2H_IND_HDR_LEN) {		/* c2h indication length must >= 3 (type, version and length) */
+		gl_coex_offload.c2h_ind_status[COL_STATUS_INVALID_C2H_LEN]++;
+	} else {
+		BT_PrintData(Adapter, "[COL], c2h indication:", length, tmpBuf);
+
+		p_c2h_ind = (PCOL_C2H_IND)tmpBuf;
+		ind_type = p_c2h_ind->type;
+		ind_version = p_c2h_ind->version;
+		ind_length = p_c2h_ind->length;
+
+		_rtw_memmove(&gl_coex_offload.c2h_ind_buf[0], tmpBuf, length);
+		gl_coex_offload.c2h_ind_len = length;
+
+		/* log */
+		gl_coex_offload.c2h_ind_record[ind_type].count++;
+		gl_coex_offload.c2h_ind_record[ind_type].status[COL_STATUS_C2H_OK]++;
+		_rtw_memmove(&gl_coex_offload.c2h_ind_record[ind_type].ind_buf[0], tmpBuf, length);
+		gl_coex_offload.c2h_ind_record[ind_type].ind_len = length;
+
+		gl_coex_offload.c2h_ind_status[COL_STATUS_C2H_OK]++;
+		/*TODO: need to check c2h indication length*/
+		/* TODO: Notification */
+	}
+}
+
+void BT_CoexOffloadC2hCheck(PADAPTER Adapter, u8 *Buffer, u8 Length)
+{
+#if 0 /*(USE_HAL_MAC_API == 1)*/
+	u8	c2hSubCmdId = 0, c2hAckLen = 0, h2cCmdId = 0, h2cSubCmdId = 0, c2hIndLen = 0;
+
+	BT_PrintData(Adapter, "[COL], c2h packet:", Length - 2, Buffer + 2);
+	c2hSubCmdId = (u1Byte)C2H_HDR_GET_C2H_SUB_CMD_ID(Buffer);
+
+	if (c2hSubCmdId == C2H_SUB_CMD_ID_H2C_ACK_HDR ||
+	    c2hSubCmdId == C2H_SUB_CMD_ID_BT_COEX_INFO) {
+		if (c2hSubCmdId == C2H_SUB_CMD_ID_H2C_ACK_HDR) {
+			/* coex c2h ack */
+			h2cCmdId = (u1Byte)H2C_ACK_HDR_GET_H2C_CMD_ID(Buffer);
+			h2cSubCmdId = (u1Byte)H2C_ACK_HDR_GET_H2C_SUB_CMD_ID(Buffer);
+			if (h2cCmdId == 0xff && h2cSubCmdId == 0x60) {
+				c2hAckLen = (u1Byte)C2H_HDR_GET_LEN(Buffer);
+				if (c2hAckLen >= 8)
+					BT_CoexOffloadC2hAckCheck(Adapter, &Buffer[12], (u1Byte)(c2hAckLen - 8));
+				else
+					BT_CoexOffloadRecordErrC2hAck(Adapter);
+			}
+		} else if (c2hSubCmdId == C2H_SUB_CMD_ID_BT_COEX_INFO) {
+			/* coex c2h indication */
+			c2hIndLen = (u1Byte)C2H_HDR_GET_LEN(Buffer);
+			BT_CoexOffloadC2hIndCheck(Adapter, &Buffer[4], (u1Byte)c2hIndLen);
+		}
+	}
+#endif
+}
+#endif
+
+/* ************************************
+ *		Extern functions called by other module
+ * ************************************ */
+u8 EXhalbtcoutsrc_BindBtCoexWithAdapter(void *padapter)
+{
+	PBTC_COEXIST		pBtCoexist = &GLBtCoexist;
+	u8	antNum = 2, chipType = 0, singleAntPath = 0;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA((PADAPTER)padapter);
+
+	if (pBtCoexist->bBinded)
+		return _FALSE;
+	else
+		pBtCoexist->bBinded = _TRUE;
+
+	pBtCoexist->statistics.cnt_bind++;
+
+	pBtCoexist->Adapter = padapter;
+	pBtCoexist->odm_priv = (PVOID)&(((PADAPTER)padapter)->pshare->_dmODM);
+
+	pBtCoexist->stack_info.profile_notified = _FALSE;
+
+	pBtCoexist->bt_info.bt_ctrl_agg_buf_size = _FALSE;
+	pBtCoexist->bt_info.agg_buf_size = 5;
+
+	pBtCoexist->bt_info.increase_scan_dev_num = _FALSE;
+	pBtCoexist->bt_info.miracast_plus_bt = _FALSE;
+
+#if 1
+	antNum = rtw_btcoex_get_pg_ant_num((PADAPTER)padapter);
+	EXhalbtcoutsrc_SetAntNum(BT_COEX_ANT_TYPE_PG, antNum);
+#endif
+
+#if 0
+	if (antNum == 1) {
+		singleAntPath = rtw_btcoex_get_pg_single_ant_path((PADAPTER)padapter);
+		EXhalbtcoutsrc_SetSingleAntPath(singleAntPath);
+	}
+#endif
+
+	/* set default antenna position to main  port */
+	pBtCoexist->board_info.btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+
+	pBtCoexist->board_info.btdm_ant_det_finish = _FALSE;
+	pBtCoexist->board_info.btdm_ant_num_by_ant_det = 1;
+
+	pBtCoexist->board_info.tfbga_package = rtw_btcoex_is_tfbga_package_type((PADAPTER)padapter);
+
+	pBtCoexist->board_info.rfe_type = rtw_btcoex_get_pg_rfe_type((PADAPTER)padapter);
+
+	pBtCoexist->board_info.ant_div_cfg = rtw_btcoex_get_ant_div_cfg((PADAPTER)padapter);
+
+	return _TRUE;
+}
+
+u8 EXhalbtcoutsrc_InitlizeVariables(void *padapter)
+{
+	PBTC_COEXIST pBtCoexist = &GLBtCoexist;
+
+	/* pBtCoexist->statistics.cntBind++; */
+
+	halbtcoutsrc_DbgInit();
+
+	halbtcoutsrc_coex_offload_init();
+
+#ifdef CONFIG_PCI_HCI
+	pBtCoexist->chip_interface = BTC_INTF_PCI;
+#elif defined(CONFIG_USB_HCI)
+	pBtCoexist->chip_interface = BTC_INTF_USB;
+#elif defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+	pBtCoexist->chip_interface = BTC_INTF_SDIO;
+#else
+	pBtCoexist->chip_interface = BTC_INTF_UNKNOWN;
+#endif
+
+	EXhalbtcoutsrc_BindBtCoexWithAdapter(padapter);
+
+	pBtCoexist->btc_read_1byte = halbtcoutsrc_Read1Byte;
+	pBtCoexist->btc_write_1byte = halbtcoutsrc_Write1Byte;
+	pBtCoexist->btc_write_1byte_bitmask = halbtcoutsrc_BitMaskWrite1Byte;
+	pBtCoexist->btc_read_2byte = halbtcoutsrc_Read2Byte;
+	pBtCoexist->btc_write_2byte = halbtcoutsrc_Write2Byte;
+	pBtCoexist->btc_read_4byte = halbtcoutsrc_Read4Byte;
+	pBtCoexist->btc_write_4byte = halbtcoutsrc_Write4Byte;
+	pBtCoexist->btc_write_local_reg_1byte = halbtcoutsrc_WriteLocalReg1Byte;
+
+	pBtCoexist->btc_set_bb_reg = halbtcoutsrc_SetBbReg;
+	pBtCoexist->btc_get_bb_reg = halbtcoutsrc_GetBbReg;
+
+	pBtCoexist->btc_set_rf_reg = halbtcoutsrc_SetRfReg;
+	pBtCoexist->btc_get_rf_reg = halbtcoutsrc_GetRfReg;
+
+	pBtCoexist->btc_fill_h2c = halbtcoutsrc_FillH2cCmd;
+	pBtCoexist->btc_disp_dbg_msg = halbtcoutsrc_DisplayDbgMsg;
+
+	pBtCoexist->btc_get = halbtcoutsrc_Get;
+	pBtCoexist->btc_set = halbtcoutsrc_Set;
+	pBtCoexist->btc_get_bt_reg = halbtcoutsrc_GetBtReg;
+	pBtCoexist->btc_set_bt_reg = halbtcoutsrc_SetBtReg;
+	pBtCoexist->btc_set_bt_ant_detection = halbtcoutsrc_SetBtAntDetection;
+	pBtCoexist->btc_set_bt_trx_mask = halbtcoutsrc_SetBtTRXMASK;
+	pBtCoexist->btc_coex_h2c_process = halbtcoutsrc_CoexH2cProcess;
+	pBtCoexist->btc_get_bt_coex_supported_feature = halbtcoutsrc_GetBtCoexSupportedFeature;
+	pBtCoexist->btc_get_bt_coex_supported_version= halbtcoutsrc_GetBtCoexSupportedVersion;
+	pBtCoexist->btc_get_ant_det_val_from_bt = halbtcoutsrc_GetAntDetValFromBt;
+	pBtCoexist->btc_get_ble_scan_type_from_bt = halbtcoutsrc_GetBleScanTypeFromBt;
+	pBtCoexist->btc_get_ble_scan_para_from_bt = halbtcoutsrc_GetBleScanParaFromBt;
+	pBtCoexist->btc_get_bt_afh_map_from_bt = halbtcoutsrc_GetBtAFHMapFromBt;
+	pBtCoexist->btc_get_bt_phydm_version = halbtcoutsrc_GetPhydmVersion;
+	pBtCoexist->btc_phydm_modify_RA_PCR_threshold = halbtcoutsrc_phydm_modify_RA_PCR_threshold;
+	pBtCoexist->btc_phydm_query_PHY_counter = halbtcoutsrc_phydm_query_PHY_counter;
+
+	pBtCoexist->cli_buf = &GLBtcDbgBuf[0];
+
+	GLBtcWiFiInScanState = _FALSE;
+
+	GLBtcWiFiInIQKState = _FALSE;
+
+	GLBtcWiFiInIPS = _FALSE;
+
+	GLBtcWiFiInLPS = _FALSE;
+
+	GLBtcBtCoexAliveRegistered = _FALSE;
+
+	/* BT Control H2C/C2H*/
+	GLBtcBtMpOperSeq = 0;
+	_rtw_mutex_init(&GLBtcBtMpOperLock);
+	_init_timer(&GLBtcBtMpOperTimer, ((PADAPTER)padapter)->dev, _btmpoper_timer_hdl, pBtCoexist);
+	_rtw_init_sema(&GLBtcBtMpRptSema, 0);
+	GLBtcBtMpRptSeq = 0;
+	GLBtcBtMpRptStatus = 0;
+	_rtw_memset(GLBtcBtMpRptRsp, 0, C2H_MAX_SIZE);
+	GLBtcBtMpRptRspSize = 0;
+	GLBtcBtMpRptWait = _FALSE;
+	GLBtcBtMpRptWiFiOK = _FALSE;
+	GLBtcBtMpRptBTOK = _FALSE;
+
+	return _TRUE;
+}
+
+void EXhalbtcoutsrc_PowerOnSetting(PBTC_COEXIST pBtCoexist)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	/* Power on setting function is only added in 8723B currently */
+	if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_power_on_setting(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_power_on_setting(pBtCoexist);
+	}
+
+	if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_power_on_setting(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_power_on_setting(pBtCoexist);
+	}
+
+	if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_power_on_setting(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_power_on_setting(pBtCoexist);
+	}
+
+	if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_power_on_setting(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_power_on_setting(pBtCoexist);
+	}
+}
+
+void EXhalbtcoutsrc_PreLoadFirmware(PBTC_COEXIST pBtCoexist)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	pBtCoexist->statistics.cnt_pre_load_firmware++;
+
+	if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_pre_load_firmware(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_pre_load_firmware(pBtCoexist);
+	}
+
+	if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_pre_load_firmware(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_pre_load_firmware(pBtCoexist);
+	}
+
+	if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_pre_load_firmware(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_pre_load_firmware(pBtCoexist);
+	}
+}
+
+void EXhalbtcoutsrc_init_hw_config(PBTC_COEXIST pBtCoexist, u8 bWifiOnly)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	pBtCoexist->statistics.cnt_init_hw_config++;
+
+	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+#if 0
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			ex_halbtc8821aCsr2ant_init_hw_config(pBtCoexist, bWifiOnly);
+		else
+#endif
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821a2ant_init_hw_config(pBtCoexist, bWifiOnly);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821a1ant_init_hw_config(pBtCoexist, bWifiOnly);
+	} else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_init_hw_config(pBtCoexist, bWifiOnly);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_init_hw_config(pBtCoexist, bWifiOnly);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_init_hw_config(pBtCoexist, bWifiOnly);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_init_hw_config(pBtCoexist, bWifiOnly);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_init_hw_config(pBtCoexist, bWifiOnly);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8192e2ant_init_hw_config(pBtCoexist, bWifiOnly);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_init_hw_config(pBtCoexist, bWifiOnly);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_init_hw_config(pBtCoexist, bWifiOnly);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_init_hw_config(pBtCoexist, bWifiOnly);
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_init_hw_config(pBtCoexist, bWifiOnly);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_init_hw_config(pBtCoexist, bWifiOnly);
+		#ifdef CONFIG_FW_MULTI_PORT_SUPPORT
+		rtw_hal_set_default_port_id_cmd(pBtCoexist->Adapter, 0);
+		rtw_hal_set_wifi_port_id_cmd(pBtCoexist->Adapter);
+		#endif
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_init_hw_config(pBtCoexist, bWifiOnly);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_init_hw_config(pBtCoexist, bWifiOnly);
+		#ifdef CONFIG_FW_MULTI_PORT_SUPPORT
+		rtw_hal_set_default_port_id_cmd(pBtCoexist->Adapter, 0);
+		rtw_hal_set_wifi_port_id_cmd(pBtCoexist->Adapter);
+		#endif
+	}
+}
+
+void EXhalbtcoutsrc_init_coex_dm(PBTC_COEXIST pBtCoexist)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	pBtCoexist->statistics.cnt_init_coex_dm++;
+
+	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+#if 0
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			ex_halbtc8821aCsr2ant_init_coex_dm(pBtCoexist);
+		else
+#endif
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821a2ant_init_coex_dm(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821a1ant_init_coex_dm(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_init_coex_dm(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_init_coex_dm(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_init_coex_dm(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_init_coex_dm(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_init_coex_dm(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8192e2ant_init_coex_dm(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_init_coex_dm(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_init_coex_dm(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_init_coex_dm(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_init_coex_dm(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_init_coex_dm(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_init_coex_dm(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_init_coex_dm(pBtCoexist);
+	}
+
+	pBtCoexist->initilized = _TRUE;
+}
+
+void EXhalbtcoutsrc_ips_notify(PBTC_COEXIST pBtCoexist, u8 type)
+{
+	u8	ipsType;
+
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	pBtCoexist->statistics.cnt_ips_notify++;
+	if (pBtCoexist->manual_control)
+		return;
+
+	if (0/*IPS_NONE*/ == type) {
+		ipsType = BTC_IPS_LEAVE;
+		GLBtcWiFiInIPS = _FALSE;
+	} else {
+		ipsType = BTC_IPS_ENTER;
+		GLBtcWiFiInIPS = _TRUE;
+	}
+
+	/* All notify is called in cmd thread, don't need to leave low power again
+	*	halbtcoutsrc_LeaveLowPower(pBtCoexist); */
+
+	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+#if 0
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			ex_halbtc8821aCsr2ant_ips_notify(pBtCoexist, ipsType);
+		else
+#endif
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821a2ant_ips_notify(pBtCoexist, ipsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821a1ant_ips_notify(pBtCoexist, ipsType);
+	} else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_ips_notify(pBtCoexist, ipsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_ips_notify(pBtCoexist, ipsType);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_ips_notify(pBtCoexist, ipsType);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_ips_notify(pBtCoexist, ipsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_ips_notify(pBtCoexist, ipsType);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8192e2ant_ips_notify(pBtCoexist, ipsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_ips_notify(pBtCoexist, ipsType);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_ips_notify(pBtCoexist, ipsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_ips_notify(pBtCoexist, ipsType);
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_ips_notify(pBtCoexist, ipsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_ips_notify(pBtCoexist, ipsType);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_ips_notify(pBtCoexist, ipsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_ips_notify(pBtCoexist, ipsType);
+	}
+
+	/*	halbtcoutsrc_NormalLowPower(pBtCoexist); */
+}
+
+void EXhalbtcoutsrc_lps_notify(PBTC_COEXIST pBtCoexist, u8 type)
+{
+	u8 lpsType;
+
+
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	pBtCoexist->statistics.cnt_lps_notify++;
+	if (pBtCoexist->manual_control)
+		return;
+
+	if (PS_MODE_ACTIVE == type) {
+		lpsType = BTC_LPS_DISABLE;
+		GLBtcWiFiInLPS = _FALSE;
+	} else {
+		lpsType = BTC_LPS_ENABLE;
+		GLBtcWiFiInLPS = _TRUE;
+	}
+
+	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+#if 0
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			ex_halbtc8821aCsr2ant_lps_notify(pBtCoexist, lpsType);
+		else
+#endif
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821a2ant_lps_notify(pBtCoexist, lpsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821a1ant_lps_notify(pBtCoexist, lpsType);
+	} else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_lps_notify(pBtCoexist, lpsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_lps_notify(pBtCoexist, lpsType);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_lps_notify(pBtCoexist, lpsType);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_lps_notify(pBtCoexist, lpsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_lps_notify(pBtCoexist, lpsType);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8192e2ant_lps_notify(pBtCoexist, lpsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_lps_notify(pBtCoexist, lpsType);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_lps_notify(pBtCoexist, lpsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_lps_notify(pBtCoexist, lpsType);
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_lps_notify(pBtCoexist, lpsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_lps_notify(pBtCoexist, lpsType);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_lps_notify(pBtCoexist, lpsType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_lps_notify(pBtCoexist, lpsType);
+	}
+}
+
+void EXhalbtcoutsrc_scan_notify(PBTC_COEXIST pBtCoexist, u8 type)
+{
+	u8	scanType;
+
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+	pBtCoexist->statistics.cnt_scan_notify++;
+	if (pBtCoexist->manual_control)
+		return;
+
+	if (type) {
+		scanType = BTC_SCAN_START;
+		GLBtcWiFiInScanState = _TRUE;
+		printk("[%s:%d] BTC_SCAN_START\n", __func__, __LINE__);
+	} else {
+		scanType = BTC_SCAN_FINISH;
+		GLBtcWiFiInScanState = _FALSE;
+		printk("[%s:%d] BTC_SCAN_FINISH\n", __func__, __LINE__);
+	}
+
+	/* All notify is called in cmd thread, don't need to leave low power again
+	*	halbtcoutsrc_LeaveLowPower(pBtCoexist); */
+
+	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+#if 0
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			ex_halbtc8821aCsr2ant_scan_notify(pBtCoexist, scanType);
+		else
+#endif
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821a2ant_scan_notify(pBtCoexist, scanType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821a1ant_scan_notify(pBtCoexist, scanType);
+	} else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_scan_notify(pBtCoexist, scanType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_scan_notify(pBtCoexist, scanType);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_scan_notify(pBtCoexist, scanType);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_scan_notify(pBtCoexist, scanType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_scan_notify(pBtCoexist, scanType);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8192e2ant_scan_notify(pBtCoexist, scanType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_scan_notify(pBtCoexist, scanType);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_scan_notify(pBtCoexist, scanType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_scan_notify(pBtCoexist, scanType);
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_scan_notify(pBtCoexist, scanType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_scan_notify(pBtCoexist, scanType);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_scan_notify(pBtCoexist, scanType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_scan_notify(pBtCoexist, scanType);
+	}
+
+	/*	halbtcoutsrc_NormalLowPower(pBtCoexist); */
+}
+
+void EXhalbtcoutsrc_SetAntennaPathNotify(PBTC_COEXIST pBtCoexist, u8 type)
+{
+#if 0
+	u8	switchType;
+
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	if (pBtCoexist->manual_control)
+		return;
+
+	halbtcoutsrc_LeaveLowPower(pBtCoexist);
+
+	switchType = type;
+
+	if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_set_antenna_notify(pBtCoexist, type);
+	}
+	if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_set_antenna_notify(pBtCoexist, type);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_set_antenna_notify(pBtCoexist, type);
+	}
+
+	halbtcoutsrc_NormalLowPower(pBtCoexist);
+#endif
+}
+
+void EXhalbtcoutsrc_connect_notify(PBTC_COEXIST pBtCoexist, u8 action)
+{
+	u8	assoType;
+
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+	pBtCoexist->statistics.cnt_connect_notify++;
+	if (pBtCoexist->manual_control)
+		return;
+
+	if (action)
+		assoType = BTC_ASSOCIATE_START;
+	else
+		assoType = BTC_ASSOCIATE_FINISH;
+
+	/* All notify is called in cmd thread, don't need to leave low power again
+	*	halbtcoutsrc_LeaveLowPower(pBtCoexist); */
+
+	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+#if 0
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			ex_halbtc8821aCsr2ant_connect_notify(pBtCoexist, assoType);
+		else
+#endif
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821a2ant_connect_notify(pBtCoexist, assoType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821a1ant_connect_notify(pBtCoexist, assoType);
+	} else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_connect_notify(pBtCoexist, assoType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_connect_notify(pBtCoexist, assoType);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_connect_notify(pBtCoexist, assoType);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_connect_notify(pBtCoexist, assoType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_connect_notify(pBtCoexist, assoType);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8192e2ant_connect_notify(pBtCoexist, assoType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_connect_notify(pBtCoexist, assoType);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_connect_notify(pBtCoexist, assoType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_connect_notify(pBtCoexist, assoType);
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_connect_notify(pBtCoexist, assoType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_connect_notify(pBtCoexist, assoType);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_connect_notify(pBtCoexist, assoType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_connect_notify(pBtCoexist, assoType);
+	}
+
+	/*	halbtcoutsrc_NormalLowPower(pBtCoexist); */
+}
+
+void EXhalbtcoutsrc_media_status_notify(PBTC_COEXIST pBtCoexist, RT_MEDIA_STATUS mediaStatus)
+{
+	u8 mStatus;
+
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	pBtCoexist->statistics.cnt_media_status_notify++;
+	if (pBtCoexist->manual_control)
+		return;
+
+	if (RT_MEDIA_CONNECT == mediaStatus)
+		mStatus = BTC_MEDIA_CONNECT;
+	else
+		mStatus = BTC_MEDIA_DISCONNECT;
+
+	/* All notify is called in cmd thread, don't need to leave low power again
+	*	halbtcoutsrc_LeaveLowPower(pBtCoexist); */
+
+	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+#if 0
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			ex_halbtc8821aCsr2ant_media_status_notify(pBtCoexist, mStatus);
+		else
+#endif
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821a2ant_media_status_notify(pBtCoexist, mStatus);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821a1ant_media_status_notify(pBtCoexist, mStatus);
+	} else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_media_status_notify(pBtCoexist, mStatus);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_media_status_notify(pBtCoexist, mStatus);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_media_status_notify(pBtCoexist, mStatus);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_media_status_notify(pBtCoexist, mStatus);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_media_status_notify(pBtCoexist, mStatus);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8192e2ant_media_status_notify(pBtCoexist, mStatus);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_media_status_notify(pBtCoexist, mStatus);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_media_status_notify(pBtCoexist, mStatus);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_media_status_notify(pBtCoexist, mStatus);
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_media_status_notify(pBtCoexist, mStatus);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_media_status_notify(pBtCoexist, mStatus);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_media_status_notify(pBtCoexist, mStatus);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_media_status_notify(pBtCoexist, mStatus);
+	}
+
+	/*	halbtcoutsrc_NormalLowPower(pBtCoexist); */
+}
+
+void EXhalbtcoutsrc_specific_packet_notify(PBTC_COEXIST pBtCoexist, u8 pktType)
+{
+	u8	packetType;
+
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+	pBtCoexist->statistics.cnt_specific_packet_notify++;
+	if (pBtCoexist->manual_control)
+		return;
+
+	if (PACKET_DHCP == pktType)
+		packetType = BTC_PACKET_DHCP;
+	else if (PACKET_EAPOL == pktType)
+		packetType = BTC_PACKET_EAPOL;
+	else if (PACKET_ARP == pktType)
+		packetType = BTC_PACKET_ARP;
+	else {
+		packetType = BTC_PACKET_UNKNOWN;
+		return;
+	}
+
+	/* All notify is called in cmd thread, don't need to leave low power again
+	*	halbtcoutsrc_LeaveLowPower(pBtCoexist); */
+
+	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+#if 0
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			ex_halbtc8821aCsr2ant_specific_packet_notify(pBtCoexist, packetType);
+		else
+#endif
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821a2ant_specific_packet_notify(pBtCoexist, packetType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821a1ant_specific_packet_notify(pBtCoexist, packetType);
+	} else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_specific_packet_notify(pBtCoexist, packetType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_specific_packet_notify(pBtCoexist, packetType);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_specific_packet_notify(pBtCoexist, packetType);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_specific_packet_notify(pBtCoexist, packetType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_specific_packet_notify(pBtCoexist, packetType);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8192e2ant_specific_packet_notify(pBtCoexist, packetType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_specific_packet_notify(pBtCoexist, packetType);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_specific_packet_notify(pBtCoexist, packetType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_specific_packet_notify(pBtCoexist, packetType);
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_specific_packet_notify(pBtCoexist, packetType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_specific_packet_notify(pBtCoexist, packetType);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_specific_packet_notify(pBtCoexist, packetType);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_specific_packet_notify(pBtCoexist, packetType);
+	}
+
+	/*	halbtcoutsrc_NormalLowPower(pBtCoexist); */
+}
+
+void EXhalbtcoutsrc_bt_info_notify(PBTC_COEXIST pBtCoexist, u8 *tmpBuf, u8 length)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	pBtCoexist->statistics.cnt_bt_info_notify++;
+
+	/* All notify is called in cmd thread, don't need to leave low power again
+	*	halbtcoutsrc_LeaveLowPower(pBtCoexist); */
+
+	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+#if 0
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			ex_halbtc8821aCsr2ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+		else
+#endif
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821a2ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821a1ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+	} else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8192e2ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_bt_info_notify(pBtCoexist, tmpBuf, length);
+	}
+
+	/*	halbtcoutsrc_NormalLowPower(pBtCoexist); */
+}
+
+VOID
+EXhalbtcoutsrc_RfStatusNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte				type
+)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+	pBtCoexist->statistics.cnt_rf_status_notify++;
+
+	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+	} else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_rf_status_notify(pBtCoexist, type);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_rf_status_notify(pBtCoexist, type);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_rf_status_notify(pBtCoexist, type);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_rf_status_notify(pBtCoexist, type);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_rf_status_notify(pBtCoexist, type);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_rf_status_notify(pBtCoexist, type);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_rf_status_notify(pBtCoexist, type);
+	}
+}
+
+void EXhalbtcoutsrc_StackOperationNotify(PBTC_COEXIST pBtCoexist, u8 type)
+{
+#if 0
+	u8	stackOpType;
+
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+	pBtCoexist->statistics.cntStackOperationNotify++;
+	if (pBtCoexist->manual_control)
+		return;
+
+	if ((HCI_BT_OP_INQUIRY_START == type) ||
+	    (HCI_BT_OP_PAGING_START == type) ||
+	    (HCI_BT_OP_PAIRING_START == type))
+		stackOpType = BTC_STACK_OP_INQ_PAGE_PAIR_START;
+	else if ((HCI_BT_OP_INQUIRY_FINISH == type) ||
+		 (HCI_BT_OP_PAGING_SUCCESS == type) ||
+		 (HCI_BT_OP_PAGING_UNSUCCESS == type) ||
+		 (HCI_BT_OP_PAIRING_FINISH == type))
+		stackOpType = BTC_STACK_OP_INQ_PAGE_PAIR_FINISH;
+	else
+		stackOpType = BTC_STACK_OP_NONE;
+
+#endif
+}
+
+void EXhalbtcoutsrc_halt_notify(PBTC_COEXIST pBtCoexist)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+#if 0
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			ex_halbtc8821aCsr2ant_halt_notify(pBtCoexist);
+		else
+#endif
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821a2ant_halt_notify(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821a1ant_halt_notify(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_halt_notify(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_halt_notify(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_halt_notify(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_halt_notify(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_halt_notify(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8192e2ant_halt_notify(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_halt_notify(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_halt_notify(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_halt_notify(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_halt_notify(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_halt_notify(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_halt_notify(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_halt_notify(pBtCoexist);
+	}
+}
+
+void EXhalbtcoutsrc_SwitchBtTRxMask(PBTC_COEXIST pBtCoexist)
+{
+	if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2) {
+			halbtcoutsrc_SetBtReg(pBtCoexist, 0, 0x3c, 0x01); /* BT goto standby while GNT_BT 1-->0 */
+		} else if (pBtCoexist->board_info.btdm_ant_num == 1) {
+			halbtcoutsrc_SetBtReg(pBtCoexist, 0, 0x3c, 0x15); /* BT goto standby while GNT_BT 1-->0 */
+		}
+	}
+}
+
+void EXhalbtcoutsrc_pnp_notify(PBTC_COEXIST pBtCoexist, u8 pnpState)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	/*  */
+	/* currently only 1ant we have to do the notification, */
+	/* once pnp is notified to sleep state, we have to leave LPS that we can sleep normally. */
+	/*  */
+
+	if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_pnp_notify(pBtCoexist, pnpState);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_pnp_notify(pBtCoexist, pnpState);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_pnp_notify(pBtCoexist, pnpState);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_pnp_notify(pBtCoexist, pnpState);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_pnp_notify(pBtCoexist, pnpState);
+	} else if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+#if 0
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			ex_halbtc8821aCsr2ant_pnp_notify(pBtCoexist, pnpState);
+		else
+#endif
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821a1ant_pnp_notify(pBtCoexist, pnpState);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821a2ant_pnp_notify(pBtCoexist, pnpState);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_pnp_notify(pBtCoexist, pnpState);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_pnp_notify(pBtCoexist, pnpState);
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_pnp_notify(pBtCoexist, pnpState);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_pnp_notify(pBtCoexist, pnpState);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_pnp_notify(pBtCoexist, pnpState);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_pnp_notify(pBtCoexist, pnpState);
+	}
+}
+
+void EXhalbtcoutsrc_CoexDmSwitch(PBTC_COEXIST pBtCoexist)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+	pBtCoexist->statistics.cnt_coex_dm_switch++;
+
+	halbtcoutsrc_LeaveLowPower(pBtCoexist);
+
+	if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1) {
+			pBtCoexist->stop_coex_dm = TRUE;
+			ex_halbtc8723b1ant_coex_dm_reset(pBtCoexist);
+			EXhalbtcoutsrc_SetAntNum(BT_COEX_ANT_TYPE_DETECTED, 2);
+			ex_halbtc8723b2ant_init_hw_config(pBtCoexist, FALSE);
+			ex_halbtc8723b2ant_init_coex_dm(pBtCoexist);
+			pBtCoexist->stop_coex_dm = FALSE;
+		}
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1) {
+			pBtCoexist->stop_coex_dm = TRUE;
+			ex_halbtc8723d1ant_coex_dm_reset(pBtCoexist);
+			EXhalbtcoutsrc_SetAntNum(BT_COEX_ANT_TYPE_DETECTED, 2);
+			ex_halbtc8723d2ant_init_hw_config(pBtCoexist, FALSE);
+			ex_halbtc8723d2ant_init_coex_dm(pBtCoexist);
+			pBtCoexist->stop_coex_dm = FALSE;
+		}
+	}
+
+	halbtcoutsrc_NormalLowPower(pBtCoexist);
+}
+
+void EXhalbtcoutsrc_periodical(PBTC_COEXIST pBtCoexist)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+	pBtCoexist->statistics.cnt_periodical++;
+
+	/* Periodical should be called in cmd thread, */
+	/* don't need to leave low power again
+	*	halbtcoutsrc_LeaveLowPower(pBtCoexist); */
+
+	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+#if 0
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			ex_halbtc8821aCsr2ant_periodical(pBtCoexist);
+		else
+#endif
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821a2ant_periodical(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1) {
+			if (!halbtcoutsrc_UnderIps(pBtCoexist))
+				ex_halbtc8821a1ant_periodical(pBtCoexist);
+		}
+	} else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_periodical(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_periodical(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_periodical(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_periodical(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_periodical(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8192e2ant_periodical(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_periodical(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_periodical(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_periodical(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_periodical(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_periodical(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_periodical(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_periodical(pBtCoexist);
+	}
+
+	/*	halbtcoutsrc_NormalLowPower(pBtCoexist); */
+}
+
+void EXhalbtcoutsrc_dbg_control(PBTC_COEXIST pBtCoexist, u8 opCode, u8 opLen, u8 *pData)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	pBtCoexist->statistics.cnt_dbg_ctrl++;
+
+	/* This function doesn't be called yet, */
+	/* default no need to leave low power to avoid deadlock
+	*	halbtcoutsrc_LeaveLowPower(pBtCoexist); */
+
+	if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_dbg_control(pBtCoexist, opCode, opLen, pData);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_dbg_control(pBtCoexist, opCode, opLen, pData);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_dbg_control(pBtCoexist, opCode, opLen, pData);
+	} else if(IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter))
+		if(pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_dbg_control(pBtCoexist, opCode, opLen, pData);
+
+	/*	halbtcoutsrc_NormalLowPower(pBtCoexist); */
+}
+
+#if 0
+VOID
+EXhalbtcoutsrc_AntennaDetection(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u4Byte					centFreq,
+	IN	u4Byte					offset,
+	IN	u4Byte					span,
+	IN	u4Byte					seconds
+)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	/* Need to refine the following power save operations to enable this function in the future */
+#if 0
+	IPSDisable(pBtCoexist->Adapter, FALSE, 0);
+	LeisurePSLeave(pBtCoexist->Adapter, LPS_DISABLE_BT_COEX);
+#endif
+
+	if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_AntennaDetection(pBtCoexist, centFreq, offset, span, seconds);
+	}
+
+	/* IPSReturn(pBtCoexist->Adapter, 0xff); */
+}
+#endif
+
+void EXhalbtcoutsrc_StackUpdateProfileInfo(void)
+{
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+	PBTC_COEXIST pBtCoexist = &GLBtCoexist;
+	PADAPTER padapter = (PADAPTER)GLBtCoexist.Adapter;
+	PBT_MGNT pBtMgnt = &padapter->coex_info.BtMgnt;
+	u8 i;
+
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	pBtCoexist->stack_info.profile_notified = _TRUE;
+
+	pBtCoexist->stack_info.num_of_link =
+		pBtMgnt->ExtConfig.NumberOfACL + pBtMgnt->ExtConfig.NumberOfSCO;
+
+	/* reset first */
+	pBtCoexist->stack_info.bt_link_exist = _FALSE;
+	pBtCoexist->stack_info.sco_exist = _FALSE;
+	pBtCoexist->stack_info.acl_exist = _FALSE;
+	pBtCoexist->stack_info.a2dp_exist = _FALSE;
+	pBtCoexist->stack_info.hid_exist = _FALSE;
+	pBtCoexist->stack_info.num_of_hid = 0;
+	pBtCoexist->stack_info.pan_exist = _FALSE;
+
+	if (!pBtMgnt->ExtConfig.NumberOfACL)
+		pBtCoexist->stack_info.min_bt_rssi = 0;
+
+	if (pBtCoexist->stack_info.num_of_link) {
+		pBtCoexist->stack_info.bt_link_exist = _TRUE;
+		if (pBtMgnt->ExtConfig.NumberOfSCO)
+			pBtCoexist->stack_info.sco_exist = _TRUE;
+		if (pBtMgnt->ExtConfig.NumberOfACL)
+			pBtCoexist->stack_info.acl_exist = _TRUE;
+	}
+
+	for (i = 0; i < pBtMgnt->ExtConfig.NumberOfACL; i++) {
+		if (BT_PROFILE_A2DP == pBtMgnt->ExtConfig.aclLink[i].BTProfile)
+			pBtCoexist->stack_info.a2dp_exist = _TRUE;
+		else if (BT_PROFILE_PAN == pBtMgnt->ExtConfig.aclLink[i].BTProfile)
+			pBtCoexist->stack_info.pan_exist = _TRUE;
+		else if (BT_PROFILE_HID == pBtMgnt->ExtConfig.aclLink[i].BTProfile) {
+			pBtCoexist->stack_info.hid_exist = _TRUE;
+			pBtCoexist->stack_info.num_of_hid++;
+		} else
+			pBtCoexist->stack_info.unknown_acl_exist = _TRUE;
+	}
+#endif /* CONFIG_BT_COEXIST_SOCKET_TRX */
+}
+
+void EXhalbtcoutsrc_UpdateMinBtRssi(s8 btRssi)
+{
+	PBTC_COEXIST pBtCoexist = &GLBtCoexist;
+
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	pBtCoexist->stack_info.min_bt_rssi = btRssi;
+}
+
+void EXhalbtcoutsrc_SetHciVersion(u16 hciVersion)
+{
+	PBTC_COEXIST pBtCoexist = &GLBtCoexist;
+
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	pBtCoexist->stack_info.hci_version = hciVersion;
+}
+
+void EXhalbtcoutsrc_SetBtPatchVersion(u16 btHciVersion, u16 btPatchVersion)
+{
+	PBTC_COEXIST pBtCoexist = &GLBtCoexist;
+
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	pBtCoexist->bt_info.bt_real_fw_ver = btPatchVersion;
+	pBtCoexist->bt_info.bt_hci_ver = btHciVersion;
+}
+
+#if 0
+void EXhalbtcoutsrc_SetBtExist(u8 bBtExist)
+{
+	GLBtCoexist.boardInfo.bBtExist = bBtExist;
+}
+#endif
+void EXhalbtcoutsrc_SetChipType(u8 chipType)
+{
+	switch (chipType) {
+	default:
+	case BT_2WIRE:
+	case BT_ISSC_3WIRE:
+	case BT_ACCEL:
+	case BT_RTL8756:
+		GLBtCoexist.board_info.bt_chip_type = BTC_CHIP_UNDEF;
+		break;
+	case BT_CSR_BC4:
+		GLBtCoexist.board_info.bt_chip_type = BTC_CHIP_CSR_BC4;
+		break;
+	case BT_CSR_BC8:
+		GLBtCoexist.board_info.bt_chip_type = BTC_CHIP_CSR_BC8;
+		break;
+	case BT_RTL8723A:
+		GLBtCoexist.board_info.bt_chip_type = BTC_CHIP_RTL8723A;
+		break;
+	case BT_RTL8821:
+		GLBtCoexist.board_info.bt_chip_type = BTC_CHIP_RTL8821;
+		break;
+	case BT_RTL8723B:
+		GLBtCoexist.board_info.bt_chip_type = BTC_CHIP_RTL8723B;
+		break;
+	}
+}
+
+void EXhalbtcoutsrc_SetAntNum(u8 type, u8 antNum)
+{
+	if (BT_COEX_ANT_TYPE_PG == type) {
+		GLBtCoexist.board_info.pg_ant_num = antNum;
+		GLBtCoexist.board_info.btdm_ant_num = antNum;
+#if 0
+		/* The antenna position: Main (default) or Aux for pgAntNum=2 && btdmAntNum =1 */
+		/* The antenna position should be determined by auto-detect mechanism */
+		/* The following is assumed to main, and those must be modified if y auto-detect mechanism is ready */
+		if ((GLBtCoexist.board_info.pg_ant_num == 2) && (GLBtCoexist.board_info.btdm_ant_num == 1))
+			GLBtCoexist.board_info.btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+		else
+			GLBtCoexist.board_info.btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+#endif
+	} else if (BT_COEX_ANT_TYPE_ANTDIV == type) {
+		GLBtCoexist.board_info.btdm_ant_num = antNum;
+		/* GLBtCoexist.boardInfo.btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT;	 */
+	} else if (BT_COEX_ANT_TYPE_DETECTED == type) {
+		GLBtCoexist.board_info.btdm_ant_num = antNum;
+		/* GLBtCoexist.boardInfo.btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT; */
+	}
+}
+
+/*
+ * Currently used by 8723b only, S0 or S1
+ *   */
+void EXhalbtcoutsrc_SetSingleAntPath(u8 singleAntPath)
+{
+	GLBtCoexist.board_info.single_ant_path = singleAntPath;
+}
+
+void EXhalbtcoutsrc_DisplayBtCoexInfo(PBTC_COEXIST pBtCoexist)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	halbtcoutsrc_LeaveLowPower(pBtCoexist);
+
+	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter)) {
+#if 0
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			ex_halbtc8821aCsr2ant_display_coex_info(pBtCoexist);
+		else
+#endif
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821a2ant_display_coex_info(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821a1ant_display_coex_info(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723b2ant_display_coex_info(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_display_coex_info(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8703B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8703b1ant_display_coex_info(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8723D(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8723d2ant_display_coex_info(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723d1ant_display_coex_info(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8192e2ant_display_coex_info(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8192e1ant_display_coex_info(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_display_coex_info(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8812a1ant_display_coex_info(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_display_coex_info(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_display_coex_info(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_display_coex_info(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_display_coex_info(pBtCoexist);
+	}
+
+	halbtcoutsrc_NormalLowPower(pBtCoexist);
+}
+
+void EXhalbtcoutsrc_DisplayAntDetection(PBTC_COEXIST pBtCoexist)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	halbtcoutsrc_LeaveLowPower(pBtCoexist);
+
+	if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8723b1ant_display_ant_detection(pBtCoexist);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_display_ant_detection(pBtCoexist);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_display_ant_detection(pBtCoexist);
+	}
+
+	halbtcoutsrc_NormalLowPower(pBtCoexist);
+}
+
+void ex_halbtcoutsrc_pta_off_on_notify(PBTC_COEXIST pBtCoexist, u8 bBTON)
+{
+	if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8812a2ant_pta_off_on_notify(pBtCoexist, (bBTON == _TRUE) ? BTC_BT_ON : BTC_BT_OFF);
+	}
+}
+
+void EXhalbtcoutsrc_set_rfe_type(u8 type)
+{
+	GLBtCoexist.board_info.rfe_type= type;
+}
+
+#ifdef CONFIG_RF4CE_COEXIST
+void EXhalbtcoutsrc_set_rf4ce_link_state(u8 state)
+{
+	GLBtCoexist.rf4ce_info.link_state = state;
+}
+
+u8 EXhalbtcoutsrc_get_rf4ce_link_state(void)
+{
+	return GLBtCoexist.rf4ce_info.link_state;
+}
+#endif
+
+void EXhalbtcoutsrc_switchband_notify(struct btc_coexist *pBtCoexist, u8 type)
+{
+	if(!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+	
+	if(pBtCoexist->manual_control)
+		return;
+
+	/* Driver should guarantee that the HW status isn't in low power mode */
+	/* halbtcoutsrc_LeaveLowPower(pBtCoexist); */
+
+	if(IS_HARDWARE_TYPE_8822B(pBtCoexist->Adapter)) {
+		if(pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8822b1ant_switchband_notify(pBtCoexist, type);
+		else if(pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8822b2ant_switchband_notify(pBtCoexist, type);
+	} else if (IS_HARDWARE_TYPE_8821C(pBtCoexist->Adapter)) {
+		if (pBtCoexist->board_info.btdm_ant_num == 2)
+			ex_halbtc8821c2ant_switchband_notify(pBtCoexist, type);
+		else if (pBtCoexist->board_info.btdm_ant_num == 1)
+			ex_halbtc8821c1ant_switchband_notify(pBtCoexist, type);
+	}
+
+	/* halbtcoutsrc_NormalLowPower(pBtCoexist); */
+}
+
+static void halbt_init_hw_config92C(PADAPTER padapter)
+{
+#if 0
+	PHAL_DATA_TYPE pHalData;
+	u8 u1Tmp;
+
+
+	pHalData = GET_HAL_DATA(padapter);
+	if ((padapter->pshare->bt_coexist.btChipType == BT_CSR_BC4) ||
+	    (padapter->pshare->bt_coexist.btChipType == BT_CSR_BC8)) {
+		if (padapter->pshare->rf_type == RF_1T1R) {
+			/* Config to 1T1R */
+			u1Tmp = rtw_read8(padapter, rOFDM0_TRxPathEnable);
+			u1Tmp &= ~BIT(1);
+			rtw_write8(padapter, rOFDM0_TRxPathEnable, u1Tmp);
+			RT_DISP(FBT, BT_TRACE, ("[BTCoex], BT write 0xC04 = 0x%x\n", u1Tmp));
+
+			u1Tmp = rtw_read8(padapter, rOFDM1_TRxPathEnable);
+			u1Tmp &= ~BIT(1);
+			rtw_write8(padapter, rOFDM1_TRxPathEnable, u1Tmp);
+			RT_DISP(FBT, BT_TRACE, ("[BTCoex], BT write 0xD04 = 0x%x\n", u1Tmp));
+		}
+	}
+#endif
+}
+
+static void halbt_init_hw_config92D(PADAPTER padapter)
+{
+#if 0
+	PHAL_DATA_TYPE pHalData;
+	u8 u1Tmp;
+
+	pHalData = GET_HAL_DATA(padapter);
+	if ((pHalData->bt_coexist.btChipType == BT_CSR_BC4) ||
+	    (pHalData->bt_coexist.btChipType == BT_CSR_BC8)) {
+		if (pHalData->rf_type == RF_1T1R) {
+			/* Config to 1T1R */
+			u1Tmp = rtw_read8(padapter, rOFDM0_TRxPathEnable);
+			u1Tmp &= ~BIT(1);
+			rtw_write8(padapter, rOFDM0_TRxPathEnable, u1Tmp);
+			RT_DISP(FBT, BT_TRACE, ("[BTCoex], BT write 0xC04 = 0x%x\n", u1Tmp));
+
+			u1Tmp = rtw_read8(padapter, rOFDM1_TRxPathEnable);
+			u1Tmp &= ~BIT(1);
+			rtw_write8(padapter, rOFDM1_TRxPathEnable, u1Tmp);
+			RT_DISP(FBT, BT_TRACE, ("[BTCoex], BT write 0xD04 = 0x%x\n", u1Tmp));
+		}
+	}
+#endif
+}
+
+/*
+ * Description:
+ *	Run BT-Coexist mechansim or not
+ *
+ */
+void hal_btcoex_SetBTCoexist(PADAPTER padapter, u8 bBtExist)
+{
+	PHAL_DATA_TYPE	pHalData;
+
+
+	pHalData = GET_HAL_DATA(padapter);
+	pHalData->bt_coexist.bBtExist = bBtExist;
+}
+
+/*
+ * Dewcription:
+ *	Check is co-exist mechanism enabled or not
+ *
+ * Return:
+ *	_TRUE	Enable BT co-exist mechanism
+ *	_FALSE	Disable BT co-exist mechanism
+ */
+u8 hal_btcoex_IsBtExist(PADAPTER padapter)
+{
+	PHAL_DATA_TYPE	pHalData;
+
+
+	pHalData = GET_HAL_DATA(padapter);
+	return pHalData->bt_coexist.bBtExist;
+}
+
+u8 hal_btcoex_IsBtDisabled(PADAPTER padapter)
+{
+	if (!hal_btcoex_IsBtExist(padapter))
+		return _TRUE;
+
+	if (GLBtCoexist.bt_info.bt_disabled)
+		return _TRUE;
+	else
+		return _FALSE;
+}
+
+void hal_btcoex_SetChipType(PADAPTER padapter, u8 chipType)
+{
+	PHAL_DATA_TYPE	pHalData;
+
+	pHalData = GET_HAL_DATA(padapter);
+	pHalData->bt_coexist.btChipType = chipType;
+}
+
+void hal_btcoex_SetPgAntNum(PADAPTER padapter, u8 antNum)
+{
+	PHAL_DATA_TYPE	pHalData;
+
+	pHalData = GET_HAL_DATA(padapter);
+
+	pHalData->bt_coexist.btTotalAntNum = antNum;
+}
+
+u8 hal_btcoex_Initialize(PADAPTER padapter)
+{
+	u8 ret;
+
+	_rtw_memset(&GLBtCoexist, 0, sizeof(GLBtCoexist));
+
+	hal_btcoex_SetBTCoexist(padapter, rtw_btcoex_get_bt_coexist(padapter));
+	hal_btcoex_SetChipType(padapter, rtw_btcoex_get_chip_type(padapter));
+	hal_btcoex_SetPgAntNum(padapter, rtw_btcoex_get_pg_ant_num(padapter));
+	
+	ret = EXhalbtcoutsrc_InitlizeVariables((void *)padapter);
+
+	return ret;
+}
+
+void hal_btcoex_PowerOnSetting(PADAPTER padapter)
+{
+	EXhalbtcoutsrc_PowerOnSetting(&GLBtCoexist);
+}
+
+void hal_btcoex_PreLoadFirmware(PADAPTER padapter)
+{
+	EXhalbtcoutsrc_PreLoadFirmware(&GLBtCoexist);
+}
+
+void hal_btcoex_InitHwConfig(PADAPTER padapter, u8 bWifiOnly)
+{
+	if (!hal_btcoex_IsBtExist(padapter))
+		return;
+
+	EXhalbtcoutsrc_init_hw_config(&GLBtCoexist, bWifiOnly);
+	EXhalbtcoutsrc_init_coex_dm(&GLBtCoexist);
+}
+
+void hal_btcoex_IpsNotify(PADAPTER padapter, u8 type)
+{
+	EXhalbtcoutsrc_ips_notify(&GLBtCoexist, type);
+}
+
+void hal_btcoex_LpsNotify(PADAPTER padapter, u8 type)
+{
+	EXhalbtcoutsrc_lps_notify(&GLBtCoexist, type);
+}
+
+void hal_btcoex_ScanNotify(PADAPTER padapter, u8 type)
+{
+	EXhalbtcoutsrc_scan_notify(&GLBtCoexist, type);
+}
+
+void hal_btcoex_ConnectNotify(PADAPTER padapter, u8 action)
+{
+	EXhalbtcoutsrc_connect_notify(&GLBtCoexist, action);
+}
+
+void hal_btcoex_MediaStatusNotify(PADAPTER padapter, u8 mediaStatus)
+{
+	EXhalbtcoutsrc_media_status_notify(&GLBtCoexist, mediaStatus);
+}
+
+void hal_btcoex_SpecialPacketNotify(PADAPTER padapter, u8 pktType)
+{
+	EXhalbtcoutsrc_specific_packet_notify(&GLBtCoexist, pktType);
+}
+
+void hal_btcoex_IQKNotify(PADAPTER padapter, u8 state)
+{
+	GLBtcWiFiInIQKState = state;
+}
+
+void hal_btcoex_BtInfoNotify(PADAPTER padapter, u8 length, u8 *tmpBuf)
+{
+	if (GLBtcWiFiInIQKState == _TRUE)
+		return;
+
+	EXhalbtcoutsrc_bt_info_notify(&GLBtCoexist, tmpBuf, length);
+}
+
+void hal_btcoex_BtMpRptNotify(PADAPTER padapter, u8 length, u8 *tmpBuf)
+{
+	u8 extid, status, len, seq;
+
+
+	if (GLBtcBtMpRptWait == _FALSE)
+		return;
+
+	if ((length < 3) || (!tmpBuf))
+		return;
+
+	extid = tmpBuf[0];
+	/* not response from BT FW then exit*/
+	switch (extid) {
+	case C2H_WIFI_FW_ACTIVE_RSP:
+		GLBtcBtMpRptWiFiOK = _TRUE;
+		break;
+
+	case C2H_TRIG_BY_BT_FW:
+		GLBtcBtMpRptBTOK = _TRUE;
+
+		status = tmpBuf[1] & 0xF;
+		len = length - 3;
+		seq = tmpBuf[2] >> 4;
+
+		GLBtcBtMpRptSeq = seq;
+		GLBtcBtMpRptStatus = status;
+		_rtw_memcpy(GLBtcBtMpRptRsp, tmpBuf + 3, len);
+		GLBtcBtMpRptRspSize = len;
+
+		break;
+
+	default:
+		return;
+	}
+
+	if ((GLBtcBtMpRptWiFiOK == _TRUE) && (GLBtcBtMpRptBTOK == _TRUE)) {
+		GLBtcBtMpRptWait = _FALSE;
+		_cancel_timer_ex(&GLBtcBtMpOperTimer);
+		_rtw_up_sema(&GLBtcBtMpRptSema);
+	}
+}
+
+void hal_btcoex_SuspendNotify(PADAPTER padapter, u8 state)
+{
+	switch (state) {
+	case BTCOEX_SUSPEND_STATE_SUSPEND:
+		EXhalbtcoutsrc_pnp_notify(&GLBtCoexist, BTC_WIFI_PNP_SLEEP);
+		break;
+	case BTCOEX_SUSPEND_STATE_SUSPEND_KEEP_ANT:
+		/* should switch to "#if 1" once all ICs' coex. revision are upgraded to support the KEEP_ANT case */
+#if 0
+		EXhalbtcoutsrc_pnp_notify(&GLBtCoexist, BTC_WIFI_PNP_SLEEP_KEEP_ANT);
+#else
+		EXhalbtcoutsrc_pnp_notify(&GLBtCoexist, BTC_WIFI_PNP_SLEEP);
+		EXhalbtcoutsrc_pnp_notify(&GLBtCoexist, BTC_WIFI_PNP_SLEEP_KEEP_ANT);
+#endif
+		break;
+	case BTCOEX_SUSPEND_STATE_RESUME:
+		EXhalbtcoutsrc_pnp_notify(&GLBtCoexist, BTC_WIFI_PNP_WAKE_UP);
+		break;
+	}
+}
+
+void hal_btcoex_HaltNotify(PADAPTER padapter, u8 do_halt)
+{
+	if (do_halt == 1)
+		EXhalbtcoutsrc_halt_notify(&GLBtCoexist);
+
+	GLBtCoexist.bBinded = _FALSE;
+	GLBtCoexist.Adapter = NULL;
+}
+
+void hal_btcoex_SwitchBtTRxMask(PADAPTER padapter)
+{
+	EXhalbtcoutsrc_SwitchBtTRxMask(&GLBtCoexist);
+}
+
+void hal_btcoex_Hanlder(PADAPTER padapter)
+{
+	u32	bt_patch_ver;
+	u16	BusyThresholdHigh = 25;
+	u16	BusyThresholdLow = 10;
+	u16	BusyThreshold = BusyThresholdHigh;
+
+	padapter->pshare->bt_coexist.NumTxOkInPeriod = padapter->pshare->bt_coexist.tx_data_pkts - padapter->pshare->bt_coexist.tx_data_pkts_pre;
+	padapter->pshare->bt_coexist.NumRxOkInPeriod = padapter->pshare->bt_coexist.rx_data_pkts - padapter->pshare->bt_coexist.rx_data_pkts_pre;
+	if (padapter->pmib->dot11OperationEntry.opmode & (WIFI_ASOC_STATE|WIFI_AP_STATE))
+	{
+		if (padapter->pshare->bt_coexist.bBusyTraffic)
+			BusyThreshold = BusyThresholdLow;
+		if ((padapter->pshare->bt_coexist.NumTxOkInPeriod > BusyThreshold) || 
+			(padapter->pshare->bt_coexist.NumRxOkInPeriod > BusyThreshold))
+		{
+			padapter->pshare->bt_coexist.bBusyTraffic = _TRUE;
+		}
+		else
+		{
+			padapter->pshare->bt_coexist.bBusyTraffic = _FALSE;
+		}
+	}
+	else
+		padapter->pshare->bt_coexist.bBusyTraffic = _FALSE;
+	padapter->pshare->bt_coexist.tx_data_pkts_pre = padapter->pshare->bt_coexist.tx_data_pkts;
+	padapter->pshare->bt_coexist.rx_data_pkts_pre = padapter->pshare->bt_coexist.rx_data_pkts;
+	EXhalbtcoutsrc_periodical(&GLBtCoexist);
+
+	if (GLBtCoexist.bt_info.bt_get_fw_ver == 0) {
+		GLBtCoexist.btc_get(&GLBtCoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+		GLBtCoexist.bt_info.bt_get_fw_ver = bt_patch_ver;
+	}
+}
+
+s32 hal_btcoex_IsBTCoexRejectAMPDU(PADAPTER padapter)
+{
+	return (s32)GLBtCoexist.bt_info.reject_agg_pkt;
+}
+
+s32 hal_btcoex_IsBTCoexCtrlAMPDUSize(PADAPTER padapter)
+{
+	return (s32)GLBtCoexist.bt_info.bt_ctrl_agg_buf_size;
+}
+
+u32 hal_btcoex_GetAMPDUSize(PADAPTER padapter)
+{
+	return (u32)GLBtCoexist.bt_info.agg_buf_size;
+}
+
+void hal_btcoex_SetManualControl(PADAPTER padapter, u8 bmanual)
+{
+	GLBtCoexist.manual_control = bmanual;
+}
+
+u8 hal_btcoex_1Ant(PADAPTER padapter)
+{
+	if (hal_btcoex_IsBtExist(padapter) == _FALSE)
+		return _FALSE;
+
+	if (GLBtCoexist.board_info.btdm_ant_num == 1)
+		return _TRUE;
+
+	return _FALSE;
+}
+
+u8 hal_btcoex_IsBtControlLps(PADAPTER padapter)
+{
+	if (GLBtCoexist.bdontenterLPS == _TRUE)
+		return _TRUE;
+	
+	if (hal_btcoex_IsBtExist(padapter) == _FALSE)
+		return _FALSE;
+
+	if (GLBtCoexist.bt_info.bt_disabled)
+		return _FALSE;
+
+	if (GLBtCoexist.bt_info.bt_ctrl_lps)
+		return _TRUE;
+
+	return _FALSE;
+}
+
+u8 hal_btcoex_IsLpsOn(PADAPTER padapter)
+{
+	if (GLBtCoexist.bdontenterLPS == _TRUE)
+		return _FALSE;
+	
+	if (hal_btcoex_IsBtExist(padapter) == _FALSE)
+		return _FALSE;
+
+	if (GLBtCoexist.bt_info.bt_disabled)
+		return _FALSE;
+
+	if (GLBtCoexist.bt_info.bt_lps_on)
+		return _TRUE;
+
+	return _FALSE;
+}
+
+u8 hal_btcoex_RpwmVal(PADAPTER padapter)
+{
+	return GLBtCoexist.bt_info.rpwm_val;
+}
+
+u8 hal_btcoex_LpsVal(PADAPTER padapter)
+{
+	return GLBtCoexist.bt_info.lps_val;
+}
+
+u32 hal_btcoex_GetRaMask(PADAPTER padapter)
+{
+	if (!hal_btcoex_IsBtExist(padapter))
+		return 0;
+
+	if (GLBtCoexist.bt_info.bt_disabled)
+		return 0;
+
+	/* Modify by YiWei , suggest by Cosa and Jenyu
+	 * Remove the limit antenna number , because 2 antenna case (ex: 8192eu)also want to get BT coex report rate mask.
+	 */
+	/*if (GLBtCoexist.board_info.btdm_ant_num != 1)
+		return 0;*/
+
+	return GLBtCoexist.bt_info.ra_mask;
+}
+
+void hal_btcoex_RecordPwrMode(PADAPTER padapter, u8 *pCmdBuf, u8 cmdLen)
+{
+
+	_rtw_memcpy(GLBtCoexist.pwrModeVal, pCmdBuf, cmdLen);
+}
+
+void hal_btcoex_DisplayBtCoexInfo(PADAPTER padapter, u8 *pbuf, u32 bufsize)
+{
+	PBTCDBGINFO pinfo;
+
+
+	pinfo = &GLBtcDbgInfo;
+	DBG_BT_INFO_INIT(pinfo, pbuf, bufsize);
+	EXhalbtcoutsrc_DisplayBtCoexInfo(&GLBtCoexist);
+	DBG_BT_INFO_INIT(pinfo, NULL, 0);
+}
+
+void hal_btcoex_SetDBG(PADAPTER padapter, u32 *pDbgModule)
+{
+	u32 i;
+
+
+	if (NULL == pDbgModule)
+		return;
+
+	printk("===> COMP_MAX=%d, module=%x\n", COMP_MAX, pDbgModule[0]);
+	for (i = 0; i < COMP_MAX; i++)
+		GLBtcDbgType[i] = pDbgModule[i];
+}
+
+u32 hal_btcoex_GetDBG(PADAPTER padapter, u8 *pStrBuf, u32 bufSize)
+{
+	s32 count;
+	u8 *pstr;
+	u32 leftSize;
+
+
+	if ((NULL == pStrBuf) || (0 == bufSize))
+		return 0;
+
+	count = 0;
+	pstr = pStrBuf;
+	leftSize = bufSize;
+//	DBG_871X(FUNC_ADPT_FMT ": bufsize=%d\n", FUNC_ADPT_ARG(padapter), bufSize);
+
+	count = snprintf(pstr, leftSize, "#define DBG\t%d\n", DBG);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+
+	count = snprintf(pstr, leftSize, "BTCOEX Debug Setting:\n");
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+
+	count = snprintf(pstr, leftSize,
+		"COMP_COEX: 0x%08X\n\n",
+		GLBtcDbgType[COMP_COEX]);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+
+#if 0
+	count = snprintf(pstr, leftSize, "INTERFACE Debug Setting Definition:\n");
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+	count = snprintf(pstr, leftSize, "\tbit[0]=%d for INTF_INIT\n",
+		GLBtcDbgType[BTC_MSG_INTERFACE]&INTF_INIT?1:0);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+	count = snprintf(pstr, leftSize, "\tbit[2]=%d for INTF_NOTIFY\n\n",
+		GLBtcDbgType[BTC_MSG_INTERFACE]&INTF_NOTIFY?1:0);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+	
+	count = snprintf(pstr, leftSize, "ALGORITHM Debug Setting Definition:\n");
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+	count = snprintf(pstr, leftSize, "\tbit[0]=%d for BT_RSSI_STATE\n",
+		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_BT_RSSI_STATE?1:0);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+	count = snprintf(pstr, leftSize, "\tbit[1]=%d for WIFI_RSSI_STATE\n",
+		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_WIFI_RSSI_STATE?1:0);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+	count = snprintf(pstr, leftSize, "\tbit[2]=%d for BT_MONITOR\n",
+		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_BT_MONITOR?1:0);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+	count = snprintf(pstr, leftSize, "\tbit[3]=%d for TRACE\n",
+		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE?1:0);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+	count = snprintf(pstr, leftSize, "\tbit[4]=%d for TRACE_FW\n",
+		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_FW?1:0);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+	count = snprintf(pstr, leftSize, "\tbit[5]=%d for TRACE_FW_DETAIL\n",
+		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_FW_DETAIL?1:0);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+	count = snprintf(pstr, leftSize, "\tbit[6]=%d for TRACE_FW_EXEC\n",
+		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_FW_EXEC?1:0);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+	count = snprintf(pstr, leftSize, "\tbit[7]=%d for TRACE_SW\n",
+		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_SW?1:0);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+	count = snprintf(pstr, leftSize, "\tbit[8]=%d for TRACE_SW_DETAIL\n",
+		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_SW_DETAIL?1:0);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+	count = snprintf(pstr, leftSize, "\tbit[9]=%d for TRACE_SW_EXEC\n",
+		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_SW_EXEC?1:0);
+	if ((count < 0) || (count >= leftSize))
+		goto exit;
+	pstr += count;
+	leftSize -= count;
+#endif
+
+exit:
+	count = pstr - pStrBuf;
+//	DBG_871X(FUNC_ADPT_FMT ": usedsize=%d\n", FUNC_ADPT_ARG(padapter), count);
+
+	return count;
+}
+
+u8 hal_btcoex_IncreaseScanDeviceNum(PADAPTER padapter)
+{
+	if (!hal_btcoex_IsBtExist(padapter))
+		return _FALSE;
+
+	if (GLBtCoexist.bt_info.increase_scan_dev_num)
+		return _TRUE;
+
+	return _FALSE;
+}
+
+u8 hal_btcoex_IsBtLinkExist(PADAPTER padapter)
+{
+	if (GLBtCoexist.bt_link_info.bt_link_exist)
+		return _TRUE;
+
+	return _FALSE;
+}
+
+void hal_btcoex_SetBtPatchVersion(PADAPTER padapter, u16 btHciVer, u16 btPatchVer)
+{
+	EXhalbtcoutsrc_SetBtPatchVersion(btHciVer, btPatchVer);
+}
+
+void hal_btcoex_SetHciVersion(PADAPTER padapter, u16 hciVersion)
+{
+	EXhalbtcoutsrc_SetHciVersion(hciVersion);
+}
+
+void hal_btcoex_StackUpdateProfileInfo(void)
+{
+	EXhalbtcoutsrc_StackUpdateProfileInfo();
+}
+
+void hal_btcoex_pta_off_on_notify(PADAPTER padapter, u8 bBTON)
+{
+	ex_halbtcoutsrc_pta_off_on_notify(&GLBtCoexist, bBTON);
+}
+
+/*
+ *	Description:
+ *	Setting BT coex antenna isolation type .
+ *	coex mechanisn/ spital stream/ best throughput
+ *	anttype = 0	,	PSTDMA	/	2SS	/	0.5T	,	bad isolation , WiFi/BT ANT Distance<15cm , (<20dB) for 2,3 antenna
+ *	anttype = 1	,	PSTDMA	/	1SS	/	0.5T	,	normal isolaiton , 50cm>WiFi/BT ANT Distance>15cm , (>20dB) for 2 antenna
+ *	anttype = 2	,	TDMA	/	2SS	/	T ,		normal isolaiton , 50cm>WiFi/BT ANT Distance>15cm , (>20dB) for 3 antenna
+ *	anttype = 3	,	no TDMA	/	1SS	/	0.5T	,	good isolation , WiFi/BT ANT Distance >50cm , (>40dB) for 2 antenna
+ *	anttype = 4	,	no TDMA	/	2SS	/	T ,		good isolation , WiFi/BT ANT Distance >50cm , (>40dB) for 3 antenna
+ *	wifi only throughput ~ T
+ *	wifi/BT share one antenna with SPDT
+ */
+void hal_btcoex_SetAntIsolationType(PADAPTER padapter, u8 anttype)
+{
+	//PHAL_DATA_TYPE pHalData;
+	PBTC_COEXIST	pBtCoexist = &GLBtCoexist;
+
+	/*DBG_871X("####%s , anttype = %d  , %d\n" , __func__ , anttype , __LINE__); */
+	//pHalData = GET_HAL_DATA(padapter);
+
+
+	//pHalData->bt_coexist.btAntisolation = anttype;
+	padapter->pshare->bt_coexist.btAntisolation = anttype;
+
+	//switch (pHalData->bt_coexist.btAntisolation) {
+	switch (padapter->pshare->bt_coexist.btAntisolation) {
+	case 0:
+		pBtCoexist->board_info.ant_type = (u1Byte)BTC_ANT_TYPE_0;
+		break;
+	case 1:
+		pBtCoexist->board_info.ant_type = (u1Byte)BTC_ANT_TYPE_1;
+		break;
+	case 2:
+		pBtCoexist->board_info.ant_type = (u1Byte)BTC_ANT_TYPE_2;
+		break;
+	case 3:
+		pBtCoexist->board_info.ant_type = (u1Byte)BTC_ANT_TYPE_3;
+		break;
+	case 4:
+		pBtCoexist->board_info.ant_type = (u1Byte)BTC_ANT_TYPE_4;
+		break;
+	}
+
+}
+
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+int
+hal_btcoex_ParseAntIsolationConfigFile(
+	PADAPTER		Adapter,
+	char			*buffer
+)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u32	i = 0 , j = 0;
+	char	*szLine , *ptmp;
+	int rtStatus = _SUCCESS;
+	char param_value_string[10];
+	u8 param_value;
+	u8 anttype = 4;
+
+	u8 ant_num = 3 , ant_distance = 50 , rfe_type = 1;
+
+	typedef struct ant_isolation {
+		char *param_name;  /* antenna isolation config parameter name */
+		u8 *value; /* antenna isolation config parameter value */
+	} ANT_ISOLATION;
+
+	ANT_ISOLATION ant_isolation_param[] = {
+		{"ANT_NUMBER" , &ant_num},
+		{"ANT_DISTANCE" , &ant_distance},
+		{"RFE_TYPE" , &rfe_type},
+		{NULL , 0}
+	};
+
+
+
+	/* RTW_INFO("===>Hal_ParseAntIsolationConfigFile()\n" ); */
+
+	ptmp = buffer;
+	for (szLine = GetLineFromBuffer(ptmp) ; szLine != NULL; szLine = GetLineFromBuffer(ptmp)) {
+		/* skip comment */
+		if (IsCommentString(szLine))
+			continue;
+
+		/* RTW_INFO("%s : szLine = %s , strlen(szLine) = %d\n" , __func__ , szLine , strlen(szLine));*/
+		for (j = 0 ; ant_isolation_param[j].param_name != NULL ; j++) {
+			if (strstr(szLine , ant_isolation_param[j].param_name) != NULL) {
+				i = 0;
+				while (i < strlen(szLine)) {
+					if (szLine[i] != '"')
+						++i;
+					else {
+						/* skip only has one " */
+						if (strpbrk(szLine , "\"") == strrchr(szLine , '"')) {
+							DBG_871X("Fail to parse parameters , format error!\n");
+							break;
+						}
+						_rtw_memset((PVOID)param_value_string , 0 , 10);
+						if (!ParseQualifiedString(szLine , &i , param_value_string , '"' , '"')) {
+							DBG_871X("Fail to parse parameters\n");
+							return _FAIL;
+						} else if (!GetU1ByteIntegerFromStringInDecimal(param_value_string , ant_isolation_param[j].value))
+							DBG_871X("Fail to GetU1ByteIntegerFromStringInDecimal\n");
+
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	/* YiWei 20140716 , for BT coex antenna isolation control */
+	/* rfe_type = 0 was SPDT , rfe_type = 1 was coupler */
+	if (ant_num == 3 && ant_distance >= 50)
+		anttype = 3;
+	else if (ant_num == 2 && ant_distance >= 50 && rfe_type == 1)
+		anttype = 2;
+	else if (ant_num == 3 && ant_distance >= 15 && ant_distance < 50)
+		anttype = 2;
+	else if (ant_num == 2 && ant_distance >= 15 && ant_distance < 50 && rfe_type == 1)
+		anttype = 2;
+	else if ((ant_num == 2 && ant_distance < 15 && rfe_type == 1) || (ant_num == 3 && ant_distance < 15))
+		anttype = 1;
+	else if (ant_num == 2 && rfe_type == 0)
+		anttype = 0;
+	else
+		anttype = 0;
+
+	hal_btcoex_SetAntIsolationType(Adapter, anttype);
+
+	DBG_871X("%s : ant_num = %d\n" , __func__ , ant_num);
+	DBG_871X("%s : ant_distance = %d\n" , __func__ , ant_distance);
+	DBG_871X("%s : rfe_type = %d\n" , __func__ , rfe_type);
+	/* RTW_INFO("<===Hal_ParseAntIsolationConfigFile()\n"); */
+	return rtStatus;
+}
+
+
+int
+hal_btcoex_AntIsolationConfig_ParaFile(
+	IN	PADAPTER	Adapter,
+	IN	char		*pFileName
+)
+{
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
+	int	rlen = 0 , rtStatus = _FAIL;
+
+	_rtw_memset(pHalData->para_file_buf , 0 , MAX_PARA_FILE_BUF_LEN);
+
+	rtw_get_phy_file_path(Adapter, pFileName);
+	if (rtw_is_file_readable(rtw_phy_para_file_path) == _TRUE) {
+		rlen = rtw_retrieve_from_file(rtw_phy_para_file_path, pHalData->para_file_buf, MAX_PARA_FILE_BUF_LEN);
+		if (rlen > 0)
+			rtStatus = _SUCCESS;
+	}
+
+
+	if (rtStatus == _SUCCESS) {
+		/*RTW_INFO("%s(): read %s ok\n", __func__ , pFileName);*/
+		rtStatus = hal_btcoex_ParseAntIsolationConfigFile(Adapter , pHalData->para_file_buf);
+	} else
+		RTW_INFO("%s(): No File %s, Load from *** Array!\n" , __func__ , pFileName);
+
+	return rtStatus;
+}
+#endif /* CONFIG_LOAD_PHY_PARA_FROM_FILE */
+
+u16 hal_btcoex_btreg_read(PADAPTER padapter, u8 type, u16 addr, u32 *data)
+{
+	u16 ret = 0;
+
+	halbtcoutsrc_LeaveLowPower(&GLBtCoexist);
+
+	ret = halbtcoutsrc_GetBtReg_with_status(&GLBtCoexist, type, addr, data);
+
+	halbtcoutsrc_NormalLowPower(&GLBtCoexist);
+
+	return ret;
+}
+
+u16 hal_btcoex_btreg_write(PADAPTER padapter, u8 type, u16 addr, u16 val)
+{
+	u16 ret = 0;
+
+	halbtcoutsrc_LeaveLowPower(&GLBtCoexist);
+
+	ret = halbtcoutsrc_SetBtReg(&GLBtCoexist, type, addr, val);
+
+	halbtcoutsrc_NormalLowPower(&GLBtCoexist);
+
+	return ret;
+}
+
+void hal_btcoex_set_rfe_type(u8 type)
+{
+	EXhalbtcoutsrc_set_rfe_type(type);
+}
+
+#ifdef CONFIG_RF4CE_COEXIST
+void hal_btcoex_set_rf4ce_link_state(u8 state)
+{
+	EXhalbtcoutsrc_set_rf4ce_link_state(state);
+}
+
+u8 hal_btcoex_get_rf4ce_link_state(void)
+{
+	return EXhalbtcoutsrc_get_rf4ce_link_state();
+}
+#endif /* CONFIG_RF4CE_COEXIST */
+
+void hal_btcoex_switchband_notify(u8 under_scan, u8 band_type)
+{
+#if 0
+	switch (band_type) {
+	case BAND_ON_2_4G:
+		if (under_scan)
+			EXhalbtcoutsrc_switchband_notify(&GLBtCoexist, BTC_SWITCH_TO_24G);
+		else
+			EXhalbtcoutsrc_switchband_notify(&GLBtCoexist, BTC_SWITCH_TO_24G_NOFORSCAN);
+		break;
+	case BAND_ON_5G:
+		EXhalbtcoutsrc_switchband_notify(&GLBtCoexist, BTC_SWITCH_TO_5G);
+		break;
+	default:
+		RTW_INFO("[BTCOEX] unkown switch band type\n");
+		break;
+	}
+#endif
+}
+
+u8 rtw_btcoex_get_bt_coexist(PADAPTER padapter)
+{
+	return 1;
+}
+
+u8 rtw_btcoex_get_chip_type(PADAPTER padapter)
+{
+	return BT_RTL8192E;
+}
+
+u8 rtw_btcoex_get_pg_ant_num(PADAPTER padapter)
+{
+	return 2;
+}
+
+u8 rtw_btcoex_get_pg_rfe_type(PADAPTER padapter)
+{
+	return padapter->pmib->dot11RFEntry.rfe_type;
+}
+
+u8 rtw_btcoex_is_tfbga_package_type(PADAPTER padapter)
+{
+	return _FALSE;
+}
+
+u8 rtw_btcoex_get_ant_div_cfg(PADAPTER padapter)
+{
+	return _FALSE; 
+}
+
+void rtw_btcoex_BtInfoNotify(PADAPTER padapter, u8 length, u8 *tmpBuf)
+{
+	u8 i;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[c2h] "));
+	for (i=0; i<length; i++)
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("%02x ", tmpBuf[i]));
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("\n"));
+
+	hal_btcoex_BtInfoNotify(padapter ,length, tmpBuf);
+}
+
+s32 rtw_hal_fill_h2c_cmd(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer)
+{
+	s32 ret = _FAIL;
+	u8 i;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[h2c] %02x: ", ElementID));
+	for (i=0; i<CmdLen; i++)
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("%02x ", pCmdBuffer[i]));
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("\n"));
+	ret = FillH2CCmd88XX(padapter, ElementID, CmdLen, pCmdBuffer);
+
+	return ret;
+}
+
+VOID
+FillFakeTxDescriptor_8192E(
+	IN PADAPTER	Adapter,
+	IN pu1Byte	pDesc,
+	IN u4Byte	BufferLen,
+	IN BOOLEAN	IsPsPoll,
+	IN BOOLEAN	IsBTQosNull,
+	IN BOOLEAN	bDataFrame
+)
+{
+	u1Byte	Rate;
+
+	// Clear all status
+	PlatformZeroMemory(pDesc, 40);
+	
+	SET_BITS_TO_LE_4BYTE(pDesc, 27, 1, 1); //bFirstSeg;
+	SET_BITS_TO_LE_4BYTE(pDesc, 26, 1, 1); //bLastSeg;
+	
+	SET_BITS_TO_LE_4BYTE(pDesc, 16, 8, 0x28); // Offset = 32
+	
+	SET_BITS_TO_LE_4BYTE(pDesc, 0, 16, BufferLen); // Buffer size + command header
+	SET_BITS_TO_LE_4BYTE(pDesc+4, 8, 5, 0x12); // Fixed queue of Mgnt queue
+
+	if(IsPsPoll)
+	{
+		SET_BITS_TO_LE_4BYTE(pDesc+12, 15, 1, 1);
+	}
+	else
+	{
+		SET_BITS_TO_LE_4BYTE(pDesc+32, 15, 1, 1); // Hw set sequence number
+	}
+	
+	if(IsBTQosNull)
+	{
+		SET_BITS_TO_LE_4BYTE(pDesc+8, 23, 1, 1);
+	}
+	
+	SET_BITS_TO_LE_4BYTE(pDesc+12, 8, 1, 1); // use data rate which is set by Sw
+	SET_BITS_TO_LE_4BYTE(pDesc, 31, 1, 1);
+
+	Rate = 0;
+	SET_BITS_TO_LE_4BYTE(pDesc+16, 0, 7, Rate);
+}
+
+#define BEACON_PAGE 2
+#define TOTAL_RSVD_PAGE 3
+#define PAGE_SIZE_TX_92E 256
+#define TXDESC_SIZE 40
+#define TOTAL_RSVD_PAGE_SIZE (BEACON_PAGE+TOTAL_RSVD_PAGE)*PAGE_SIZE_TX_92E
+
+void rtw_hal_set_fw_rsvd_page(PADAPTER priv)
+{
+	u8 page[TOTAL_RSVD_PAGE_SIZE]={0}, desc[TXDESC_SIZE], *pPage;
+	u8 reg8, i;
+	u8 CmdBuffer[5]={0,0,0,0,0};
+	int len;
+	u8 cur_page_num = BEACON_PAGE;
+	u16 page_size = PAGE_SIZE_TX_92E;
+
+	RTL_W8(0x101, RTL_R8(0x101)|BIT0);
+	RTL_W8(0x20a, RTL_R8(0x20a)&~BIT0);
+
+	// BT QoS Null Data
+	pPage = &page[cur_page_num*page_size];
+	SetPwrMgt(pPage);
+	SetToDs(pPage);
+	memcpy((void *)GetAddr1Ptr(pPage), BSSID, MACADDRLEN);
+	memcpy((void *)GetAddr2Ptr(pPage), GET_MY_HWADDR, MACADDRLEN);
+	memcpy((void *)GetAddr3Ptr(pPage), BSSID, MACADDRLEN);
+	SetFrameSubType(pPage, BIT(7) | WIFI_DATA_NULL);
+	len = WLAN_HDR_A3_QOS_LEN;
+	FillFakeTxDescriptor_8192E(priv, pPage-TXDESC_SIZE, len, FALSE, TRUE, FALSE);
+	CmdBuffer[4] = cur_page_num;
+	cur_page_num += 1;
+
+	// Null Data
+	pPage = &page[cur_page_num*page_size];
+	SetPwrMgt(pPage);
+	SetToDs(pPage);
+	memcpy((void *)GetAddr1Ptr(pPage), BSSID, MACADDRLEN);
+	memcpy((void *)GetAddr2Ptr(pPage), GET_MY_HWADDR, MACADDRLEN);
+	memcpy((void *)GetAddr3Ptr(pPage), BSSID, MACADDRLEN);
+	SetFrameSubType(pPage, WIFI_DATA_NULL);
+	len = WLAN_HDR_A3_LEN;
+	FillFakeTxDescriptor_8192E(priv, pPage-TXDESC_SIZE, len, FALSE, TRUE, FALSE);
+	CmdBuffer[2] = cur_page_num;
+	cur_page_num += 1;
+
+	// QoS Null Data
+	pPage = &page[cur_page_num*page_size];
+	SetPwrMgt(pPage);
+	SetToDs(pPage);
+	memcpy((void *)GetAddr1Ptr(pPage), BSSID, MACADDRLEN);
+	memcpy((void *)GetAddr2Ptr(pPage), GET_MY_HWADDR, MACADDRLEN);
+	memcpy((void *)GetAddr3Ptr(pPage), BSSID, MACADDRLEN);
+	SetFrameSubType(pPage, BIT(7) | WIFI_DATA_NULL);
+	len = WLAN_HDR_A3_QOS_LEN;
+	FillFakeTxDescriptor_8192E(priv, pPage-TXDESC_SIZE, len, FALSE, TRUE, FALSE);
+	CmdBuffer[3] = cur_page_num;
+	cur_page_num += 1;
+
+	FillBeaconDesc88XX(priv, desc, (void*)page, TOTAL_RSVD_PAGE_SIZE-TXDESC_SIZE, 1);
+	SigninBeaconTXBD88XX(priv, page, TOTAL_RSVD_PAGE_SIZE-TXDESC_SIZE);
+	DownloadRsvdPage88XX(priv, page, TOTAL_RSVD_PAGE_SIZE-TXDESC_SIZE, 0);
+	
+	for (i=0; i<20; i++)
+	{
+		reg8 = RTL_R8(0x383);
+		if (!(reg8 & BIT4))
+			break;
+		delay_us(10);
+	}	
+	RTL_W8(0x383, reg8|BIT4);
+	for (i=0; i<20; i++)
+	{
+		reg8 = RTL_R8(0x20a);
+		if (reg8 & BIT0)
+			break;
+		delay_us(50);
+	}
+	rtw_hal_fill_h2c_cmd(priv, 0, sizeof(CmdBuffer), CmdBuffer);
+
+	RTL_W8(0x101, RTL_R8(0x101)&~BIT0);
+}
+
+void rtw_btcoex_LPS_Enter(PADAPTER padapter)
+{
+	u8 CmdBuffer[7]={0x01,0x20,0x02,0x00,0x04,0x50,0x00};
+	//CmdBuffer[4] = hal_btcoex_RpwmVal(padapter);
+	//CmdBuffer[5] = hal_btcoex_LpsVal(padapter);
+	rtw_hal_fill_h2c_cmd(padapter, 0x20, sizeof(CmdBuffer), CmdBuffer);
+	hal_btcoex_RecordPwrMode(padapter, CmdBuffer, sizeof(CmdBuffer));
+	GLBtcWiFiInLPS = PS_MODE_MIN;
+}
+
+void rtw_btcoex_LPS_Leave(PADAPTER padapter)
+{
+	u8 CmdBuffer[7]={0x00,0x20,0x02,0x00,0x0c,0x40,0x00};
+	//CmdBuffer[4] = hal_btcoex_RpwmVal(padapter);
+	//CmdBuffer[5] = hal_btcoex_LpsVal(padapter);
+	rtw_hal_fill_h2c_cmd(padapter, 0x20, sizeof(CmdBuffer), CmdBuffer);
+	hal_btcoex_RecordPwrMode(padapter, CmdBuffer, sizeof(CmdBuffer));
+	GLBtcWiFiInLPS = PS_MODE_ACTIVE;
+}
+
+#undef PADAPTER
+#undef GET_HAL_DATA
+#endif /* CONFIG_BT_COEXIST */
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/hal_btcoex.h
@@ -0,0 +1,188 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_BTCOEX_H__
+#define __HAL_BTCOEX_H__
+
+//#include <drv_types.h>
+#include "8192cd_headers.h"
+
+#define DBG_871X
+#define RTW_DBG(x,...) do {} while (0)
+#define RTW_INFO(x,...) do {} while (0)
+#define RTW_WARN(x,...) do {} while (0)
+#define RTW_ERR(x, ...) do {} while (0)
+
+#define rtw_read8		RTL_R8_F
+#define rtw_read16		RTL_R16_F
+#define rtw_read32		RTL_R32_F
+#define rtw_write8		RTL_W8_F
+#define rtw_write16		RTL_W16_F
+#define rtw_write32		RTL_W32_F
+
+typedef	enum _BT_CoType{
+	BT_2WIRE		= 0,		
+	BT_ISSC_3WIRE	= 1,
+	BT_ACCEL		= 2,
+	BT_CSR_BC4		= 3,
+	BT_CSR_BC8		= 4,
+	BT_RTL8756		= 5,
+	BT_RTL8723A		= 6,
+	BT_RTL8821		= 7,
+	BT_RTL8723B		= 8,
+	BT_RTL8192E		= 9,
+	BT_RTL8814A		= 10,
+	BT_RTL8812A		= 11
+} BT_CoType, *PBT_CoType;
+
+struct btinfo {
+	u8 cid;
+	u8 len;
+
+	u8 bConnection:1;
+	u8 bSCOeSCO:1;
+	u8 bInQPage:1;
+	u8 bACLBusy:1;
+	u8 bSCOBusy:1;
+	u8 bHID:1;
+	u8 bA2DP:1;
+	u8 bFTP:1;
+
+	u8 retry_cnt:4;
+	u8 rsvd_34:1;
+	u8 rsvd_35:1;
+	u8 rsvd_36:1;
+	u8 rsvd_37:1;
+
+	u8 rssi;
+
+	u8 rsvd_50:1;
+	u8 rsvd_51:1;
+	u8 rsvd_52:1;
+	u8 rsvd_53:1;
+	u8 rsvd_54:1;
+	u8 rsvd_55:1;
+	u8 eSCO_SCO:1;
+	u8 Master_Slave:1;
+
+	u8 rsvd_6;
+	u8 rsvd_7;
+};
+
+#define	PACKET_NORMAL			0
+#define	PACKET_DHCP				1
+#define	PACKET_ARP				2
+#define	PACKET_EAPOL			3
+
+#define _FAIL		0
+#define _SUCCESS	1
+
+/* Some variables can't get from outsrc BT-Coex,
+ * so we need to save here */
+/*typedef struct _BT_COEXIST {
+	u8 bBtExist;
+	u8 btTotalAntNum;
+	u8 btChipType;
+	u8 bInitlized;
+	u8 btAntisolation;
+} BT_COEXIST, *PBT_COEXIST;*/
+
+enum Power_Mgnt
+{
+	PS_MODE_ACTIVE	= 0	,
+	PS_MODE_MIN			,
+};
+
+#define PADAPTER PRTL8192CD_PRIV
+void DBG_BT_INFO(u8 *dbgmsg);
+
+void hal_btcoex_SetBTCoexist(PADAPTER padapter, u8 bBtExist);
+u8 hal_btcoex_IsBtExist(PADAPTER padapter);
+u8 hal_btcoex_IsBtDisabled(PADAPTER);
+void hal_btcoex_SetChipType(PADAPTER padapter, u8 chipType);
+void hal_btcoex_SetPgAntNum(PADAPTER padapter, u8 antNum);
+
+u8 hal_btcoex_Initialize(PADAPTER padapter);
+void hal_btcoex_PowerOnSetting(PADAPTER padapter);
+void hal_btcoex_PreLoadFirmware(PADAPTER padapter);
+void hal_btcoex_InitHwConfig(PADAPTER padapter, u8 bWifiOnly);
+
+void hal_btcoex_IpsNotify(PADAPTER padapter, u8 type);
+void hal_btcoex_LpsNotify(PADAPTER padapter, u8 type);
+void hal_btcoex_ScanNotify(PADAPTER padapter, u8 type);
+void hal_btcoex_ConnectNotify(PADAPTER padapter, u8 action);
+void hal_btcoex_MediaStatusNotify(PADAPTER padapter, u8 mediaStatus);
+void hal_btcoex_SpecialPacketNotify(PADAPTER padapter, u8 pktType);
+void hal_btcoex_IQKNotify(PADAPTER padapter, u8 state);
+void hal_btcoex_BtInfoNotify(PADAPTER padapter, u8 length, u8 *tmpBuf);
+void hal_btcoex_BtMpRptNotify(PADAPTER padapter, u8 length, u8 *tmpBuf);
+void hal_btcoex_SuspendNotify(PADAPTER padapter, u8 state);
+void hal_btcoex_HaltNotify(PADAPTER padapter, u8 do_halt);
+void hal_btcoex_SwitchBtTRxMask(PADAPTER padapter);
+
+void hal_btcoex_Hanlder(PADAPTER padapter);
+
+s32 hal_btcoex_IsBTCoexRejectAMPDU(PADAPTER padapter);
+s32 hal_btcoex_IsBTCoexCtrlAMPDUSize(PADAPTER padapter);
+u32 hal_btcoex_GetAMPDUSize(PADAPTER padapter);
+void hal_btcoex_SetManualControl(PADAPTER padapter, u8 bmanual);
+u8 hal_btcoex_1Ant(PADAPTER padapter);
+u8 hal_btcoex_IsBtControlLps(PADAPTER);
+u8 hal_btcoex_IsLpsOn(PADAPTER);
+u8 hal_btcoex_RpwmVal(PADAPTER);
+u8 hal_btcoex_LpsVal(PADAPTER);
+u32 hal_btcoex_GetRaMask(PADAPTER);
+void hal_btcoex_RecordPwrMode(PADAPTER padapter, u8 *pCmdBuf, u8 cmdLen);
+void hal_btcoex_DisplayBtCoexInfo(PADAPTER, u8 *pbuf, u32 bufsize);
+void hal_btcoex_SetDBG(PADAPTER, u32 *pDbgModule);
+u32 hal_btcoex_GetDBG(PADAPTER, u8 *pStrBuf, u32 bufSize);
+u8 hal_btcoex_IncreaseScanDeviceNum(PADAPTER);
+u8 hal_btcoex_IsBtLinkExist(PADAPTER);
+void hal_btcoex_SetBtPatchVersion(PADAPTER, u16 btHciVer, u16 btPatchVer);
+void hal_btcoex_SetHciVersion(PADAPTER, u16 hciVersion);
+void hal_btcoex_SendScanNotify(PADAPTER, u8 type);
+void hal_btcoex_StackUpdateProfileInfo(void);
+void hal_btcoex_pta_off_on_notify(PADAPTER padapter, u8 bBTON);
+void hal_btcoex_SetAntIsolationType(PADAPTER padapter, u8 anttype);
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+	int hal_btcoex_AntIsolationConfig_ParaFile(IN PADAPTER	Adapter, IN char *pFileName);
+	int hal_btcoex_ParseAntIsolationConfigFile(PADAPTER Adapter, char	*buffer);
+#endif /* CONFIG_LOAD_PHY_PARA_FROM_FILE */
+u16 hal_btcoex_btreg_read(PADAPTER padapter, u8 type, u16 addr, u32 *data);
+u16 hal_btcoex_btreg_write(PADAPTER padapter, u8 type, u16 addr, u16 val);
+void hal_btcoex_set_rfe_type(u8 type);
+void hal_btcoex_switchband_notify(u8 under_scan, u8 band_type);
+
+#ifdef CONFIG_RF4CE_COEXIST
+void hal_btcoex_set_rf4ce_link_state(u8 state);
+u8 hal_btcoex_get_rf4ce_link_state(void);
+#endif
+u8 rtw_btcoex_get_bt_coexist(PADAPTER padapter);
+u8 rtw_btcoex_get_chip_type(PADAPTER padapter);
+u8 rtw_btcoex_get_pg_ant_num(PADAPTER padapter);
+u8 rtw_btcoex_get_pg_rfe_type(PADAPTER padapter);
+u8 rtw_btcoex_is_tfbga_package_type(PADAPTER padapter);
+u8 rtw_btcoex_get_ant_div_cfg(PADAPTER padapter);
+void rtw_btcoex_BtInfoNotify(PADAPTER padapter, u8 length, u8 *tmpBuf);
+s32 rtw_hal_fill_h2c_cmd(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+void rtw_hal_set_fw_rsvd_page(PADAPTER priv);
+void rtw_btcoex_LPS_Enter(PADAPTER padapter);
+void rtw_btcoex_LPS_Leave(PADAPTER padapter);
+#undef PADAPTER
+#endif /* !__HAL_BTCOEX_H__ */
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8192e1ant.c
@@ -0,0 +1,3417 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8192E Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8192E_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8192e_1ant		glcoex_dm_8192e_1ant;
+static struct  coex_dm_8192e_1ant	*coex_dm = &glcoex_dm_8192e_1ant;
+static struct  coex_sta_8192e_1ant		glcoex_sta_8192e_1ant;
+static struct  coex_sta_8192e_1ant	*coex_sta = &glcoex_sta_8192e_1ant;
+
+const char *const glbt_info_src_8192e_1ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8192e_1ant = 20140527;
+u32	glcoex_ver_8192e_1ant = 0x4f;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8192e1ant_
+ * ************************************************************ */
+u8 halbtc8192e1ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8192e1ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8192e1ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8192e1ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8192e1ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8192e1ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8192e1ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8192e1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8192e1ant_update_ra_mask(btcoexist, force_exec,
+					       0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8192e1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8192e1ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8192e1ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8192e1ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8192e1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8192e1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+void halbtc8192e1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u8		num_of_bt_counter_chk = 0;
+
+	/* to avoid 0x76e[3] = 1 (WLAN_Act control by PTA) during IPS */
+	/* if (! (btcoexist->btc_read_1byte(btcoexist, 0x76e) & 0x8) ) */
+
+	if (coex_sta->under_ips) {
+		coex_sta->high_priority_tx = 65535;
+		coex_sta->high_priority_rx = 65535;
+		coex_sta->low_priority_tx = 65535;
+		coex_sta->low_priority_rx = 65535;
+		return;
+	}
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if ((coex_sta->low_priority_tx >= 1050)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Hi-Pri Rx/Tx: %d/%d, Lo-Pri Rx/Tx: %d/%d\n",
+		    reg_hp_rx, reg_hp_tx, reg_lp_rx, reg_lp_tx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	if ((reg_hp_tx == 0) && (reg_hp_rx == 0) && (reg_lp_tx == 0) &&
+	    (reg_lp_rx == 0)) {
+		num_of_bt_counter_chk++;
+		if (num_of_bt_counter_chk >= 3) {
+			halbtc8192e1ant_query_bt_info(btcoexist);
+			num_of_bt_counter_chk = 0;
+		}
+	}
+}
+
+
+void halbtc8192e1ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+	s32	wifi_rssi = 0;
+	boolean wifi_busy = false, wifi_under_b_mode = false;
+	static u8 cck_lock_counter = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+			   &wifi_under_b_mode);
+
+	if (coex_sta->under_ips) {
+		coex_sta->crc_ok_cck = 0;
+		coex_sta->crc_ok_11g = 0;
+		coex_sta->crc_ok_11n = 0;
+		coex_sta->crc_ok_11n_agg = 0;
+
+		coex_sta->crc_err_cck = 0;
+		coex_sta->crc_err_11g = 0;
+		coex_sta->crc_err_11n = 0;
+		coex_sta->crc_err_11n_agg = 0;
+	} else {
+		coex_sta->crc_ok_cck	= btcoexist->btc_read_4byte(btcoexist,
+					  0xf88);
+		coex_sta->crc_ok_11g	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf94);
+		coex_sta->crc_ok_11n	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf90);
+		coex_sta->crc_ok_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					   0xfb8);
+
+		coex_sta->crc_err_cck	 = btcoexist->btc_read_4byte(btcoexist,
+					   0xf84);
+		coex_sta->crc_err_11g	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf96);
+		coex_sta->crc_err_11n	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf92);
+		coex_sta->crc_err_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					    0xfba);
+	}
+
+
+	/* reset counter */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xf16, 0x1, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xf16, 0x1, 0x0);
+
+	if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+		if ((coex_dm->bt_status == BT_8192E_1ANT_BT_STATUS_ACL_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8192E_1ANT_BT_STATUS_SCO_BUSY)) {
+			if (coex_sta->crc_ok_cck > (coex_sta->crc_ok_11g +
+						    coex_sta->crc_ok_11n +
+						    coex_sta->crc_ok_11n_agg)) {
+				if (cck_lock_counter < 5)
+					cck_lock_counter++;
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+	} else {
+		if (cck_lock_counter > 0)
+			cck_lock_counter--;
+	}
+
+	if (!coex_sta->pre_ccklock) {
+
+		if (cck_lock_counter >= 5)
+			coex_sta->cck_lock = true;
+		else
+			coex_sta->cck_lock = false;
+	} else {
+		if (cck_lock_counter == 0)
+			coex_sta->cck_lock = false;
+		else
+			coex_sta->cck_lock = true;
+	}
+
+	coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+
+}
+
+boolean halbtc8192e1ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void halbtc8192e1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8192e1ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8192E_1ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Profile = SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8192E_1ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_1ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_1ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8192E_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_1ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8192E_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! BT Profile = SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8192e1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8192e1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8192e1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8192e1ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf7;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf8;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf9;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8192e1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8192e1ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8192e1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8192e1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8192e1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8192e1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** CoexTable(%d) **********\n", type);
+	BTC_TRACE(trace_buf);
+
+	coex_sta->coex_table_type = type;
+
+	switch (type) {
+	case 0:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaa5a5a, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0xaa5a5a5a, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8192e1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable)
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8192e1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8192e1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8192e1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8192e1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8192e1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8192e1ant_sw_mechanism(IN struct btc_coexist *btcoexist,
+				  IN boolean low_penalty_ra)
+{
+	halbtc8192e1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+
+void halbtc8192e1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean init_hwcfg, IN boolean wifi_off)
+{
+	u32			u32tmp = 0;
+
+	if (init_hwcfg) {
+		btcoexist->btc_write_1byte(btcoexist, 0x944, 0x24);
+		btcoexist->btc_write_4byte(btcoexist, 0x930, 0x700700);
+		if (btcoexist->chip_interface == BTC_INTF_USB)
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30430004);
+		else
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30030004);
+
+		/* 0x4c[27][24]='00', Set Antenna to BB */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(24);
+		u32tmp &= ~BIT(27);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+	} else if (wifi_off) {
+		if (btcoexist->chip_interface == BTC_INTF_USB)
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30430004);
+		else
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30030004);
+
+		/* 0x4c[27][24]='11', Set Antenna to BT, 0x64[8:7]=0, 0x64[2]=1 */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp |= BIT(24);
+		u32tmp |= BIT(27);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+	}
+
+	/* ext switch setting */
+	switch (ant_pos_type) {
+	case BTC_ANT_PATH_WIFI:
+		btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x4);
+		break;
+	case BTC_ANT_PATH_BT:
+		btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x20);
+		break;
+	default:
+	case BTC_ANT_PATH_PTA:
+		btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x4);
+		break;
+	}
+}
+
+void halbtc8192e1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for 1Ant AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+		}
+	}
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+
+void halbtc8192e1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_busy = false;
+	u8			rssi_adjust_val = 0;
+	u8			ps_tdma_byte4_val = 0x50, ps_tdma_byte0_val = 0x51,
+				ps_tdma_byte3_val =  0x10;
+	s8			wifi_duration_adjust = 0x0;
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (coex_sta->scan_ap_num <= 5)
+		wifi_duration_adjust = 5;
+	else if (coex_sta->scan_ap_num >= 40)
+		wifi_duration_adjust = -15;
+	else if (coex_sta->scan_ap_num >= 20)
+		wifi_duration_adjust = -10;
+
+	if (!coex_sta->force_lps_on) { /* only for A2DP-only case 1/2/9/11 while wifi noisy threshold > 30 */
+		ps_tdma_byte0_val = 0x61;  /* no null-pkt */
+		ps_tdma_byte3_val = 0x11; /* no tx-pause at BT-slot */
+		ps_tdma_byte4_val = 0x10; /* 0x778 = d/1 toggle */
+	}
+
+	if ((type == 3) || (type == 13) || (type == 14))
+		ps_tdma_byte4_val = ps_tdma_byte4_val &
+			    0xbf;  /* no dynamic slot for multi-profile */
+
+	if (bt_link_info->slave_role == true)
+		ps_tdma_byte4_val = ps_tdma_byte4_val |
+			0x1;  /* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+
+	if (turn_on) {
+		switch (type) {
+		default:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x1a, 0x1a, 0x0, ps_tdma_byte4_val);
+			break;
+		case 1:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x3a +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 2:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x2d +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 3:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x1d, 0x1d, 0x0, ps_tdma_byte4_val);
+			break;
+		case 4:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x14, 0x0);
+			break;
+		case 5:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x15, 0x3, 0x11, 0x11);
+			break;
+		case 6:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x20, 0x3, 0x11, 0x11);
+			break;
+		case 7:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xc, 0x5, 0x0, 0x0);
+			break;
+		case 8:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 9:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 10:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0xa, 0x0, 0x40);
+			break;
+		case 11:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 12:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x0a, 0x0a, 0x0, 0x50);
+			break;
+		case 13:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x12, 0x12, 0x0, ps_tdma_byte4_val);
+			break;
+		case 14:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x21, 0x3, 0x10, ps_tdma_byte4_val);
+			break;
+		case 15:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0x3, 0x8, 0x0);
+			break;
+		case 16:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x10, 0x0);
+			break;
+		case 18:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 20:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x3f, 0x03, 0x11, 0x10);
+			break;
+		case 21:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x11);
+			break;
+		case 22:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x10);
+			break;
+		case 23:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x18);
+			break;
+		case 24:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x3, 0x31, 0x18);
+			break;
+		case 25:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 26:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 27:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x98);
+			break;
+		case 28:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x69,
+						      0x25, 0x3, 0x31, 0x0);
+			break;
+		case 29:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xab,
+						      0x1a, 0x1a, 0x1, 0x10);
+			break;
+		case 30:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x10);
+			break;
+		case 31:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1a, 0x1a, 0, 0x58);
+			break;
+		case 32:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x3, 0x11, 0x11);
+			break;
+		case 33:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x25, 0x3, 0x30, 0x90);
+			break;
+		case 34:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 35:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x63,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 36:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x12, 0x3, 0x14, 0x50);
+			break;
+		case 40: /* SoftAP only with no sta associated,BT disable ,TDMA mode for power saving */
+			/* here softap mode screen off will cost 70-80mA for phone */
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x23,
+						      0x18, 0x00, 0x10, 0x24);
+			break;
+		}
+	} else {
+
+		/* disable PS tdma */
+		switch (type) {
+		case 8: /* PTA Control */
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			halbtc8192e1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_PTA, false, false);
+			break;
+		case 0:
+		default:  /* Software control, Antenna at BT side */
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			halbtc8192e1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_BT, false, false);
+			break;
+		case 9:   /* Software control, Antenna at WiFi side */
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			halbtc8192e1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_WIFI, false, false);
+			break;
+		}
+	}
+	rssi_adjust_val = 0;
+	btcoexist->btc_set(btcoexist,
+		BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE, &rssi_adjust_val);
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x\n",
+		    btcoexist->btc_read_4byte(btcoexist, 0x948),
+		    btcoexist->btc_read_1byte(btcoexist, 0x765),
+		    btcoexist->btc_read_1byte(btcoexist, 0x67));
+	BTC_TRACE(trace_buf);
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8192e1ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* sw all off */
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+
+	/* hw all off */
+	halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+boolean halbtc8192e1ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected &&
+	    BT_8192E_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		/* halbtc8192e1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8192E_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		/* halbtc8192e1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (!wifi_connected &&
+		(BT_8192E_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		/* halbtc8192e1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (wifi_connected &&
+		(BT_8192E_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		/* halbtc8192e1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (!wifi_connected &&
+		(BT_8192E_1ANT_BT_STATUS_CONNECTED_IDLE != coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non connected-idle + BT Busy!!\n");
+		BTC_TRACE(trace_buf);
+		/* halbtc8192e1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else {
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		common = false;
+	}
+
+	return common;
+}
+
+
+void halbtc8192e1ant_tdma_duration_adjust_for_acl(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0, bt_info_ext;
+	boolean			wifi_busy = false;
+	/*static boolean	pre_wifi_busy = false;*/
+
+	if (BT_8192E_1ANT_WIFI_STATUS_CONNECTED_BUSY == wifi_status)
+		wifi_busy = true;
+	else
+		wifi_busy = false;
+
+	if ((BT_8192E_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN ==
+	     wifi_status) ||
+	    (BT_8192E_1ANT_WIFI_STATUS_CONNECTED_SCAN == wifi_status) ||
+	    (BT_8192E_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT ==
+	     wifi_status)) {
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 3 &&
+		    coex_dm->cur_ps_tdma != 9) {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						9);
+			coex_dm->ps_tdma_du_adj_type = 9;
+
+			up = 0;
+			dn = 0;
+			m = 1;
+			n = 3;
+			result = 0;
+			wait_count = 0;
+		}
+		return;
+	}
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 2);
+		coex_dm->ps_tdma_du_adj_type = 2;
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* acquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		bt_info_ext = coex_sta->bt_info_ext;
+
+		if ((coex_sta->low_priority_tx) > 1050 ||
+		    (coex_sta->low_priority_rx) > 1250)
+			retry_count++;
+
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if retry count during continuous n*2 seconds is 0, enlarge WiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if continuous 2 retry count(every 2 seconds) >0 and < 3, reduce WiFi duration */
+				if (wait_count <= 2)
+					m++; /* to avoid loop between the two levels */
+				else
+					m = 1;
+
+				if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, once retry count > 3, to reduce WiFi duration */
+			if (wait_count == 1)
+				m++; /* to avoid loop between the two levels */
+			else
+				m = 1;
+
+			if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (result == -1) {
+			if ((BT_INFO_8192E_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+			    ((coex_dm->cur_ps_tdma == 1) ||
+			     (coex_dm->cur_ps_tdma == 2))) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 1) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 11);
+				coex_dm->ps_tdma_du_adj_type = 11;
+			}
+		} else if (result == 1) {
+			if ((BT_INFO_8192E_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+			    ((coex_dm->cur_ps_tdma == 1) ||
+			     (coex_dm->cur_ps_tdma == 2))) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 11) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 1);
+				coex_dm->ps_tdma_du_adj_type = 1;
+			}
+		} else { /* no change */
+			/* Bryant Modify
+			if(wifi_busy != pre_wifi_busy)
+			{
+				pre_wifi_busy = wifi_busy;
+				halbtc8192e1ant_ps_tdma(btcoexist, FORCE_EXEC, true, coex_dm->cur_ps_tdma);
+			}
+			*/
+		}
+
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 9 &&
+		    coex_dm->cur_ps_tdma != 11) {
+			/* recover to previous adjust type */
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		}
+	}
+}
+
+void halbtc8192e1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8192e1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8192e1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8192e1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8192e1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8192e1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 9);
+}
+
+void halbtc8192e1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e1ant_action_wifi_only(btcoexist);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		if (!bt_disabled) {
+		} else {
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+					   NULL);
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+					   NULL);
+		}
+	}
+}
+
+/* *********************************************
+ *
+ *	Software Coex Mechanism start
+ *
+ * ********************************************* */
+
+/* SCO only or SCO+PAN(HS) */
+
+/*
+void halbtc8192e1ant_action_sco(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8192e1ant_action_hid(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8192e1ant_action_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8192e1ant_action_a2dp_pan_hs(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8192e1ant_action_pan_edr(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+}
+
+
+void halbtc8192e1ant_action_pan_hs(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+}
+
+
+void halbtc8192e1ant_action_pan_edr_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8192e1ant_action_pan_edr_hid(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8192e1ant_action_hid_a2dp_pan_edr(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, true);
+}
+
+void halbtc8192e1ant_action_hid_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, true);
+}
+
+*/
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+void halbtc8192e1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8192e1ant_action_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8192e1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_connected = false, ap_enable = false, wifi_busy = false,
+				bt_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	if ((!wifi_connected) && (!coex_sta->wifi_is_high_pri_task)) {
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+		   (bt_link_info->a2dp_exist)) {
+		/* SCO/HID/A2DP  busy */
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if ((bt_link_info->pan_exist) || (wifi_busy)) {
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	}
+}
+
+void halbtc8192e1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	/* tdma and coex table */
+
+	if (bt_link_info->sco_exist) {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	} else { /* HID */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 6);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	}
+}
+
+void halbtc8192e1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	u8		bt_rssi_state;
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	bt_rssi_state = halbtc8192e1ant_bt_rssi_state(2, 28, 0);
+
+	if ((coex_sta->low_priority_rx >= 1000)  &&
+	    (coex_sta->low_priority_rx != 65535))
+		bt_link_info->slave_role = true;
+	else
+		bt_link_info->slave_role = false;
+
+	if (bt_link_info->hid_only) { /* HID */
+		halbtc8192e1ant_action_bt_sco_hid_only_busy(btcoexist,
+				wifi_status);
+		coex_dm->auto_tdma_adjust = false;
+		return;
+	} else if (bt_link_info->a2dp_only) { /* A2DP		 */
+		if (BT_8192E_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifi_status) {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = false;
+		} else {
+			halbtc8192e1ant_tdma_duration_adjust_for_acl(btcoexist,
+					wifi_status);
+#if 0
+			if (coex_sta->cck_lock)
+				halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 3);
+			else
+#endif
+				halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = true;
+		}
+	} else if (((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	} else if (bt_link_info->hid_exist &&
+		   bt_link_info->a2dp_exist) { /* HID+A2DP */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+		coex_dm->auto_tdma_adjust = false;
+
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	} else if ((bt_link_info->pan_only) || (bt_link_info->hid_exist &&
+		bt_link_info->pan_exist)) { /* PAN(OPP,FTP), HID+PAN(OPP,FTP)			 */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		/* BT no-profile busy (0x9) */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	}
+}
+
+void halbtc8192e1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	/* power save state */
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	halbtc8192e1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8192e1ant_action_wifi_not_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if (BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8192E_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8192e1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8192E_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8192e1ant_action_wifi_not_connected_asso_auth(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist)  || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8192e1ant_action_wifi_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if (BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8192E_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8192e1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8192E_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8192e1ant_action_wifi_connected_specific_packet(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8192e1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	boolean	wifi_busy = false;
+	boolean		scan = false, link = false, roam = false;
+	boolean		under_4way = false, ap_enable = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+	if (under_4way) {
+		halbtc8192e1ant_action_wifi_connected_specific_packet(btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under 4way<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	if (scan || link || roam) {
+		if (scan)
+			halbtc8192e1ant_action_wifi_connected_scan(btcoexist);
+		else
+			halbtc8192e1ant_action_wifi_connected_specific_packet(
+				btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under scan<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	/* power save state */
+	if (!ap_enable &&
+	    BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status &&
+	    !btcoexist->bt_link_info.hid_only) {
+		if (btcoexist->bt_link_info.a2dp_only) {	/* A2DP */
+			if (!wifi_busy)
+				halbtc8192e1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			else { /* busy */
+				if (coex_sta->scan_ap_num >=
+				    BT_8192E_1ANT_WIFI_NOISY_THRESH)  /* no force LPS, no PS-TDMA, use pure TDMA */
+					halbtc8192e1ant_power_save_state(
+						btcoexist, BTC_PS_WIFI_NATIVE,
+						0x0, 0x0);
+				else
+					halbtc8192e1ant_power_save_state(
+						btcoexist, BTC_PS_LPS_ON, 0x50,
+						0x4);
+			}
+		} else if ((coex_sta->pan_exist == false) &&
+			   (coex_sta->a2dp_exist == false) &&
+			   (coex_sta->hid_exist == false))
+			halbtc8192e1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		else
+			halbtc8192e1ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+	} else
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+
+	/* tdma and coex table */
+	if (!wifi_busy) {
+		if (BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8192e1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8192E_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else if ((BT_8192E_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8192e1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8192E_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+
+			if ((coex_sta->high_priority_tx) +
+			    (coex_sta->high_priority_rx) <= 60)
+				halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+			else
+				halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		}
+	} else {
+		if (BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8192e1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8192E_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else if ((BT_8192E_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8192e1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8192E_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+
+			if ((coex_sta->high_priority_tx) +
+			    (coex_sta->high_priority_rx) <= 60)
+				halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+			else
+				halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		}
+	}
+}
+
+void halbtc8192e1ant_run_sw_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8				algorithm = 0;
+
+	algorithm = halbtc8192e1ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+
+	if (halbtc8192e1ant_is_common_action(btcoexist)) {
+
+	} else {
+		switch (coex_dm->cur_algorithm) {
+		case BT_8192E_1ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_sco(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_hid(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_a2dp(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_a2dp_pan_hs(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_pan_edr(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_pan_hs(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_pan_edr_a2dp(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_pan_edr_hid(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_hid_a2dp_pan_edr(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_hid_a2dp(btcoexist); */
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_coex_all_off(btcoexist); */
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8192e1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, bt_hs_on = false;
+	boolean	increase_scan_dev_num = false;
+	boolean	bt_ctrl_agg_buf_size = false;
+	boolean	miracast_plus_bt = false;
+	u8	agg_buf_size = 5;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if ((BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8192E_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+			   &increase_scan_dev_num);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist) {
+			halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1,
+						   0, 1);
+			miracast_plus_bt = true;
+		} else {
+			halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0,
+						   0, 0);
+			miracast_plus_bt = false;
+		}
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+		halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+
+		if ((bt_link_info->a2dp_exist) &&
+		    (coex_sta->c2h_bt_inquiry_page)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is Inquirying\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e1ant_action_bt_inquiry(btcoexist);
+		} else
+			halbtc8192e1ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	}
+
+	miracast_plus_bt = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+			   &miracast_plus_bt);
+
+	if ((bt_link_info->bt_link_exist) && (wifi_connected)) {
+		halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1, 0, 1);
+
+		if (bt_link_info->sco_exist)
+			halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, true, 0x5);
+		else
+			halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, true, 0x8);
+
+		halbtc8192e1ant_sw_mechanism(btcoexist, true);
+		halbtc8192e1ant_run_sw_coexist_mechanism(
+			btcoexist);  /* just print debug message */
+	} else {
+		halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+		halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x5);
+
+		halbtc8192e1ant_sw_mechanism(btcoexist, false);
+		halbtc8192e1ant_run_sw_coexist_mechanism(
+			btcoexist); /* just print debug message */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "############# [BTCoex],  BT Is Inquirying\n");
+		BTC_TRACE(trace_buf);
+		halbtc8192e1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8192e1ant_action_hs(btcoexist);
+		return;
+	}
+
+
+	if (!wifi_connected) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is non connected-idle !!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (scan || link || roam) {
+			if (scan)
+				halbtc8192e1ant_action_wifi_not_connected_scan(
+					btcoexist);
+			else
+				halbtc8192e1ant_action_wifi_not_connected_asso_auth(
+					btcoexist);
+		} else
+			halbtc8192e1ant_action_wifi_not_connected(btcoexist);
+	} else	/* wifi LPS/Busy */
+		halbtc8192e1ant_action_wifi_connected(btcoexist);
+}
+
+void halbtc8192e1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+
+	/* sw all off */
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+
+	/* halbtc8192e1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8); */
+	halbtc8192e1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	coex_sta->pop_event_cnt = 0;
+}
+
+void halbtc8192e1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean wifi_only)
+{
+	u16	u16tmp = 0;
+	u8	u8tmp = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	/* antenna sw ctrl to bt */
+	halbtc8192e1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, true, false);
+
+	halbtc8192e1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	/* antenna switch control parameter */
+	btcoexist->btc_write_4byte(btcoexist, 0x858, 0x55555555);
+
+	/* coex parameters */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	/* enable PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x40, 0x20);
+	/* enable mailbox interface */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x40);
+	u16tmp |= BIT(9);
+	btcoexist->btc_write_2byte(btcoexist, 0x40, u16tmp);
+
+	/* enable PTA I2C mailbox */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x101);
+	u8tmp |= BIT(4);
+	btcoexist->btc_write_1byte(btcoexist, 0x101, u8tmp);
+
+	/* enable bt clock when wifi is disabled. */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x93);
+	u8tmp |= BIT(0);
+	btcoexist->btc_write_1byte(btcoexist, 0x93, u8tmp);
+	/* enable bt clock when suspend. */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x7);
+	u8tmp |= BIT(0);
+	btcoexist->btc_write_1byte(btcoexist, 0x7, u8tmp);
+}
+
+
+/*
+void halbtc8192e1ant_wifi_off_hw_cfg(IN struct btc_coexist* btcoexist)
+{
+
+
+}
+*/
+
+/* ************************************************************
+ * work around function start with wa_halbtc8192e1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8192e1ant_
+ * ************************************************************ */
+void ex_halbtc8192e1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+#if 0
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x0;
+	u16 u16tmp = 0x0;
+
+	btcoexist->stop_coex_dm = true;
+
+	btcoexist->btc_write_1byte(btcoexist, 0x67, 0x20);
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write 0x948 correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+	/* set GRAN_BT = 1 */
+	btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+	/* set WLAN_ACT = 0 */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	/*  */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+	if (btcoexist->chip_interface == BTC_INTF_USB) {
+		/* fixed at S0 for USB interface */
+		btcoexist->btc_write_4byte(btcoexist, 0x948, 0x0);
+
+		u8tmp |= 0x1;	/* antenna inverse */
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+	} else {
+		/* for PCIE and SDIO interface, we check efuse 0xc3[6] */
+		if (board_info->single_ant_path == 0) {
+			/* set to S1 */
+			btcoexist->btc_write_4byte(btcoexist, 0x948, 0x280);
+			board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+		} else if (board_info->single_ant_path == 1) {
+			/* set to S0 */
+			btcoexist->btc_write_4byte(btcoexist, 0x948, 0x0);
+			u8tmp |= 0x1;	/* antenna inverse */
+			board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+		}
+
+		if (btcoexist->chip_interface == BTC_INTF_PCI)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x384,
+							     u8tmp);
+		else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60,
+							     u8tmp);
+	}
+#endif
+}
+
+void ex_halbtc8192e1ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8192e1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8192e1ant_init_hw_config(btcoexist, wifi_only);
+	btcoexist->stop_coex_dm = false;
+}
+
+void ex_halbtc8192e1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = false;
+
+	halbtc8192e1ant_init_coex_dm(btcoexist);
+
+	halbtc8192e1ant_query_bt_info(btcoexist);
+}
+
+void ex_halbtc8192e1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u32				u32tmp[4];
+	u32				fw_ver = 0, bt_patch_ver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%d/ 0x%x/ 0x%x(%d)",
+		   "CoexVer/ FwVer/ PatchVer",
+		   glcoex_ver_date_8192e_1ant, glcoex_ver_8192e_1ant, fw_ver,
+		   bt_patch_ver, bt_patch_ver);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8192E_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8192E_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_BT_LINK_INFO);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8192E_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8192e_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	if (!btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[mechanisms]============");
+		CL_PRINTF(cli_buf);
+
+		ps_tdma_case = coex_dm->cur_ps_tdma;
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n %-35s = %02x %02x %02x %02x %02x case-%d (auto:%d)",
+			   "PS TDMA",
+			   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+			   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+			   coex_dm->ps_tdma_para[4], ps_tdma_case,
+			   coex_dm->auto_tdma_adjust);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ",
+			   "Latest error condition(should be 0)",
+			   coex_dm->error_condition);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ",
+			   "IgnWlanAct",
+			   coex_dm->cur_ignore_wlan_act);
+		CL_PRINTF(cli_buf);
+	}
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc04);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xd04);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x90c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0xc04/ 0xd04/ 0x90c",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x778",
+		   u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x92c);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x930);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x92c/ 0x930",
+		   (u8tmp[0]), u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x4f);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x40/ 0x4f",
+		   u8tmp[0], u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)",
+		   u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(hp rx[31:16]/tx[15:0])",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(lp rx[31:16]/tx[15:0])",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8192E_1ANT == 1)
+	halbtc8192e1ant_monitor_bt_ctr(btcoexist);
+#endif
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+void ex_halbtc8192e1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8192e1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false,
+					     true);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+
+		halbtc8192e1ant_init_hw_config(btcoexist, false);
+		halbtc8192e1ant_init_coex_dm(btcoexist);
+		halbtc8192e1ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8192e1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8192e1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	u8 u8tmpa, u8tmpb;
+	u32 u32tmp;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_SCAN_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8192e1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+		u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+		u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x\n",
+			    u32tmp,  u8tmpa, u8tmpb);
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+	}
+
+	if (coex_sta->bt_disabled)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	halbtc8192e1ant_query_bt_info(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8192e1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8192e1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8192e1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_SCAN_START == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8192e1ant_action_wifi_not_connected_scan(
+				btcoexist);
+		else	/* wifi is connected */
+			halbtc8192e1ant_action_wifi_connected_scan(btcoexist);
+	} else if (BTC_SCAN_FINISH == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8192e1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8192e1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8192e1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	boolean	wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_ASSOCIATE_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		/* coex_dm->arp_cnt = 0; */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8192e1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8192e1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8192e1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_ASSOCIATE_START == type)
+		halbtc8192e1ant_action_wifi_not_connected_asso_auth(btcoexist);
+	else if (BTC_ASSOCIATE_FINISH == type) {
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+				   &wifi_connected);
+		if (!wifi_connected) /* non-connected scan */
+			halbtc8192e1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8192e1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8192e1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	boolean			wifi_under_b_mode = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x10); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		/* h2c_parameter[0] = 0x1; */
+		h2c_parameter[0] = 0x0;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+}
+
+void ex_halbtc8192e1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    BTC_PACKET_ARP == type) {
+		if (BTC_PACKET_ARP == type) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], specific Packet ARP notify\n");
+			BTC_TRACE(trace_buf);
+
+			coex_dm->arp_cnt++;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], ARP Packet Count = %d\n",
+				    coex_dm->arp_cnt);
+			BTC_TRACE(trace_buf);
+
+			if (coex_dm->arp_cnt >=
+			    10) /* if APR PKT > 10 after connect, do not go to ActionWifiConnectedSpecificPacket(btcoexist) */
+				coex_sta->wifi_is_high_pri_task = false;
+			else
+				coex_sta->wifi_is_high_pri_task = true;
+		} else {
+			coex_sta->wifi_is_high_pri_task = true;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], specific Packet DHCP or EAPOL notify\n");
+			BTC_TRACE(trace_buf);
+		}
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet [Type = %d] notify\n", type);
+		BTC_TRACE(trace_buf);
+	}
+
+	coex_sta->specific_pkt_period_cnt = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8192e1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8192e1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8192e1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    ((BTC_PACKET_ARP == type) && (coex_sta->wifi_is_high_pri_task)))
+		halbtc8192e1ant_action_wifi_connected_specific_packet(btcoexist);
+}
+
+void ex_halbtc8192e1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8				bt_info = 0;
+	u8				i, rsp_source = 0;
+	boolean				wifi_connected = false;
+	boolean				bt_busy = false;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8192E_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8192E_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	if (BT_INFO_SRC_8192E_1ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->bt_info_c2h[rsp_source][2] & 0x20)
+			coex_sta->c2h_bt_page = true;
+		else
+			coex_sta->c2h_bt_page = false;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 - 90;
+		/* coex_sta->bt_info_c2h[rsp_source][3]*2+10; */
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+		if (!coex_sta->bt_tx_rx_mask) {
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x15\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+						  0x3c, 0x15);
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if (coex_sta->bt_info_ext & BIT(1)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8192e1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8192e1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if (coex_sta->bt_info_ext & BIT(3)) {
+			if (!btcoexist->manual_control &&
+			    !btcoexist->stop_coex_dm) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8192e1ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			}
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+		}
+#if (BT_AUTO_REPORT_ONLY_8192E_1ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8192e1ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8192E_1ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8192E_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8192E_1ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8192E_1ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8192E_1ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8192E_1ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+	}
+
+	halbtc8192e1ant_update_bt_link_info(btcoexist);
+
+	bt_info = bt_info &
+		0x1f;  /* mask profile bit for connect-ilde identification ( for CSR case: A2DP idle --> 0x41) */
+
+	if (!(bt_info & BT_INFO_8192E_1ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8192E_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8192E_1ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8192E_1ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8192E_1ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8192E_1ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8192E_1ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8192E_1ANT_B_ACL_BUSY) {
+		if (BT_8192E_1ANT_BT_STATUS_ACL_BUSY != coex_dm->bt_status)
+			coex_dm->auto_tdma_adjust = false;
+		coex_dm->bt_status = BT_8192E_1ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8192E_1ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8192E_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	halbtc8192e1ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8192e1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u32	u32tmp;
+	u8	u8tmpa, u8tmpb, u8tmpc;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+	} else if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+		halbtc8192e1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false,
+					     true);
+
+		halbtc8192e1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		btcoexist->stop_coex_dm = true;
+
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+		u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+		u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x67);
+		u8tmpc = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x, 0x76e=0x%x\n",
+			    u32tmp,  u8tmpa, u8tmpb, u8tmpc);
+		BTC_TRACE(trace_buf);
+
+	}
+}
+
+void ex_halbtc8192e1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8192e1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+	halbtc8192e1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false, true);
+
+	halbtc8192e1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8192e1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	btcoexist->stop_coex_dm = true;
+}
+
+void ex_halbtc8192e1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+		halbtc8192e1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false,
+					     true);
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+		btcoexist->stop_coex_dm = true;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+		halbtc8192e1ant_init_hw_config(btcoexist, false);
+		halbtc8192e1ant_init_coex_dm(btcoexist);
+		halbtc8192e1ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8192e1ant_coex_dm_reset(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], *****************Coex DM Reset*****************\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8192e1ant_init_hw_config(btcoexist, false);
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); */
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x2, 0xfffff, 0x0); */
+	halbtc8192e1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8192e1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+#if (BT_AUTO_REPORT_ONLY_8192E_1ANT == 0)
+	halbtc8192e1ant_query_bt_info(btcoexist);
+	halbtc8192e1ant_monitor_bt_enable_disable(btcoexist);
+#else
+	halbtc8192e1ant_monitor_bt_ctr(btcoexist);
+	halbtc8192e1ant_monitor_wifi_ctr(btcoexist);
+
+	if (halbtc8192e1ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust)
+
+		halbtc8192e1ant_run_coexist_mechanism(btcoexist);
+
+	coex_sta->specific_pkt_period_cnt++;
+#endif
+}
+
+
+void ex_halbtc8192e1ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata)
+{
+	switch (op_code) {
+	case BTC_DBG_SET_COEX_NORMAL:
+		btcoexist->manual_control = false;
+		halbtc8192e1ant_init_coex_dm(btcoexist);
+		break;
+	case BTC_DBG_SET_COEX_WIFI_ONLY:
+		btcoexist->manual_control = true;
+		halbtc8192e1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+					9);
+		break;
+	case BTC_DBG_SET_COEX_BT_ONLY:
+		/* todo */
+		break;
+	default:
+		break;
+	}
+}
+
+#endif	/*  #if (RTL8192E_SUPPORT == 1) */
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8192e1ant.h
@@ -0,0 +1,226 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8192E_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8192E 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8192E_1ANT				1
+
+#define	BT_INFO_8192E_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8192E_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8192E_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8192E_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8192E_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8192E_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8192E_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8192E_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8192E_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+		(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT		2
+
+#define  BT_8192E_1ANT_WIFI_NOISY_THRESH								30   /* max: 255 */
+
+enum bt_info_src_8192e_1ant {
+	BT_INFO_SRC_8192E_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8192E_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8192E_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8192E_1ANT_MAX
+};
+
+enum bt_8192e_1ant_bt_status {
+	BT_8192E_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8192E_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8192E_1ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8192E_1ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8192E_1ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8192E_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8192e_1ant_wifi_status {
+	BT_8192E_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8192E_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8192E_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8192E_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT				= 0x3,
+	BT_8192E_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8192E_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8192E_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8192e_1ant_coex_algo {
+	BT_8192E_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8192E_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8192E_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8192E_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8192E_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8192E_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8192E_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8192E_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8192E_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8192E_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8192E_1ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8192E_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8192e_1ant {
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8192e_1ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	s8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8192E_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8192E_1ANT_MAX];
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_page;				/* Add for win8.1 page out issue */
+	boolean					wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_agg;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_agg;
+
+	boolean					cck_lock;
+	boolean					pre_ccklock;
+	u8					coex_table_type;
+
+	boolean					force_lps_on;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8192e1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8192e1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8192e1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8192e1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8192e1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8192e1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8192e1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8192e1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8192e1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8192e1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8192e1ant_coex_dm_reset(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata);
+
+#else	/*  #if (RTL8192E_SUPPORT == 1) */
+#define	ex_halbtc8192e1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8192e1ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8192e1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8192e1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8192e1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8192e1ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_halt_notify(btcoexist)
+#define	ex_halbtc8192e1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8192e1ant_coex_dm_reset(btcoexist)
+#define	ex_halbtc8192e1ant_periodical(btcoexist)
+#define	ex_halbtc8192e1ant_display_coex_info(btcoexist)
+#define	ex_halbtc8192e1ant_dbg_control(btcoexist, op_code, op_len, pdata)
+
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8192e2ant.c
@@ -0,0 +1,4271 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8192E Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8192E_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8192e_2ant		glcoex_dm_8192e_2ant;
+static struct  coex_dm_8192e_2ant	*coex_dm = &glcoex_dm_8192e_2ant;
+static struct  coex_sta_8192e_2ant		glcoex_sta_8192e_2ant;
+static struct  coex_sta_8192e_2ant	*coex_sta = &glcoex_sta_8192e_2ant;
+
+const char *const glbt_info_src_8192e_2ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+/* ************************************************************
+ * BtCoex Version Format:
+ * 1. date :			glcoex_ver_date_XXXXX_1ant
+ * 2. WifiCoexVersion : glcoex_ver_XXXX_1ant
+ * 3. BtCoexVersion :	glcoex_ver_btdesired_XXXXX_1ant
+ * 4. others :			glcoex_ver_XXXXXX_XXXXX_1ant
+ *
+ * Variable should be indicated IC and Antenna numbers !!!
+ * Please strictly follow this order and naming style !!!
+ *
+ * ************************************************************ */
+u32	glcoex_ver_date_8192e_2ant = 20170113;
+u32	glcoex_ver_8192e_2ant = 0x46;
+u32	glcoex_ver_btdesired_8192e_2ant = 0x04;
+/*1.fix miracast issue*/
+/*2.update BT FW for power on latch issue*/
+/*3. move the function of polling BT version to ex_halbtc8192e2ant_display_coex_info*/
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8192e2ant_
+ * ************************************************************ */
+u8 halbtc8192e2ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8192e2ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+u32 halbtc8192e2ant_decide_ra_mask(IN struct btc_coexist *btcoexist,
+				   IN u8 ss_type, IN u32 ra_mask_type)
+{
+	u32	dis_ra_mask = 0x0;
+
+	switch (ra_mask_type) {
+	case 0: /* normal mode */
+		if (ss_type == 2)
+			dis_ra_mask = 0x0;			/* enable 2ss */
+		else
+			dis_ra_mask = 0xfff00000;		/* disable 2ss */
+		break;
+	case 1: /* disable cck 1/2 */
+		if (ss_type == 2)
+			dis_ra_mask = 0x00000003;		/* enable 2ss */
+		else
+			dis_ra_mask = 0xfff00003;		/* disable 2ss */
+		break;
+	case 2: /* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		if (ss_type == 2)
+			dis_ra_mask = 0x0001f1f7;		/* enable 2ss */
+		else
+			dis_ra_mask = 0xfff1f1f7;		/* disable 2ss */
+		break;
+	default:
+		break;
+	}
+
+	return dis_ra_mask;
+}
+
+void halbtc8192e2ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8192e2ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8192e2ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8192e2ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8192e2ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	u32	dis_ra_mask = 0x0;
+
+	coex_dm->cur_ra_mask_type = ra_mask_type;
+	dis_ra_mask = halbtc8192e2ant_decide_ra_mask(btcoexist,
+			coex_dm->cur_ss_type, ra_mask_type);
+	halbtc8192e2ant_update_ra_mask(btcoexist, force_exec, dis_ra_mask);
+
+	halbtc8192e2ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8192e2ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8192e2ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8192e2ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8192e2ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_hp_txrx, reg_hp_tx, reg_hp_tx, reg_hp_rx, reg_hp_rx);
+	BTC_TRACE(trace_buf);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_lp_txrx, reg_lp_tx, reg_lp_tx, reg_lp_rx, reg_lp_rx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+}
+
+
+void halbtc8192e2ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+#if 1
+
+	coex_sta->crc_ok_cck =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_OK_CCK);
+	coex_sta->crc_ok_11g =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_OK_LEGACY);
+	coex_sta->crc_ok_11n =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_OK_HT);
+	coex_sta->crc_ok_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_OK_VHT);
+
+	coex_sta->crc_err_cck =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_ERROR_CCK);
+	coex_sta->crc_err_11g =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_ERROR_LEGACY);
+	coex_sta->crc_err_11n =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_ERROR_HT);
+	coex_sta->crc_err_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_ERROR_VHT);
+#endif
+}
+
+
+
+void halbtc8192e2ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex],Query BT info!!!! H2C 0x61 = 0x1\n");
+	BTC_TRACE(trace_buf);
+}
+
+boolean halbtc8192e2ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean	wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean	wifi_connected = false;
+	u8	wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+
+		wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0,
+				  2, 34, 0);
+
+		if ((BTC_RSSI_STATE_HIGH == wifi_rssi_state) ||
+		    (BTC_RSSI_STATE_LOW == wifi_rssi_state))
+			return true;
+	}
+
+	return false;
+}
+
+void halbtc8192e2ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8192e2ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	struct  btc_stack_info	*stack_info = &btcoexist->stack_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8192E_2ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_2ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_SCO_PAN;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (stack_info->num_of_hid >= 2) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID*2 + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8192E_2ANT_COEX_ALGO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_SCO_PAN;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8192e2ant_set_fw_dac_swing_level(IN struct btc_coexist *btcoexist,
+		IN u8 dac_swing_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	/* There are several type of dacswing */
+	/* 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6 */
+	h2c_parameter[0] = dac_swing_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
+}
+
+void halbtc8192e2ant_set_fw_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				       IN u8 dec_bt_pwr_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = dec_bt_pwr_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x62, 1, h2c_parameter);
+}
+
+void halbtc8192e2ant_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN u8 dec_bt_pwr_lvl)
+{
+	coex_dm->cur_bt_dec_pwr_lvl = dec_bt_pwr_lvl;
+
+	if (!force_exec) {
+#if 0	/* work around, avoid h2c command fail. */
+		if (coex_dm->pre_bt_dec_pwr_lvl == coex_dm->cur_bt_dec_pwr_lvl)
+			return;
+#endif
+	}
+	halbtc8192e2ant_set_fw_dec_bt_pwr(btcoexist,
+					  coex_dm->cur_bt_dec_pwr_lvl);
+
+	coex_dm->pre_bt_dec_pwr_lvl = coex_dm->cur_bt_dec_pwr_lvl;
+}
+
+void halbtc8192e2ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8192e2ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8192e2ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8192e2ant_fw_dac_swing_lvl(IN struct btc_coexist *btcoexist,
+			      IN boolean force_exec, IN u8 fw_dac_swing_lvl)
+{
+	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swing_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_fw_dac_swing_lvl ==
+		    coex_dm->cur_fw_dac_swing_lvl)
+			return;
+	}
+
+	halbtc8192e2ant_set_fw_dac_swing_level(btcoexist,
+					       coex_dm->cur_fw_dac_swing_lvl);
+
+	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
+}
+
+void halbtc8192e2ant_set_sw_rf_rx_lpf_corner(IN struct btc_coexist *btcoexist,
+		IN boolean rx_rf_shrink_on)
+{
+	if (rx_rf_shrink_on) {
+		/* Shrink RF Rx LPF corner */
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Shrink RF Rx LPF corner!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e, 0xfffff,
+					  0xffffc);
+	} else {
+		/* Resume RF Rx LPF corner */
+		/* After initialized, we can use coex_dm->bt_rf_0x1e_backup */
+		if (btcoexist->initilized) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Resume RF Rx LPF corner!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+					  0xfffff, coex_dm->bt_rf_0x1e_backup);
+		}
+	}
+}
+
+void halbtc8192e2ant_rf_shrink(IN struct btc_coexist *btcoexist,
+		       IN boolean force_exec, IN boolean rx_rf_shrink_on)
+{
+	coex_dm->cur_rf_rx_lpf_shrink = rx_rf_shrink_on;
+
+	if (!force_exec) {
+		if (coex_dm->pre_rf_rx_lpf_shrink ==
+		    coex_dm->cur_rf_rx_lpf_shrink)
+			return;
+	}
+	halbtc8192e2ant_set_sw_rf_rx_lpf_corner(btcoexist,
+						coex_dm->cur_rf_rx_lpf_shrink);
+
+	coex_dm->pre_rf_rx_lpf_shrink = coex_dm->cur_rf_rx_lpf_shrink;
+}
+
+void halbtc8192e2ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf7;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf8;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf9;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8192e2ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8192e2ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8192e2ant_set_dac_swing_reg(IN struct btc_coexist *btcoexist,
+				       IN u32 level)
+{
+	u8	val = (u8)level;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Write SwDacSwing = 0x%x\n", level);
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x883, 0x3e, val);
+}
+
+void halbtc8192e2ant_set_sw_full_time_dac_swing(IN struct btc_coexist
+		*btcoexist, IN boolean sw_dac_swing_on, IN u32 sw_dac_swing_lvl)
+{
+	if (sw_dac_swing_on)
+		halbtc8192e2ant_set_dac_swing_reg(btcoexist, sw_dac_swing_lvl);
+	else
+		halbtc8192e2ant_set_dac_swing_reg(btcoexist, 0x18);
+}
+
+
+void halbtc8192e2ant_dac_swing(IN struct btc_coexist *btcoexist,
+	IN boolean force_exec, IN boolean dac_swing_on, IN u32 dac_swing_lvl)
+{
+	coex_dm->cur_dac_swing_on = dac_swing_on;
+	coex_dm->cur_dac_swing_lvl = dac_swing_lvl;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_dac_swing_on == coex_dm->cur_dac_swing_on) &&
+		    (coex_dm->pre_dac_swing_lvl ==
+		     coex_dm->cur_dac_swing_lvl))
+			return;
+	}
+	delay_ms(30);
+	halbtc8192e2ant_set_sw_full_time_dac_swing(btcoexist, dac_swing_on,
+			dac_swing_lvl);
+
+	coex_dm->pre_dac_swing_on = coex_dm->cur_dac_swing_on;
+	coex_dm->pre_dac_swing_lvl = coex_dm->cur_dac_swing_lvl;
+}
+
+void halbtc8192e2ant_set_adc_back_off(IN struct btc_coexist *btcoexist,
+				      IN boolean adc_back_off)
+{
+	if (adc_back_off) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc05, 0x30, 0x3);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc05, 0x30, 0x1);
+	}
+}
+
+void halbtc8192e2ant_adc_back_off(IN struct btc_coexist *btcoexist,
+			  IN boolean force_exec, IN boolean adc_back_off)
+{
+	coex_dm->cur_adc_back_off = adc_back_off;
+
+	if (!force_exec) {
+		if (coex_dm->pre_adc_back_off == coex_dm->cur_adc_back_off)
+			return;
+	}
+	halbtc8192e2ant_set_adc_back_off(btcoexist, coex_dm->cur_adc_back_off);
+
+	coex_dm->pre_adc_back_off = coex_dm->cur_adc_back_off;
+}
+
+void halbtc8192e2ant_set_agc_table(IN struct btc_coexist *btcoexist,
+				   IN boolean agc_table_en)
+{
+	/* =================BB AGC Gain Table */
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x0a1A0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x091B0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x081C0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x071D0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x061E0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x051F0001);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xaa1A0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa91B0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa81C0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa71D0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa61E0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa51F0001);
+	}
+}
+
+void halbtc8192e2ant_agc_table(IN struct btc_coexist *btcoexist,
+			       IN boolean force_exec, IN boolean agc_table_en)
+{
+	coex_dm->cur_agc_table_en = agc_table_en;
+
+	if (!force_exec) {
+		if (coex_dm->pre_agc_table_en == coex_dm->cur_agc_table_en)
+			return;
+	}
+	halbtc8192e2ant_set_agc_table(btcoexist, agc_table_en);
+
+	coex_dm->pre_agc_table_en = coex_dm->cur_agc_table_en;
+}
+
+void halbtc8192e2ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8192e2ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8192e2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8192e2ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	switch (type) {
+	case 0:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0x55555555,
+					   0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0x5a5a5a5a,
+					   0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0x55dd55dd,
+					   0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0x5fdf5fdf,
+					   0x5fdb5fdb, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0xdfffdfff,
+					   0x5ffb5ffb, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0x5ddd5ddd,
+					   0x5fdb5fdb, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0x5fff5fff,
+					   0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 7:
+		if (coex_sta->scan_ap_num <= NOISY_AP_NUM_THRESH_8192E)
+			halbtc8192e2ant_coex_table(btcoexist, force_exec,  0xffffffff, 0xfafafafa, 0xffffff, 0x3);
+		else
+			halbtc8192e2ant_coex_table(btcoexist, force_exec, 0xffffffff, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 8:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0x5f5f5f5f, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 9:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0x55555555, 0xfafafafa, 0xffffff, 0x3);
+		break;
+	case 10:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0x55555555, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 11:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0x55555555, 0xfafafafa, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8192e2ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable)
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8192e2ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8192e2ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8192e2ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8192e2ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8192e2ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8192e2ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0x8, 0, 0, 0, 0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			/*halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);*/
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			/*halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);*/
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+
+void halbtc8192e2ant_power_save_state(IN struct btc_coexist *btcoexist,
+		      IN u8 ps_type,  IN u8 lps_val,  IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+	boolean		bApEnable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE, &bApEnable);
+	if (bApEnable) {
+		ps_type = BTC_PS_WIFI_NATIVE;
+		lps_val = 0x0;
+		rpwm_val = 0x0;
+	}
+	/*for 8192e, NO 32k*/
+	low_pwr_disable = true;
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		coex_sta->force_lps_on = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS, NULL);
+		break;
+	case BTC_PS_LPS_ON:
+		coex_sta->force_lps_on = true;
+		halbtc8192e2ant_ps_tdma_check_for_power_save_state(btcoexist, true);
+		halbtc8192e2ant_lps_rpwm(btcoexist, NORMAL_EXEC, lps_val, rpwm_val);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &low_pwr_disable);
+		/* power save must executed before psTdma. */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS, NULL);
+		break;
+	case BTC_PS_LPS_OFF:
+		coex_sta->force_lps_on = false;
+		halbtc8192e2ant_ps_tdma_check_for_power_save_state(btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS, NULL);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8192e2ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean		ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if ((ap_enable) && (byte1 & BIT(4) && !(byte1 & BIT(5)))) {
+		real_byte1 &= ~BIT(4);
+		real_byte1 |= BIT(5);
+
+		real_byte5 |= BIT(5);
+		real_byte5 &= ~BIT(6);
+		halbtc8192e2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+	} else if ((byte1 & BIT(4)) && (!(byte1 & BIT(5))))
+		halbtc8192e2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50, 0x4);
+	else
+		halbtc8192e2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8192e2ant_sw_mechanism1(IN struct btc_coexist *btcoexist,
+			   IN boolean shrink_rx_lpf, IN boolean low_penalty_ra,
+			   IN boolean limited_dig, IN boolean bt_lna_constrain)
+{
+	/*
+	u32	wifi_bw;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if(BTC_WIFI_BW_HT40 != wifi_bw)
+	{
+		if (shrink_rx_lpf)
+			shrink_rx_lpf = false;
+	}
+	*/
+
+	halbtc8192e2ant_rf_shrink(btcoexist, NORMAL_EXEC, shrink_rx_lpf);
+	/* halbtc8192e2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra); */
+}
+
+void halbtc8192e2ant_sw_mechanism2(IN struct btc_coexist *btcoexist,
+			   IN boolean agc_table_shift, IN boolean adc_back_off,
+			   IN boolean sw_dac_swing, IN u32 dac_swing_lvl)
+{
+	halbtc8192e2ant_agc_table(btcoexist, NORMAL_EXEC, agc_table_shift);
+	/* halbtc8192e2ant_adc_back_off(btcoexist, NORMAL_EXEC, adc_back_off); */
+	halbtc8192e2ant_dac_swing(btcoexist, NORMAL_EXEC, sw_dac_swing,
+				  dac_swing_lvl);
+}
+
+void halbtc8192e2ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean init_hwcfg, IN boolean wifi_off)
+{
+	u32			u32tmp = 0;
+
+#ifdef BTCOEX_DISABLE_ANT_CTRL
+	return;
+#endif
+
+	if (init_hwcfg) {
+		btcoexist->btc_write_1byte(btcoexist, 0x944, 0x24);
+		btcoexist->btc_write_4byte(btcoexist, 0x930, 0x700700);
+		if (btcoexist->chip_interface == BTC_INTF_USB)
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30430004);
+		else
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30030004);
+
+		/* 0x4c[27][24]='00', Set Antenna to BB */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(24);
+		u32tmp &= ~BIT(27);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+	} else if (wifi_off) {
+		if (btcoexist->chip_interface == BTC_INTF_USB)
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30430004);
+		else
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30030004);
+
+		/* 0x4c[27][24]='11', Set Antenna to BT, 0x64[8:7]=0, 0x64[2]=1 */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp |= BIT(24);
+		u32tmp |= BIT(27);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+	}
+
+	/* ext switch setting */
+	switch (ant_pos_type) {
+	case BTC_ANT_PATH_WIFI:
+		btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x4);
+		break;
+	case BTC_ANT_PATH_BT:
+		btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x20);
+		break;
+	default:
+	case BTC_ANT_PATH_PTA:
+		btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x4);
+		break;
+	}
+}
+
+void halbtc8192e2ant_set_switch_ss_type(IN struct btc_coexist *btcoexist,
+					IN u8 ss_type)
+{
+	u8	mimo_ps = BTC_MIMO_PS_DYNAMIC;
+	u32	dis_ra_mask = 0x0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], REAL set SS Type = %d\n", ss_type);
+	BTC_TRACE(trace_buf);
+
+	dis_ra_mask = halbtc8192e2ant_decide_ra_mask(btcoexist, ss_type,
+			coex_dm->cur_ra_mask_type);
+	halbtc8192e2ant_update_ra_mask(btcoexist, FORCE_EXEC, dis_ra_mask);
+
+	if (ss_type == 1) {
+		/*halbtc8192e2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 1);*/
+		/* switch ofdm path */
+		btcoexist->btc_write_1byte(btcoexist, 0xc04, 0x11);
+		btcoexist->btc_write_1byte(btcoexist, 0xd04, 0x1);
+		btcoexist->btc_write_4byte(btcoexist, 0x90c, 0x81111111);
+		/* switch cck patch */
+		/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0xe77, 0x4, 0x1); */
+		/* btcoexist->btc_write_1byte(btcoexist, 0xa07, 0x81); */
+		mimo_ps = BTC_MIMO_PS_STATIC;
+	} else if (ss_type == 2) {
+		/*halbtc8192e2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);*/
+		btcoexist->btc_write_1byte(btcoexist, 0xc04, 0x33);
+		btcoexist->btc_write_1byte(btcoexist, 0xd04, 0x3);
+		btcoexist->btc_write_4byte(btcoexist, 0x90c, 0x81121313);
+		/* remove, if 0xe77[2]=0x0 then CCK will fail, advised by Jenyu */
+		/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0xe77, 0x4, 0x0); */
+		/* btcoexist->btc_write_1byte(btcoexist, 0xa07, 0x41); */
+		mimo_ps = BTC_MIMO_PS_DYNAMIC;
+	}
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_SEND_MIMO_PS,
+			   &mimo_ps);	/* set rx 1ss or 2ss */
+}
+
+void halbtc8192e2ant_switch_ss_type(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 new_ss_type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], %s Switch SS Type = %d\n",
+		    (force_exec ? "force to" : ""), new_ss_type);
+	BTC_TRACE(trace_buf);
+	coex_dm->cur_ss_type = new_ss_type;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ss_type == coex_dm->cur_ss_type)
+			return;
+	}
+	halbtc8192e2ant_set_switch_ss_type(btcoexist, coex_dm->cur_ss_type);
+
+	coex_dm->pre_ss_type = coex_dm->cur_ss_type;
+}
+
+void halbtc8192e2ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	s8		wifi_duration_adjust = 0x0;
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (coex_sta->scan_ap_num  >= 40)
+		wifi_duration_adjust = -15;
+	else if (coex_sta->scan_ap_num  >= 20)
+		wifi_duration_adjust = -10;
+
+
+	if (turn_on) {
+		switch (type) {
+		case 1:
+		default:	/*d1,wb*/
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x3c, 0x03, 0x11, 0x10);
+			break;
+		case 2:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x32, 0x03, 0x11, 0x10);
+			break;
+		case 3:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x28, 0x03, 0x11, 0x10);
+			break;
+		case 4:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1e, 0x03, 0x11, 0x10);
+			break;
+		case 5:		/*d1,pb,TXpause*/
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x63, 0x3c, 0x03, 0x90, 0x10);
+			break;
+		case 6:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x63, 0x32, 0x03, 0x90, 0x10);
+			break;
+		case 7:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x63, 0x28, 0x03, 0x90, 0x10);
+			break;
+		case 8:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x63, 0x1e, 0x03, 0x90, 0x10);
+			break;
+		case 9:		/*d1,bb*/
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x3c, 0x03, 0x31, 0x10);
+			break;
+		case 10:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x32, 0x03, 0x31, 0x10);
+			break;
+		case 11:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x28, 0x03, 0x31, 0x10);
+			break;
+		case 12:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1e, 0x03, 0x31, 0x10);
+			break;
+		case 13:		/*d1,bb,TXpause*/
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x3c, 0x03, 0x30, 0x10);
+			break;
+		case 14:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x32, 0x03, 0x30, 0x10);
+			break;
+		case 15:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x28, 0x03, 0x30, 0x10);
+			break;
+		case 16:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1e, 0x03, 0x30, 0x10);
+			break;
+		case 17:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x61, 0x20, 0x03, 0x10, 0x10);
+			break;
+		case 18:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x5, 0x5, 0xe1, 0x90);
+			break;
+		case 19:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x25, 0x25, 0xe1, 0x90);
+			break;
+		case 20:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x25, 0x25, 0x60, 0x90);
+			break;
+		case 21:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x61, 0x15, 0x03, 0x11, 0x11);
+			break;
+		case 22:	/* d1,wb */
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x14, 0x03, 0x11, 0x14);
+			break;
+		case 23:	/* d1,pb,TXpause */
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x63, 0x14, 0x03, 0x90, 0x14);
+			break;
+		case 24:	/* d1,bb */
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x14, 0x03, 0x31, 0x14);
+			break;
+		case 25:	/* d1,bb,TXpause */
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x14, 0x03, 0x30, 0x14);
+			break;
+		case 26:	/*d1,wp,noTXpause*/
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe1, 0x3c, 0x03, 0x11, 0x10);
+			break;
+		case 27:	/*11,pp,noTXpause*/
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x61, 0x3c, 0x03, 0x11, 0x11);
+			break;
+		case 28:	/*11,pp,noTXpause*/
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x61, 0x50, 0x03, 0x11, 0x11);
+			break;
+		case 29:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x61, 0x15, 0x03, 0x11, 0x11);
+			break;
+		case 30:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x14, 0x03, 0x10, 0x14);
+			break;
+		case 31: /*d3,bb,TXpause*/
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x14, 0x03, 0x30, 0x94);
+			break;
+		case 32:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x61, 0x35, 0x03, 0x11, 0x11);
+			break;
+		case 71:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+			break;
+		/* following cases is for wifi rssi low // bad antenna isolation, started from 81 */
+		case 80:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x51, 0x3c, 0x3, 0x10, 0x50);
+			break;
+		case 81:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x51, 0x3a + wifi_duration_adjust, 0x3, 0x10, 0x50);
+			break;
+		case 82:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x51, 0x30 + wifi_duration_adjust, 0x03, 0x10, 0x50);
+			break;
+		case 83:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x51, 0x21, 0x03, 0x10, 0x50);
+			break;
+		case 84:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x51, 0x15, 0x3, 0x10, 0x50);
+			break;
+		case 85:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x51, 0x3a, 0x03, 0x10, 0x50);
+			break;
+		case 86:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x51, 0x21, 0x03, 0x10, 0x50);
+			break;
+		case 87:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x51, 0x14, 0x03, 0x10, 0x54);
+			break;
+		case 88:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x53, 0x14, 0x03, 0x10, 0x54);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		default:
+		case 0:  /* ANT2PTA, 0x778=1 */
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x8, 0x0, 0x0, 0x0, 0x0);
+			halbtc8192e2ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, false, false);
+			break;
+		case 1:  /* ANT2BT, 0x778=3 */
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x0, 0x0, 0x0, 0x8, 0x0);
+			delay_ms(5);
+			halbtc8192e2ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false, false);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+
+void halbtc8192e2ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32	bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		if (bt_disabled) {
+			halbtc8192e2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		}
+	}
+}
+
+
+void halbtc8192e2ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* fw all off */
+	halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	/* hw all off */
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8192e2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	coex_sta->cnt_setup_link = 0;
+
+	/* force to reset coex mechanism */
+	halbtc8192e2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 6);
+	halbtc8192e2ant_dec_bt_pwr(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+	halbtc8192e2ant_switch_ss_type(btcoexist, FORCE_EXEC, 2);
+
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+void halbtc8192e2ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct	btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+
+	if (coex_sta->wifi_is_high_pri_task && (!bt_link_info->a2dp_exist)) {
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 11);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+	} else {
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 29);
+	}
+
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+boolean halbtc8192e2ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+	boolean			bt_hs_on = false, low_pwr_disable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (bt_link_info->sco_exist || bt_link_info->hid_exist)
+		halbtc8192e2ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 0, 0, 0);
+	else
+		halbtc8192e2ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+	if (!wifi_connected) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non-connected idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		if ((coex_dm->bt_status == BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE) ||
+		    (coex_dm->bt_status == BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE)) {
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		} else {
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+		}
+		halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+		halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+		common = true;
+	} else {
+		if (coex_dm->bt_status == BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE) {
+			if (wifi_busy && (coex_sta->high_priority_rx > 10))  {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Wifi busy + BT non connected-idle!!\n");
+				BTC_TRACE(trace_buf);
+
+				halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 9);
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 26);
+				halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+				halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+				halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+				halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+				common = true;
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Wifi connected-idle + BT non connected-idle!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+				halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+				halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+				halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+				halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+				common = true;
+			}
+		} else if (coex_dm->bt_status == BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE) {
+
+			if (bt_hs_on)
+				return false;
+
+			if (wifi_busy) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Wifi busy + BT connected-idle!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 10);
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 27);
+				halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+				halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+				halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+				halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+				common = true;
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Wifi connected-idle + BT connected-idle!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+				halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+				halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+				halbtc8192e2ant_sw_mechanism1(btcoexist, true, false, false, false);
+				halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+				common = true;
+			}
+		} else {
+
+			if (wifi_busy) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+				common = false;
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+				halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+				halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+				halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+				halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+				common = true;
+			}
+		}
+	}
+	return common;
+}
+
+
+void halbtc8192e2ant_tdma_duration_adjust(IN struct btc_coexist *btcoexist,
+		IN boolean sco_hid, IN boolean tx_pause, IN u8 max_interval)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0;
+
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+		{
+			if (sco_hid) {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					} else if (max_interval == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (max_interval == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					} else if (max_interval == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (max_interval == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			} else {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (max_interval == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (max_interval == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (max_interval == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (max_interval == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					}
+				}
+			}
+		}
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* acquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if retry count during continuous n*2 seconds is 0, enlarge WiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if continuous 2 retry count(every 2 seconds) >0 and < 3, reduce WiFi duration */
+				if (wait_count <= 2)
+					m++; /* to avoid loop between the two levels */
+				else
+					m = 1;
+
+				if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, once retry count > 3, to reduce WiFi duration */
+			if (wait_count == 1)
+				m++; /* to avoid loop between the two levels */
+			else
+				m = 1;
+
+			if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (max_interval == 1) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 13);
+					coex_dm->ps_tdma_du_adj_type = 13;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 1);
+					coex_dm->ps_tdma_du_adj_type = 1;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 9);
+					coex_dm->ps_tdma_du_adj_type = 9;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 71);
+						coex_dm->ps_tdma_du_adj_type =
+							71;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					}
+				}
+			}
+		} else if (max_interval == 2) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					}
+				}
+			}
+		} else if (max_interval == 3) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			}
+		}
+	}
+
+	/* if current PsTdma not match with the recorded one (when scan, dhcp...), */
+	/* then we have to adjust it back to the previous record one. */
+	if (coex_dm->cur_ps_tdma != coex_dm->ps_tdma_du_adj_type) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], PsTdma type dismatch!!!, cur_ps_tdma=%d, recordPsTdma=%d\n",
+			    coex_dm->cur_ps_tdma, coex_dm->ps_tdma_du_adj_type);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (!scan && !link && !roam)
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+}
+
+/* ******************
+ * pstdma for wifi rssi low
+ * ****************** */
+void halbtc8192e2ant_tdma_duration_adjust_for_wifi_rssi_low(
+	IN struct btc_coexist *btcoexist/* , */ /* IN u8 wifi_status */)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0, bt_info_ext;
+
+	coex_dm->auto_tdma_adjust = false;
+
+	retry_count = coex_sta->bt_retry_cnt;
+	bt_info_ext = coex_sta->bt_info_ext;
+
+	if (!coex_dm->auto_tdma_adjust_low_rssi) {
+		coex_dm->auto_tdma_adjust_low_rssi = true;
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 81);
+		coex_dm->ps_tdma_du_adj_type = 81;
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* acquire the BT TRx retry count from BT_Info byte2
+		*		retry_count = coex_sta->bt_retry_cnt;
+		*		bt_info_ext = coex_sta->bt_info_ext; */
+		result = 0;
+		wait_count++;
+
+		if ((coex_sta->low_priority_tx) > 1050 ||
+		    (coex_sta->low_priority_rx) > 1250)
+			retry_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if retry count during continuous n*2 seconds is 0, enlarge WiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if continuous 2 retry count(every 2 seconds) >0 and < 3, reduce WiFi duration */
+				if (wait_count <= 2)
+					m++; /* to avoid loop between the two levels */
+				else
+					m = 1;
+
+				if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, once retry count > 3, to reduce WiFi duration */
+			if (wait_count == 1)
+				m++; /* to avoid loop between the two levels */
+			else
+				m = 1;
+
+			if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (result == -1) {
+			if (coex_dm->cur_ps_tdma == 80) {
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 81);
+				coex_dm->ps_tdma_du_adj_type = 81;
+			} else if (coex_dm->cur_ps_tdma == 81) {
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 82);
+				coex_dm->ps_tdma_du_adj_type = 82;
+			} else if (coex_dm->cur_ps_tdma == 82) {
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 83);
+				coex_dm->ps_tdma_du_adj_type = 83;
+			} else if (coex_dm->cur_ps_tdma == 83) {
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 84);
+				coex_dm->ps_tdma_du_adj_type = 84;
+			}
+		} else if (result == 1) {
+			if (coex_dm->cur_ps_tdma == 84) {
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 83);
+				coex_dm->ps_tdma_du_adj_type = 83;
+			} else if (coex_dm->cur_ps_tdma == 83) {
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 82);
+				coex_dm->ps_tdma_du_adj_type = 82;
+			} else if (coex_dm->cur_ps_tdma == 82) {
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 81);
+				coex_dm->ps_tdma_du_adj_type = 81;
+			} else if ((coex_dm->cur_ps_tdma == 81) &&
+				   (coex_sta->scan_ap_num <= 5)) {
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 81);
+				coex_dm->ps_tdma_du_adj_type = 81;
+			}
+		}
+
+		if (coex_dm->cur_ps_tdma != 80 &&
+		    coex_dm->cur_ps_tdma != 81 &&
+		    coex_dm->cur_ps_tdma != 82 &&
+		    coex_dm->cur_ps_tdma != 83 &&
+		    coex_dm->cur_ps_tdma != 84) {
+			/* recover to previous adjust type */
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		}
+	}
+}
+
+
+void halbtc8192e2ant_get_bt_rssi_threshold(IN struct btc_coexist *btcoexist,
+		IN u8 *pThres0, IN u8 *pThres1)
+{
+	u8 ant_type;
+
+	struct  btc_board_info  *board_info = &btcoexist->board_info;
+
+	ant_type = board_info->ant_type;
+
+	switch (ant_type) {
+	case BTC_ANT_TYPE_0:
+		*pThres0 = 100;
+		*pThres1 = 100;
+		break;
+	case BTC_ANT_TYPE_1:
+		*pThres0 = 34;
+		*pThres1 = 42;
+		break;
+	case BTC_ANT_TYPE_2:
+		*pThres0 = 34;
+		*pThres1 = 42;
+		break;
+	case BTC_ANT_TYPE_3:
+		*pThres0 = 34;
+		*pThres1 = 42;
+		break;
+	case BTC_ANT_TYPE_4:
+		*pThres0 = 34;
+		*pThres1 = 42;
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8192e2ant_action_bt_relink(IN struct btc_coexist *btcoexist)
+{
+	if (coex_sta->wifi_is_high_pri_task) {
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	} else {
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+
+/* SCO only or SCO+PAN(HS) */
+void halbtc8192e2ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	u8	wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+	u32	wifi_bw;
+	u8	bt_thresh0 = 0, bt_thresh1 = 0;
+
+	halbtc8192e2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	else
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&	(!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	else
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+
+	halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+void halbtc8192e2ant_action_sco_pan(IN struct btc_coexist *btcoexist)
+{
+	u8	wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+	u32	wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+
+	halbtc8192e2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	else
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 10);
+	else
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 86);
+
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)) &&
+	    (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8192E))
+		halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+	else if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)) &&
+		 (coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8192E))
+		halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+	else
+		halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+}
+
+
+void halbtc8192e2ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	u8	wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32	wifi_bw;
+	u8	anttype = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_ANT_TYPE, &anttype);
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 34, 0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	if (anttype == 0) {
+		/*ANTTYPE = 0   2ant with SPDT*/
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 28);
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (anttype == 1) {
+		/*2ant with coupler and bad ant. isolation, 3ant with bad ant. isolation*/
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 28);
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (anttype == 2) {
+		/*ANTTYPE = 2, 2ant with coupler and normal/good ant. isolation, 3ant with normal ant. isolation*/
+		if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state))) {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+		} else {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+		}
+	} else if (anttype == 3) {
+		/*ANTTYPE = 3,  3ant with good ant. isolation*/
+		if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state))) {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		} else {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		}
+	}
+
+	halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8192e2ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	boolean		long_dist = false;
+	u8	anttype = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_ANT_TYPE, &anttype);
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 34, 0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	if (anttype == 0) {
+		/*ANTTYPE = 0   2ant with SPDT*/
+		if ((coex_sta->scan_ap_num > 40) && (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))) {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 30);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		} else {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 88);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		}
+	} else if (anttype == 1) {
+		/*2ant with coupler and bad ant. isolation, 3ant with bad ant. isolation*/
+		if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state))) {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 25);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		} else {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 88);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		}
+	} else if (anttype == 2) {
+		/*ANTTYPE = 2, 2ant with coupler and normal/good ant. isolation, 3ant with normal ant. isolation*/
+		if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state))) {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+		} else {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 88);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		}
+	} else if (anttype == 3) {
+		/*ANTTYPE = 3,  3ant with good ant. isolation*/
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	}
+	halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+void halbtc8192e2ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false, true, 2);
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false, false,
+						     2);
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false, false,
+						     2);
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+	}
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x6);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x6);
+		}
+	}
+}
+
+void halbtc8192e2ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+	halbtc8192e2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+	/*	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 34, 0); */
+	wifi_rssi_state = BTC_RSSI_STATE_LOW;
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&	(!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 1);
+	else
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 85);
+
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+/* PAN(HS) only */
+void halbtc8192e2ant_action_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW))
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+		 (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM))
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		 (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+	halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* PAN(EDR)+A2DP */
+void halbtc8192e2ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+	halbtc8192e2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+	/*	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 34, 0); */
+	wifi_rssi_state = BTC_RSSI_STATE_LOW;
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 4);
+	else
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 86);
+
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+}
+
+void halbtc8192e2ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+	halbtc8192e2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	else
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&	(!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 10);
+	else
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 86);
+
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8192e2ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+	halbtc8192e2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	else
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 4);
+	else
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 86);
+
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+void halbtc8192e2ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0, anttype = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_ANT_TYPE, &anttype);
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 34, 0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	if (anttype == 0) {
+		/*2ant with SPDT*/
+		if ((coex_sta->scan_ap_num > 40) && (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))) {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 31);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 11);
+		} else {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 88);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+		}
+	} else if (anttype == 1) {
+		/*2ant with coupler and bad ant. isolation, 3ant with bad ant. isolation*/
+		if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state))) {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 25);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+		} else {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 87);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+		}
+	} else if (anttype == 2) {
+		/*ANTTYPE = 2, 2ant with coupler and normal/good ant. isolation, 3ant with normal ant. isolation*/
+		if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state))) {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 25);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+		} else {
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 87);
+			halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+		}
+	} else if (anttype == 3) {
+		/*ANTTYPE = 3,  3ant with good ant. isolation*/
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	}
+
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+void halbtc8192e2ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8				algorithm = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	algorithm = halbtc8192e2ant_action_algorithm(btcoexist);
+	if (coex_sta->c2h_bt_inquiry_page &&
+	    (BT_8192E_2ANT_COEX_ALGO_PANHS != algorithm)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8192e2ant_action_bt_inquiry(btcoexist);
+		return;
+	}
+
+	if (coex_sta->is_setup_link) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is re-link !!!\n");
+		halbtc8192e2ant_action_bt_relink(btcoexist);
+		return;
+	}
+
+
+	coex_dm->cur_algorithm = algorithm;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Algorithm = %d\n",
+		    coex_dm->cur_algorithm);
+	BTC_TRACE(trace_buf);
+
+	if (halbtc8192e2ant_is_common_action(btcoexist)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant common.\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->auto_tdma_adjust = false;
+		coex_dm->auto_tdma_adjust_low_rssi = false;
+
+	} else {
+		if (coex_dm->cur_algorithm != coex_dm->pre_algorithm) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], pre_algorithm=%d, cur_algorithm=%d\n",
+				coex_dm->pre_algorithm, coex_dm->cur_algorithm);
+			BTC_TRACE(trace_buf);
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+
+		}
+		switch (coex_dm->cur_algorithm) {
+		case BT_8192E_2ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_sco(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_SCO_PAN:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = SCO+PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_sco_pan(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_hid(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_a2dp(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_a2dp_pan_hs(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_pan_edr(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_pan_hs(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_pan_edr_a2dp(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_pan_edr_hid(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_hid_a2dp_pan_edr(
+				btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_hid_a2dp(btcoexist);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = unknown!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_coex_all_off(btcoexist);
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8192e2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up)
+{
+	u16	u16tmp = 0;
+	u8	u8tmp = 0;
+	u8	h2c_parameter[1] = {0};
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 2Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	if (back_up) {
+		/* backup rf 0x1e value */
+		coex_dm->bt_rf_0x1e_backup =
+			btcoexist->btc_get_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+						  0xfffff);
+
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	}
+
+	/* antenna sw ctrl to bt */
+	halbtc8192e2ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, true, false);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	/* antenna switch control parameter */
+	/*	btcoexist->btc_write_4byte(btcoexist, 0x858, 0x55555555); */
+
+	/* coex parameters */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x3);
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	/* enable PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x40, 0x20);
+	/* enable mailbox interface */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x40);
+	u16tmp |= BIT(9);
+	btcoexist->btc_write_2byte(btcoexist, 0x40, u16tmp);
+
+	/* enable PTA I2C mailbox */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x101);
+	u8tmp |= BIT(4);
+	btcoexist->btc_write_1byte(btcoexist, 0x101, u8tmp);
+
+	/* enable bt clock when wifi is disabled. */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x93);
+	u8tmp |= BIT(0);
+	btcoexist->btc_write_1byte(btcoexist, 0x93, u8tmp);
+	/* enable bt clock when suspend. */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x7);
+	u8tmp |= BIT(0);
+	btcoexist->btc_write_1byte(btcoexist, 0x7, u8tmp);
+
+#ifdef BTCOEX_DISABLE_ANT_CTRL
+	//disable antenna control by WIFI FW
+	h2c_parameter[0] =0x10;
+	btcoexist->btc_fill_h2c(btcoexist, 0x70, 1, h2c_parameter);
+#endif
+
+	/* Give bt_coex_supported_version the default value */
+	coex_sta->bt_coex_supported_version = 0;
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8192e2ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8192e2ant_
+ * ************************************************************ */
+void ex_halbtc8192e2ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8192e2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8192e2ant_init_hw_config(btcoexist, true);
+}
+
+void ex_halbtc8192e2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8192e2ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8192e2ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_stack_info		*stack_info = &btcoexist->stack_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+	u32				fw_ver = 0, bt_patch_ver = 0, bt_coex_ver = 0;
+	u32				phyver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "Antenna type:",
+		   board_info->ant_type);
+	CL_PRINTF(cli_buf);
+
+	if (!coex_sta->bt_disabled) {
+		if ((coex_sta->bt_coex_supported_version == 0) ||
+			(coex_sta->bt_coex_supported_version == 0xffff))
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION,
+						&coex_sta->bt_coex_supported_version);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER,
+						&bt_patch_ver);
+		btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+	bt_coex_ver = coex_sta->bt_coex_supported_version & 0xff;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+		   "CoexVer WL/  BT_Desired/ BT_Report",
+		   glcoex_ver_date_8192e_2ant, glcoex_ver_8192e_2ant,
+		   glcoex_ver_btdesired_8192e_2ant,
+		   bt_coex_ver,
+		   (bt_coex_ver == 0xff ? "Unknown" :
+		    (coex_sta->bt_disabled ? "BT-disable" :
+		     (bt_coex_ver >= glcoex_ver_btdesired_8192e_2ant ?
+		      "Match" : "Mis-Match"))));
+	CL_PRINTF(cli_buf);
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d",
+		   "W_FW/ B_FW/ Phy", fw_ver, bt_patch_ver, phyver);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/", "WifibHiPri",
+		(coex_sta->wifi_is_high_pri_task ? "Yes" : "No"));
+	CL_PRINTF(cli_buf);
+
+#if 0
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/", "test patch version",
+			"20161003_v3");
+		CL_PRINTF(cli_buf);
+#endif
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   stack_info->sco_exist, stack_info->hid_exist,
+		   stack_info->pan_exist, stack_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_BT_LINK_INFO);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8192E_2ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8192e_2ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ", "SS Type",
+		   coex_dm->cur_ss_type);
+	CL_PRINTF(cli_buf);
+
+	/* Sw mechanism	 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Sw mechanism]============");
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ",
+		   "SM1[ShRf/ LpRA/ LimDig]",
+		   coex_dm->cur_rf_rx_lpf_shrink, coex_dm->cur_low_penalty_ra,
+		   coex_dm->limited_dig);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ",
+		   "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]",
+		   coex_dm->cur_agc_table_en, coex_dm->cur_adc_back_off,
+		   coex_dm->cur_dac_swing_on, coex_dm->cur_dac_swing_lvl);
+	CL_PRINTF(cli_buf);
+
+	/* Fw mechanism		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Fw mechanism]============");
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (auto:%d)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   coex_dm->auto_tdma_adjust);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "DecBtPwr/ IgnWlanAct",
+		   coex_dm->cur_bt_dec_pwr_lvl, coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x",
+		   "RF-A, 0x1e initVal",
+		   coex_dm->bt_rf_0x1e_backup);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "backup ARFR1/ARFR2/RL/AMaxTime",
+		   coex_dm->backup_arfr_cnt1, coex_dm->backup_arfr_cnt2,
+		   coex_dm->backup_retry_limit,
+		   coex_dm->backup_ampdu_max_time);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "0x430/0x434/0x42a/0x456",
+		   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc04);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xd04);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x90c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0xc04/ 0xd04/ 0x90c",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x880);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x", "0x778/0x880[29:25]",
+		u8tmp[0], (u32tmp[0] & 0x3e000000) >> 25);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x92c);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x930);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x92c/ 0x930",
+		   (u8tmp[0]), u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x4f);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x40/ 0x4f",
+		   u8tmp[0], u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)",
+		   u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(hp rx[31:16]/tx[15:0])",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(lp rx[31:16]/tx[15:0])",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8192E_2ANT == 1)
+	halbtc8192e2ant_monitor_bt_ctr(btcoexist);
+#endif
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8192e2ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+		halbtc8192e2ant_coex_all_off(btcoexist);
+		halbtc8192e2ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false, true);
+		halbtc8192e2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		ex_halbtc8192e2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+		halbtc8192e2ant_init_hw_config(btcoexist, false);
+		halbtc8192e2ant_init_coex_dm(btcoexist);
+	}
+}
+
+void ex_halbtc8192e2ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8192e2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	if (BTC_SCAN_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_SCAN_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+
+	}
+}
+
+void ex_halbtc8192e2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	if (BTC_ASSOCIATE_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->cnt_wifi_high_pri = 2;
+		halbtc8192e2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, false);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 11);
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	} else if (BTC_ASSOCIATE_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->wifi_is_high_pri_task = false;
+		halbtc8192e2ant_run_coexist_mechanism(btcoexist);
+	}
+}
+
+void ex_halbtc8192e2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] = 0x1;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+}
+
+void ex_halbtc8192e2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	if (type == BTC_PACKET_DHCP) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], DHCP Packet notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8192e2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8			bt_info = 0;
+	u8			i, rsp_source = 0;
+	boolean			bt_busy = false, limited_dig = false;
+	boolean			wifi_connected = false;
+	static u8		bt_info_for_wifi_fw_count = 0;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8192E_2ANT_MAX)
+		rsp_source = BT_INFO_SRC_8192E_2ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+
+	/*avoid mailbox issue*/
+	if (rsp_source == BT_INFO_SRC_8192E_2ANT_WIFI_FW) {
+		bt_info_for_wifi_fw_count++;
+		if (bt_info_for_wifi_fw_count < 5)
+			return;
+	} else
+		bt_info_for_wifi_fw_count = 0;
+
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	if (BT_INFO_SRC_8192E_2ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if ((coex_sta->bt_info_ext & BIT(1))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8192e2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8192e2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if (coex_sta->bt_info_ext & BIT(2)) {
+			coex_sta->cnt_setup_link++;
+			coex_sta->is_setup_link = true;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Re-Link start in BT info!!\n");
+			BTC_TRACE(trace_buf);
+		} else
+			coex_sta->is_setup_link = false;
+
+		if ((coex_sta->bt_info_ext & BIT(3))) {
+			if (!btcoexist->manual_control &&
+			    !btcoexist->stop_coex_dm) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8192e2ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			}
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+		}
+
+#if (BT_AUTO_REPORT_ONLY_8192E_2ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8192e2ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8192E_2ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8192E_2ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8192E_2ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8192E_2ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8192E_2ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8192E_2ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+	}
+
+	halbtc8192e2ant_update_bt_link_info(btcoexist);
+
+	if (!(bt_info & BT_INFO_8192E_2ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8192E_2ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8192E_2ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8192E_2ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8192E_2ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8192E_2ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8192E_2ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8192E_2ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status)) {
+		bt_busy = true;
+		limited_dig = true;
+	} else {
+		bt_busy = false;
+		limited_dig = false;
+	}
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	coex_dm->limited_dig = limited_dig;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_LIMITED_DIG, &limited_dig);
+
+	halbtc8192e2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8192e2ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8192e2ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false, true);
+	halbtc8192e2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+	ex_halbtc8192e2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+}
+
+void ex_halbtc8192e2ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	boolean			wifi_connected = false;
+	static u8			count = 0;
+	static boolean		pre_wifi_connected = false;
+
+/*If wifi is connecting, the update of wifi channel mask may fail caused by wifi FW*/
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED, &wifi_connected);
+
+	if (pre_wifi_connected != wifi_connected)
+		count = 0;
+
+	if  (count < 10)
+		count++;
+
+	if (count == 2) {
+		if (wifi_connected)
+			ex_halbtc8192e2ant_media_status_notify(btcoexist, BTC_MEDIA_CONNECT);
+		else
+			ex_halbtc8192e2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+	}
+
+	pre_wifi_connected = wifi_connected;
+/*If wifi is connecting, the update of wifi channel mask may fail caused by wifi FW*/
+
+#if (BT_AUTO_REPORT_ONLY_8192E_2ANT == 0)
+	halbtc8192e2ant_query_bt_info(btcoexist);
+	halbtc8192e2ant_monitor_bt_ctr(btcoexist);
+	halbtc8192e2ant_monitor_wifi_ctr(btcoexist);
+	halbtc8192e2ant_monitor_bt_enable_disable(btcoexist);
+#else
+	halbtc8192e2ant_monitor_wifi_ctr(btcoexist);
+
+	if (halbtc8192e2ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust)
+		halbtc8192e2ant_run_coexist_mechanism(btcoexist);
+#endif
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
+
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8192e2ant.h
@@ -0,0 +1,216 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8192E_SUPPORT == 1)
+/* *******************************************
+ * The following is for 8192E 2Ant BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8192E_2ANT				0
+
+#define	BT_INFO_8192E_2ANT_B_FTP						BIT(7)
+#define	BT_INFO_8192E_2ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8192E_2ANT_B_HID						BIT(5)
+#define	BT_INFO_8192E_2ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8192E_2ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8192E_2ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8192E_2ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8192E_2ANT_B_CONNECTION				BIT(0)
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT		2
+#define	NOISY_AP_NUM_THRESH_8192E				10
+
+enum bt_info_src_8192e_2ant {
+	BT_INFO_SRC_8192E_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8192E_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8192E_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8192E_2ANT_MAX
+};
+
+enum bt_8192e_2ant_bt_status {
+	BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8192E_2ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8192E_2ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8192E_2ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8192E_2ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8192E_2ANT_BT_STATUS_MAX
+};
+
+enum bt_8192e_2ant_coex_algo {
+	BT_8192E_2ANT_COEX_ALGO_UNDEFINED		= 0x0,
+	BT_8192E_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8192E_2ANT_COEX_ALGO_SCO_PAN			= 0x2,
+	BT_8192E_2ANT_COEX_ALGO_HID				= 0x3,
+	BT_8192E_2ANT_COEX_ALGO_A2DP			= 0x4,
+	BT_8192E_2ANT_COEX_ALGO_A2DP_PANHS		= 0x5,
+	BT_8192E_2ANT_COEX_ALGO_PANEDR			= 0x6,
+	BT_8192E_2ANT_COEX_ALGO_PANHS			= 0x7,
+	BT_8192E_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x8,
+	BT_8192E_2ANT_COEX_ALGO_PANEDR_HID		= 0x9,
+	BT_8192E_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0xa,
+	BT_8192E_2ANT_COEX_ALGO_HID_A2DP		= 0xb,
+	BT_8192E_2ANT_COEX_ALGO_MAX				= 0xc
+};
+
+struct coex_dm_8192e_2ant {
+	/* fw mechanism */
+	u8		pre_bt_dec_pwr_lvl;
+	u8		cur_bt_dec_pwr_lvl;
+	u8		pre_fw_dac_swing_lvl;
+	u8		cur_fw_dac_swing_lvl;
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		reset_tdma_adjust;
+	boolean		auto_tdma_adjust;
+	boolean		auto_tdma_adjust_low_rssi;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+
+	/* sw mechanism */
+	boolean		pre_rf_rx_lpf_shrink;
+	boolean		cur_rf_rx_lpf_shrink;
+	u32		bt_rf_0x1e_backup;
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	boolean		pre_dac_swing_on;
+	u32		pre_dac_swing_lvl;
+	boolean		cur_dac_swing_on;
+	u32		cur_dac_swing_lvl;
+	boolean		pre_adc_back_off;
+	boolean		cur_adc_back_off;
+	boolean	pre_agc_table_en;
+	boolean		cur_agc_table_en;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u8		pre_ss_type;
+	u8		cur_ss_type;
+
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		cur_ra_mask_type;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+};
+
+struct coex_sta_8192e_2ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+	boolean					force_lps_on;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	u8					bt_rssi;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8192E_2ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8192E_2ANT_MAX];
+	boolean					c2h_bt_inquiry_page;
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u8					scan_ap_num;
+	u32				bt_coex_supported_version;
+	u32					cnt_setup_link;
+	u32					cnt_wifi_high_pri;
+	boolean				is_setup_link;
+	boolean				wifi_is_high_pri_task;
+
+	u32				crc_ok_cck;
+	u32				crc_ok_11g;
+	u32				crc_ok_11n;
+	u32				crc_ok_11n_vht;
+
+	u32				crc_err_cck;
+	u32				crc_err_11g;
+	u32				crc_err_11n;
+	u32				crc_err_11n_vht;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8192e2ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8192e2ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8192e2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8192e2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8192e2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8192e2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8192e2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8192e2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8192e2ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e2ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e2ant_display_coex_info(IN struct btc_coexist *btcoexist);
+
+#else	/*  #if (RTL8192E_SUPPORT == 1) */
+#define	ex_halbtc8192e2ant_power_on_setting(btcoexist)
+#define	ex_halbtc8192e2ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8192e2ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8192e2ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8192e2ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8192e2ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8192e2ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8192e2ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8192e2ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8192e2ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8192e2ant_halt_notify(btcoexist)
+#define	ex_halbtc8192e2ant_periodical(btcoexist)
+#define	ex_halbtc8192e2ant_display_coex_info(btcoexist)
+
+#endif
+
+#endif
+
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8703b1ant.c
@@ -0,0 +1,4252 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8703B Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8703B_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	*trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8703b_1ant		glcoex_dm_8703b_1ant;
+static struct  coex_dm_8703b_1ant	*coex_dm = &glcoex_dm_8703b_1ant;
+static struct  coex_sta_8703b_1ant		glcoex_sta_8703b_1ant;
+static struct  coex_sta_8703b_1ant	*coex_sta = &glcoex_sta_8703b_1ant;
+static struct  psdscan_sta_8703b_1ant	gl_psd_scan_8703b_1ant;
+static struct  psdscan_sta_8703b_1ant *psd_scan = &gl_psd_scan_8703b_1ant;
+
+
+const char *const glbt_info_src_8703b_1ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+/* ************************************************************
+ * BtCoex Version Format:
+ * 1. date :			glcoex_ver_date_XXXXX_1ant
+ * 2. WifiCoexVersion : glcoex_ver_XXXX_1ant
+ * 3. BtCoexVersion :	glcoex_ver_btdesired_XXXXX_1ant
+ * 4. others :			glcoex_ver_XXXXXX_XXXXX_1ant
+ *
+ * Variable should be indicated IC and Antenna numbers !!!
+ * Please strictly follow this order and naming style !!!
+ *
+ * ************************************************************ */
+u32	glcoex_ver_date_8703b_1ant = 20161123;
+u32	glcoex_ver_8703b_1ant = 0x11;
+u32	glcoex_ver_btdesired_8703b_1ant = 0x10;
+
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8703b1ant_
+ * ************************************************************ */
+u8 halbtc8703b1ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8703b1ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8703b1ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8703b1ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8703b1ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8703b1ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8703b1ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8703b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8703b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8703b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8703b1ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8703b1ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8703b1ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8703b1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8703b1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+void halbtc8703b1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u8		num_of_bt_counter_chk = 0, cnt_slave = 0, cnt_overhead = 0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* to avoid 0x76e[3] = 1 (WLAN_Act control by PTA) during IPS */
+	/* if (! (btcoexist->btc_read_1byte(btcoexist, 0x76e) & 0x8) ) */
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if (BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			coex_dm->bt_status) {
+
+			if (coex_sta->high_priority_rx >= 15) {
+					if (cnt_overhead < 3)
+						cnt_overhead++;
+
+					if (cnt_overhead == 3)
+						coex_sta->is_hiPri_rx_overhead = true;
+			} else {
+					if (cnt_overhead > 0)
+						cnt_overhead--;
+
+					if (cnt_overhead == 0)
+						coex_sta->is_hiPri_rx_overhead = false;
+			}
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Hi-Pri Rx/Tx: %d/%d, Lo-Pri Rx/Tx: %d/%d\n",
+		    reg_hp_rx, reg_hp_tx, reg_lp_rx, reg_lp_tx);
+
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	if ((coex_sta->low_priority_tx > 1150)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	if ((coex_sta->low_priority_rx >= 1150) &&
+	    (coex_sta->low_priority_rx >= coex_sta->low_priority_tx)
+	    && (!coex_sta->under_ips)  && (!coex_sta->c2h_bt_inquiry_page) &&
+	    (coex_sta->bt_link_exist))	{
+		if (cnt_slave >= 3) {
+			bt_link_info->slave_role = true;
+			cnt_slave = 3;
+		} else
+			cnt_slave++;
+	} else {
+		if (cnt_slave == 0)	{
+			bt_link_info->slave_role = false;
+			cnt_slave = 0;
+		} else
+			cnt_slave--;
+
+	}
+
+	if (!coex_sta->bt_disabled) {
+		if ((coex_sta->high_priority_tx == 0) &&
+		    (coex_sta->high_priority_rx == 0) &&
+		    (coex_sta->low_priority_tx == 0) &&
+		    (coex_sta->low_priority_rx == 0)) {
+			num_of_bt_counter_chk++;
+			if (num_of_bt_counter_chk >= 3) {
+				halbtc8703b1ant_query_bt_info(btcoexist);
+				num_of_bt_counter_chk = 0;
+			}
+		}
+	}
+
+}
+
+
+void halbtc8703b1ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+#if 1
+		s32 wifi_rssi = 0;
+		boolean wifi_busy = false, wifi_under_b_mode = false,
+				wifi_scan = false;
+		boolean bt_idle = false, wl_idle = false;
+		static u8 cck_lock_counter = 0, wl_noisy_count0 = 0,
+			   wl_noisy_count1 = 3, wl_noisy_count2 = 0;
+		u32 total_cnt, reg_val1, reg_val2, cck_cnt;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+		btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+
+		coex_sta->crc_ok_cck = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_OK_CCK);
+		coex_sta->crc_ok_11g = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_OK_LEGACY);
+		coex_sta->crc_ok_11n = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_OK_HT);
+		coex_sta->crc_ok_11n_vht = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_OK_VHT);
+
+		coex_sta->crc_err_cck = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_ERROR_CCK);
+		coex_sta->crc_err_11g =  btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_ERROR_LEGACY);
+		coex_sta->crc_err_11n = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_ERROR_HT);
+		coex_sta->crc_err_11n_vht = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_ERROR_VHT);
+
+		cck_cnt = coex_sta->crc_ok_cck + coex_sta->crc_err_cck;
+
+		if ((coex_dm->bt_status == BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE) ||
+			(coex_dm->bt_status == BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE) ||
+			(coex_sta->bt_disabled))
+			bt_idle = true;
+
+		if ((!wifi_busy) && (!wifi_scan) && (!coex_sta->under_lps)
+			&& (!coex_sta->under_ips))
+			wl_idle = true;
+
+		if ((wl_idle) && (bt_idle)) {
+			if (cck_cnt > 250) {
+				if (wl_noisy_count2 < 3)
+					wl_noisy_count2++;
+
+				if (wl_noisy_count2 == 3) {
+					wl_noisy_count0 = 0;
+					wl_noisy_count1 = 0;
+				}
+			} else if (cck_cnt < 50) {
+				if (wl_noisy_count0 < 3)
+					wl_noisy_count0++;
+
+				if (wl_noisy_count0 == 3) {
+					wl_noisy_count1 = 0;
+					wl_noisy_count2 = 0;
+				}
+			} else {
+				if (wl_noisy_count1 < 3)
+					wl_noisy_count1++;
+
+				if (wl_noisy_count1 == 3) {
+					wl_noisy_count0 = 0;
+					wl_noisy_count2 = 0;
+				}
+			}
+
+			if (wl_noisy_count2 == 3)
+				coex_sta->wl_noisy_level = 2;
+			else if (wl_noisy_count1 == 3)
+				coex_sta->wl_noisy_level = 1;
+			else
+				coex_sta->wl_noisy_level = 0;
+		}
+
+		if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+			total_cnt = coex_sta->crc_ok_cck + coex_sta->crc_ok_11g +
+					coex_sta->crc_ok_11n + coex_sta->crc_ok_11n_vht;
+
+			if ((coex_dm->bt_status == BT_8703B_1ANT_BT_STATUS_ACL_BUSY) ||
+				(coex_dm->bt_status == BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY) ||
+				(coex_dm->bt_status == BT_8703B_1ANT_BT_STATUS_SCO_BUSY)) {
+				if (coex_sta->crc_ok_cck > (total_cnt -
+								coex_sta->crc_ok_cck)) {
+					if (cck_lock_counter < 3)
+						cck_lock_counter++;
+				} else {
+					if (cck_lock_counter > 0)
+						cck_lock_counter--;
+				}
+
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+
+		if (!coex_sta->pre_ccklock) {
+
+			if (cck_lock_counter >= 3)
+				coex_sta->cck_lock = true;
+			else
+				coex_sta->cck_lock = false;
+		} else {
+			if (cck_lock_counter == 0)
+				coex_sta->cck_lock = false;
+			else
+				coex_sta->cck_lock = true;
+		}
+
+		if (coex_sta->cck_lock)
+			coex_sta->cck_ever_lock = true;
+
+		coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+#endif
+}
+
+void halbtc8703b1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	boolean		bt_busy = false;
+
+
+	coex_sta->num_of_profile = 0;
+
+	/* set link exist status */
+	if (!(coex_sta->bt_info & BT_INFO_8703B_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (coex_sta->bt_info & BT_INFO_8703B_1ANT_B_FTP) {
+			coex_sta->pan_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->pan_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8703B_1ANT_B_A2DP) {
+			coex_sta->a2dp_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->a2dp_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8703B_1ANT_B_HID) {
+			coex_sta->hid_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->hid_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8703B_1ANT_B_SCO_ESCO) {
+			coex_sta->sco_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->sco_exist = false;
+
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+	bt_link_info->acl_busy = coex_sta->acl_busy;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+
+	if (coex_sta->bt_info & BT_INFO_8703B_1ANT_B_INQ_PAGE) {
+		coex_dm->bt_status = BT_8703B_1ANT_BT_STATUS_INQ_PAGE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Inq/page!!!\n");
+	} else if (!(coex_sta->bt_info & BT_INFO_8703B_1ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+	} else if (coex_sta->bt_info == BT_INFO_8703B_1ANT_B_CONNECTION) {
+		/* connection exists but no busy */
+		coex_dm->bt_status = BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+	} else if (((coex_sta->bt_info & BT_INFO_8703B_1ANT_B_SCO_ESCO) ||
+		    (coex_sta->bt_info & BT_INFO_8703B_1ANT_B_SCO_BUSY)) &&
+		   (coex_sta->bt_info & BT_INFO_8703B_1ANT_B_ACL_BUSY)) {
+		coex_dm->bt_status = BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL SCO busy!!!\n");
+	} else if ((coex_sta->bt_info & BT_INFO_8703B_1ANT_B_SCO_ESCO) ||
+		   (coex_sta->bt_info & BT_INFO_8703B_1ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8703B_1ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+	} else if (coex_sta->bt_info & BT_INFO_8703B_1ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8703B_1ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+	} else {
+		coex_dm->bt_status = BT_8703B_1ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+	}
+
+	BTC_TRACE(trace_buf);
+
+	if ((BT_8703B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8703B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+}
+
+
+void halbtc8703b1ant_update_wifi_channel_info(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] =
+			0x1;  /* enable BT AFH skip WL channel for 8703b because BT Rx LO interference */
+		/* h2c_parameter[0] = 0x0; */
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+
+}
+
+void halbtc8703b1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8703b1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8703b1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8703b1ant_set_fw_low_penalty_ra(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf7;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf8;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf9;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8703b1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+
+	halbtc8703b1ant_set_fw_low_penalty_ra(btcoexist,
+					      coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8703b1ant_write_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16				bitpos,
+	IN	boolean		state
+)
+{
+
+	static u16 originalval = 0x8002;
+
+	if (state)
+		originalval = originalval | bitpos;
+	else
+		originalval = originalval & (~bitpos);
+
+
+	btcoexist->btc_write_2byte(btcoexist, 0xaa, originalval);
+#if 0
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "\n [BTCoex], ********** Write Scoreboard = %x**********\n",
+		    originalval);
+	BTC_TRACE(trace_buf);
+#endif
+
+}
+
+void halbtc8703b1ant_read_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN   u16				*score_board_val
+)
+{
+
+	*score_board_val = (btcoexist->btc_read_2byte(btcoexist,
+			    0xaa)) & 0x7fff;
+}
+
+void halbtc8703b1ant_post_state_to_bt(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16						type,
+	IN  boolean                 state
+)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], halbtc8703b1ant_post_state_to_bt: type = %d, state =%d\n",
+		type, state);
+	BTC_TRACE(trace_buf);
+
+	halbtc8703b1ant_write_score_board(btcoexist, (u16) type, state);
+}
+
+boolean halbtc8703b1ant_is_wifibt_status_changed(IN struct btc_coexist
+		*btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false, pre_bt_off = false, pre_bt_slave = false;
+	static u8 pre_hid_busy_num = 0, pre_wl_noisy_level = 0;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (coex_sta->bt_disabled != pre_bt_off) {
+		pre_bt_off = coex_sta->bt_disabled;
+
+		if (coex_sta->bt_disabled)
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT is disabled !!\n");
+		else
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT is enabled !!\n");
+
+		BTC_TRACE(trace_buf);
+
+		coex_sta->bt_coex_supported_feature = 0;
+		coex_sta->bt_coex_supported_version = 0;
+		coex_sta->bt_ble_scan_type = 0;
+		coex_sta->bt_ble_scan_para[0] = 0;
+		coex_sta->bt_ble_scan_para[1] = 0;
+		coex_sta->bt_ble_scan_para[2] = 0;
+
+		return true;
+	}
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+
+			if (wifi_busy)
+				halbtc8703b1ant_post_state_to_bt(btcoexist,
+						BT_8703B_1ANT_SCOREBOARD_UNDERTEST, true);
+			else
+				halbtc8703b1ant_post_state_to_bt(btcoexist,
+						BT_8703B_1ANT_SCOREBOARD_UNDERTEST, false);
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+		if (coex_sta->wl_noisy_level != pre_wl_noisy_level) {
+			pre_wl_noisy_level = coex_sta->wl_noisy_level;
+			return true;
+		}
+	}
+
+	if (!coex_sta->bt_disabled) {
+		if (coex_sta->hid_busy_num != pre_hid_busy_num) {
+			pre_hid_busy_num = coex_sta->hid_busy_num;
+			return true;
+		}
+	}
+
+	if (bt_link_info->slave_role != pre_bt_slave) {
+		pre_bt_slave = bt_link_info->slave_role;
+		return true;
+	}
+
+	return false;
+}
+
+
+void halbtc8703b1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+	u16			u16tmp;
+
+	/* This function check if bt is disabled */
+#if 1
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+
+
+#else   /*  8703b BT can't show correct on/off status in scoreboard[1] 2015/11/26 */
+
+	halbtc8703b1ant_read_score_board(btcoexist,	&u16tmp);
+
+	bt_active = u16tmp & BIT(1);
+
+
+#endif
+
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	} else {
+
+		bt_disable_cnt++;
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			bt_disable_cnt = 2;
+		}
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	}
+
+	if (bt_disabled)
+		halbtc8703b1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, false);
+	else
+		halbtc8703b1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, true);
+
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+
+	}
+}
+
+
+
+void halbtc8703b1ant_enable_gnt_to_gpio(IN struct btc_coexist *btcoexist,
+					IN boolean isenable)
+{
+
+#if (BT_8703B_1ANT_ENABLE_GNTBT_TO_GPIO14 == 1)
+	if (isenable) {
+		/* enable GNT_WL/GNT_BT debug signal to GPIO14/15 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x1);
+
+		/* enable GNT_BT debug to GPIO */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e, 0x40, 0x0);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x1, 0x0);
+	} else {
+		/* enable GNT_WL/GNT_BT debug signal to GPIO14/15 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x0);
+
+		/* Disable GNT_BT debug to GPIO, and enable chip_wakeup_host */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e, 0x40, 0x1);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x1, 0x1);
+	}
+#endif
+}
+
+u32 halbtc8703b1ant_ltecoex_indirect_read_reg(IN struct btc_coexist *btcoexist,
+		IN u16 reg_addr)
+{
+	u32 j = 0, delay_count = 0;
+
+
+	/* wait for ready bit before access 0x7c0		 */
+	btcoexist->btc_write_4byte(btcoexist, 0x7c0, 0x800F0000 | reg_addr);
+
+	while (1) {
+		if ((btcoexist->btc_read_1byte(btcoexist, 0x7c3)&BIT(5)) == 0) {
+			delay_ms(50);
+			delay_count++;
+			if (delay_count >= 10) {
+				delay_count = 0;
+				break;
+			}
+		} else
+			break;
+	}
+
+	return btcoexist->btc_read_4byte(btcoexist,
+					 0x7c8);  /* get read data */
+
+}
+
+void halbtc8703b1ant_ltecoex_indirect_write_reg(IN struct btc_coexist
+		*btcoexist,
+		IN u16 reg_addr, IN u32 bit_mask, IN u32 reg_value)
+{
+	u32 val, i = 0, j = 0, bitpos = 0, delay_count = 0;
+
+
+	if (bit_mask == 0x0)
+		return;
+	if (bit_mask == 0xffffffff) {
+		btcoexist->btc_write_4byte(btcoexist, 0x7c4,
+					   reg_value); /* put write data */
+
+		/* wait for ready bit before access 0x7c0 */
+	while (1) {
+		if ((btcoexist->btc_read_1byte(btcoexist, 0x7c3)&BIT(5)) == 0) {
+			delay_ms(50);
+			delay_count++;
+			if (delay_count >= 10) {
+				delay_count = 0;
+				break;
+			}
+		} else
+			break;
+	}
+
+		btcoexist->btc_write_4byte(btcoexist, 0x7c0,
+					   0xc00F0000 | reg_addr);
+	} else {
+		for (i = 0; i <= 31; i++) {
+			if (((bit_mask >> i) & 0x1) == 0x1) {
+				bitpos = i;
+				break;
+			}
+		}
+
+		/* read back register value before write */
+		val = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist,
+				reg_addr);
+		val = (val & (~bit_mask)) | (reg_value << bitpos);
+
+		btcoexist->btc_write_4byte(btcoexist, 0x7c4,
+					   val); /* put write data */
+
+		/* wait for ready bit before access 0x7c0		 */
+		while (1) {
+		if ((btcoexist->btc_read_1byte(btcoexist, 0x7c3)&BIT(5)) == 0) {
+			delay_ms(50);
+			delay_count++;
+			if (delay_count >= 10) {
+				delay_count = 0;
+				break;
+			}
+		} else
+			break;
+	}
+
+		btcoexist->btc_write_4byte(btcoexist, 0x7c0,
+					   0xc00F0000 | reg_addr);
+
+	}
+
+}
+
+void halbtc8703b1ant_ltecoex_enable(IN struct btc_coexist *btcoexist,
+				    IN boolean enable)
+{
+	u8 val;
+
+	val = (enable) ? 1 : 0;
+	halbtc8703b1ant_ltecoex_indirect_write_reg(btcoexist, 0x38, 0x80,
+			val);  /* 0x38[7] */
+
+}
+
+void halbtc8703b1ant_ltecoex_pathcontrol_owner(IN struct btc_coexist *btcoexist,
+		IN boolean wifi_control)
+{
+	u8 val;
+
+	val = (wifi_control) ? 1 : 0;
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x4,
+					   val); /* 0x70[26] */
+
+}
+
+void halbtc8703b1ant_ltecoex_set_gnt_bt(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, val_orig = 0;
+
+	if (!sw_control)
+		val = 0x0;
+	else if (state & 0x1)
+		val = 0x3;
+	else
+		val = 0x1;
+
+	val_orig = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist,
+				0x38);
+
+	switch (control_block) {
+	case BT_8703B_1ANT_GNT_BLOCK_RFC_BB:
+	default:
+		val = ((val << 14) | (val << 10)) | (val_orig & 0xffff33ff);
+		break;
+	case BT_8703B_1ANT_GNT_BLOCK_RFC:
+		val = (val << 14) | (val_orig & 0xffff3fff);
+		break;
+	case BT_8703B_1ANT_GNT_BLOCK_BB:
+		val = (val << 10) | (val_orig & 0xfffff3ff);
+		break;
+	}
+
+	halbtc8703b1ant_ltecoex_indirect_write_reg(btcoexist,
+			0x38, 0xffffffff, val);
+}
+
+
+void halbtc8703b1ant_ltecoex_set_gnt_wl(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, val_orig = 0;
+
+	if (!sw_control)
+		val = 0x0;
+	else if (state & 0x1)
+		val = 0x3;
+	else
+		val = 0x1;
+
+	val_orig = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist,
+				0x38);
+
+	switch (control_block) {
+	case BT_8703B_1ANT_GNT_BLOCK_RFC_BB:
+	default:
+		val = ((val << 12) | (val << 8)) | (val_orig & 0xffffccff);
+		break;
+	case BT_8703B_1ANT_GNT_BLOCK_RFC:
+		val = (val << 12) | (val_orig & 0xffffcfff);
+		break;
+	case BT_8703B_1ANT_GNT_BLOCK_BB:
+		val = (val << 8) | (val_orig & 0xfffffcff);
+		break;
+	}
+
+	halbtc8703b1ant_ltecoex_indirect_write_reg(btcoexist,
+			0x38, 0xffffffff, val);
+}
+
+
+void halbtc8703b1ant_ltecoex_set_coex_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u16 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8703B_1ANT_CTT_WL_VS_LTE:
+		reg_addr = 0xa0;
+		break;
+	case BT_8703B_1ANT_CTT_BT_VS_LTE:
+		reg_addr = 0xa4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8703b1ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xffff, table_content); /* 0xa0[15:0] or 0xa4[15:0] */
+
+
+}
+
+
+void halbtc8703b1ant_ltecoex_set_break_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u8 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8703B_1ANT_LBTT_WL_BREAK_LTE:
+		reg_addr = 0xa8;
+		break;
+	case BT_8703B_1ANT_LBTT_BT_BREAK_LTE:
+		reg_addr = 0xac;
+		break;
+	case BT_8703B_1ANT_LBTT_LTE_BREAK_WL:
+		reg_addr = 0xb0;
+		break;
+	case BT_8703B_1ANT_LBTT_LTE_BREAK_BT:
+		reg_addr = 0xb4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8703b1ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xff, table_content); /* 0xa8[15:0] or 0xb4[15:0] */
+
+
+}
+
+void halbtc8703b1ant_set_wltoggle_coex_table(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec,  IN u8 interval,
+		IN u8 val0x6c4_b0, IN u8 val0x6c4_b1, IN u8 val0x6c4_b2,
+		IN u8 val0x6c4_b3)
+{
+	static u8 pre_h2c_parameter[6] = {0};
+	u8	cur_h2c_parameter[6] = {0};
+	u8 i, match_cnt = 0;
+
+	cur_h2c_parameter[0] = 0x7;	/* op_code, 0x7= wlan toggle slot*/
+
+	cur_h2c_parameter[1] = interval;
+	cur_h2c_parameter[2] = val0x6c4_b0;
+	cur_h2c_parameter[3] = val0x6c4_b1;
+	cur_h2c_parameter[4] = val0x6c4_b2;
+	cur_h2c_parameter[5] = val0x6c4_b3;
+
+	if (!force_exec) {
+		for (i = 1; i <= 5; i++) {
+			if (cur_h2c_parameter[i] != pre_h2c_parameter[i])
+				break;
+
+			match_cnt++;
+		}
+
+		if (match_cnt == 5)
+			return;
+	}
+
+	for (i = 1; i <= 5; i++)
+		pre_h2c_parameter[i] = cur_h2c_parameter[i];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, cur_h2c_parameter);
+}
+
+
+void halbtc8703b1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8703b1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8703b1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8703b1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	u32	break_table;
+	u8	select_table;
+
+	coex_sta->coex_table_type = type;
+
+	if (coex_sta->concurrent_rx_mode_on == true) {
+		break_table = 0xf0ffffff;  /* set WL hi-pri can break BT */
+		select_table =
+			0xb;		/* set Tx response = Hi-Pri (ex: Transmitting ACK,BA,CTS) */
+	} else {
+		break_table = 0xffffff;
+		select_table = 0x3;
+	}
+
+		switch (type) {
+		case 0:
+			halbtc8703b1ant_coex_table(btcoexist, force_exec,
+						   0x55555555, 0x55555555, break_table,
+						   select_table);
+			break;
+		case 1:
+			halbtc8703b1ant_coex_table(btcoexist, force_exec,
+						   0x55555555, 0xaa5a5a5a, break_table,
+						   select_table);
+			break;
+		case 2:
+			halbtc8703b1ant_coex_table(btcoexist, force_exec,
+						   0xaa5a5a5a, 0xaa5a5a5a, break_table,
+						   select_table);
+			break;
+		case 3:
+			halbtc8703b1ant_coex_table(btcoexist, force_exec,
+						   0x55555555, 0x5a5a5a5a, break_table,
+						   select_table);
+			break;
+		case 4:
+			halbtc8703b1ant_coex_table(btcoexist, force_exec,
+						   0xa5555555, 0xaa5a5a5a, break_table,
+						   select_table);
+			break;
+		case 5:
+			halbtc8703b1ant_coex_table(btcoexist, force_exec,
+						   0x5a5a5a5a, 0x5a5a5a5a, break_table,
+						   select_table);
+			break;
+		case 6:
+			halbtc8703b1ant_coex_table(btcoexist, force_exec,
+						   0xa5555555, 0x5a5a5a5a, break_table,
+						   select_table);
+			break;
+		case 7:
+			halbtc8703b1ant_coex_table(btcoexist, force_exec,
+						   0xaaaaaaaa, 0xaaaaaaaa, break_table,
+						   select_table);
+			break;
+		case 8:
+			halbtc8703b1ant_coex_table(btcoexist, force_exec,
+						   0xa5555555, 0xaaaaaaaa, break_table,
+						   select_table);
+			break;
+		case 9:
+			halbtc8703b1ant_coex_table(btcoexist, force_exec,
+						   0x5a5a5a5a, 0xaaaa5aaa, break_table,
+						   select_table);
+			break;
+		default:
+			break;
+		}
+}
+
+void halbtc8703b1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable)
+		h2c_parameter[0] |= BIT(0);/* function enable */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8703b1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8703b1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8703b1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8703b1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8703b1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8703b1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0x8, 0, 0, 0, 0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			/*halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			/*halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);*/
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8703b1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		coex_sta->force_lps_on = false;
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+
+		break;
+	case BTC_PS_LPS_ON:
+		coex_sta->force_lps_on = true;
+		halbtc8703b1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8703b1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+
+		break;
+	case BTC_PS_LPS_OFF:
+		coex_sta->force_lps_on = false;
+		halbtc8703b1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+
+		break;
+	default:
+		break;
+	}
+}
+
+
+
+void halbtc8703b1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for 1Ant AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8703b1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0,
+							 0x0);
+		}
+	} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+
+		halbtc8703b1ant_power_save_state(
+			btcoexist, BTC_PS_LPS_ON, 0x50,
+			0x4);
+	} else {
+		halbtc8703b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0,
+						 0x0);
+	}
+
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+
+void halbtc8703b1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_busy = false;
+	u8			rssi_adjust_val = 0;
+	static u8			psTdmaByte4Modify = 0x0, pre_psTdmaByte4Modify = 0x0;
+	static boolean	 pre_wifi_busy = false;
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (wifi_busy != pre_wifi_busy) {
+		force_exec = true;
+		pre_wifi_busy = wifi_busy;
+	}
+
+	/* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+	if ((bt_link_info->slave_role) && (bt_link_info->a2dp_exist))
+		psTdmaByte4Modify = 0x1;
+	else
+		psTdmaByte4Modify = 0x0;
+
+	if (pre_psTdmaByte4Modify != psTdmaByte4Modify) {
+
+		force_exec = true;
+		pre_psTdmaByte4Modify = psTdmaByte4Modify;
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+	if (turn_on)	{
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+	}
+
+
+	if (turn_on) {
+		switch (type) {
+		default:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x35, 0x03, 0x11, 0x11);
+			break;
+
+		case 3:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x3a, 0x03, 0x10, 0x50);
+			break;
+		case 4:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x21, 0x03, 0x10, 0x50);
+			break;
+		case 5:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x15, 0x03, 0x11, 0x11);
+			break;
+		case 6:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x20, 0x03, 0x11, 0x11);
+			break;
+		case 7:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x10, 0x03, 0x10,  0x54 |
+							psTdmaByte4Modify);
+			break;
+		case 8:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x10, 0x03, 0x10,  0x54 |
+							psTdmaByte4Modify);
+			break;
+		case 9:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x55, 0x10, 0x03, 0x10,  0x54 |
+							psTdmaByte4Modify);
+			break;
+		case 10:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x30, 0x03, 0x11, 0x10);
+			break;
+		case 11:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x65, 0x25, 0x03, 0x11,  0x11 |
+							psTdmaByte4Modify);
+			break;
+		case 12:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x55, 0x30, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 13:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x25, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 14:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x15, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 15:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x20, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 16:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x10, 0x03, 0x11,  0x15 |
+							psTdmaByte4Modify);
+			break;
+		case 17:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x10, 0x03, 0x11, 0x14);
+			break;
+		case 18:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x30, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 19:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x15, 0x03, 0x11, 0x10);
+			break;
+		case 20:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x30, 0x03, 0x11, 0x10);
+			break;
+		case 21:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x30, 0x03, 0x11, 0x10);
+			break;
+		case 22:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x25, 0x03, 0x11, 0x10);
+			break;
+		case 27:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x10, 0x03, 0x11, 0x15);
+			break;
+		case 32:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x35, 0x03, 0x11, 0x11);
+			break;
+		case 33:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x35, 0x03, 0x11, 0x10);
+			break;
+		case 57:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x10, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 58:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x10, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 67:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x10, 0x03, 0x11,  0x10 |
+							psTdmaByte4Modify);
+			break;
+		}
+	} else {
+
+		/* disable PS tdma */
+		switch (type) {
+		case 8: /* PTA Control */
+			halbtc8703b1ant_set_fw_pstdma(btcoexist, 0x8,
+							0x0, 0x0, 0x0, 0x0);
+			break;
+		case 0:
+		default:  /* Software control, Antenna at BT side */
+			halbtc8703b1ant_set_fw_pstdma(btcoexist, 0x0,
+							0x0, 0x0, 0x0, 0x0);
+			break;
+		case 1: /* 2-Ant, 0x778=3, antenna control by antenna diversity */
+			halbtc8703b1ant_set_fw_pstdma(btcoexist, 0x0,
+							0x0, 0x0, 0x48, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8703b1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+				  IN u8 ant_pos_type, IN boolean force_exec,
+				  IN u8 phase)
+{
+	u32	cnt_bt_cal_chk = 0;
+	boolean	is_in_mp_mode = false;
+	u8	u8tmp = 0;
+	u32	u32tmp1 = 0, u32tmp2 = 0;
+
+
+	u32tmp1 = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist,
+				0x38);
+
+	/* To avoid indirect access fail	*/
+	if (((u32tmp1 & 0xf000) >> 12) != ((u32tmp1 & 0x0f00) >> 8)) {
+		force_exec = true;
+		coex_sta->gnt_error_cnt++;
+	}
+
+#if 1
+	u32tmp2 = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0x54);
+	u8tmp  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (Before Ant Setup) 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x**********\n",
+		    u8tmp, u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+#endif
+
+	coex_dm->cur_ant_pos_type = ant_pos_type;
+
+	if (!force_exec) {
+		if (coex_dm->cur_ant_pos_type == coex_dm->pre_ant_pos_type) {
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** Skip Antenna Path Setup because no change!!**********\n");
+			BTC_TRACE(trace_buf);
+			return;
+		}
+	}
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+
+	switch (phase) {
+	case BT_8703B_1ANT_PHASE_COEX_INIT:
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8703b1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8703b1ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8703B_1ANT_CTT_WL_VS_LTE,
+			0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8703b1ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8703B_1ANT_CTT_BT_VS_LTE,
+			0xffff);
+
+		/* Wait If BT IQK running, because Path control owner is at BT during BT IQK (setup by WiFi firmware) */
+		while (cnt_bt_cal_chk <= 20) {
+			u8tmp = btcoexist->btc_read_1byte(
+					btcoexist,
+					0x49d);
+			cnt_bt_cal_chk++;
+			if (u8tmp & BIT(0)) {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ########### BT is calibrating (wait cnt=%d) ###########\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				delay_ms(50);
+			} else {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ********** BT is NOT calibrating (wait cnt=%d)**********\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				break;
+			}
+		}
+
+
+		/* set Path control owner to WL at initial step */
+		halbtc8703b1ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8703B_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW high */
+		halbtc8703b1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW low */
+		halbtc8703b1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_LOW);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		coex_sta->run_time_state = false;
+		break;
+	case BT_8703B_1ANT_PHASE_WLANONLY_INIT:
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8703b1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8703b1ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8703B_1ANT_CTT_WL_VS_LTE,
+			0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8703b1ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8703B_1ANT_CTT_BT_VS_LTE,
+			0xffff);
+
+		/* set Path control owner to WL at initial step */
+		halbtc8703b1ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8703B_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW low */
+		halbtc8703b1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_LOW);
+		/* Set GNT_WL to SW high */
+		halbtc8703b1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_HIGH);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type =
+				BTC_ANT_PATH_WIFI;
+
+		coex_sta->run_time_state = false;
+		break;
+	case BT_8703B_1ANT_PHASE_WLAN_OFF:
+		/* Disable LTE Coex Function in WiFi side */
+		halbtc8703b1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* set Path control owner to BT */
+		halbtc8703b1ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8703B_1ANT_PCO_BTSIDE);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		coex_sta->run_time_state = false;
+		break;
+	case BT_8703B_1ANT_PHASE_2G_RUNTIME:
+		halbtc8703b1ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8703B_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to PTA */
+		halbtc8703b1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_PTA,
+					   BT_8703B_1ANT_SIG_STA_SET_BY_HW);
+		/* Set GNT_WL to PTA */
+		halbtc8703b1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_PTA,
+					   BT_8703B_1ANT_SIG_STA_SET_BY_HW);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_PTA;
+
+		coex_sta->run_time_state = true;
+		break;
+	case BT_8703B_1ANT_PHASE_BTMPMODE:
+		halbtc8703b1ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8703B_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to high */
+		halbtc8703b1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to low */
+		halbtc8703b1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_LOW);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		coex_sta->run_time_state = false;
+		break;
+	}
+
+
+#if 1
+	u32tmp1 = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u8tmp  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (After Ant-Setup) 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x**********\n",
+		    u8tmp, u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+
+#endif
+}
+
+
+boolean halbtc8703b1ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected &&
+	    BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		common = true;
+	} else if (!wifi_connected &&
+		   (BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		common = true;
+	} else if (!wifi_connected &&
+		   (BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE !=
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non connected-idle + BT Busy!!\n");
+		BTC_TRACE(trace_buf);
+		common = true;
+	} else {
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		common = false;
+	}
+
+	return common;
+}
+
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+u8 halbtc8703b1ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean	bt_hs_on = false;
+	u8	algorithm = BT_8703B_1ANT_COEX_ALGO_UNDEFINED;
+	u8	num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Profile = SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8703B_1ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8703B_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8703B_1ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8703B_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8703B_1ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8703B_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8703B_1ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8703B_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8703B_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! BT Profile = SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8703b1ant_action_bt_whql_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8703B_1ANT_PHASE_2G_RUNTIME);
+	halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8703b1ant_action_bt_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8703b1ant_action_bt_relink(IN struct btc_coexist *btcoexist)
+{
+	halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+}
+
+void halbtc8703b1ant_action_bt_idle(IN struct btc_coexist *btcoexist)
+{
+	boolean wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_busy) {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							6);
+		halbtc8703b1ant_coex_table_with_type(btcoexist,
+							NORMAL_EXEC, 3);
+	} else {/* if wl busy */
+
+	if (BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			coex_dm->bt_status) {
+
+		if (coex_sta->is_hiPri_rx_overhead)
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+								NORMAL_EXEC, 7);
+		else
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+								NORMAL_EXEC, 8);
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							33);
+	} else {
+
+	   halbtc8703b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+	   halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							32);
+	  }
+	}
+}
+
+void halbtc8703b1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_connected = false, ap_enable = false, wifi_busy = false,
+				bt_busy = false;
+	boolean	wifi_scan = false, wifi_link = false, wifi_roam = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &wifi_link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &wifi_roam);
+
+	if ((wifi_link) || (wifi_roam)  || (coex_sta->wifi_is_high_pri_task)) {
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+
+	} else if (((wifi_scan) || (wifi_busy)) &&
+		   (coex_sta->bt_create_connection)) {
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+
+	} else if ((!wifi_connected) && (!wifi_scan)) {
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	}  else if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist)) {
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 6);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	} else if ((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) {
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	} else if (bt_link_info->a2dp_exist) {
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (wifi_scan) {
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	} else if (wifi_busy) {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	}
+}
+
+void halbtc8703b1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, wifi_busy = false;
+	u32  wifi_bw = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,
+			   &wifi_bw);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+
+	if (bt_link_info->sco_exist) {
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC,	true, 5);
+			halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+		} else if (coex_sta->hid_busy_num >= 2) {/*for 4/18 hid */
+		/* if 11bg mode */
+		if (wifi_bw == 0) {
+
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+								NORMAL_EXEC, 6);
+			halbtc8703b1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x1, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 11);
+		} else {
+
+		if (wifi_busy) {
+
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+								NORMAL_EXEC, 6);
+			halbtc8703b1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+		     halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 11);
+		  } else {
+
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 6);
+			halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+		  }
+		}
+	} else {
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						true, 6);
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 3);
+		}
+}
+
+
+void halbtc8703b1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+				     BT_8703B_1ANT_PHASE_2G_RUNTIME);
+	halbtc8703b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+}
+
+void halbtc8703b1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8703B_1ANT_PHASE_2G_RUNTIME);
+
+	if (!bt_link_info->pan_exist)
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	else
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8703b1ant_action_wifi_linkscan_process(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	if (bt_link_info->pan_exist) {
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	} else if (bt_link_info->a2dp_exist) {
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 27);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	}
+}
+
+void halbtc8703b1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist)
+{
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_busy = false, wifi_turbo = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				&coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  scan_ap_num = %d, wl_noisy_level = %d\n",
+			coex_sta->scan_ap_num, coex_sta->wl_noisy_level);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->wl_noisy_level == 0))
+		wifi_turbo = true;
+#endif
+
+	if (bt_link_info->a2dp_only) { /* A2DP		 */
+		if (!wifi_busy) {
+			/*halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);*/
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						27);
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+								 NORMAL_EXEC, 4);
+		} else {
+
+			if (coex_sta->wl_noisy_level == 2)
+				halbtc8703b1ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 17);
+			else
+				halbtc8703b1ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+
+			if (wifi_turbo)
+				halbtc8703b1ant_coex_table_with_type(btcoexist,
+								 NORMAL_EXEC, 8);
+			else
+				halbtc8703b1ant_coex_table_with_type(btcoexist,
+								 NORMAL_EXEC, 4);
+		}
+	} else if (((bt_link_info->a2dp_exist) &&
+			(bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+
+		if ((bt_link_info->hid_exist) && (coex_sta->hid_busy_num >= 2)) {
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+								 NORMAL_EXEC, 6);
+			halbtc8703b1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+									0xaa);
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							12);
+		} else if (wifi_busy)	{
+			if (((coex_sta->a2dp_bit_pool > 40) &&
+				 (coex_sta->a2dp_bit_pool < 255)) ||
+				(!coex_sta->is_A2DP_3M))
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 15);
+			else if (wifi_turbo)
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 18);
+			else
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 13);
+		} else
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+
+		if (bt_link_info->hid_exist)
+			halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+		else if (wifi_turbo)
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+								NORMAL_EXEC, 8);
+		else
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+								NORMAL_EXEC, 4);
+	} else if (bt_link_info->hid_exist &&
+					bt_link_info->a2dp_exist) {/* HID+A2DP */
+
+			if ((wifi_busy) && (coex_sta->hid_busy_num >= 2)) { /*for 4/18 hid */
+				halbtc8703b1ant_coex_table_with_type(btcoexist,
+								NORMAL_EXEC, 6);
+				halbtc8703b1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							9);
+			} else {
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							8);
+				halbtc8703b1ant_coex_table_with_type(btcoexist,
+							NORMAL_EXEC, 1);
+			}
+
+	} else if ((bt_link_info->pan_only)
+					|| (bt_link_info->hid_exist && bt_link_info->pan_exist)) {
+			/* PAN(OPP,FTP), HID+PAN(OPP,FTP) */
+
+		if ((bt_link_info->hid_exist) && (bt_link_info->pan_exist) &&
+				(coex_sta->hid_busy_num >= 2)) {
+
+				halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 6);
+				halbtc8703b1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							12);
+		} else {
+
+			if (!wifi_busy)
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							4);
+			else
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							3);
+
+			if (bt_link_info->hid_exist)
+				halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+			else if (wifi_turbo)
+				halbtc8703b1ant_coex_table_with_type(btcoexist,
+									 NORMAL_EXEC, 8);
+			else
+				halbtc8703b1ant_coex_table_with_type(btcoexist,
+									 NORMAL_EXEC, 4);
+		}
+	} else {
+		/* BT no-profile busy (0x9) */
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	}
+}
+
+void halbtc8703b1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	/* tdma and coex table */
+	halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8703b1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean wifi_busy = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					NORMAL_EXEC,
+					BT_8703B_1ANT_PHASE_2G_RUNTIME);
+
+	if (BT_8703B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+
+		if (bt_link_info->hid_only)/* HID only */
+			halbtc8703b1ant_action_bt_sco_hid_only_busy(btcoexist);
+		else
+			halbtc8703b1ant_action_wifi_connected_bt_acl_busy(btcoexist);
+
+	} else if ((BT_8703B_1ANT_BT_STATUS_SCO_BUSY ==
+				coex_dm->bt_status) ||
+			   (BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+				coex_dm->bt_status)) {
+			halbtc8703b1ant_action_bt_sco_hid_only_busy(btcoexist);
+	} else
+		halbtc8703b1ant_action_bt_idle(btcoexist);
+}
+
+
+void halbtc8703b1ant_run_sw_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8	algorithm = 0;
+
+	algorithm = halbtc8703b1ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+
+	if (halbtc8703b1ant_is_common_action(btcoexist)) {
+
+	} else {
+		switch (coex_dm->cur_algorithm) {
+		case BT_8703B_1ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8703b1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean wifi_connected = false, bt_hs_on = false;
+	boolean increase_scan_dev_num = false;
+	boolean bt_ctrl_agg_buf_size = false;
+	boolean miracast_plus_bt = false, wifi_under_5g = false;
+	u8	agg_buf_size = 5;
+	u32 wifi_link_status = 0;
+	u32 num_of_wifi_link = 0, wifi_bw;
+	u8	iot_peer = BTC_IOT_PEER_UNKNOWN;
+	boolean scan = false, link = false, roam = false, under_4way = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (!coex_sta->run_time_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], return for run_time_state = false !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->freeze_coexrun_by_btinfo) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), return for freeze_coexrun_by_btinfo\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_action_bt_whql_test(btcoexist);
+		return;
+	}
+
+	if (coex_sta->bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT is disabled !!!\n");
+		halbtc8703b1ant_action_wifi_only(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT is under inquiry/page scan !!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8703b1ant_action_bt_inquiry(btcoexist);
+			return;
+	}
+
+	if (coex_sta->is_setupLink) {
+		 BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		 "[BTCoex], BT is re-link !!!\n");
+		 halbtc8703b1ant_action_bt_relink(btcoexist);
+		 return;
+	}
+
+	if ((BT_8703B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+		(BT_8703B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		(BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+				&increase_scan_dev_num);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+				&wifi_link_status);
+
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+		(wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+				num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist)
+			miracast_plus_bt = true;
+		else
+			miracast_plus_bt = false;
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+
+		halbtc8703b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					false, 0x5);
+
+		halbtc8703b1ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	} else {
+
+	miracast_plus_bt = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				&miracast_plus_bt);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED, &wifi_connected);
+
+	if ((bt_link_info->bt_link_exist) && (wifi_connected)) {
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_IOT_PEER, &iot_peer);
+
+		if (BTC_IOT_PEER_CISCO == iot_peer) {
+
+			if (BTC_WIFI_BW_HT40 == wifi_bw)
+					halbtc8703b1ant_limited_rx(btcoexist,
+						NORMAL_EXEC, false, true, 0x10);
+			else
+					halbtc8703b1ant_limited_rx(btcoexist,
+						NORMAL_EXEC, false, true, 0x8);
+		}  else
+				halbtc8703b1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+						0x5);
+	}
+
+	halbtc8703b1ant_run_sw_coexist_mechanism(
+			btcoexist);  /* just print debug message */
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (bt_hs_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is hs\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_action_bt_hs(btcoexist);
+		return;
+	}
+
+	if ((BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			coex_dm->bt_status) ||
+		(BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE ==
+			coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is idle\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_action_bt_idle(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			&under_4way);
+
+	if (scan || link || roam || under_4way) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], scan = %d, link = %d, roam = %d 4way = %d!!!\n",
+					scan, link, roam, under_4way);
+		BTC_TRACE(trace_buf);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], wifi is under linkscan process!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8703b1ant_action_wifi_linkscan_process(btcoexist);
+	} else if (wifi_connected) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], wifi is under connected!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8703b1ant_action_wifi_connected(btcoexist);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], wifi is under not-connected!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8703b1ant_action_wifi_not_connected(btcoexist);
+	 }
+}
+
+
+void halbtc8703b1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+
+	halbtc8703b1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, false);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	coex_sta->pop_event_cnt = 0;
+	coex_sta->cnt_RemoteNameReq = 0;
+	coex_sta->cnt_ReInit = 0;
+	coex_sta->cnt_setupLink = 0;
+	coex_sta->cnt_IgnWlanAct = 0;
+	coex_sta->cnt_Page = 0;
+}
+
+void halbtc8703b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up, IN boolean wifi_only)
+{
+	u32				u32tmp0 = 0, u32tmp1 = 0, u32tmp2 = 0;
+
+	u32tmp0 = btcoexist->btc_read_4byte(btcoexist, 0x70),
+	u32tmp1 = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"\n [BTCoex], ********** 0x70/ 0x38/ 0x54 (Before Init HW config) = 0x%x/ 0x%x/ 0x%x**********\n",
+		    u32tmp0,
+		    u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	coex_sta->bt_coex_supported_feature = 0;
+	coex_sta->bt_coex_supported_version = 0;
+	coex_sta->bt_ble_scan_type = 0;
+	coex_sta->bt_ble_scan_para[0] = 0;
+	coex_sta->bt_ble_scan_para[1] = 0;
+	coex_sta->bt_ble_scan_para[2] = 0;
+	coex_sta->gnt_error_cnt = 0;
+
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+
+	/* BT report packet sample rate	 */
+	btcoexist->btc_write_1byte(btcoexist, 0x790, 0x5);
+
+	/* Enable BT counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+
+	/* Enable PTA (3-wire function form BT side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x41, 0x02, 0x1);
+
+	/* Enable PTA (tx/rx signal form WiFi side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4c6, 0x10, 0x1);
+
+	halbtc8703b1ant_enable_gnt_to_gpio(btcoexist, false);
+
+#if 0
+	if (btcoexist->btc_read_1byte(btcoexist, 0x80) == 0xc6)
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+					 BT_8703B_1ANT_SCOREBOARD_ONOFF, true);
+#endif
+
+	halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+
+	/* Antenna config */
+	if (wifi_only) {
+		coex_sta->concurrent_rx_mode_on = false;
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_WIFI,
+					     FORCE_EXEC,
+					     BT_8703B_1ANT_PHASE_WLANONLY_INIT);
+	} else {
+		coex_sta->concurrent_rx_mode_on = true;
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x953, 0x2, 0x1);
+		/* RF 0x1[0] = 0->Set GNT_WL_RF_Rx always = 1 for con-current Rx */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0x1, 0x0);
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8703B_1ANT_PHASE_COEX_INIT);
+	}
+
+	/* PTA parameter */
+	halbtc8703b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	u32tmp0 = btcoexist->btc_read_4byte(btcoexist, 0x70),
+	u32tmp1 = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** 0x70/ 0x38/ 0x54 (After Init HW config) = 0x%x/ 0x%x/ 0x%x**********\n",
+		    u32tmp0,
+		    u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+
+}
+
+
+
+/* ************************************************************
+ * work around function start with wa_halbtc8703b1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8703b1ant_
+ * ************************************************************ */
+void ex_halbtc8703b1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x0;
+	u16 u16tmp = 0x0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"xxxxxxxxxxxxxxxx Execute 8703b 1-Ant PowerOn Setting xxxxxxxxxxxxxxxx!!\n");
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "Ant Det Finish = %s, Ant Det Number  = %d\n",
+		    (board_info->btdm_ant_det_finish ? "Yes" : "No"),
+		    board_info->btdm_ant_num_by_ant_det);
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = true;
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write BB/MAC reg correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+	/* set Path control owner to WiFi */
+	halbtc8703b1ant_ltecoex_pathcontrol_owner(btcoexist,
+			BT_8703B_1ANT_PCO_WLSIDE);
+
+	/* set GNT_BT to high */
+	halbtc8703b1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_HIGH);
+	/* Set GNT_WL to low */
+	halbtc8703b1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_LOW);
+
+	/* set WLAN_ACT = 0 */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	halbtc8703b1ant_enable_gnt_to_gpio(btcoexist, false);
+
+	/* */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+
+	u8tmp = 0;
+	board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+
+	if (btcoexist->chip_interface == BTC_INTF_USB)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60, u8tmp);
+
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********  0x70(MAC)/0x38/0x54 (Power-On) =0x%x/  0x%x/ 0x%x**********\n",
+		    btcoexist->btc_read_4byte(btcoexist, 0x70),
+		    halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist, 0x38),
+		    halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist, 0x54));
+	BTC_TRACE(trace_buf);
+
+
+}
+
+void ex_halbtc8703b1ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8703b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8703b1ant_init_hw_config(btcoexist, true, wifi_only);
+	btcoexist->stop_coex_dm = false;
+}
+
+void ex_halbtc8703b1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8703b1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8703b1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_stack_info		*stack_info = &btcoexist->stack_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+	u32				fw_ver = 0, bt_patch_ver = 0, bt_coex_ver = 0;
+	static u8			pop_report_in_10s = 0;
+	u32			phyver = 0;
+	boolean			lte_coex_on = false;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	if (psd_scan->ant_det_try_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d",
+			   "Ant PG Num/ Mech/ Pos",
+			   board_info->pg_ant_num, board_info->btdm_ant_num,
+			   board_info->btdm_ant_pos);
+		CL_PRINTF(cli_buf);
+	} else {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %d  (%d/%d/%d)",
+			   "Ant PG Num/ Mech(Ant_Det)/ Pos",
+			   board_info->pg_ant_num,
+			   board_info->btdm_ant_num_by_ant_det,
+			   board_info->btdm_ant_pos,
+			   psd_scan->ant_det_try_count,
+			   psd_scan->ant_det_fail_count,
+			   psd_scan->ant_det_result);
+		CL_PRINTF(cli_buf);
+
+		if (board_info->btdm_ant_det_finish) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+				   "Ant Det PSD Value",
+				   psd_scan->ant_det_peak_val);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+
+	/*bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;*/
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+
+	bt_coex_ver = ((coex_sta->bt_coex_supported_version & 0xff00) >> 8);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+		   "CoexVer WL/  BT_Desired/ BT_Report",
+		   glcoex_ver_date_8703b_1ant, glcoex_ver_8703b_1ant,
+		   glcoex_ver_btdesired_8703b_1ant,
+		   bt_coex_ver,
+		   (bt_coex_ver == 0xff ? "Unknown" :
+		   (bt_coex_ver >= glcoex_ver_btdesired_8703b_1ant ?
+		      "Match":"Mis-Match")));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d/ %c",
+		   "W_FW/ B_FW/ Phy/ Kt",
+		   fw_ver, bt_patch_ver, phyver,
+		   coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s",
+		   "WifibHiPri/ Ccklock/ CckEverLock",
+		   (coex_sta->wifi_is_high_pri_task ? "Yes" : "No"),
+		   (coex_sta->cck_lock ? "Yes" : "No"),
+		   (coex_sta->cck_ever_lock ? "Yes" : "No"));
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	pop_report_in_10s++;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt/ popCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+			   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page")
+			   : ((BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi - 100, coex_sta->bt_retry_cnt,
+		   coex_sta->pop_event_cnt);
+	CL_PRINTF(cli_buf);
+
+	if (pop_report_in_10s >= 5) {
+		coex_sta->pop_event_cnt = 0;
+		pop_report_in_10s = 0;
+	}
+
+	if (coex_sta->num_of_profile != 0)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %s%s%s%s%s",
+			   "Profiles",
+			   ((bt_link_info->a2dp_exist) ? "A2DP," : ""),
+			   ((bt_link_info->sco_exist) ?  "SCO," : ""),
+			   ((bt_link_info->hid_exist) ?
+			    ((coex_sta->hid_busy_num >= 2) ? "HID(4/18)," :
+			     "HID(2/18),") : ""),
+			   ((bt_link_info->pan_exist) ?  "PAN," : ""),
+			   ((coex_sta->voice_over_HOGP) ? "Voice" : ""));
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = None",
+			   "Profiles");
+
+	CL_PRINTF(cli_buf);
+
+	if (bt_link_info->a2dp_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %d/ %s",
+			   "A2DP Rate/Bitpool/Auto_Slot",
+			   ((coex_sta->is_A2DP_3M) ? "3M" : "No_3M"),
+			   coex_sta->a2dp_bit_pool,
+			   ((coex_sta->is_autoslot) ? "On" : "Off")
+			  );
+		CL_PRINTF(cli_buf);
+	}
+
+	if (bt_link_info->hid_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+			   "HID PairNum/Forbid_Slot",
+			   coex_sta->hid_pair_cnt,
+			   coex_sta->forbidden_slot
+			  );
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ 0x%x",
+		   "Role/IgnWlanAct/Feature",
+		   ((bt_link_info->slave_role) ? "Slave" : "Master"),
+		   ((coex_dm->cur_ignore_wlan_act) ? "Yes" : "No"),
+		   coex_sta->bt_coex_supported_feature);
+	CL_PRINTF(cli_buf);
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d",
+		   "ReInit/ReLink/IgnWlact/Page/NameReq",
+		   coex_sta->cnt_ReInit,
+		   coex_sta->cnt_setupLink,
+		   coex_sta->cnt_IgnWlanAct,
+		   coex_sta->cnt_Page,
+		   coex_sta->cnt_RemoteNameReq
+		  );
+	CL_PRINTF(cli_buf);
+
+	halbtc8703b1ant_read_score_board(btcoexist, &u16tmp[0]);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %04x",
+		   "ScoreBoard[14:0] (from BT)", u16tmp[0]);
+	CL_PRINTF(cli_buf);
+
+
+	for (i = 0; i < BT_INFO_SRC_8703B_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8703b_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[mechanisms] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[mechanisms]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "SM[LowPenaltyRA]",
+		   coex_dm->cur_low_penalty_ra);
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (%s,%s)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   (coex_dm->cur_ps_tdma_on ? "On" : "Off"),
+		   (coex_dm->auto_tdma_adjust ? "Adj" : "Fix"));
+
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "WL/BT Coex Table Type",
+		   coex_sta->coex_table_type);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x778/0x6cc/IgnWlanAct",
+		   u8tmp[0], u32tmp[0],  coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	lte_coex_on = ((u32tmp[0] & BIT(7)) >> 7) ?  true : false;
+
+	if (lte_coex_on) {
+		u32tmp[0] = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa0);
+		u32tmp[1] = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa4);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+			   "LTE Coex Table W_L/B_L",
+			   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff);
+		CL_PRINTF(cli_buf);
+
+		u32tmp[0] = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa8);
+		u32tmp[1] = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xac);
+		u32tmp[2] = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xb0);
+		u32tmp[3] = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xb4);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+			   "LTE Break Table W_L/B_L/L_W/L_B",
+			   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff,
+			   u32tmp[2] & 0xffff, u32tmp[3] & 0xffff);
+		CL_PRINTF(cli_buf);
+	}
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %s",
+		   "LTE CoexOn/Path Ctrl Owner",
+		   (int)((u32tmp[0] & BIT(7)) >> 7),
+		   ((u8tmp[0] & BIT(2)) ? "WL" : "BT"));
+	CL_PRINTF(cli_buf);
+
+	if (lte_coex_on) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+			   "LTE 3Wire/OPMode/UART/UARTMode",
+			   (int)((u32tmp[0] & BIT(6)) >> 6),
+			   (int)((u32tmp[0] & (BIT(5) | BIT(4))) >> 4),
+			   (int)((u32tmp[0] & BIT(3)) >> 3),
+			   (int)(u32tmp[0] & (BIT(2) | BIT(1) | BIT(0))));
+		CL_PRINTF(cli_buf);
+	}
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %s (BB:%s)/ %s (BB:%s)/ %s %d",
+			   "GNT_WL_Ctrl/GNT_BT_Ctrl/Dbg",
+			   ((u32tmp[0] & BIT(12)) ? "SW" : "HW"),
+			   ((u32tmp[0] & BIT(8)) ?	"SW" : "HW"),
+			   ((u32tmp[0] & BIT(14)) ? "SW" : "HW"),
+			   ((u32tmp[0] & BIT(10)) ?  "SW" : "HW"),
+			   ((u8tmp[0] & BIT(3)) ? "On" : "Off"),
+			   coex_sta->gnt_error_cnt);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8703b1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "GNT_WL/GNT_BT/LTE_Busy/UART_Busy",
+		   (int)((u32tmp[0] & BIT(2)) >> 2),
+		   (int)((u32tmp[0] & BIT(3)) >> 3),
+		   (int)((u32tmp[0] & BIT(1)) >> 1), (int)(u32tmp[0] & BIT(0)));
+	CL_PRINTF(cli_buf);
+
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x4c6);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x4c6[4]/0x40[5] (WL/BT PTA)",
+		   (int)((u8tmp[0] & BIT(4)) >> 4),
+		   (int)((u8tmp[1] & BIT(5)) >> 5));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x953);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ %s",
+		   "0x550(bcn ctrl)/0x522/4-RxAGC",
+		   u32tmp[0], u8tmp[0], (u8tmp[1] & 0x2) ? "On" : "Off");
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist, PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist, PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist, PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist, PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+#if 1
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+#endif
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s/ %d",
+			   "WlHiPri/ Locking/ Locked/ Noisy",
+			   (coex_sta->wifi_is_high_pri_task ? "Yes" : "No"),
+			   (coex_sta->cck_lock ? "Yes" : "No"),
+			   (coex_sta->cck_ever_lock ? "Yes" : "No"),
+			   coex_sta->wl_noisy_level);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d %s",
+		   "0x770(Hi-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx,
+		   (coex_sta->is_hiPri_rx_overhead ? "(scan overhead!!)" : ""));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d %s",
+		   "0x774(Lo-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx,
+		   (bt_link_info->slave_role ? "(Slave!!)" : ""));
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8703b1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+		coex_sta->under_lps = false;
+
+		/* Write WL "Active" in Score-board for LPS off */
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+				BT_8703B_1ANT_SCOREBOARD_ACTIVE |
+				BT_8703B_1ANT_SCOREBOARD_ONOFF |
+				BT_8703B_1ANT_SCOREBOARD_SCAN |
+				BT_8703B_1ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8703B_1ANT_PHASE_WLAN_OFF);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+#if 0
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+				 BT_8703B_1ANT_SCOREBOARD_ACTIVE, true);
+#endif
+		halbtc8703b1ant_init_hw_config(btcoexist, false, false);
+		halbtc8703b1ant_init_coex_dm(btcoexist);
+		halbtc8703b1ant_query_bt_info(btcoexist);
+
+		coex_sta->under_ips = false;
+	}
+}
+
+void ex_halbtc8703b1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+		coex_sta->under_ips = false;
+
+		if (coex_sta->force_lps_on == true) { /* LPS No-32K */
+			/* Write WL "Active" in Score-board for PS-TDMA */
+			halbtc8703b1ant_post_state_to_bt(btcoexist,
+				 BT_8703B_1ANT_SCOREBOARD_ACTIVE, true);
+
+		} else { /* LPS-32K, need check if this h2c 0x71 can work?? (2015/08/28) */
+			/* Write WL "Non-Active" in Score-board for Native-PS */
+			halbtc8703b1ant_post_state_to_bt(btcoexist,
+				 BT_8703B_1ANT_SCOREBOARD_ACTIVE, false);
+		}
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+
+
+		/* Write WL "Active" in Score-board for LPS off */
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+				 BT_8703B_1ANT_SCOREBOARD_ACTIVE, true);
+	}
+}
+
+void ex_halbtc8703b1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	halbtc8703b1ant_query_bt_info(btcoexist);
+
+	if (BTC_SCAN_START == type) {
+
+		coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+					BT_8703B_1ANT_SCOREBOARD_ACTIVE |
+					BT_8703B_1ANT_SCOREBOARD_SCAN |
+					BT_8703B_1ANT_SCOREBOARD_ONOFF,
+					true);
+
+		halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+					8);
+
+		/* Force antenna setup for no scan result issue */
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8703B_1ANT_PHASE_2G_RUNTIME);
+
+		halbtc8703b1ant_run_coexist_mechanism(btcoexist);
+
+	} else {
+
+		coex_sta->wifi_is_high_pri_task = false;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify  (Scan-AP = %d)\n",
+			    coex_sta->scan_ap_num);
+		BTC_TRACE(trace_buf);
+
+		halbtc8703b1ant_run_coexist_mechanism(btcoexist);
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], SCAN START Notify() end\n");
+	BTC_TRACE(trace_buf);
+
+}
+
+void ex_halbtc8703b1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	boolean	wifi_connected = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	if (BTC_ASSOCIATE_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+					 BT_8703B_1ANT_SCOREBOARD_ACTIVE |
+					 BT_8703B_1ANT_SCOREBOARD_SCAN |
+					 BT_8703B_1ANT_SCOREBOARD_ONOFF,
+					 true);
+
+		halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+					8);
+
+		/* Force antenna setup for no scan result issue */
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8703B_1ANT_PHASE_2G_RUNTIME);
+		/* psd_scan->ant_det_is_ant_det_available = true; */
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+
+		halbtc8703b1ant_run_coexist_mechanism(btcoexist);
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8703b1ant_run_coexist_mechanism(btcoexist);
+	}
+
+}
+
+void ex_halbtc8703b1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean			wifi_under_b_mode = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+					 BT_8703B_1ANT_SCOREBOARD_ACTIVE |
+					 BT_8703B_1ANT_SCOREBOARD_ONOFF,
+					 true);
+
+		halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+					8);
+
+		/* Force antenna setup for no scan result issue */
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8703B_1ANT_PHASE_2G_RUNTIME);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+			/* btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x10); */ /*CCK Tx */
+			/* btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x10); */ /*CCK Rx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+				 BT_8703B_1ANT_SCOREBOARD_ACTIVE, false);
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+
+		coex_sta->cck_ever_lock = false;
+	}
+
+	halbtc8703b1ant_update_wifi_channel_info(btcoexist, type);
+
+}
+
+void ex_halbtc8703b1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	under_4way = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (under_4way) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ---- under_4way!!\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+	} else if (BTC_PACKET_ARP == type) {
+
+		coex_dm->arp_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ARP notify -cnt = %d\n",
+			    coex_dm->arp_cnt);
+		BTC_TRACE(trace_buf);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet DHCP or EAPOL notify [Type = %d]\n",
+			    type);
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+	}
+
+	if (coex_sta->wifi_is_high_pri_task) {
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+					 BT_8703B_1ANT_SCOREBOARD_SCAN, true);
+		halbtc8703b1ant_run_coexist_mechanism(btcoexist);
+	}
+}
+
+void ex_halbtc8703b1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8				i, rsp_source = 0;
+	boolean				wifi_connected = false;
+	boolean	wifi_scan = false, wifi_link = false, wifi_roam = false,
+		    wifi_busy = false;
+	static boolean is_scoreboard_scan = false;
+
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8703B_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8703B_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt_info[%d], len=%d, data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	coex_sta->bt_info = coex_sta->bt_info_c2h[rsp_source][1];
+	coex_sta->bt_info_ext = coex_sta->bt_info_c2h[rsp_source][4];
+	coex_sta->bt_info_ext2 = coex_sta->bt_info_c2h[rsp_source][5];
+
+	if (BT_INFO_SRC_8703B_1ANT_WIFI_FW != rsp_source) {
+
+		/* if 0xff, it means BT is under WHCK test */
+		coex_sta->bt_whck_test = ((coex_sta->bt_info == 0xff) ? true :
+					  false);
+
+		coex_sta->bt_create_connection = ((
+			coex_sta->bt_info_c2h[rsp_source][2] & 0x80) ? true :
+						  false);
+
+		/* unit: %, value-100 to translate to unit: dBm */
+		coex_sta->bt_rssi = coex_sta->bt_info_c2h[rsp_source][3] * 2 +
+				    10;
+
+		coex_sta->c2h_bt_remote_name_req = ((
+			coex_sta->bt_info_c2h[rsp_source][2] & 0x20) ? true :
+						    false);
+
+		coex_sta->is_A2DP_3M = ((coex_sta->bt_info_c2h[rsp_source][2] &
+					 0x10) ? true : false);
+
+		coex_sta->acl_busy = ((coex_sta->bt_info_c2h[rsp_source][1] &
+				       0x9) ? true : false);
+
+		coex_sta->voice_over_HOGP = ((coex_sta->bt_info_ext & 0x10) ?
+					     true : false);
+
+		coex_sta->c2h_bt_inquiry_page = ((coex_sta->bt_info &
+			  BT_INFO_8703B_1ANT_B_INQ_PAGE) ? true : false);
+
+		coex_sta->a2dp_bit_pool = (((
+			coex_sta->bt_info_c2h[rsp_source][1] & 0x49) == 0x49) ?
+				   coex_sta->bt_info_c2h[rsp_source][6] : 0);
+
+		coex_sta->bt_retry_cnt = coex_sta->bt_info_c2h[rsp_source][2] &
+					 0xf;
+
+		coex_sta->is_autoslot = coex_sta->bt_info_ext2 & 0x8;
+
+		coex_sta->forbidden_slot = coex_sta->bt_info_ext2 & 0x7;
+
+		coex_sta->hid_busy_num = (coex_sta->bt_info_ext2 & 0x30) >> 4;
+
+		coex_sta->hid_pair_cnt = (coex_sta->bt_info_ext2 & 0xc0) >> 6;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->c2h_bt_remote_name_req)
+			coex_sta->cnt_RemoteNameReq++;
+
+		if (coex_sta->bt_info_ext & BIT(1))
+			coex_sta->cnt_ReInit++;
+
+		if (coex_sta->bt_info_ext & BIT(2)) {
+			coex_sta->cnt_setupLink++;
+			coex_sta->is_setupLink = true;
+		} else
+			coex_sta->is_setupLink = false;
+
+		if (coex_sta->bt_info_ext & BIT(3))
+			coex_sta->cnt_IgnWlanAct++;
+
+		if (coex_sta->bt_create_connection) {
+			coex_sta->cnt_Page++;
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY,
+					   &wifi_busy);
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &wifi_link);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &wifi_roam);
+
+			if ((wifi_link) || (wifi_roam) || (wifi_scan) ||
+			    (coex_sta->wifi_is_high_pri_task) || (wifi_busy)) {
+
+				is_scoreboard_scan = true;
+				halbtc8703b1ant_post_state_to_bt(btcoexist,
+					 BT_8703B_1ANT_SCOREBOARD_SCAN, true);
+
+			} else
+				halbtc8703b1ant_post_state_to_bt(btcoexist,
+					 BT_8703B_1ANT_SCOREBOARD_SCAN, false);
+
+		} else {
+				if (is_scoreboard_scan) {
+					halbtc8703b1ant_post_state_to_bt(btcoexist,
+						 BT_8703B_1ANT_SCOREBOARD_SCAN, false);
+					is_scoreboard_scan = false;
+				}
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+
+		if ((!btcoexist->manual_control) &&
+		    (!btcoexist->stop_coex_dm)) {
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+
+			/*  Re-Init */
+			if ((coex_sta->bt_info_ext & BIT(1))) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+				BTC_TRACE(trace_buf);
+				if (wifi_connected)
+					halbtc8703b1ant_update_wifi_channel_info(
+						btcoexist, BTC_MEDIA_CONNECT);
+				else
+					halbtc8703b1ant_update_wifi_channel_info(
+						btcoexist,
+						BTC_MEDIA_DISCONNECT);
+			}
+
+
+			/*  If Ignore_WLanAct && not SetUp_Link */
+			if ((coex_sta->bt_info_ext & BIT(3)) &&
+			    (!(coex_sta->bt_info_ext & BIT(2)))) {
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8703b1ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			}
+		}
+
+	}
+	if ((coex_sta->bt_info_ext & BIT(5))) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit4 check, query BLE Scan type!!\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_ble_scan_type = btcoexist->btc_get_ble_scan_type_from_bt(btcoexist);
+
+		if ((coex_sta->bt_ble_scan_type & 0x1) == 0x1)
+			coex_sta->bt_ble_scan_para[0]  = btcoexist->btc_get_ble_scan_para_from_bt(btcoexist, 0x1);
+		if ((coex_sta->bt_ble_scan_type & 0x2) == 0x2)
+			coex_sta->bt_ble_scan_para[1]  = btcoexist->btc_get_ble_scan_para_from_bt(btcoexist, 0x2);
+		if ((coex_sta->bt_ble_scan_type & 0x4) == 0x4)
+			coex_sta->bt_ble_scan_para[2]  = btcoexist->btc_get_ble_scan_para_from_bt(btcoexist, 0x4);
+	}
+
+	halbtc8703b1ant_update_bt_link_info(btcoexist);
+
+	halbtc8703b1ant_run_coexist_mechanism(btcoexist);
+}
+
+
+void ex_halbtc8703b1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->stop_coex_dm = false;
+#if 0
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+				 BT_8703B_1ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+					 BT_8703B_1ANT_SCOREBOARD_ONOFF, true);
+#endif
+		/*	halbtc8703b1ant_init_hw_config(btcoexist, false, false); */
+	} else if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+				BT_8703B_1ANT_SCOREBOARD_ACTIVE |
+				BT_8703B_1ANT_SCOREBOARD_ONOFF |
+				BT_8703B_1ANT_SCOREBOARD_SCAN |
+				BT_8703B_1ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8703B_1ANT_PHASE_WLAN_OFF);
+
+		btcoexist->stop_coex_dm = true;
+
+	}
+}
+
+void ex_halbtc8703b1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8703b1ant_post_state_to_bt(btcoexist,
+				BT_8703B_1ANT_SCOREBOARD_ACTIVE |
+				BT_8703B_1ANT_SCOREBOARD_ONOFF |
+				BT_8703B_1ANT_SCOREBOARD_SCAN |
+				BT_8703B_1ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+	halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+	halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+				     BT_8703B_1ANT_PHASE_WLAN_OFF);
+
+	ex_halbtc8703b1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	halbtc8703b1ant_enable_gnt_to_gpio(btcoexist, false);
+
+	btcoexist->stop_coex_dm = true;
+}
+
+void ex_halbtc8703b1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if ((BTC_WIFI_PNP_SLEEP == pnp_state) ||
+	    (BTC_WIFI_PNP_SLEEP_KEEP_ANT == pnp_state)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+				BT_8703B_1ANT_SCOREBOARD_ACTIVE |
+				BT_8703B_1ANT_SCOREBOARD_ONOFF |
+				BT_8703B_1ANT_SCOREBOARD_SCAN |
+				BT_8703B_1ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		if (BTC_WIFI_PNP_SLEEP_KEEP_ANT == pnp_state) {
+
+			halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+						     FORCE_EXEC,
+					     BT_8703B_1ANT_PHASE_2G_RUNTIME);
+		} else {
+
+			halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+						     FORCE_EXEC,
+					     BT_8703B_1ANT_PHASE_WLAN_OFF);
+		}
+
+		btcoexist->stop_coex_dm = true;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+#if 0
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+				 BT_8703B_1ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8703b1ant_post_state_to_bt(btcoexist,
+							 BT_8703B_1ANT_SCOREBOARD_ONOFF, true);
+#endif
+		btcoexist->stop_coex_dm = false;
+	}
+}
+
+void ex_halbtc8703b1ant_coex_dm_reset(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], *****************Coex DM Reset*****************\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8703b1ant_init_hw_config(btcoexist, false, false);
+	halbtc8703b1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8703b1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	u32	bt_patch_ver;
+	boolean wifi_busy = false;
+
+#if (BT_AUTO_REPORT_ONLY_8703B_1ANT == 0)
+	halbtc8703b1ant_query_bt_info(btcoexist);
+#endif
+
+	halbtc8703b1ant_monitor_bt_ctr(btcoexist);
+	halbtc8703b1ant_monitor_wifi_ctr(btcoexist);
+
+	halbtc8703b1ant_monitor_bt_enable_disable(btcoexist);
+
+#if 0
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+		/* halbtc8703b1ant_read_score_board(btcoexist, &bt_scoreboard_val); */
+
+		if (wifi_busy) {
+			halbtc8703b1ant_post_state_to_bt(btcoexist,
+					BT_8703B_1ANT_SCOREBOARD_UNDERTEST, true);
+			/*
+			halbtc8703b1ant_post_state_to_bt(btcoexist,
+						 BT_8703B_1ANT_SCOREBOARD_WLBUSY, true);
+
+			if (bt_scoreboard_val & BIT(6))
+				halbtc8703b1ant_query_bt_info(btcoexist); */
+		} else {
+			halbtc8703b1ant_post_state_to_bt(btcoexist,
+						BT_8703B_1ANT_SCOREBOARD_UNDERTEST, false);
+			/*
+			halbtc8703b1ant_post_state_to_bt(btcoexist,
+						BT_8703B_1ANT_SCOREBOARD_WLBUSY,
+						false);  */
+		}
+#endif
+
+
+	/* for 4-way, DHCP, EAPOL packet */
+	if (coex_sta->specific_pkt_period_cnt > 0) {
+
+		coex_sta->specific_pkt_period_cnt--;
+
+		if ((coex_sta->specific_pkt_period_cnt == 0) &&
+		    (coex_sta->wifi_is_high_pri_task))
+			coex_sta->wifi_is_high_pri_task = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ***************** Hi-Pri Task = %s*****************\n",
+			    (coex_sta->wifi_is_high_pri_task ? "Yes" :
+			     "No"));
+		BTC_TRACE(trace_buf);
+
+	}
+
+	if (!coex_sta->bt_disabled) {
+		if (coex_sta->bt_coex_supported_feature == 0)
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_FEATURE,
+						&coex_sta->bt_coex_supported_feature);
+
+		if ((coex_sta->bt_coex_supported_version == 0) ||
+			 (coex_sta->bt_coex_supported_version == 0xffff))
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION,
+						&coex_sta->bt_coex_supported_version);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+		btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+	}
+
+	if (halbtc8703b1ant_is_wifibt_status_changed(btcoexist))
+		halbtc8703b1ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8703b1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+	/* No Antenna Detection required because 8730b is only 1-Ant */
+}
+
+void ex_halbtc8703b1ant_antenna_isolation(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+
+}
+
+void ex_halbtc8703b1ant_psd_scan(IN struct btc_coexist *btcoexist,
+		 IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+
+}
+
+void ex_halbtc8703b1ant_display_ant_detection(IN struct btc_coexist *btcoexist)
+{
+
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8703b1ant.h
@@ -0,0 +1,404 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8703B_SUPPORT == 1)
+/* *******************************************
+ * The following is for 8703B 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8703B_1ANT				1
+#define BT_8703B_1ANT_ENABLE_GNTBT_TO_GPIO14		0
+
+#define	BT_INFO_8703B_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8703B_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8703B_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8703B_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8703B_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8703B_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8703B_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8703B_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8703B_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+	(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT		2
+
+#define  BT_8703B_1ANT_WIFI_NOISY_THRESH							50   /* max: 255 */
+
+/* for Antenna detection */
+#define	BT_8703B_1ANT_ANTDET_PSDTHRES_BACKGROUND					50
+#define	BT_8703B_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION				70
+#define	BT_8703B_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION			55
+#define	BT_8703B_1ANT_ANTDET_PSDTHRES_1ANT							35
+#define	BT_8703B_1ANT_ANTDET_RETRY_INTERVAL							10	/* retry timer if ant det is fail, unit: second */
+#define	BT_8703B_1ANT_ANTDET_SWEEPPOINT_DELAY							40000
+#define	BT_8703B_1ANT_ANTDET_ENABLE									0
+#define	BT_8703B_1ANT_ANTDET_COEXMECHANISMSWITCH_ENABLE				0
+
+#define	BT_8703B_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT		30000
+
+enum bt_8703b_1ant_signal_state {
+	BT_8703B_1ANT_SIG_STA_SET_TO_LOW		= 0x0,
+	BT_8703B_1ANT_SIG_STA_SET_BY_HW		= 0x0,
+	BT_8703B_1ANT_SIG_STA_SET_TO_HIGH		= 0x1,
+	BT_8703B_1ANT_SIG_STA_MAX
+};
+
+enum bt_8703b_1ant_path_ctrl_owner {
+	BT_8703B_1ANT_PCO_BTSIDE		= 0x0,
+	BT_8703B_1ANT_PCO_WLSIDE	= 0x1,
+	BT_8703B_1ANT_PCO_MAX
+};
+
+enum bt_8703b_1ant_gnt_ctrl_type {
+	BT_8703B_1ANT_GNT_TYPE_CTRL_BY_PTA		= 0x0,
+	BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW		= 0x1,
+	BT_8703B_1ANT_GNT_TYPE_MAX
+};
+
+enum bt_8703b_1ant_gnt_ctrl_block {
+	BT_8703B_1ANT_GNT_BLOCK_RFC_BB		= 0x0,
+	BT_8703B_1ANT_GNT_BLOCK_RFC			= 0x1,
+	BT_8703B_1ANT_GNT_BLOCK_BB			= 0x2,
+	BT_8703B_1ANT_GNT_BLOCK_MAX
+};
+
+enum bt_8703b_1ant_lte_coex_table_type {
+	BT_8703B_1ANT_CTT_WL_VS_LTE			= 0x0,
+	BT_8703B_1ANT_CTT_BT_VS_LTE			= 0x1,
+	BT_8703B_1ANT_CTT_MAX
+};
+
+enum bt_8703b_1ant_lte_break_table_type {
+	BT_8703B_1ANT_LBTT_WL_BREAK_LTE			= 0x0,
+	BT_8703B_1ANT_LBTT_BT_BREAK_LTE				= 0x1,
+	BT_8703B_1ANT_LBTT_LTE_BREAK_WL			= 0x2,
+	BT_8703B_1ANT_LBTT_LTE_BREAK_BT				= 0x3,
+	BT_8703B_1ANT_LBTT_MAX
+};
+
+enum bt_info_src_8703b_1ant {
+	BT_INFO_SRC_8703B_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8703B_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8703B_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8703B_1ANT_MAX
+};
+
+enum bt_8703b_1ant_bt_status {
+	BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8703B_1ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8703B_1ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8703B_1ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8703B_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8703b_1ant_wifi_status {
+	BT_8703B_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8703B_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8703B_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8703B_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT				= 0x3,
+	BT_8703B_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8703B_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8703B_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8703b_1ant_coex_algo {
+	BT_8703B_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8703B_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8703B_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8703B_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8703B_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8703B_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8703B_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8703B_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8703B_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8703B_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8703B_1ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8703B_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+enum bt_8703b_1ant_phase {
+	BT_8703B_1ANT_PHASE_COEX_INIT								= 0x0,
+	BT_8703B_1ANT_PHASE_WLANONLY_INIT							= 0x1,
+	BT_8703B_1ANT_PHASE_WLAN_OFF								= 0x2,
+	BT_8703B_1ANT_PHASE_2G_RUNTIME								= 0x3,
+	BT_8703B_1ANT_PHASE_5G_RUNTIME								= 0x4,
+	BT_8703B_1ANT_PHASE_BTMPMODE								= 0x5,
+	BT_8703B_1ANT_PHASE_ANTENNA_DET								= 0x6,
+	BT_8703B_1ANT_PHASE_MAX
+};
+
+enum bt_8703b_1ant_Scoreboard {
+	BT_8703B_1ANT_SCOREBOARD_ACTIVE								= BIT(0),
+	BT_8703B_1ANT_SCOREBOARD_ONOFF								= BIT(1),
+	BT_8703B_1ANT_SCOREBOARD_SCAN								= BIT(2),
+	BT_8703B_1ANT_SCOREBOARD_UNDERTEST							= BIT(3),
+	BT_8703B_1ANT_SCOREBOARD_WLBUSY								= BIT(6)
+};
+
+
+struct coex_dm_8703b_1ant {
+	/* hw setting */
+	u8		pre_ant_pos_type;
+	u8		cur_ant_pos_type;
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8703b_1ant {
+	boolean				bt_disabled;
+	boolean				bt_link_exist;
+	boolean				sco_exist;
+	boolean				a2dp_exist;
+	boolean				hid_exist;
+	boolean				pan_exist;
+	boolean				bt_hi_pri_link_exist;
+	u8					num_of_profile;
+
+	boolean				under_lps;
+	boolean				under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	boolean             is_hiPri_rx_overhead;
+	s8					bt_rssi;
+	boolean				bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	u8					bt_info_c2h[BT_INFO_SRC_8703B_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8703B_1ANT_MAX];
+	boolean			    bt_whck_test;
+	boolean				c2h_bt_inquiry_page;
+	boolean				c2h_bt_remote_name_req;
+	boolean				c2h_bt_page;				/* Add for win8.1 page out issue */
+	boolean				wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u8					bt_info_ext2;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_vht;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_vht;
+
+	boolean				cck_lock;
+	boolean				pre_ccklock;
+	boolean				cck_ever_lock;
+	u8					coex_table_type;
+
+	boolean				force_lps_on;
+
+	boolean				concurrent_rx_mode_on;
+
+	u16					score_board;
+	u8					isolation_btween_wb;   /* 0~ 50 */
+
+	u8					a2dp_bit_pool;
+	u8					cut_version;
+	boolean				acl_busy;
+	boolean				bt_create_connection;
+
+	u32					bt_coex_supported_feature;
+	u32					bt_coex_supported_version;
+
+	u8					bt_ble_scan_type;
+	u32					bt_ble_scan_para[3];
+
+	boolean				run_time_state;
+	boolean				freeze_coexrun_by_btinfo;
+
+	boolean				is_A2DP_3M;
+	boolean				voice_over_HOGP;
+	u8                  bt_info;
+	boolean				is_autoslot;
+	u8					forbidden_slot;
+	u8					hid_busy_num;
+	u8					hid_pair_cnt;
+
+	u32					cnt_RemoteNameReq;
+	u32					cnt_setupLink;
+	u32					cnt_ReInit;
+	u32					cnt_IgnWlanAct;
+	u32					cnt_Page;
+
+	u16					bt_reg_vendor_ac;
+	u16					bt_reg_vendor_ae;
+
+	boolean				is_setupLink;
+	u8					wl_noisy_level;
+	u32                 gnt_error_cnt;
+
+	u8					bt_afh_map[10];
+	u8					bt_relink_downcount;
+	boolean				is_tdma_btautoslot;
+	boolean				is_tdma_btautoslot_hang;
+};
+
+#define  BT_8703B_1ANT_ANTDET_PSD_POINTS			256	/* MAX:1024 */
+#define  BT_8703B_1ANT_ANTDET_PSD_AVGNUM			1	/* MAX:3 */
+#define	BT_8703B_1ANT_ANTDET_BUF_LEN				16
+
+struct psdscan_sta_8703b_1ant {
+
+	u32			ant_det_bt_le_channel;  /* BT LE Channel ex:2412 */
+	u32			ant_det_bt_tx_time;
+	u32			ant_det_pre_psdscan_peak_val;
+	boolean			ant_det_is_ant_det_available;
+	u32			ant_det_psd_scan_peak_val;
+	boolean			ant_det_is_btreply_available;
+	u32			ant_det_psd_scan_peak_freq;
+
+	u8			ant_det_result;
+	u8			ant_det_peak_val[BT_8703B_1ANT_ANTDET_BUF_LEN];
+	u8			ant_det_peak_freq[BT_8703B_1ANT_ANTDET_BUF_LEN];
+	u32			ant_det_try_count;
+	u32			ant_det_fail_count;
+	u32			ant_det_inteval_count;
+	u32			ant_det_thres_offset;
+
+	u32			real_cent_freq;
+	s32			real_offset;
+	u32			real_span;
+
+	u32			psd_band_width;  /* unit: Hz */
+	u32			psd_point;		/* 128/256/512/1024 */
+	u32			psd_report[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_report_max_hold[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_start_point;
+	u32			psd_stop_point;
+	u32			psd_max_value_point;
+	u32			psd_max_value;
+	u32			psd_start_base;
+	u32			psd_avg_num;	/* 1/8/16/32 */
+	u32			psd_gen_count;
+	boolean			is_psd_running;
+	boolean			is_psd_show_max_only;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8703b1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8703b1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8703b1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8703b1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8703b1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8703b1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8703b1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8703b1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8703b1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8703b1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8703b1ant_coex_dm_reset(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+void ex_halbtc8703b1ant_antenna_isolation(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+
+void ex_halbtc8703b1ant_psd_scan(IN struct btc_coexist *btcoexist,
+		 IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+void ex_halbtc8703b1ant_display_ant_detection(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8703b1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8703b1ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8703b1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8703b1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8703b1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8703b1ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_halt_notify(btcoexist)
+#define	ex_halbtc8703b1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8703b1ant_coex_dm_reset(btcoexist)
+#define	ex_halbtc8703b1ant_periodical(btcoexist)
+#define	ex_halbtc8703b1ant_display_coex_info(btcoexist)
+#define	ex_halbtc8703b1ant_antenna_detection(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8703b1ant_antenna_isolation(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8703b1ant_psd_scan(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8703b1ant_display_ant_detection(btcoexist)
+
+#endif
+
+
+#endif
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8723b1ant.c
@@ -0,0 +1,5113 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8723B Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8723B_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8723b_1ant		glcoex_dm_8723b_1ant;
+static struct  coex_dm_8723b_1ant	*coex_dm = &glcoex_dm_8723b_1ant;
+static struct  coex_sta_8723b_1ant		glcoex_sta_8723b_1ant;
+static struct  coex_sta_8723b_1ant	*coex_sta = &glcoex_sta_8723b_1ant;
+static struct  psdscan_sta_8723b_1ant	gl_psd_scan_8723b_1ant;
+static struct  psdscan_sta_8723b_1ant *psd_scan = &gl_psd_scan_8723b_1ant;
+
+
+const char *const glbt_info_src_8723b_1ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8723b_1ant = 20161007;
+u32	glcoex_ver_8723b_1ant = 0x69;
+u32	glcoex_ver_btdesired_8723b_1ant = 0x69;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8723b1ant_
+ * ************************************************************ */
+
+void halbtc8723b1ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8723b1ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8723b1ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8723b1ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8723b1ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8723b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8723b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8723b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8723b1ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8723b1ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8723b1ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8723b1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8723b1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+void halbtc8723b1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u32		num_of_bt_counter_chk = 0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* to avoid 0x76e[3] = 1 (WLAN_Act control by PTA) during IPS */
+	/* if (! (btcoexist->btc_read_1byte(btcoexist, 0x76e) & 0x8) ) */
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if ((coex_sta->high_priority_tx  + coex_sta->high_priority_rx < 50) &&
+	    (bt_link_info->hid_exist == true))
+		bt_link_info->hid_exist  = false;
+
+	if ((coex_sta->low_priority_tx > 1050)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	if ((coex_sta->low_priority_rx >= 950)  && (!coex_sta->under_ips)
+	    && (coex_sta->low_priority_rx >=
+		coex_sta->low_priority_tx)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		bt_link_info->slave_role = true;
+	else
+		bt_link_info->slave_role = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Hi-Pri Rx/Tx: %d/%d, Lo-Pri Rx/Tx: %d/%d\n",
+		    reg_hp_rx, reg_hp_tx, reg_lp_rx, reg_lp_tx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	/* This part is for wifi FW and driver to update BT's status as disabled. */
+	/* The flow is as the following */
+	/* 1. disable BT */
+	/* 2. if all BT Tx/Rx counter=0, after 6 sec we query bt info */
+	/* 3. Because BT will not rsp from mailbox, so wifi fw will know BT is disabled */
+	/* 4. FW will rsp c2h for BT that driver will know BT is disabled. */
+	if ((reg_hp_tx == 0) && (reg_hp_rx == 0) && (reg_lp_tx == 0) &&
+	    (reg_lp_rx == 0)) {
+		num_of_bt_counter_chk++;
+		if (num_of_bt_counter_chk >= 3) {
+			halbtc8723b1ant_query_bt_info(btcoexist);
+			num_of_bt_counter_chk = 0;
+		}
+	}
+
+}
+
+
+void halbtc8723b1ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+	s32	wifi_rssi = 0;
+	boolean wifi_busy = false, wifi_under_b_mode = false;
+	static u8 cck_lock_counter = 0;
+	u32	total_cnt;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+			   &wifi_under_b_mode);
+
+#if 1
+
+	coex_sta->crc_ok_cck = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_CCK);
+	coex_sta->crc_ok_11g = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_LEGACY);
+	coex_sta->crc_ok_11n = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_HT);
+	coex_sta->crc_ok_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_OK_VHT);
+
+	coex_sta->crc_err_cck = btcoexist->btc_phydm_query_PHY_counter(
+					btcoexist,
+					PHYDM_INFO_CRC32_ERROR_CCK);
+	coex_sta->crc_err_11g =  btcoexist->btc_phydm_query_PHY_counter(
+					 btcoexist,
+					 PHYDM_INFO_CRC32_ERROR_LEGACY);
+	coex_sta->crc_err_11n = btcoexist->btc_phydm_query_PHY_counter(
+					btcoexist,
+					PHYDM_INFO_CRC32_ERROR_HT);
+	coex_sta->crc_err_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_ERROR_VHT);
+
+#endif
+
+	if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+		total_cnt = coex_sta->crc_ok_cck + coex_sta->crc_ok_11g +
+			    coex_sta->crc_ok_11n +
+			    coex_sta->crc_ok_11n_vht;
+
+		if ((coex_dm->bt_status == BT_8723B_1ANT_BT_STATUS_ACL_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8723B_1ANT_BT_STATUS_SCO_BUSY)) {
+			if (coex_sta->crc_ok_cck > (total_cnt -
+						    coex_sta->crc_ok_cck))			{
+				if (cck_lock_counter < 3)
+					cck_lock_counter++;
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+	} else {
+		if (cck_lock_counter > 0)
+			cck_lock_counter--;
+	}
+
+	if (!coex_sta->pre_ccklock) {
+
+		if (cck_lock_counter >= 3)
+			coex_sta->cck_lock = true;
+		else
+			coex_sta->cck_lock = false;
+	} else {
+		if (cck_lock_counter == 0)
+			coex_sta->cck_lock = false;
+		else
+			coex_sta->cck_lock = true;
+	}
+
+	if (coex_sta->cck_lock)
+		coex_sta->cck_ever_lock = true;
+
+	coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+
+}
+
+boolean halbtc8723b1ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+
+
+	}
+
+	return false;
+}
+
+void halbtc8723b1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false, bt_change = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+	} else {
+		bt_disable_cnt++;
+		if (bt_disable_cnt >= 10)
+			bt_disabled = true;
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		bt_change = true;
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_BL_BT_ENABLE_DISABLE_CHANGE,
+				   &bt_change);
+
+		coex_sta->bt_disabled = bt_disabled;
+	} else {
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_BL_BT_ENABLE_DISABLE_CHANGE,
+				   &bt_change);
+	}
+}
+
+void halbtc8723b1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+	bt_link_info->bt_hi_pri_link_exist = coex_sta->bt_hi_pri_link_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+void halbtc8723b1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8723b1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8723b1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8723b1ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf7;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf8;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf9;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8723b1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8723b1ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8723b1ant_sw_mechanism(IN struct btc_coexist *btcoexist,
+				  IN boolean low_penalty_ra)
+{
+	halbtc8723b1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+
+void halbtc8723b1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+
+
+void halbtc8723b1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8723b1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8723b1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+#if BT_8723B_1ANT_ANTDET_ENABLE
+#if BT_8723B_1ANT_ANTDET_COEXMECHANISMSWITCH_ENABLE
+	if (board_info->btdm_ant_num_by_ant_det == 2) {
+		if (type == 3)
+			type = 14;
+		else if (type == 4)
+			type  = 13;
+		else if (type == 5)
+			type = 8;
+	}
+#endif
+#endif
+
+	coex_sta->coex_table_type = type;
+
+	switch (type) {
+	case 0:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 4:
+		if ((coex_sta->cck_ever_lock)  &&
+		    (coex_sta->scan_ap_num <= 5))
+			halbtc8723b1ant_coex_table(btcoexist,
+					   force_exec, 0x55555555, 0xaaaa5a5a,
+						   0xffffff, 0x3);
+		else
+			halbtc8723b1ant_coex_table(btcoexist,
+					   force_exec, 0x55555555, 0x5a5a5a5a,
+						   0xffffff, 0x3);
+		break;
+	case 5:
+		if ((coex_sta->cck_ever_lock)  &&
+		    (coex_sta->scan_ap_num <= 5))
+			halbtc8723b1ant_coex_table(btcoexist,
+					   force_exec, 0x5a5a5a5a, 0x5aaa5a5a,
+						   0xffffff, 0x3);
+		else
+			halbtc8723b1ant_coex_table(btcoexist,
+					   force_exec, 0x5a5a5a5a, 0x5aaa5a5a,
+						   0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 8:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 9:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 10:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 11:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 12:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 13:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 14:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 15:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8723b1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable)
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8723b1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8723b1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8723b1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8723b1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8723b1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8723b1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean force_exec, IN boolean init_hwcfg,
+				  IN boolean wifi_off)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u32			fw_ver = 0, u32tmp = 0, cnt_bt_cal_chk = 0;
+	boolean			pg_ext_switch = false;
+	boolean			use_ext_switch = false;
+	boolean			is_in_mp_mode = false;
+	u8			h2c_parameter[2] = {0}, u8tmp = 0;
+	u32         u32tmp_1[4];
+	boolean		is_fw_ready;
+
+	coex_dm->cur_ant_pos_type = ant_pos_type;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_EXT_SWITCH, &pg_ext_switch);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER,
+			   &fw_ver);	/* [31:16]=fw ver, [15:0]=fw sub ver */
+
+	if ((fw_ver > 0 && fw_ver < 0xc0000) || pg_ext_switch)
+		use_ext_switch = true;
+
+#if BT_8723B_1ANT_ANTDET_ENABLE
+#if BT_8723B_1ANT_ANTDET_COEXMECHANISMSWITCH_ENABLE
+	if (ant_pos_type == BTC_ANT_PATH_PTA) {
+		if ((board_info->btdm_ant_det_finish) &&
+		    (board_info->btdm_ant_num_by_ant_det == 2)) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type = BTC_ANT_PATH_WIFI;
+			else
+				ant_pos_type = BTC_ANT_PATH_BT;
+		}
+	}
+#endif
+#endif
+
+	if (init_hwcfg) {
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x780); /* WiFi TRx Mask on */
+		/* remove due to interrupt is disabled that polling c2h will fail and delay 100ms. */
+		/* btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x3c, 0x15); */ /*BT TRx Mask on */
+
+		if (fw_ver >= 0x180000) {
+			/* Use H2C to set GNT_BT to HIGH */
+			h2c_parameter[0] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1,
+						h2c_parameter);
+
+			cnt_bt_cal_chk = 0;
+			while (1) {
+				btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_FW_READY, &is_fw_ready);
+				if (is_fw_ready == false) {
+					BTC_SPRINTF(trace_buf , BT_TMP_BUF_SIZE,
+						("halbtc8723b1ant_set_ant_path(): we don't need to wait for H2C command completion because of Fw download fail!!!\n"));
+					BTC_TRACE(trace_buf);
+					break;
+				}
+
+				if (btcoexist->btc_read_1byte(btcoexist,
+							      0x765) == 0x18)
+					break;
+
+				cnt_bt_cal_chk++;
+				if (cnt_bt_cal_chk > 20)
+					break;
+			}
+		} else {
+			/* set grant_bt to high */
+			btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+		}
+		/* set wlan_act control by PTA */
+		btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+			   0x0); /* BT select s0/s1 is controlled by BT */
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x39, 0x8, 0x1);
+		btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x944, 0x3, 0x3);
+		btcoexist->btc_write_1byte(btcoexist, 0x930, 0x77);
+	} else if (wifi_off) {
+		if (fw_ver >= 0x180000) {
+			/* Use H2C to set GNT_BT to HIGH */
+			h2c_parameter[0] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1,
+						h2c_parameter);
+
+			cnt_bt_cal_chk = 0;
+			while (1) {
+				btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_FW_READY, &is_fw_ready);
+				if (is_fw_ready == false) {
+					BTC_SPRINTF(trace_buf , BT_TMP_BUF_SIZE,
+						("halbtc8723b1ant_set_ant_path(): we don't need to wait for H2C command completion because of Fw download fail!!!\n"));
+					BTC_TRACE(trace_buf);
+					break;
+				}
+
+				if (btcoexist->btc_read_1byte(btcoexist,
+							      0x765) == 0x18)
+					break;
+
+				cnt_bt_cal_chk++;
+				if (cnt_bt_cal_chk > 20)
+					break;
+			}
+		} else {
+			/* set grant_bt to high */
+			btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+		}
+		/* set wlan_act to always low */
+		btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_IS_IN_MP_MODE,
+				   &is_in_mp_mode);
+		if (!is_in_mp_mode)
+			btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67,
+				0x20, 0x0); /* BT select s0/s1 is controlled by BT */
+		else
+			btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67,
+				0x20, 0x1); /* BT select s0/s1 is controlled by WiFi */
+
+		/* 0x4c[24:23]=00, Set Antenna control by BT_RFE_CTRL	BT Vendor 0xac=0xf002 */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp &= ~BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+	} else {
+		/* Use H2C to set GNT_BT to LOW */
+		if (fw_ver >= 0x180000) {
+			if (btcoexist->btc_read_1byte(btcoexist, 0x765) != 0) {
+				h2c_parameter[0] = 0;
+				btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1,
+							h2c_parameter);
+
+				cnt_bt_cal_chk = 0;
+				while (1) {
+					btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_FW_READY, &is_fw_ready);
+					if (is_fw_ready == false) {
+						BTC_SPRINTF(trace_buf ,
+							    BT_TMP_BUF_SIZE,
+							("halbtc8723b1ant_set_ant_path(): we don't need to wait for H2C command completion because of Fw download fail!!!\n"));
+						BTC_TRACE(trace_buf);
+						break;
+					}
+
+					if (btcoexist->btc_read_1byte(btcoexist,
+							      0x765) == 0x0)
+						break;
+
+					cnt_bt_cal_chk++;
+					if (cnt_bt_cal_chk > 20)
+						break;
+				}
+			}
+		} else {
+			/* BT calibration check */
+			while (cnt_bt_cal_chk <= 20) {
+				u8tmp = btcoexist->btc_read_1byte(btcoexist,
+								  0x49d);
+				cnt_bt_cal_chk++;
+				if (u8tmp & BIT(0)) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], ########### BT is calibrating (wait cnt=%d) ###########\n",
+						    cnt_bt_cal_chk);
+					BTC_TRACE(trace_buf);
+					delay_ms(50);
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], ********** BT is NOT calibrating (wait cnt=%d)**********\n",
+						    cnt_bt_cal_chk);
+					BTC_TRACE(trace_buf);
+					break;
+				}
+			}
+
+			/* set grant_bt to PTA */
+			btcoexist->btc_write_1byte(btcoexist, 0x765, 0x0);
+		}
+
+		if (btcoexist->btc_read_1byte(btcoexist, 0x76e) != 0xc) {
+			/* set wlan_act control by PTA */
+			btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+		}
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+			   0x1); /* BT select s0/s1 is controlled by WiFi */
+	}
+
+	if (use_ext_switch) {
+		if (init_hwcfg) {
+			/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+			u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+			u32tmp &= ~BIT(23);
+			u32tmp |= BIT(24);
+			btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+
+			u32tmp_1[0] = btcoexist->btc_read_4byte(btcoexist,
+								0x948);
+			if ((u32tmp_1[0] == 0x40) || (u32tmp_1[0] == 0x240))
+				btcoexist->btc_write_4byte(btcoexist, 0x948,
+							   u32tmp_1[0]);
+			else
+				btcoexist->btc_write_4byte(btcoexist, 0x948,
+							   0x0);
+
+
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT) {
+				/* tell firmware "no antenna inverse" */
+				h2c_parameter[0] = 0;
+				h2c_parameter[1] = 1;  /* ext switch type */
+				btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+							h2c_parameter);
+			} else {
+				/* tell firmware "antenna inverse" */
+				h2c_parameter[0] = 1;
+				h2c_parameter[1] = 1;  /* ext switch type */
+				btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+							h2c_parameter);
+			}
+		}
+
+		if (force_exec ||
+		    (coex_dm->cur_ant_pos_type !=
+		     coex_dm->pre_ant_pos_type)) {
+			/* ext switch setting */
+			switch (ant_pos_type) {
+			case BTC_ANT_PATH_WIFI:
+				if (board_info->btdm_ant_pos ==
+				    BTC_ANTENNA_AT_MAIN_PORT)
+					btcoexist->btc_write_1byte_bitmask(
+						btcoexist, 0x92c, 0x3,
+						0x1);
+				else
+					btcoexist->btc_write_1byte_bitmask(
+						btcoexist, 0x92c, 0x3,
+						0x2);
+				break;
+			case BTC_ANT_PATH_BT:
+				if (board_info->btdm_ant_pos ==
+				    BTC_ANTENNA_AT_MAIN_PORT)
+					btcoexist->btc_write_1byte_bitmask(
+						btcoexist, 0x92c, 0x3,
+						0x2);
+				else
+					btcoexist->btc_write_1byte_bitmask(
+						btcoexist, 0x92c, 0x3,
+						0x1);
+				break;
+			default:
+			case BTC_ANT_PATH_PTA:
+				if (board_info->btdm_ant_pos ==
+				    BTC_ANTENNA_AT_MAIN_PORT)
+					btcoexist->btc_write_1byte_bitmask(
+						btcoexist, 0x92c, 0x3,
+						0x1);
+				else
+					btcoexist->btc_write_1byte_bitmask(
+						btcoexist, 0x92c, 0x3,
+						0x2);
+				break;
+			}
+		}
+	} else {
+		if (init_hwcfg) {
+			/* 0x4c[23]=1, 0x4c[24]=0  Antenna control by 0x64 */
+			u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+			u32tmp |= BIT(23);
+			u32tmp &= ~BIT(24);
+			btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+			/* Fix Ext switch Main->S1, Aux->S0 */
+			btcoexist->btc_write_1byte_bitmask(btcoexist, 0x64, 0x1,
+							   0x0);
+
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT) {
+
+				/* tell firmware "no antenna inverse" */
+				h2c_parameter[0] = 0;
+				h2c_parameter[1] =
+					0;  /* internal switch type */
+				btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+							h2c_parameter);
+			} else {
+
+				/* tell firmware "antenna inverse" */
+				h2c_parameter[0] = 1;
+				h2c_parameter[1] =
+					0;  /* internal switch type */
+				btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+							h2c_parameter);
+			}
+		}
+
+		if (force_exec ||
+		    (coex_dm->cur_ant_pos_type !=
+		     coex_dm->pre_ant_pos_type)) {
+			/* internal switch setting */
+			switch (ant_pos_type) {
+			case BTC_ANT_PATH_WIFI:
+				if (board_info->btdm_ant_pos ==
+				    BTC_ANTENNA_AT_MAIN_PORT) {
+					u32tmp_1[0] = btcoexist->btc_read_4byte(
+							      btcoexist, 0x948);
+					if ((u32tmp_1[0] == 0x40) ||
+					    (u32tmp_1[0] == 0x240))
+						btcoexist->btc_write_4byte(
+							btcoexist, 0x948,
+							u32tmp_1[0]);
+					else
+						btcoexist->btc_write_4byte(
+							btcoexist, 0x948, 0x0);
+				} else {
+					u32tmp_1[0] = btcoexist->btc_read_4byte(
+							      btcoexist, 0x948);
+					if ((u32tmp_1[0] == 0x40) ||
+					    (u32tmp_1[0] == 0x240))
+						btcoexist->btc_write_4byte(
+							btcoexist, 0x948,
+							u32tmp_1[0]);
+					else
+						btcoexist->btc_write_4byte(
+							btcoexist, 0x948,
+							0x280);
+				}
+				break;
+			case BTC_ANT_PATH_BT:
+				if (board_info->btdm_ant_pos ==
+				    BTC_ANTENNA_AT_MAIN_PORT) {
+					u32tmp_1[0] = btcoexist->btc_read_4byte(
+							      btcoexist, 0x948);
+					if ((u32tmp_1[0] == 0x40) ||
+					    (u32tmp_1[0] == 0x240))
+						btcoexist->btc_write_4byte(
+							btcoexist, 0x948,
+							u32tmp_1[0]);
+					else
+						btcoexist->btc_write_4byte(
+							btcoexist, 0x948,
+							0x280);
+				} else {
+					u32tmp_1[0] = btcoexist->btc_read_4byte(
+							      btcoexist, 0x948);
+					if ((u32tmp_1[0] == 0x40) ||
+					    (u32tmp_1[0] == 0x240))
+						btcoexist->btc_write_4byte(
+							btcoexist, 0x948,
+							u32tmp_1[0]);
+					else
+						btcoexist->btc_write_4byte(
+							btcoexist, 0x948, 0x0);
+				}
+				break;
+			default:
+			case BTC_ANT_PATH_PTA:
+				if (board_info->btdm_ant_pos ==
+				    BTC_ANTENNA_AT_MAIN_PORT)
+					btcoexist->btc_write_4byte(
+						btcoexist, 0x948,
+						0x200);
+				else
+					btcoexist->btc_write_4byte(
+						btcoexist, 0x948, 0x80);
+				break;
+			}
+		}
+	}
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+}
+
+void halbtc8723b1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0x8, 0, 0, 0, 0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			/* halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+				h2c_parameter);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			/* halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+				h2c_parameter);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+
+void halbtc8723b1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8723b1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8723b1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8723b1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+
+void halbtc8723b1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean		ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8723b1ant_power_save_state(btcoexist,
+				BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		}
+	} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			halbtc8723b1ant_power_save_state(btcoexist,
+				BTC_PS_LPS_ON, 0x50, 0x4);
+
+	} else {
+			halbtc8723b1ant_power_save_state(btcoexist,
+				BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+	}
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+
+void halbtc8723b1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_busy = false;
+	u8			rssi_adjust_val = 0;
+	u8			ps_tdma_byte4_val = 0x50, ps_tdma_byte0_val = 0x51,
+				ps_tdma_byte3_val =  0x10;
+	s8			wifi_duration_adjust = 0x0;
+	static boolean	 pre_wifi_busy = false;
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+#if BT_8723B_1ANT_ANTDET_ENABLE
+#if BT_8723B_1ANT_ANTDET_COEXMECHANISMSWITCH_ENABLE
+	if (board_info->btdm_ant_num_by_ant_det == 2) {
+		if (turn_on)
+			type = type +
+			       100; /* for WiFi RSSI low or BT RSSI low */
+		else
+			type = 1; /* always translate to TDMA(off,1) for TDMA-off case */
+	}
+
+#endif
+#endif
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (wifi_busy != pre_wifi_busy) {
+		force_exec = true;
+		pre_wifi_busy = wifi_busy;
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (coex_sta->scan_ap_num <= 5) {
+		wifi_duration_adjust = 5;
+
+		if (coex_sta->a2dp_bit_pool >= 35)
+			wifi_duration_adjust = -10;
+		else if (coex_sta->a2dp_bit_pool >= 45)
+			wifi_duration_adjust = -15;
+	} else if (coex_sta->scan_ap_num >= 40) {
+		wifi_duration_adjust = -15;
+
+		if (coex_sta->a2dp_bit_pool < 35)
+			wifi_duration_adjust = -5;
+		else if (coex_sta->a2dp_bit_pool < 45)
+			wifi_duration_adjust = -10;
+	} else if (coex_sta->scan_ap_num >= 20) {
+		wifi_duration_adjust = -10;
+
+		if (coex_sta->a2dp_bit_pool >= 45)
+			wifi_duration_adjust = -15;
+	} else {
+		wifi_duration_adjust = 0;
+
+		if (coex_sta->a2dp_bit_pool >= 35)
+			wifi_duration_adjust = -10;
+		else if (coex_sta->a2dp_bit_pool >= 45)
+			wifi_duration_adjust = -15;
+	}
+
+	if ((type == 1) || (type == 2) || (type == 9) || (type == 11) ||
+	    (type == 101)
+	    || (type == 102) || (type == 109) || (type == 101)) {
+		if (!coex_sta->force_lps_on) { /* Native power save TDMA, only for A2DP-only case 1/2/9/11 while wifi noisy threshold > 30 */
+			ps_tdma_byte0_val = 0x61;  /* no null-pkt */
+			ps_tdma_byte3_val = 0x11; /* no tx-pause at BT-slot */
+			ps_tdma_byte4_val =
+				0x10; /* 0x778 = d/1 toggle, no dynamic slot */
+		} else {
+			ps_tdma_byte0_val = 0x51;  /* null-pkt */
+			ps_tdma_byte3_val = 0x10; /* tx-pause at BT-slot */
+			ps_tdma_byte4_val =
+				0x50; /* 0x778 = d/1 toggle, dynamic slot */
+		}
+	} else if ((type == 3) || (type == 13) || (type == 14) ||
+		   (type == 103) || (type == 113) || (type == 114)) {
+		ps_tdma_byte0_val = 0x51;  /* null-pkt */
+		ps_tdma_byte3_val = 0x10; /* tx-pause at BT-slot */
+		ps_tdma_byte4_val =
+			0x10; /* 0x778 = d/1 toggle, no dynamic slot */
+#if 0
+		if (!wifi_busy)
+			ps_tdma_byte4_val = ps_tdma_byte4_val |
+				0x1;  /* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+#endif
+	} else { /* native power save case */
+		ps_tdma_byte0_val = 0x61;  /* no null-pkt */
+		ps_tdma_byte3_val = 0x11; /* no tx-pause at BT-slot */
+		ps_tdma_byte4_val =
+			0x11; /* 0x778 = d/1 toggle, no dynamic slot */
+		/* psTdmaByte4Va is not defne for 0x778 = d/1, 1/1 case */
+	}
+
+	/* if (bt_link_info->slave_role == true) */
+	if ((bt_link_info->slave_role == true)	&& (bt_link_info->a2dp_exist))
+		ps_tdma_byte4_val = ps_tdma_byte4_val |
+			0x1;  /* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+
+	if (type > 100) {
+		ps_tdma_byte0_val = ps_tdma_byte0_val |
+				    0x82; /* set antenna control by SW	 */
+		ps_tdma_byte3_val = ps_tdma_byte3_val |
+			0x60;  /* set antenna no toggle, control by antenna diversity */
+	}
+
+
+	if (turn_on) {
+		switch (type) {
+		default:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x1a, 0x1a, 0x0, ps_tdma_byte4_val);
+			break;
+		case 1:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x3a +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 2:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x2d +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 3:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x30, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 4:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x14, 0x0);
+			break;
+		case 5:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x1f, 0x3,
+						      ps_tdma_byte3_val, 0x11);
+			break;
+		case 6:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x20, 0x3,
+						      ps_tdma_byte3_val, 0x11);
+			break;
+		case 7:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xc, 0x5, 0x0, 0x0);
+			break;
+		case 8:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 9:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 10:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0xa, 0x0, 0x40);
+			break;
+		case 11:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 12:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x0a, 0x0a, 0x0, 0x50);
+			break;
+		case 13:
+			if (coex_sta->scan_ap_num <= 3)
+				halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x40, 0x3,
+							      ps_tdma_byte3_val,
+						      ps_tdma_byte4_val);
+			else
+				halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+							      ps_tdma_byte3_val,
+						      ps_tdma_byte4_val);
+			break;
+		case 14:
+			if (coex_sta->scan_ap_num <= 3)
+				halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x30, 0x3, 0x10, 0x50);
+			else
+				halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+							      ps_tdma_byte3_val,
+						      ps_tdma_byte4_val);
+			break;
+		case 15:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0x3, 0x8, 0x0);
+			break;
+		case 16:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x10, 0x0);
+			break;
+		case 18:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 20:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x3f, 0x03,
+						      ps_tdma_byte3_val, 0x10);
+			break;
+		case 21:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x11);
+			break;
+		case 22:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x25, 0x03,
+						      ps_tdma_byte3_val, 0x10);
+			break;
+		case 23:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x18);
+			break;
+		case 24:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x3, 0x31, 0x18);
+			break;
+		case 25:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 26:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 27:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x98);
+			break;
+		case 28:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x69,
+						      0x25, 0x3, 0x31, 0x0);
+			break;
+		case 29:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xab,
+						      0x1a, 0x1a, 0x1, 0x10);
+			break;
+		case 30:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x10);
+			break;
+		case 31:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1a, 0x1a, 0, 0x58);
+			break;
+		case 32:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x35, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 33:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x35, 0x3,
+						      ps_tdma_byte3_val, 0x10);
+			break;
+		case 34:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 35:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x63,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 36:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x12, 0x3, 0x14, 0x50);
+			break;
+		case 40: /* SoftAP only with no sta associated,BT disable ,TDMA mode for power saving */
+			/* here softap mode screen off will cost 70-80mA for phone */
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x23,
+						      0x18, 0x00, 0x10, 0x24);
+			break;
+
+		/* for 1-Ant translate to 2-Ant	 */
+		case 101:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x3a +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 102:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x2d +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 103:
+			/* halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x51, 0x1d, 0x1d, 0x0, ps_tdma_byte4_val); */
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x3a, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 105:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x15, 0x3,
+						      ps_tdma_byte3_val, 0x11);
+			break;
+		case 106:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x20, 0x3,
+						      ps_tdma_byte3_val, 0x11);
+			break;
+		case 109:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 111:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 113:
+			/* halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x51, 0x12, 0x12, 0x0, ps_tdma_byte4_val); */
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 114:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 120:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x3f, 0x03,
+						      ps_tdma_byte3_val, 0x10);
+			break;
+		case 122:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x25, 0x03,
+						      ps_tdma_byte3_val, 0x10);
+			break;
+		case 132:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x25, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 133:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x25, 0x03,
+						      ps_tdma_byte3_val, 0x11);
+			break;
+
+		}
+	} else {
+
+		/* disable PS tdma */
+		switch (type) {
+		case 8: /* PTA Control */
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 0:
+		default:  /* Software control, Antenna at BT side */
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 1: /* 2-Ant, 0x778=3, antenna control by antenna diversity */
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x48, 0x0);
+			break;
+		}
+	}
+	rssi_adjust_val = 0;
+	btcoexist->btc_set(btcoexist,
+		BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE, &rssi_adjust_val);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x\n",
+		    btcoexist->btc_read_4byte(btcoexist, 0x948),
+		    btcoexist->btc_read_1byte(btcoexist, 0x765),
+		    btcoexist->btc_read_1byte(btcoexist, 0x67));
+	BTC_TRACE(trace_buf);
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8723b1ant_tdma_duration_adjust_for_acl(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0, bt_info_ext;
+	boolean			wifi_busy = false;
+
+	if (BT_8723B_1ANT_WIFI_STATUS_CONNECTED_BUSY == wifi_status)
+		wifi_busy = true;
+	else
+		wifi_busy = false;
+
+	if ((BT_8723B_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN ==
+	     wifi_status) ||
+	    (BT_8723B_1ANT_WIFI_STATUS_CONNECTED_SCAN == wifi_status) ||
+	    (BT_8723B_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT ==
+	     wifi_status)) {
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 3 &&
+		    coex_dm->cur_ps_tdma != 9) {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						9);
+			coex_dm->ps_tdma_du_adj_type = 9;
+
+			up = 0;
+			dn = 0;
+			m = 1;
+			n = 3;
+			result = 0;
+			wait_count = 0;
+		}
+		return;
+	}
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 2);
+		coex_dm->ps_tdma_du_adj_type = 2;
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* acquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		bt_info_ext = coex_sta->bt_info_ext;
+
+		if ((coex_sta->low_priority_tx) > 1050 ||
+		    (coex_sta->low_priority_rx) > 1250)
+			retry_count++;
+
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if retry count during continuous n*2 seconds is 0, enlarge WiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if continuous 2 retry count(every 2 seconds) >0 and < 3, reduce WiFi duration */
+				if (wait_count <= 2)
+					m++; /* to avoid loop between the two levels */
+				else
+					m = 1;
+
+				if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, once retry count > 3, to reduce WiFi duration */
+			if (wait_count == 1)
+				m++; /* to avoid loop between the two levels */
+			else
+				m = 1;
+
+			if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (result == -1) {
+			/*		if( (BT_INFO_8723B_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+						((coex_dm->cur_ps_tdma == 1) ||(coex_dm->cur_ps_tdma == 2)) )
+					{
+						halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+						coex_dm->ps_tdma_du_adj_type = 9;
+					}
+					else */ if (coex_dm->cur_ps_tdma == 1) {
+							halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 11);
+				coex_dm->ps_tdma_du_adj_type = 11;
+			}
+		} else if (result == 1) {
+			/*			if( (BT_INFO_8723B_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+							((coex_dm->cur_ps_tdma == 1) ||(coex_dm->cur_ps_tdma == 2)) )
+						{
+							halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+							coex_dm->ps_tdma_du_adj_type = 9;
+						}
+						else */ if (coex_dm->cur_ps_tdma == 11) {
+								halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+								true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 1);
+				coex_dm->ps_tdma_du_adj_type = 1;
+			}
+		} else { /* no change */
+			/* Bryant Modify
+			if(wifi_busy != pre_wifi_busy)
+			{
+				pre_wifi_busy = wifi_busy;
+				halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, true, coex_dm->cur_ps_tdma);
+			}
+			*/
+
+		}
+
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 9 &&
+		    coex_dm->cur_ps_tdma != 11) {
+			/* recover to previous adjust type */
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		}
+	}
+}
+
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+void halbtc8723b1ant_action_bt_whck_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC,
+				     false, false);
+	halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+
+void halbtc8723b1ant_action_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8723b1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_connected = false, ap_enable = false, wifi_busy = false,
+				bt_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	if (coex_sta->bt_abnormal_scan) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+					33);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	} else if ((!wifi_connected) && (!coex_sta->wifi_is_high_pri_task)) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+		   (bt_link_info->a2dp_exist)) {
+		/* SCO/HID/A2DP  busy */
+
+		if (coex_sta->c2h_bt_remote_name_req)
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						33);
+		else
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if ((bt_link_info->pan_exist) || (wifi_busy)) {
+
+		if (coex_sta->c2h_bt_remote_name_req)
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						33);
+		else
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+
+	}
+}
+
+void halbtc8723b1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	/* tdma and coex table */
+
+	if (bt_link_info->sco_exist) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	} else { /* HID */
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 6);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	}
+}
+
+void halbtc8723b1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+	halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, FORCE_EXEC,
+				     false, false);
+}
+
+void halbtc8723b1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC,
+				     false, false);
+	halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8723b1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	if ((coex_sta->low_priority_rx >= 950)  && (!coex_sta->under_ips))
+		bt_link_info->slave_role = true;
+	else
+		bt_link_info->slave_role = false;
+
+	if (bt_link_info->hid_only) { /* HID */
+		halbtc8723b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				wifi_status);
+		coex_dm->auto_tdma_adjust = false;
+		return;
+	} else if (bt_link_info->a2dp_only) { /* A2DP		 */
+		if (BT_8723B_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifi_status) {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = false;
+		} else {
+			halbtc8723b1ant_tdma_duration_adjust_for_acl(btcoexist,
+					wifi_status);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = true;
+		}
+	} else if (((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	} else if (bt_link_info->hid_exist &&
+		   bt_link_info->a2dp_exist) { /* HID+A2DP */
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+		coex_dm->auto_tdma_adjust = false;
+
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if ((bt_link_info->pan_only) || (bt_link_info->hid_exist &&
+		bt_link_info->pan_exist)) { /* PAN(OPP,FTP), HID+PAN(OPP,FTP)			 */
+
+		if (BT_8723B_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifi_status)
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						9);
+		else
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						3);
+
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		/* BT no-profile busy (0x9) */
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	}
+}
+
+void halbtc8723b1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+
+	/* tdma and coex table */
+	halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC,
+				     false, false);
+	halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8723b1ant_action_wifi_not_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* tdma and coex table */
+	if (BT_8723B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8723B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8723b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8723B_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8723b1ant_action_wifi_not_connected_asso_auth(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist)  || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 4);
+	} else {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 2);
+	}
+}
+
+void halbtc8723b1ant_action_wifi_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* tdma and coex table */
+	if (BT_8723B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8723B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8723b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8723B_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8723b1ant_action_wifi_connected_specific_packet(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	/* no specific packet process for both WiFi and BT very busy */
+	if ((wifi_busy) && ((bt_link_info->pan_exist) ||
+			    (coex_sta->num_of_profile >= 2)))
+		return;
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist)) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	} else if (bt_link_info->a2dp_exist) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8723b1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	boolean	wifi_busy = false;
+	boolean		scan = false, link = false, roam = false;
+	boolean		under_4way = false, ap_enable = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+	if (under_4way) {
+		halbtc8723b1ant_action_wifi_connected_specific_packet(
+			btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under 4way<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	if (scan || link || roam) {
+		if (scan)
+			halbtc8723b1ant_action_wifi_connected_scan(btcoexist);
+		else
+			halbtc8723b1ant_action_wifi_connected_specific_packet(
+				btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under scan<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+
+	/* tdma and coex table */
+	if (!wifi_busy) {
+		if (BT_8723B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8723b1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8723B_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else if ((BT_8723B_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8723b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8723B_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+			halbtc8723b1ant_set_ant_path(btcoexist,
+				BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false);
+			/* if ((coex_sta->high_priority_tx) +
+			    (coex_sta->high_priority_rx) <= 60) */
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+			/* else
+				halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7); */
+		}
+	} else {
+		if (BT_8723B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8723b1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8723B_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else if ((BT_8723B_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8723b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8723B_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else {
+			/* halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+			halbtc8723b1ant_set_ant_path(btcoexist,
+				BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false);
+			if ((coex_sta->high_priority_tx) +
+			    (coex_sta->high_priority_rx) <= 60)
+				halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+			else
+				halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7); */
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8723b1ant_set_ant_path(btcoexist,
+				BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+
+		}
+	}
+}
+
+void halbtc8723b1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, bt_hs_on = false, wifi_busy = false;
+	boolean	increase_scan_dev_num = false;
+	boolean	bt_ctrl_agg_buf_size = false;
+	boolean	miracast_plus_bt = false;
+	u8	agg_buf_size = 5;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0, wifi_bw;
+	u8	iot_peer = BTC_IOT_PEER_UNKNOWN;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b1ant_action_bt_whck_test(btcoexist);
+		return;
+	}
+
+	if ((BT_8723B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8723B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+			   &increase_scan_dev_num);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		if (bt_link_info->bt_link_exist) {
+			halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1,
+						   0, 1);
+			miracast_plus_bt = true;
+		} else {
+			halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0,
+						   0, 0);
+			miracast_plus_bt = false;
+		}
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+		halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+
+		if (((bt_link_info->a2dp_exist) || (wifi_busy)) &&
+		    (coex_sta->c2h_bt_inquiry_page))
+			halbtc8723b1ant_action_bt_inquiry(btcoexist);
+		else
+			halbtc8723b1ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	}
+
+	miracast_plus_bt = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+			   &miracast_plus_bt);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_link_info->bt_link_exist) && (wifi_connected)) {
+		halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1, 0, 1);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_IOT_PEER, &iot_peer);
+
+		/* if(BTC_IOT_PEER_CISCO != iot_peer)		 */
+		if ((BTC_IOT_PEER_CISCO != iot_peer) &&
+		    (BTC_IOT_PEER_BROADCOM != iot_peer)) {
+			if (bt_link_info->sco_exist) /* if (bt_link_info->bt_hi_pri_link_exist) */
+				/* halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, true, false, 0x5);				 */
+				halbtc8723b1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, true, false, 0x5);
+			else
+				halbtc8723b1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, false, false, 0x5);
+			/* halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, false, true, 0x8);		 */
+		} else {
+			if (bt_link_info->sco_exist)
+				halbtc8723b1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, true, false, 0x5);
+			else if (bt_link_info->hid_exist)
+				halbtc8723b1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, false, true, 0x3);
+			else {
+				if (BTC_WIFI_BW_HT40 == wifi_bw)
+					halbtc8723b1ant_limited_rx(btcoexist,
+						NORMAL_EXEC, false, true, 0x10);
+				else
+					halbtc8723b1ant_limited_rx(btcoexist,
+						NORMAL_EXEC, false, true, 0x8);
+			}
+		}
+
+		halbtc8723b1ant_sw_mechanism(btcoexist, true);
+
+		/* low pelnaty ra in pcr ra */
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 35);
+
+	} else {
+		halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+		halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x5);
+
+		halbtc8723b1ant_sw_mechanism(btcoexist, false);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8723b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8723b1ant_action_hs(btcoexist);
+		return;
+	}
+
+
+	if (!wifi_connected) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is non connected-idle !!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (scan || link || roam) {
+			if (scan)
+				halbtc8723b1ant_action_wifi_not_connected_scan(
+					btcoexist);
+			else
+				halbtc8723b1ant_action_wifi_not_connected_asso_auth(
+					btcoexist);
+		} else
+			halbtc8723b1ant_action_wifi_not_connected(btcoexist);
+	} else	/* wifi LPS/Busy */
+		halbtc8723b1ant_action_wifi_connected(btcoexist);
+}
+
+void halbtc8723b1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+
+	/* sw all off */
+	halbtc8723b1ant_sw_mechanism(btcoexist, false);
+
+	/* halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8); */
+	/* halbtc8723b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0); */
+
+	coex_sta->pop_event_cnt = 0;
+}
+
+void halbtc8723b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up, IN boolean wifi_only)
+{
+	u32				u32tmp = 0; /* , fw_ver; */
+	u8				u8tmpa = 0, u8tmpb = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	psd_scan->ant_det_is_ant_det_available = false;
+
+
+	/* Give bt_coex_supported_version the default value */
+	coex_sta->bt_coex_supported_version = 0;
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+
+	/* 0x790[5:0]=0x5	 */
+	btcoexist->btc_write_1byte(btcoexist, 0x790, 0x5);
+
+	/* Enable counter statistics */
+	/* btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc); */ /*0x76e[3] =1, WLAN_Act control by PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+
+
+	/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20, 0x1); */ /*BT select s0/s1 is controlled by WiFi */
+
+	halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+
+	/* Antenna config */
+	if (wifi_only)
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_WIFI,
+					     FORCE_EXEC, true, false);
+	else
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, true, false);
+
+	/* PTA parameter */
+	halbtc8723b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+	u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+	u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x\n",
+		    u32tmp,  u8tmpa, u8tmpb);
+	BTC_TRACE(trace_buf);
+
+}
+
+/* Donot remove optimize off flag, otherwise antenna detection would trigger BT collapsed */
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+void halbtc8723b1ant_mechanism_switch(IN struct btc_coexist *btcoexist,
+				      IN boolean bSwitchTo2Antenna)
+{
+
+	if (bSwitchTo2Antenna) {
+
+		/* BT TRx mask off */
+		btcoexist->btc_set_bt_trx_mask(btcoexist, 0);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex], BT TRx Mask off for mechanism_switch\n");
+
+		BTC_TRACE(trace_buf);
+
+	} else {
+
+		/* BT TRx mask on */
+		btcoexist->btc_set_bt_trx_mask(btcoexist, 1);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex], BT TRx Mask on for mechanism_switch\n");
+
+		BTC_TRACE(trace_buf);
+	}
+
+
+#if 0
+	if (bSwitchTo2Antenna) { /* 1-Ant -> 2-Ant */
+		/* un-lock TRx Mask setup for 8723b f-cut */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdd, 0x80, 0x1);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdf, 0x1, 0x1);
+		/* WiFi TRx Mask on				 */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+
+		/* BT TRx Mask un-lock 0x2c[0], 0x30[0] = 1 */
+		btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x2c,
+					  0x7c45);
+		btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x30,
+					  0x7c45);
+
+		/* BT TRx Mask on */
+		btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x3c, 0x1);
+
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, false);
+	} else {
+		/* WiFi TRx Mask on				 */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x780);
+
+		/* lock TRx Mask setup for 8723b f-cut */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdd, 0x80, 0x0);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdf, 0x1, 0x0);
+
+		/* BT TRx Mask on */
+		btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x3c, 0x15);
+
+		/* BT TRx Mask ock 0x2c[0], 0x30[0]  = 0 */
+		btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x2c,
+					  0x7c44);
+		btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x30,
+					  0x7c44);
+
+
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+	}
+
+#endif
+}
+
+u32 halbtc8723b1ant_psd_log2base(IN struct btc_coexist *btcoexist, IN u32 val)
+{
+	u8	j;
+	u32	tmp, tmp2, val_integerd_b = 0, tindex, shiftcount = 0;
+	u32	result, val_fractiond_b = 0, table_fraction[21] = {0, 432, 332, 274, 232, 200,
+				   174, 151, 132, 115, 100, 86, 74, 62, 51, 42,
+							   32, 23, 15, 7, 0
+							      };
+
+	if (val == 0)
+		return 0;
+
+	tmp = val;
+
+	while (1) {
+		if (tmp == 1)
+			break;
+
+		tmp = (tmp >> 1);
+		shiftcount++;
+	}
+
+
+	val_integerd_b = shiftcount + 1;
+
+	tmp2 = 1;
+	for (j = 1; j <= val_integerd_b; j++)
+		tmp2 = tmp2 * 2;
+
+	tmp = (val * 100) / tmp2;
+	tindex = tmp / 5;
+
+	if (tindex > 20)
+		tindex = 20;
+
+	val_fractiond_b = table_fraction[tindex];
+
+	result = val_integerd_b * 100 - val_fractiond_b;
+
+	return result;
+
+
+}
+
+void halbtc8723b1ant_psd_show_antenna_detect_result(IN struct btc_coexist
+		*btcoexist)
+{
+	u8		*cli_buf = btcoexist->cli_buf;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n============[Antenna Detection info]  ============\n");
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->ant_det_result == 1)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (>%d)",
+			   "Ant Det Result", "2-Antenna (Bad-Isolation)",
+			   BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION);
+	else if (psd_scan->ant_det_result == 2)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (%d~%d)",
+			   "Ant Det Result", "2-Antenna (Good-Isolation)",
+			   BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION
+			   + psd_scan->ant_det_thres_offset,
+			   BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION);
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (%d~%d)",
+			   "Ant Det Result", "1-Antenna",
+			   BT_8723B_1ANT_ANTDET_PSDTHRES_1ANT,
+			   BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION
+			   + psd_scan->ant_det_thres_offset);
+
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s ",
+		   "Antenna Detection Finish",
+		   (board_info->btdm_ant_det_finish
+		    ? "Yes" : "No"));
+	CL_PRINTF(cli_buf);
+
+	switch (psd_scan->ant_det_result) {
+	case 0:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is not available)");
+		break;
+	case 1:  /* 2-Ant bad-isolation */
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available)");
+		break;
+	case 2:  /* 2-Ant good-isolation */
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available)");
+		break;
+	case 3:  /* 1-Ant */
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available)");
+		break;
+	case 4:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(Uncertainty result)");
+		break;
+	case 5:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "(Pre-Scan fai)");
+		break;
+	case 6:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(WiFi is Scanning)");
+		break;
+	case 7:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is not idle)");
+		break;
+	case 8:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(Abort by WiFi Scanning)");
+		break;
+	case 9:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(Antenna Init is not ready)");
+		break;
+	case 10:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is Inquiry or page)");
+		break;
+	case 11:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is Disabled)");
+		break;
+	}
+	CL_PRINTF(cli_buf);
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Ant Detect Total Count", psd_scan->ant_det_try_count);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Ant Detect Fail Count", psd_scan->ant_det_fail_count);
+	CL_PRINTF(cli_buf);
+
+	if ((!board_info->btdm_ant_det_finish) &&
+	    (psd_scan->ant_det_result != 5))
+		return;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "BT Response",
+		   (psd_scan->ant_det_result ? "ok" : "fail"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ms", "BT Tx Time",
+		   psd_scan->ant_det_bt_tx_time);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "BT Tx Ch",
+		   psd_scan->ant_det_bt_le_channel);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d",
+		   "WiFi PSD Cent-Ch/Offset/Span",
+		   psd_scan->real_cent_freq, psd_scan->real_offset,
+		   psd_scan->real_span);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d dB",
+		   "PSD Pre-Scan Peak Value",
+		   psd_scan->ant_det_pre_psdscan_peak_val / 100);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (<= %d)",
+		   "PSD Pre-Scan result",
+		   (psd_scan->ant_det_result != 5 ? "ok" : "fail"),
+		   BT_8723B_1ANT_ANTDET_PSDTHRES_BACKGROUND
+		   + psd_scan->ant_det_thres_offset);
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->ant_det_result == 5)
+		return;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s dB",
+		   "PSD Scan Peak Value", psd_scan->ant_det_peak_val);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s MHz",
+		   "PSD Scan Peak Freq", psd_scan->ant_det_peak_freq);
+	CL_PRINTF(cli_buf);
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "TFBGA Package",
+		   (board_info->tfbga_package) ?  "Yes" : "No");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "PSD Threshold Offset", psd_scan->ant_det_thres_offset);
+	CL_PRINTF(cli_buf);
+
+}
+
+void halbtc8723b1ant_psd_showdata(IN struct btc_coexist *btcoexist)
+{
+	u8		*cli_buf = btcoexist->cli_buf;
+	u32		delta_freq_per_point;
+	u32		freq, freq1, freq2, n = 0, i = 0, j = 0, m = 0, psd_rep1, psd_rep2;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n\n============[PSD info]  (%d)============\n",
+		   psd_scan->psd_gen_count);
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->psd_gen_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n No data !!\n");
+		CL_PRINTF(cli_buf);
+		return;
+	}
+
+	if (psd_scan->psd_point == 0)
+		delta_freq_per_point = 0;
+	else
+		delta_freq_per_point = psd_scan->psd_band_width /
+				       psd_scan->psd_point;
+
+	/* if (psd_scan->is_psd_show_max_only) */
+	if (0) {
+		psd_rep1 = psd_scan->psd_max_value / 100;
+		psd_rep2 = psd_scan->psd_max_value - psd_rep1 * 100;
+
+		freq = ((psd_scan->real_cent_freq - 20) * 1000000 +
+			psd_scan->psd_max_value_point * delta_freq_per_point);
+		freq1 = freq / 1000000;
+		freq2 = freq / 1000 - freq1 * 1000;
+
+		if (freq2 < 100)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n Freq = %d.0%d MHz",
+				   freq1, freq2);
+		else
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n Freq = %d.%d MHz",
+				   freq1, freq2);
+
+		if (psd_rep2 < 10)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   ", Value = %d.0%d dB, (%d)\n",
+				   psd_rep1, psd_rep2, psd_scan->psd_max_value);
+		else
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   ", Value = %d.%d dB, (%d)\n",
+				   psd_rep1, psd_rep2, psd_scan->psd_max_value);
+
+		CL_PRINTF(cli_buf);
+	} else {
+		m = psd_scan->psd_start_point;
+		n = psd_scan->psd_start_point;
+		i = 1;
+		j = 1;
+
+		while (1) {
+			do {
+				freq = ((psd_scan->real_cent_freq - 20) *
+					1000000 + m *
+					delta_freq_per_point);
+				freq1 = freq / 1000000;
+				freq2 = freq / 1000 - freq1 * 1000;
+
+				if (i == 1) {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Freq%6d.000",
+							   freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Freq%6d.0%2d",
+							   freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Freq%6d.%3d",
+							   freq1,
+							   freq2);
+				} else if ((i % 8 == 0) ||
+					   (m == psd_scan->psd_stop_point)) {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.000\n", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.0%2d\n", freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.%3d\n", freq1,
+							   freq2);
+				} else {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.000", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.0%2d", freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.%3d", freq1,
+							   freq2);
+				}
+
+				i++;
+				m++;
+				CL_PRINTF(cli_buf);
+
+			} while ((i <= 8) && (m <= psd_scan->psd_stop_point));
+
+
+			do {
+				psd_rep1 = psd_scan->psd_report_max_hold[n] /
+					   100;
+				psd_rep2 = psd_scan->psd_report_max_hold[n] -
+					   psd_rep1 *
+					   100;
+
+				if (j == 1) {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Val %7d.0%d",
+							   psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Val %7d.%d",
+							   psd_rep1,
+							   psd_rep2);
+				} else if ((j % 8 == 0)  ||
+					   (n == psd_scan->psd_stop_point)) {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							"%7d.0%d\n", psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%7d.%d\n", psd_rep1,
+							   psd_rep2);
+				} else {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%7d.0%d", psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%7d.%d", psd_rep1,
+							   psd_rep2);
+				}
+
+				j++;
+				n++;
+				CL_PRINTF(cli_buf);
+
+			} while ((j <= 8) && (n <= psd_scan->psd_stop_point));
+
+			if ((m > psd_scan->psd_stop_point) ||
+			    (n > psd_scan->psd_stop_point))
+				break;
+
+			i = 1;
+			j = 1;
+		}
+	}
+
+
+}
+
+void halbtc8723b1ant_psd_max_holddata(IN struct btc_coexist *btcoexist,
+				      IN u32 gen_count)
+{
+	u32	i = 0, i_max = 0, val_max = 0;
+
+	if (gen_count == 1) {
+		memcpy(psd_scan->psd_report_max_hold,
+		       psd_scan->psd_report,
+		       BT_8723B_1ANT_ANTDET_PSD_POINTS * sizeof(u32));
+
+		psd_scan->psd_max_value_point = 0;
+		psd_scan->psd_max_value = 0;
+
+	} else {
+		for (i = psd_scan->psd_start_point;
+		     i <= psd_scan->psd_stop_point; i++) {
+			if (psd_scan->psd_report[i] >
+			    psd_scan->psd_report_max_hold[i])
+				psd_scan->psd_report_max_hold[i] =
+					psd_scan->psd_report[i];
+
+			/* search Max Value */
+			if (i == psd_scan->psd_start_point) {
+				i_max = i;
+				val_max = psd_scan->psd_report_max_hold[i];
+			} else {
+				if (psd_scan->psd_report_max_hold[i] >
+				    val_max) {
+					i_max = i;
+					val_max = psd_scan->psd_report_max_hold[i];
+				}
+			}
+
+		}
+
+		psd_scan->psd_max_value_point = i_max;
+		psd_scan->psd_max_value = val_max;
+
+	}
+
+
+}
+
+u32 halbtc8723b1ant_psd_getdata(IN struct btc_coexist *btcoexist, IN u32 point)
+{
+	/* reg 0x808[9:0]: FFT data x */
+	/* reg 0x808[22]: 0-->1 to get 1 FFT data y */
+	/* reg 0x8b4[15:0]: FFT data y report */
+
+	u32 val = 0, psd_report = 0;
+	int k = 0;
+
+	val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+
+	val &= 0xffbffc00;
+	val |= point;
+
+	btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+	val |= 0x00400000;
+	btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+	while (1) {
+		if (k++ > BT_8723B_1ANT_ANTDET_SWEEPPOINT_DELAY)
+			break;
+	}
+
+	val = btcoexist->btc_read_4byte(btcoexist, 0x8b4);
+
+	psd_report = val & 0x0000ffff;
+
+	return psd_report;
+}
+
+
+boolean halbtc8723b1ant_psd_sweep_point(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN s32 offset, IN u32 span, IN u32 points,
+					IN u32 avgnum, IN u32 loopcnt)
+{
+	u32	 i, val, n, k = 0, j, point_index = 0;
+	u32	points1 = 0, psd_report = 0;
+	u32	start_p = 0, stop_p = 0, delta_freq_per_point = 156250;
+	u32    psd_center_freq = 20 * 10 ^ 6;
+	boolean outloop = false, scan , roam, is_sweep_ok = true;
+	u8	 flag = 0;
+	u32	tmp;
+	u32	wifi_original_channel = 1;
+
+	psd_scan->is_psd_running = true;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx PSD Sweep Start!!\n");
+	BTC_TRACE(trace_buf);
+
+	do {
+		switch (flag) {
+		case 0:  /* Get PSD parameters */
+		default:
+
+			psd_scan->psd_band_width = 40 * 1000000;
+			psd_scan->psd_point = points;
+			psd_scan->psd_start_base = points / 2;
+			psd_scan->psd_avg_num = avgnum;
+			psd_scan->real_cent_freq = cent_freq;
+			psd_scan->real_offset = offset;
+			psd_scan->real_span = span;
+
+
+			points1 = psd_scan->psd_point;
+			delta_freq_per_point = psd_scan->psd_band_width /
+					       psd_scan->psd_point;
+
+			/* PSD point setup */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+			val &= 0xffff0fff;
+
+			switch (psd_scan->psd_point) {
+			case 128:
+				val |= 0x0;
+				break;
+			case 256:
+			default:
+				val |= 0x00004000;
+				break;
+			case 512:
+				val |= 0x00008000;
+				break;
+			case 1024:
+				val |= 0x0000c000;
+				break;
+			}
+
+			switch (psd_scan->psd_avg_num) {
+			case 1:
+				val |= 0x0;
+				break;
+			case 8:
+				val |= 0x00001000;
+				break;
+			case 16:
+				val |= 0x00002000;
+				break;
+			case 32:
+			default:
+				val |= 0x00003000;
+				break;
+			}
+			btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+			flag = 1;
+			break;
+		case 1:	  /* calculate the PSD point index from freq/offset/span */
+			psd_center_freq = psd_scan->psd_band_width / 2 +
+					  offset * (1000000);
+
+			start_p = psd_scan->psd_start_base + (psd_center_freq -
+				span * (1000000) / 2) / delta_freq_per_point;
+			psd_scan->psd_start_point = start_p -
+						    psd_scan->psd_start_base;
+
+			stop_p = psd_scan->psd_start_base + (psd_center_freq +
+				span * (1000000) / 2) / delta_freq_per_point;
+			psd_scan->psd_stop_point = stop_p -
+						   psd_scan->psd_start_base - 1;
+
+			flag = 2;
+			break;
+		case 2:  /* set RF channel/BW/Mode */
+
+			/* set 3-wire off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x88c);
+			val |= 0x00300000;
+			btcoexist->btc_write_4byte(btcoexist, 0x88c, val);
+
+			/* CCK off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x800);
+			val &= 0xfeffffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x800, val);
+
+			/* store WiFi original channel */
+			wifi_original_channel = btcoexist->btc_get_rf_reg(
+					btcoexist, BTC_RF_A, 0x18, 0x3ff);
+
+			/* Set RF channel */
+			if (cent_freq == 2484)
+				btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A,
+							  0x18, 0x3ff, 0xe);
+			else
+				btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A,
+					  0x18, 0x3ff, (cent_freq - 2412) / 5 +
+						  1); /* WiFi TRx Mask on */
+
+
+			/* Set RF Rx filter corner */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+						  0xfffff, 0x3e4);
+
+			/* Set TRx mask off */
+			/* un-lock TRx Mask setup */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdd,
+						  0x80, 0x1);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdf,
+						  0x1, 0x1);
+
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+
+			/* Set  RF mode = Rx, RF Gain = 0x8a0 */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x0,
+						  0xfffff, 0x308a0);
+
+			while (1) {
+				if (k++ > BT_8723B_1ANT_ANTDET_SWEEPPOINT_DELAY)
+					break;
+			}
+			flag = 3;
+			break;
+		case 3:
+			psd_scan->psd_gen_count = 0;
+			for (j = 1; j <= loopcnt; j++) {
+
+				btcoexist->btc_get(btcoexist,
+						   BTC_GET_BL_WIFI_SCAN, &scan);
+				btcoexist->btc_get(btcoexist,
+						   BTC_GET_BL_WIFI_ROAM, &roam);
+
+				if (scan || roam) {
+					is_sweep_ok = false;
+					break;
+				}
+				memset(psd_scan->psd_report, 0,
+				       psd_scan->psd_point * sizeof(u32));
+				start_p = psd_scan->psd_start_point +
+					  psd_scan->psd_start_base;
+				stop_p = psd_scan->psd_stop_point +
+					 psd_scan->psd_start_base + 1;
+
+				i = start_p;
+				point_index = 0;
+
+				while (i < stop_p) {
+					if (i >= points1)
+						psd_report =
+							halbtc8723b1ant_psd_getdata(
+							btcoexist, i - points1);
+					else
+						psd_report =
+							halbtc8723b1ant_psd_getdata(
+								btcoexist, i);
+
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"Point=%d, psd_raw_data = 0x%08x\n",
+						    i, psd_report);
+					BTC_TRACE(trace_buf);
+					if (psd_report == 0)
+						tmp = 0;
+					else
+						/* tmp =  20*log10((double)psd_report); */
+						/* 20*log2(x)/log2(10), log2Base return theresult of the psd_report*100 */
+						tmp = 6 * halbtc8723b1ant_psd_log2base(
+							btcoexist, psd_report);
+
+					n = i - psd_scan->psd_start_base;
+					psd_scan->psd_report[n] =  tmp;
+
+
+					halbtc8723b1ant_psd_max_holddata(
+						btcoexist, j);
+
+					i++;
+
+				}
+
+				psd_scan->psd_gen_count = j;
+			}
+
+			flag = 100;
+			break;
+		case 99:	/* error */
+
+			outloop = true;
+			break;
+		case 100: /* recovery */
+
+			/* set 3-wire on */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x88c);
+			val &= 0xffcfffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x88c, val);
+
+			/* CCK on */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x800);
+			val |= 0x01000000;
+			btcoexist->btc_write_4byte(btcoexist, 0x800, val);
+
+			/* PSD off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+			val &= 0xffbfffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+			/* TRx Mask on */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x780);
+
+			/* lock TRx Mask setup */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdd,
+						  0x80, 0x0);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdf,
+						  0x1, 0x0);
+
+			/* Set RF Rx filter corner */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+						  0xfffff, 0x0);
+
+			/* restore WiFi original channel */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x18,
+						  0x3ff, wifi_original_channel);
+
+			outloop = true;
+			break;
+
+		}
+
+	} while (!outloop);
+
+
+
+	psd_scan->is_psd_running = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx PSD Sweep Stop!!\n");
+	BTC_TRACE(trace_buf);
+	return is_sweep_ok;
+
+}
+
+void halbtc8723b1ant_psd_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 bt_tx_time, IN u32 bt_le_channel)
+{
+	u32	i = 0;
+	u32	wlpsd_cent_freq = 2484, wlpsd_span = 2, wlpsd_sweep_count = 50;
+	s32	wlpsd_offset = -4;
+	u8	bt_le_ch[13] = {3, 6, 8, 11, 13, 16, 18, 21, 23, 26, 28, 31, 33};
+
+	u8	h2c_parameter[3] = {0}, u8tmpa, u8tmpb;
+
+	u8	state = 0;
+	boolean		outloop = false, bt_resp = false;
+	u32		freq, freq1, freq2, psd_rep1, psd_rep2, delta_freq_per_point,
+			u32tmp;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	board_info->btdm_ant_det_finish = false;
+	memset(psd_scan->ant_det_peak_val, 0, 16 * sizeof(u8));
+	memset(psd_scan->ant_det_peak_freq, 0, 16 * sizeof(u8));
+
+	if (board_info->tfbga_package) /* for TFBGA */
+		psd_scan->ant_det_thres_offset = 5;
+	else
+		psd_scan->ant_det_thres_offset = 0;
+
+	do {
+		switch (state) {
+		case 0:
+			if (bt_le_channel == 39)
+				wlpsd_cent_freq = 2484;
+			else {
+				for (i = 1; i <= 13; i++) {
+					if (bt_le_ch[i - 1] ==
+					    bt_le_channel) {
+						wlpsd_cent_freq = 2412
+								  + (i - 1) * 5;
+						break;
+					}
+				}
+
+				if (i == 14) {
+
+					BTC_SPRINTF(trace_buf,
+						    BT_TMP_BUF_SIZE,
+						"xxxxxxxxxxxxxxxx AntennaDetect(), Abort!!, Invalid LE channel = %d\n ",
+						    bt_le_channel);
+					BTC_TRACE(trace_buf);
+					outloop = true;
+					break;
+				}
+			}
+
+			wlpsd_sweep_count = bt_tx_time * 238 /
+					    100; /* bt_tx_time/0.42								 */
+			wlpsd_sweep_count = wlpsd_sweep_count / 5;
+
+			if (wlpsd_sweep_count % 5 != 0)
+				wlpsd_sweep_count = (wlpsd_sweep_count /
+						     5 + 1) * 5;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), BT_LETxTime=%d,  BT_LECh = %d\n",
+				    bt_tx_time, bt_le_channel);
+			BTC_TRACE(trace_buf);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), wlpsd_cent_freq=%d,  wlpsd_offset = %d, wlpsd_span = %d, wlpsd_sweep_count = %d\n",
+				    wlpsd_cent_freq,
+				    wlpsd_offset,
+				    wlpsd_span,
+				    wlpsd_sweep_count);
+			BTC_TRACE(trace_buf);
+
+			state = 1;
+			break;
+		case 1: /* stop coex DM & set antenna path */
+			/* Stop Coex DM */
+
+			/*
+			btcoexist->stop_coex_dm = true;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Stop Coex DM!!\n");
+			BTC_TRACE(trace_buf);  */
+
+			/* Set TDMA off,				 */
+			halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC,
+						false, 0);
+
+			/* Set coex table */
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     FORCE_EXEC, 0);
+
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna at Main Port\n");
+				BTC_TRACE(trace_buf);
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna at Aux Port\n");
+				BTC_TRACE(trace_buf);
+			}
+
+			/* Set Antenna path, switch WiFi to un-certain antenna port */
+			halbtc8723b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_BT, FORCE_EXEC, false,
+						     false);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set Antenna to BT!!\n");
+			BTC_TRACE(trace_buf);
+
+			/* Set AFH mask on at WiFi channel 2472MHz +/- 10MHz */
+			h2c_parameter[0] = 0x1;
+			h2c_parameter[1] = 0xd;
+			h2c_parameter[2] = 0x14;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set AFH on, Cent-Ch= %d,  Mask=%d\n",
+				    h2c_parameter[1],
+				    h2c_parameter[2]);
+			BTC_TRACE(trace_buf);
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x66, 3,
+						h2c_parameter);
+
+			u32tmp = btcoexist->btc_read_4byte(btcoexist,
+							   0x948);
+			u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+			u8tmpb = btcoexist->btc_read_1byte(btcoexist,
+							   0x778);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x778=0x%x\n",
+				    u32tmp,  u8tmpa, u8tmpb);
+			BTC_TRACE(trace_buf);
+
+			state = 2;
+			break;
+		case 2:	/* Pre-sweep background psd */
+			if (!halbtc8723b1ant_psd_sweep_point(btcoexist,
+				     wlpsd_cent_freq, wlpsd_offset, wlpsd_span,
+					     BT_8723B_1ANT_ANTDET_PSD_POINTS,
+				     BT_8723B_1ANT_ANTDET_PSD_AVGNUM, 3)) {
+				board_info->btdm_ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				psd_scan->ant_det_result = 8;
+				state = 99;
+				break;
+			}
+
+			psd_scan->ant_det_pre_psdscan_peak_val =
+				psd_scan->psd_max_value;
+
+			if (psd_scan->psd_max_value >
+			    (BT_8723B_1ANT_ANTDET_PSDTHRES_BACKGROUND
+			     + psd_scan->ant_det_thres_offset) * 100) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Abort Antenna Detection!! becaus background = %d > thres (%d)\n",
+					    psd_scan->psd_max_value / 100,
+					BT_8723B_1ANT_ANTDET_PSDTHRES_BACKGROUND
+					    + psd_scan->ant_det_thres_offset);
+				BTC_TRACE(trace_buf);
+				board_info->btdm_ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				psd_scan->ant_det_result = 5;
+				state = 99;
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Start Antenna Detection!! becaus background = %d <= thres (%d)\n",
+					    psd_scan->psd_max_value / 100,
+					BT_8723B_1ANT_ANTDET_PSDTHRES_BACKGROUND
+					    + psd_scan->ant_det_thres_offset);
+				BTC_TRACE(trace_buf);
+				state = 3;
+			}
+			break;
+		case 3:
+			bt_resp = btcoexist->btc_set_bt_ant_detection(
+					  btcoexist, (u8)(bt_tx_time & 0xff),
+					  (u8)(bt_le_channel & 0xff));
+
+			if (!halbtc8723b1ant_psd_sweep_point(btcoexist,
+					     wlpsd_cent_freq, wlpsd_offset,
+							     wlpsd_span,
+					     BT_8723B_1ANT_ANTDET_PSD_POINTS,
+					     BT_8723B_1ANT_ANTDET_PSD_AVGNUM,
+						     wlpsd_sweep_count)) {
+				board_info->btdm_ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				psd_scan->ant_det_result = 8;
+				state = 99;
+				break;
+			}
+
+			psd_scan->ant_det_psd_scan_peak_val =
+				psd_scan->psd_max_value;
+			psd_scan->ant_det_psd_scan_peak_freq =
+				psd_scan->psd_max_value_point;
+			state = 4;
+			break;
+		case 4:
+
+			if (psd_scan->psd_point == 0)
+				delta_freq_per_point = 0;
+			else
+				delta_freq_per_point =
+					psd_scan->psd_band_width /
+					psd_scan->psd_point;
+
+			psd_rep1 = psd_scan->psd_max_value / 100;
+			psd_rep2 = psd_scan->psd_max_value - psd_rep1 *
+				   100;
+
+			freq = ((psd_scan->real_cent_freq - 20) *
+				1000000 + psd_scan->psd_max_value_point
+				* delta_freq_per_point);
+			freq1 = freq / 1000000;
+			freq2 = freq / 1000 - freq1 * 1000;
+
+			if (freq2 < 100) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Max Value: Freq = %d.0%d MHz",
+					    freq1, freq2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_freq,
+					   BT_8723B_1ANT_ANTDET_BUF_LEN,
+					   "%d.0%d", freq1, freq2);
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Max Value: Freq = %d.%d MHz",
+					    freq1, freq2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_freq,
+					   BT_8723B_1ANT_ANTDET_BUF_LEN,
+					   "%d.%d", freq1, freq2);
+			}
+
+			if (psd_rep2 < 10) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    ", Value = %d.0%d dB\n",
+					    psd_rep1, psd_rep2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_val,
+					   BT_8723B_1ANT_ANTDET_BUF_LEN,
+					   "%d.0%d", psd_rep1, psd_rep2);
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    ", Value = %d.%d dB\n",
+					    psd_rep1, psd_rep2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_val,
+					   BT_8723B_1ANT_ANTDET_BUF_LEN,
+					   "%d.%d", psd_rep1, psd_rep2);
+			}
+
+			psd_scan->ant_det_is_btreply_available = true;
+
+			if (bt_resp == false) {
+				psd_scan->ant_det_is_btreply_available =
+					false;
+				psd_scan->ant_det_result = 0;
+				board_info->btdm_ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), BT Response = Fail\n ");
+				BTC_TRACE(trace_buf);
+			} else if (psd_scan->psd_max_value >
+				(BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION)
+				   * 100) {
+				psd_scan->ant_det_result = 1;
+				board_info->btdm_ant_det_finish = true;
+				board_info->btdm_ant_det_already_init_phydm =
+					true;
+				board_info->btdm_ant_num_by_ant_det = 2;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 2-Ant, Bad-Isolation!!\n");
+				BTC_TRACE(trace_buf);
+			} else if (psd_scan->psd_max_value >
+				(BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION
+				    + psd_scan->ant_det_thres_offset) * 100) {
+				psd_scan->ant_det_result = 2;
+				board_info->btdm_ant_det_finish = true;
+				board_info->btdm_ant_det_already_init_phydm =
+					true;
+				board_info->btdm_ant_num_by_ant_det = 2;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 2-Ant, Good-Isolation!!\n");
+				BTC_TRACE(trace_buf);
+			} else if (psd_scan->psd_max_value >
+				   (BT_8723B_1ANT_ANTDET_PSDTHRES_1ANT) *
+				   100) {
+				psd_scan->ant_det_result = 3;
+				board_info->btdm_ant_det_finish = true;
+				board_info->btdm_ant_det_already_init_phydm =
+					true;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 1-Ant!!\n");
+				BTC_TRACE(trace_buf);
+			} else {
+				psd_scan->ant_det_result = 4;
+				board_info->btdm_ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 1-Ant, un-certainity!!\n");
+				BTC_TRACE(trace_buf);
+			}
+
+			state = 99;
+			break;
+		case 99:  /* restore setup */
+
+			/* Set AFH mask off at WiFi channel 2472MHz +/- 10MHz */
+			h2c_parameter[0] = 0x0;
+			h2c_parameter[1] = 0x0;
+			h2c_parameter[2] = 0x0;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set AFH on, Cent-Ch= %d,  Mask=%d\n",
+				    h2c_parameter[1], h2c_parameter[2]);
+			BTC_TRACE(trace_buf);
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x66, 3,
+						h2c_parameter);
+
+			/* Set Antenna Path					 */
+			halbtc8723b1ant_set_ant_path(btcoexist,
+				     BTC_ANT_PATH_PTA, FORCE_EXEC, false,
+						     false);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set Antenna to PTA\n!!");
+			BTC_TRACE(trace_buf);
+
+			/* Resume Coex DM */
+			/*
+			btcoexist->stop_coex_dm = false;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Resume Coex DM\n!!");
+			BTC_TRACE(trace_buf); */
+
+			/* stimulate coex running */
+			/*
+			halbtc8723b1ant_run_coexist_mechanism(
+				btcoexist);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Stimulate Coex running\n!!");
+			BTC_TRACE(trace_buf);
+			*/
+
+			outloop = true;
+			break;
+		}
+
+	} while (!outloop);
+
+
+
+}
+
+void halbtc8723b1ant_psd_antenna_detection_check(IN struct btc_coexist
+		*btcoexist)
+{
+	static u32 ant_det_count = 0, ant_det_fail_count = 0;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	boolean scan, roam;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+
+	/* psd_scan->ant_det_bt_tx_time = 20; */
+	psd_scan->ant_det_bt_tx_time =
+		BT_8723B_1ANT_ANTDET_BTTXTIME;	   /* 0.42ms*50 = 20ms (0.42ms = 1 PSD sweep) */
+	psd_scan->ant_det_bt_le_channel = BT_8723B_1ANT_ANTDET_BTTXCHANNEL;
+
+	ant_det_count++;
+
+	psd_scan->ant_det_try_count = ant_det_count;
+
+	if (scan || roam) {
+		board_info->btdm_ant_det_finish = false;
+		psd_scan->ant_det_result = 6;
+	} else if (coex_sta->bt_disabled) {
+		board_info->btdm_ant_det_finish = false;
+		psd_scan->ant_det_result = 11;
+	} else if (coex_sta->num_of_profile >= 1) {
+		board_info->btdm_ant_det_finish = false;
+		psd_scan->ant_det_result = 7;
+	} else if (
+		!psd_scan->ant_det_is_ant_det_available) { /* Antenna initial setup is not ready */
+		board_info->btdm_ant_det_finish = false;
+		psd_scan->ant_det_result = 9;
+	} else if (coex_sta->c2h_bt_inquiry_page) {
+		board_info->btdm_ant_det_finish = false;
+		psd_scan->ant_det_result = 10;
+	} else {
+		btcoexist->stop_coex_dm = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"xxxxxxxxxxxxxxxx AntennaDetect(), Stop Coex DM!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723b1ant_psd_antenna_detection(btcoexist,
+					      psd_scan->ant_det_bt_tx_time,
+					      psd_scan->ant_det_bt_le_channel);
+
+		delay_ms(psd_scan->ant_det_bt_tx_time);
+
+		btcoexist->stop_coex_dm = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"xxxxxxxxxxxxxxxx AntennaDetect(), Resume Coex DM\n!!");
+		BTC_TRACE(trace_buf);
+
+		/* stimulate coex running */
+
+		halbtc8723b1ant_run_coexist_mechanism(
+			btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"xxxxxxxxxxxxxxxx AntennaDetect(), Stimulate Coex running\n!!");
+		BTC_TRACE(trace_buf);
+	}
+
+	board_info->ant_det_result = psd_scan->ant_det_result;
+	if (!board_info->btdm_ant_det_finish)
+		ant_det_fail_count++;
+
+	psd_scan->ant_det_fail_count = ant_det_fail_count;
+
+}
+
+
+/* ************************************************************
+ * work around function start with wa_halbtc8723b1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8723b1ant_
+ * ************************************************************ */
+void ex_halbtc8723b1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8				u8tmp = 0x0;
+	u16				u16tmp = 0x0;
+	u32				value;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"xxxxxxxxxxxxxxxx Execute 8723b 1-Ant PowerOn Setting xxxxxxxxxxxxxxxx!!\n");
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "Ant Det Finish = %s, Ant Det Number  = %d\n",
+		    (board_info->btdm_ant_det_finish ? "Yes" : "No"),
+		    board_info->btdm_ant_num_by_ant_det);
+	BTC_TRACE(trace_buf);
+
+
+	btcoexist->stop_coex_dm = true;
+
+	btcoexist->btc_write_1byte(btcoexist, 0x67, 0x20);
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write 0x948 correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+	/* set GRAN_BT = 1 */
+	btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+	/* set WLAN_ACT = 0 */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	/* */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+	if (btcoexist->chip_interface == BTC_INTF_USB) {
+		/* fixed at S0 for USB interface */
+		btcoexist->btc_write_4byte(btcoexist, 0x948, 0x0);
+
+		u8tmp |= 0x1;	/* antenna inverse */
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+	} else {
+		/* for PCIE and SDIO interface, we check efuse 0xc3[6] */
+		if (board_info->single_ant_path == 0) {
+			/* set to S1 */
+			btcoexist->btc_write_4byte(btcoexist, 0x948, 0x280);
+			board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+			value = 1;
+		} else if (board_info->single_ant_path == 1) {
+			/* set to S0 */
+			btcoexist->btc_write_4byte(btcoexist, 0x948, 0x0);
+			u8tmp |= 0x1;	/* antenna inverse */
+			board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+			value = 0;
+		}
+
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ANTPOSREGRISTRY_CTRL,
+				   &value);
+
+		if (btcoexist->chip_interface == BTC_INTF_PCI)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x384,
+							     u8tmp);
+		else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60,
+							     u8tmp);
+	}
+}
+
+void ex_halbtc8723b1ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8723b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8723b1ant_init_hw_config(btcoexist, true, wifi_only);
+	btcoexist->stop_coex_dm = false;
+}
+
+void ex_halbtc8723b1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = false;
+
+	halbtc8723b1ant_init_coex_dm(btcoexist);
+
+	halbtc8723b1ant_query_bt_info(btcoexist);
+}
+
+void ex_halbtc8723b1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+	u32				fw_ver = 0, bt_patch_ver = 0;
+	u32				bt_coex_ver = 0;
+	static u8			pop_report_in_10s = 0;
+	u32				phyver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	if (psd_scan->ant_det_try_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d",
+			   "Ant PG Num/ Mech/ Pos",
+			   board_info->pg_ant_num, board_info->btdm_ant_num,
+			   board_info->btdm_ant_pos);
+		CL_PRINTF(cli_buf);
+	} else {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %d  (%d/%d/%d)",
+			   "Ant PG Num/ Mech(Ant_Det)/ Pos",
+			   board_info->pg_ant_num,
+			   board_info->btdm_ant_num_by_ant_det,
+			   board_info->btdm_ant_pos,
+			   psd_scan->ant_det_try_count,
+			   psd_scan->ant_det_fail_count,
+			   psd_scan->ant_det_result);
+		CL_PRINTF(cli_buf);
+
+		if (board_info->btdm_ant_det_finish) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+				   "Ant Det PSD Value",
+				   psd_scan->ant_det_peak_val);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	if (board_info->ant_det_result_five_complete) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d",
+			   "Ant number by AntDet",
+			   board_info->btdm_ant_num_by_ant_det);
+		CL_PRINTF(cli_buf);
+	}
+
+	/* btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver); */
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+	bt_coex_ver = ((coex_sta->bt_coex_supported_version & 0xff00) >> 8);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+		   "CoexVer WL/  BT_Desired/ BT_Report",
+		   glcoex_ver_date_8723b_1ant, glcoex_ver_8723b_1ant,
+		   glcoex_ver_btdesired_8723b_1ant,
+		   bt_coex_ver,
+		   (bt_coex_ver == 0xff ? "Unknown" :
+		    (bt_coex_ver >= glcoex_ver_btdesired_8723b_1ant ?
+		     "Match" : "Mis-Match")));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d/ %c",
+		   "W_FW/ B_FW/ Phy/ Kt",
+		   fw_ver, bt_patch_ver, phyver,
+		   coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s",
+		   "WifibHiPri/ Ccklock/ CckEverLock",
+		   (coex_sta->wifi_is_high_pri_task ? "Yes" : "No"),
+		   (coex_sta->cck_lock ? "Yes" : "No"),
+		   (coex_sta->cck_ever_lock ? "Yes" : "No"));
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Abnormal scan",
+		   (coex_sta->bt_abnormal_scan) ? "Yes" : "No");
+	CL_PRINTF(cli_buf);
+
+	pop_report_in_10s++;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt/ popCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8723B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8723B_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt,
+		   coex_sta->pop_event_cnt);
+	CL_PRINTF(cli_buf);
+
+	if (pop_report_in_10s >= 5) {
+		coex_sta->pop_event_cnt = 0;
+		pop_report_in_10s = 0;
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d / %d / %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP/NameReq/WHQL",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist,
+		   coex_sta->c2h_bt_remote_name_req,
+		   coex_sta->bt_whck_test);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Role",
+		   (bt_link_info->slave_role) ? "Slave" : "Master");
+	CL_PRINTF(cli_buf);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %d",
+		   "A2DP Rate/Bitpool",
+		(bt_info_ext & BIT(0)) ? "BR" : "EDR", coex_sta->a2dp_bit_pool);
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8723B_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8723b_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[mechanisms] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[mechanisms]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "SM[LowPenaltyRA]",
+		   coex_dm->cur_low_penalty_ra);
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	if (board_info->btdm_ant_num_by_ant_det == 2) {
+		if (coex_dm->cur_ps_tdma_on)
+			ps_tdma_case = ps_tdma_case +
+				100; /* for WiFi RSSI low or BT RSSI low */
+		else
+			ps_tdma_case =
+				1; /* always translate to TDMA(off,1) for TDMA-off case */
+	}
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (%s,%s)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   (coex_dm->cur_ps_tdma_on ? "On" : "Off"),
+		   (coex_dm->auto_tdma_adjust ? "Adj" : "Fix"));
+
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Coex Table Type",
+		   coex_sta->coex_table_type);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "IgnWlanAct",
+		   coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	/*
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ", "Latest error condition(should be 0)",
+		coex_dm->error_condition);
+	CL_PRINTF(cli_buf);
+	*/
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "backup ARFR1/ARFR2/RL/AMaxTime",
+		   coex_dm->backup_arfr_cnt1, coex_dm->backup_arfr_cnt2,
+		   coex_dm->backup_retry_limit,
+		   coex_dm->backup_ampdu_max_time);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "0x430/0x434/0x42a/0x456",
+		   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6cc);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x880);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x778/0x6cc/0x880[29:25]",
+		   u8tmp[0], u32tmp[0], (u32tmp[1] & 0x3e000000) >> 25);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x948);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x67);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x764);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x948/ 0x67[5] / 0x764 / 0x76e",
+		   u32tmp[0], ((u8tmp[0] & 0x20) >> 5), (u32tmp[1] & 0xffff),
+		   u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x92c);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x930);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x944);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x92c[1:0]/ 0x930[7:0]/0x944[1:0]",
+		   u32tmp[0] & 0x3, u32tmp[1] & 0xff, u32tmp[2] & 0x3);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x39);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0x64);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x38[11]/0x40/0x4c[24:23]/0x64[0]",
+		   ((u8tmp[0] & 0x8) >> 3), u8tmp[1],
+		   ((u32tmp[0] & 0x01800000) >> 23), u8tmp[2] & 0x1);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x49c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xc50(dig)/0x49c(null-drop)",
+		   u32tmp[0] & 0xff, u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8723B_1ANT == 1)
+	/* halbtc8723b1ant_monitor_bt_ctr(btcoexist); */
+#endif
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8723b1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723b1ant_init_hw_config(btcoexist, false, false);
+		halbtc8723b1ant_init_coex_dm(btcoexist);
+		halbtc8723b1ant_query_bt_info(btcoexist);
+
+		coex_sta->under_ips = false;
+	}
+}
+
+void ex_halbtc8723b1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8723b1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	u8 u8tmpa, u8tmpb;
+	u32 u32tmp;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_SCAN_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+		psd_scan->ant_det_is_ant_det_available = true;
+		halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+		u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+		u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x\n",
+			    u32tmp,  u8tmpa, u8tmpb);
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+	}
+
+	if (coex_sta->bt_disabled)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	halbtc8723b1ant_query_bt_info(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8723b1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8723b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8723b1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_SCAN_START == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8723b1ant_action_wifi_not_connected_scan(
+				btcoexist);
+		else	/* wifi is connected */
+			halbtc8723b1ant_action_wifi_connected_scan(btcoexist);
+	} else if (BTC_SCAN_FINISH == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8723b1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8723b1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8723b1ant_set_antenna_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (type == 2) /* two antenna */
+		halbtc8723b1ant_mechanism_switch(btcoexist, true);
+	else /* one antenna */
+		halbtc8723b1ant_mechanism_switch(btcoexist, false);
+}
+
+void ex_halbtc8723b1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	boolean	wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_ASSOCIATE_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		psd_scan->ant_det_is_ant_det_available = true;
+		halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		/* coex_dm->arp_cnt = 0; */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8723b1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8723b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8723b1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_ASSOCIATE_START == type)
+		halbtc8723b1ant_action_wifi_not_connected_asso_auth(btcoexist);
+	else if (BTC_ASSOCIATE_FINISH == type) {
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+				   &wifi_connected);
+		if (!wifi_connected) /* non-connected scan */
+			halbtc8723b1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8723b1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8723b1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	boolean			wifi_under_b_mode = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+		psd_scan->ant_det_is_ant_det_available = true;
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+
+		coex_sta->cck_ever_lock = false;
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		/* h2c_parameter[0] = 0x1; */
+		h2c_parameter[0] = 0x0;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+}
+
+void ex_halbtc8723b1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false, under_4way = false;
+	u8	agg_buf_size = 5;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    BTC_PACKET_ARP == type) {
+		if (BTC_PACKET_ARP == type) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], specific Packet ARP notify\n");
+			BTC_TRACE(trace_buf);
+
+			coex_dm->arp_cnt++;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], ARP Packet Count = %d\n",
+				    coex_dm->arp_cnt);
+			BTC_TRACE(trace_buf);
+
+			if ((coex_dm->arp_cnt >= 10) &&
+			    (!under_4way))  /* if APR PKT > 10 after connect, do not go to ActionWifiConnectedSpecificPacket(btcoexist) */
+				coex_sta->wifi_is_high_pri_task = false;
+			else
+				coex_sta->wifi_is_high_pri_task = true;
+		} else {
+			coex_sta->wifi_is_high_pri_task = true;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], specific Packet DHCP or EAPOL notify\n");
+			BTC_TRACE(trace_buf);
+		}
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet [Type = %d] notify\n", type);
+		BTC_TRACE(trace_buf);
+	}
+
+	coex_sta->specific_pkt_period_cnt = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8723b1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8723b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8723b1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    ((BTC_PACKET_ARP == type) && (coex_sta->wifi_is_high_pri_task)))
+		halbtc8723b1ant_action_wifi_connected_specific_packet(
+			btcoexist);
+}
+
+/* Donot remove optimize off flag, otherwise antenna detection would trigger BT collapsed */
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+void ex_halbtc8723b1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8				bt_info = 0;
+	u8				i, rsp_source = 0;
+	boolean				wifi_connected = false;
+	boolean				bt_busy = false;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8723B_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8723B_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	/* if 0xff, it means BT is under WHCK test */
+	if (bt_info == 0xff)
+		coex_sta->bt_whck_test = true;
+	else
+		coex_sta->bt_whck_test = false;
+
+	if (BT_INFO_SRC_8723B_1ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->bt_info_c2h[rsp_source][2] & 0x20)
+			coex_sta->c2h_bt_remote_name_req = true;
+		else
+			coex_sta->c2h_bt_remote_name_req = false;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 - 90;
+		/* coex_sta->bt_info_c2h[rsp_source][3]*2+10; */
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		if (coex_sta->bt_info_c2h[rsp_source][1] == 0x49) {
+			coex_sta->a2dp_bit_pool =
+				coex_sta->bt_info_c2h[rsp_source][6];
+		} else
+			coex_sta->a2dp_bit_pool = 0;
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+
+		if (btcoexist->stop_coex_dm) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex], BT info Notify() return because stop_coex_dm\n");
+			BTC_TRACE(trace_buf);
+
+			return;
+		}
+
+
+#if BT_8723B_1ANT_ANTDET_ENABLE
+#if BT_8723B_1ANT_ANTDET_COEXMECHANISMSWITCH_ENABLE
+		if ((board_info->btdm_ant_det_finish) &&
+		    (board_info->btdm_ant_num_by_ant_det == 2)) {
+			if (coex_sta->bt_tx_rx_mask) {
+
+				/* BT TRx mask off */
+				btcoexist->btc_set_bt_trx_mask(btcoexist, 0);
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"############# [BTCoex], BT TRx Mask off for BT Info Notify\n");
+				BTC_TRACE(trace_buf);
+#if 0
+				/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask */
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x1\n");
+				BTC_TRACE(trace_buf);
+
+				/* BT TRx Mask un-lock 0x2c[0], 0x30[0] = 1 */
+				btcoexist->btc_set_bt_reg(btcoexist,
+						  BTC_BT_REG_RF, 0x2c, 0x7c45);
+				btcoexist->btc_set_bt_reg(btcoexist,
+						  BTC_BT_REG_RF, 0x30, 0x7c45);
+
+				btcoexist->btc_set_bt_reg(btcoexist,
+						  BTC_BT_REG_RF, 0x3c, 0x1);
+#endif
+			}
+		} else
+#endif
+#endif
+
+		{
+			if (!coex_sta->bt_tx_rx_mask) {
+
+				/* BT TRx mask on */
+				btcoexist->btc_set_bt_trx_mask(btcoexist, 1);
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"############# [BTCoex], BT TRx Mask on for  BT Info Notify\n");
+				BTC_TRACE(trace_buf);
+#if 0
+				/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask */
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x15\n");
+				BTC_TRACE(trace_buf);
+				btcoexist->btc_set_bt_reg(btcoexist,
+							  BTC_BT_REG_RF,
+							  0x3c, 0x15);
+
+				/* BT TRx Mask lock 0x2c[0], 0x30[0] = 0 */
+				btcoexist->btc_set_bt_reg(btcoexist,
+							  BTC_BT_REG_RF,
+							  0x2c, 0x7c44);
+				btcoexist->btc_set_bt_reg(btcoexist,
+							  BTC_BT_REG_RF,
+							  0x30, 0x7c44);
+#endif
+			}
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if (coex_sta->bt_info_ext & BIT(1)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8723b1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8723b1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if (coex_sta->bt_info_ext & BIT(3)) {
+			if (!btcoexist->manual_control &&
+			    !btcoexist->stop_coex_dm) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8723b1ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			}
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+		}
+#if (BT_AUTO_REPORT_ONLY_8723B_1ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8723b1ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8723B_1ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	coex_sta->num_of_profile = 0;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8723B_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+
+		coex_sta->bt_hi_pri_link_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8723B_1ANT_B_FTP) {
+			coex_sta->pan_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8723B_1ANT_B_A2DP) {
+			coex_sta->a2dp_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8723B_1ANT_B_HID) {
+			coex_sta->hid_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8723B_1ANT_B_SCO_ESCO) {
+			coex_sta->sco_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->sco_exist = false;
+
+		if ((coex_sta->hid_exist == false) &&
+		    (coex_sta->c2h_bt_inquiry_page == false) &&
+		    (coex_sta->sco_exist == false)) {
+			if (coex_sta->high_priority_tx  +
+			    coex_sta->high_priority_rx >= 160) {
+				coex_sta->hid_exist = true;
+				coex_sta->wrong_profile_notification++;
+				coex_sta->num_of_profile++;
+				bt_info = bt_info | 0x28;
+			}
+		}
+
+		/* Add Hi-Pri Tx/Rx counter to avoid false detection */
+		if (((coex_sta->hid_exist) || (coex_sta->sco_exist)) &&
+		    (coex_sta->high_priority_tx  +
+		     coex_sta->high_priority_rx >= 160)
+		    && (!coex_sta->c2h_bt_inquiry_page))
+			coex_sta->bt_hi_pri_link_exist = true;
+
+		if ((bt_info & BT_INFO_8723B_1ANT_B_ACL_BUSY) &&
+		    (coex_sta->num_of_profile == 0)) {
+			if (coex_sta->low_priority_tx  +
+			    coex_sta->low_priority_rx >= 160) {
+				coex_sta->pan_exist = true;
+				coex_sta->num_of_profile++;
+				coex_sta->wrong_profile_notification++;
+				bt_info = bt_info | 0x88;
+			}
+		}
+	}
+
+	halbtc8723b1ant_update_bt_link_info(btcoexist);
+
+	bt_info = bt_info &
+		0x1f;  /* mask profile bit for connect-ilde identification ( for CSR case: A2DP idle --> 0x41) */
+
+	if (!(bt_info & BT_INFO_8723B_1ANT_B_CONNECTION))
+		coex_dm->bt_status = BT_8723B_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+	else if (bt_info ==
+		BT_INFO_8723B_1ANT_B_CONNECTION)	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8723B_1ANT_BT_STATUS_CONNECTED_IDLE;
+	else if ((bt_info & BT_INFO_8723B_1ANT_B_SCO_ESCO) ||
+		 (bt_info & BT_INFO_8723B_1ANT_B_SCO_BUSY))
+		coex_dm->bt_status = BT_8723B_1ANT_BT_STATUS_SCO_BUSY;
+	else if (bt_info & BT_INFO_8723B_1ANT_B_ACL_BUSY) {
+		if (BT_8723B_1ANT_BT_STATUS_ACL_BUSY != coex_dm->bt_status)
+			coex_dm->auto_tdma_adjust = false;
+		coex_dm->bt_status = BT_8723B_1ANT_BT_STATUS_ACL_BUSY;
+	} else
+		coex_dm->bt_status = BT_8723B_1ANT_BT_STATUS_MAX;
+
+	if ((BT_8723B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8723B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	halbtc8723b1ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8723b1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u32	u32tmp;
+	u8	u8tmpa, u8tmpb, u8tmpc;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+	} else if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+
+		halbtc8723b1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		btcoexist->stop_coex_dm = true;
+
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+		u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+		u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x67);
+		u8tmpc = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x, 0x76e=0x%x\n",
+			    u32tmp,  u8tmpa, u8tmpb, u8tmpc);
+		BTC_TRACE(trace_buf);
+
+	}
+}
+
+void ex_halbtc8723b1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+	halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, FORCE_EXEC,
+				     false, true);
+
+	halbtc8723b1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8723b1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	btcoexist->stop_coex_dm = true;
+}
+
+void ex_halbtc8723b1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+		btcoexist->stop_coex_dm = true;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+		halbtc8723b1ant_init_hw_config(btcoexist, false, false);
+		halbtc8723b1ant_init_coex_dm(btcoexist);
+		halbtc8723b1ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8723b1ant_coex_dm_reset(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8723b1ant_init_hw_config(btcoexist, false, false);
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); */
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x2, 0xfffff, 0x0); */
+	halbtc8723b1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8723b1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	u32 bt_patch_ver;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ==========================Periodical===========================\n");
+	BTC_TRACE(trace_buf);
+
+#if (BT_AUTO_REPORT_ONLY_8723B_1ANT == 0)
+	halbtc8723b1ant_query_bt_info(btcoexist);
+#endif
+	halbtc8723b1ant_monitor_bt_ctr(btcoexist);
+	halbtc8723b1ant_monitor_wifi_ctr(btcoexist);
+
+	halbtc8723b1ant_monitor_bt_enable_disable(btcoexist);
+
+
+	if (halbtc8723b1ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust ||
+	    btcoexist->bt_info.bt_enable_disable_change)
+		halbtc8723b1ant_run_coexist_mechanism(btcoexist);
+
+	if (((coex_sta->bt_coex_supported_version == 0) ||
+	     (coex_sta->bt_coex_supported_version == 0xffff)) && (!coex_sta->bt_disabled))
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION, &coex_sta->bt_coex_supported_version);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+	coex_sta->specific_pkt_period_cnt++;
+
+	/* sample to set bt to execute Ant detection */
+	/* btcoexist->btc_set_bt_ant_detection(btcoexist, 20, 14);
+	*
+	if (psd_scan->is_ant_det_enable)
+	{
+		 if (psd_scan->psd_gen_count > psd_scan->realseconds)
+			psd_scan->psd_gen_count = 0;
+
+		halbtc8723b1ant_antenna_detection(btcoexist, psd_scan->realcent_freq,  psd_scan->realoffset, psd_scan->realspan,  psd_scan->realseconds);
+		psd_scan->psd_gen_total_count +=2;
+		psd_scan->psd_gen_count += 2;
+	}
+	*/
+}
+
+/* Donot remove optimize off flag, otherwise antenna detection would trigger BT collapsed */
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+void ex_halbtc8723b1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+#if BT_8723B_1ANT_ANTDET_ENABLE
+	static u32 ant_det_count = 0, ant_det_fail_count = 0;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	/*boolean scan, roam;*/
+
+	if (seconds == 0) {
+		psd_scan->ant_det_try_count	= 0;
+		psd_scan->ant_det_fail_count	= 0;
+		ant_det_count = 0;
+		ant_det_fail_count = 0;
+		board_info->btdm_ant_det_finish = false;
+		board_info->btdm_ant_num_by_ant_det = 1;
+		return;
+	}
+
+	if (!board_info->btdm_ant_det_finish) {
+		psd_scan->ant_det_inteval_count =
+			psd_scan->ant_det_inteval_count + 2;
+
+		if (psd_scan->ant_det_inteval_count >=
+		    BT_8723B_1ANT_ANTDET_RETRY_INTERVAL) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Timer is up, Try Detect!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b1ant_psd_antenna_detection_check(btcoexist);
+
+			if (board_info->btdm_ant_det_finish) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Success!!\n");
+				BTC_TRACE(trace_buf);
+
+
+#if 1
+				if (board_info->btdm_ant_num_by_ant_det == 2)
+					halbtc8723b1ant_mechanism_switch(
+						btcoexist, true);
+				else
+					halbtc8723b1ant_mechanism_switch(
+						btcoexist, false);
+#endif
+
+				board_info->btdm_ant_det_complete_fail = false;
+
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Fail!!\n");
+				BTC_TRACE(trace_buf);
+
+				board_info->btdm_ant_det_complete_fail = true;
+			}
+			psd_scan->ant_det_inteval_count = 0;
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Timer is not up! (%d)\n",
+				    psd_scan->ant_det_inteval_count);
+			BTC_TRACE(trace_buf);
+		}
+
+	}
+#endif
+
+
+	/*
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+
+			psd_scan->ant_det_bt_tx_time = seconds;
+		psd_scan->ant_det_bt_le_channel = cent_freq;
+
+		if (seconds == 0)
+			{
+			psd_scan->ant_det_try_count	= 0;
+			psd_scan->ant_det_fail_count	= 0;
+			ant_det_count = 0;
+			ant_det_fail_count = 0;
+			board_info->btdm_ant_det_finish = false;
+			board_info->btdm_ant_num_by_ant_det = 1;
+				 return;
+		}
+		else
+		{
+			ant_det_count++;
+
+			psd_scan->ant_det_try_count = ant_det_count;
+
+				if (scan ||roam)
+			{
+				board_info->btdm_ant_det_finish = false;
+				psd_scan->ant_det_result = 6;
+			}
+			else if (coex_sta->num_of_profile >= 1)
+			{
+				board_info->btdm_ant_det_finish = false;
+				psd_scan->ant_det_result = 7;
+			}
+				else if (!psd_scan->ant_det_is_ant_det_available)
+			{
+				board_info->btdm_ant_det_finish = false;
+				psd_scan->ant_det_result = 9;
+			}
+			else if (coex_sta->c2h_bt_inquiry_page)
+			{
+				board_info->btdm_ant_det_finish = false;
+				psd_scan->ant_det_result = 10;
+			}
+			else
+			{
+
+		}
+
+			if (!board_info->btdm_ant_det_finish)
+				ant_det_fail_count++;
+
+			psd_scan->ant_det_fail_count = ant_det_fail_count;
+		}
+	*/
+}
+
+
+void ex_halbtc8723b1ant_display_ant_detection(IN struct btc_coexist *btcoexist)
+{
+#if BT_8723B_1ANT_ANTDET_ENABLE
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	if (psd_scan->ant_det_try_count != 0) {
+		halbtc8723b1ant_psd_show_antenna_detect_result(btcoexist);
+
+		if (board_info->btdm_ant_det_finish)
+			halbtc8723b1ant_psd_showdata(btcoexist);
+		return;
+	}
+#endif
+
+	/* halbtc8723b1ant_show_psd_data(btcoexist); */
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
+
+
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8723b1ant.h
@@ -0,0 +1,293 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8723B_SUPPORT == 1)
+/* *******************************************
+ * The following is for 8723B 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8723B_1ANT				1
+
+#define	BT_INFO_8723B_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8723B_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8723B_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8723B_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8723B_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8723B_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8723B_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8723B_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8723B_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+		(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8723B_1ANT		2
+
+#define  BT_8723B_1ANT_WIFI_NOISY_THRESH								50 /* 30   /max: 255								 */
+
+/* for Antenna detection */
+#define	BT_8723B_1ANT_ANTDET_PSDTHRES_BACKGROUND						50
+#define	BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION				70
+#define	BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION			48
+#define	BT_8723B_1ANT_ANTDET_PSDTHRES_1ANT							32
+#define	BT_8723B_1ANT_ANTDET_RETRY_INTERVAL							10	/* retry timer if ant det is fail, unit: second */
+#define	BT_8723B_1ANT_ANTDET_SWEEPPOINT_DELAY							40000
+#define	BT_8723B_1ANT_ANTDET_ENABLE										1
+#define	BT_8723B_1ANT_ANTDET_COEXMECHANISMSWITCH_ENABLE				1
+#define	BT_8723B_1ANT_ANTDET_BTTXTIME									100
+#define	BT_8723B_1ANT_ANTDET_BTTXCHANNEL								39
+
+enum bt_info_src_8723b_1ant {
+	BT_INFO_SRC_8723B_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8723B_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8723B_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8723B_1ANT_MAX
+};
+
+enum bt_8723b_1ant_bt_status {
+	BT_8723B_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8723B_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8723B_1ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8723B_1ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8723B_1ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8723B_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8723b_1ant_wifi_status {
+	BT_8723B_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8723B_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8723B_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8723B_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT				= 0x3,
+	BT_8723B_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8723B_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8723B_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8723b_1ant_coex_algo {
+	BT_8723B_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8723B_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8723B_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8723B_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8723B_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8723B_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8723B_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8723B_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8723B_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8723B_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8723B_1ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8723B_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8723b_1ant {
+	/* hw setting */
+	u8		pre_ant_pos_type;
+	u8		cur_ant_pos_type;
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8723b_1ant {
+	boolean					bt_disabled;
+	boolean					bt_enable_disable_change;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+	boolean					bt_hi_pri_link_exist;
+	u8					num_of_profile;
+	boolean					bt_abnormal_scan;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	s8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8723B_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8723B_1ANT_MAX];
+	boolean					bt_whck_test;
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_remote_name_req;
+	boolean					wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_vht;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_vht;
+
+	boolean					cck_lock;
+	boolean					pre_ccklock;
+	boolean					cck_ever_lock;
+	u8					coex_table_type;
+
+	boolean					force_lps_on;
+	u32					wrong_profile_notification;
+	u32					bt_coex_supported_version;
+	u8					a2dp_bit_pool;
+	u8					cut_version;
+};
+
+#define BT_8723B_1ANT_ANTDET_PSD_POINTS			256	/* MAX:1024 */
+#define BT_8723B_1ANT_ANTDET_PSD_AVGNUM		1	/* MAX:3 */
+#define	BT_8723B_1ANT_ANTDET_BUF_LEN			16
+
+struct psdscan_sta_8723b_1ant {
+
+	u32			ant_det_bt_le_channel;  /* BT LE Channel ex:2412 */
+	u32			ant_det_bt_tx_time;
+	u32			ant_det_pre_psdscan_peak_val;
+	boolean			ant_det_is_ant_det_available;
+	u32			ant_det_psd_scan_peak_val;
+	boolean			ant_det_is_btreply_available;
+	u32			ant_det_psd_scan_peak_freq;
+
+	u8			ant_det_result;
+	u8			ant_det_peak_val[BT_8723B_1ANT_ANTDET_BUF_LEN];
+	u8			ant_det_peak_freq[BT_8723B_1ANT_ANTDET_BUF_LEN];
+	u32			ant_det_try_count;
+	u32			ant_det_fail_count;
+	u32			ant_det_inteval_count;
+	u32			ant_det_thres_offset;
+
+	u32			real_cent_freq;
+	s32			real_offset;
+	u32			real_span;
+
+	u32			psd_band_width;  /* unit: Hz */
+	u32			psd_point;		/* 128/256/512/1024 */
+	u32			psd_report[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_report_max_hold[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_start_point;
+	u32			psd_stop_point;
+	u32			psd_max_value_point;
+	u32			psd_max_value;
+	u32			psd_start_base;
+	u32			psd_avg_num;	/* 1/8/16/32 */
+	u32			psd_gen_count;
+	boolean			is_psd_running;
+	boolean			is_psd_show_max_only;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8723b1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8723b1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8723b1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8723b1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8723b1ant_set_antenna_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723b1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8723b1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723b1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723b1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8723b1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723b1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8723b1ant_coex_dm_reset(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+
+void ex_halbtc8723b1ant_display_ant_detection(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8723b1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8723b1ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8723b1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8723b1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8723b1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_set_antenna_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8723b1ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_halt_notify(btcoexist)
+#define	ex_halbtc8723b1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8723b1ant_coex_dm_reset(btcoexist)
+#define	ex_halbtc8723b1ant_periodical(btcoexist)
+#define	ex_halbtc8723b1ant_display_coex_info(btcoexist)
+#define	ex_halbtc8723b1ant_antenna_detection(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8723b1ant_display_ant_detection(btcoexist)
+
+#endif
+
+#endif
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8723b2ant.c
@@ -0,0 +1,4958 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8723B Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8723B_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8723b_2ant		glcoex_dm_8723b_2ant;
+static struct  coex_dm_8723b_2ant	*coex_dm = &glcoex_dm_8723b_2ant;
+static struct  coex_sta_8723b_2ant		glcoex_sta_8723b_2ant;
+static struct  coex_sta_8723b_2ant	*coex_sta = &glcoex_sta_8723b_2ant;
+
+const char *const glbt_info_src_8723b_2ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8723b_2ant = 20161007;
+u32	glcoex_ver_8723b_2ant = 0x4c;
+u32	glcoex_ver_btdesired_8723b_2ant = 0x4c;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8723b2ant_
+ * ************************************************************ */
+u8 halbtc8723b2ant_bt_rssi_state(u8 *ppre_bt_rssi_state, u8 level_num,
+				 u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = *ppre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return *ppre_bt_rssi_state;
+		}
+
+		if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+			(*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	*ppre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8723b2ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 *pprewifi_rssi_state, IN u8 level_num, IN u8 rssi_thresh,
+				   IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = *pprewifi_rssi_state;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((*pprewifi_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return *pprewifi_rssi_state;
+		}
+
+		if ((*pprewifi_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((*pprewifi_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+			(*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	*pprewifi_rssi_state = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8723b2ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean		bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 10)
+			bt_disabled = true;
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+
+		coex_sta->bt_disabled = bt_disabled;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		if (bt_disabled) {
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+					   NULL);
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+					   NULL);
+		}
+	}
+}
+
+
+void halbtc8723b2ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+}
+
+void halbtc8723b2ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if ((coex_sta->low_priority_tx > 1050)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	if ((coex_sta->low_priority_rx >= 950)  &&
+	    (coex_sta->low_priority_rx >= coex_sta->low_priority_tx) &&
+	    (!coex_sta->under_ips))
+		bt_link_info->slave_role = true;
+	else
+		bt_link_info->slave_role = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_hp_txrx, reg_hp_tx, reg_hp_tx, reg_hp_rx, reg_hp_rx);
+	BTC_TRACE(trace_buf);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_lp_txrx, reg_lp_tx, reg_lp_tx, reg_lp_rx, reg_lp_rx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+}
+
+void halbtc8723b2ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+#if 1
+
+	coex_sta->crc_ok_cck = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_CCK);
+	coex_sta->crc_ok_11g = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_LEGACY);
+	coex_sta->crc_ok_11n = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_HT);
+	coex_sta->crc_ok_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_OK_VHT);
+
+	coex_sta->crc_err_cck = btcoexist->btc_phydm_query_PHY_counter(
+					btcoexist,
+					PHYDM_INFO_CRC32_ERROR_CCK);
+	coex_sta->crc_err_11g =  btcoexist->btc_phydm_query_PHY_counter(
+					 btcoexist,
+					 PHYDM_INFO_CRC32_ERROR_LEGACY);
+	coex_sta->crc_err_11n = btcoexist->btc_phydm_query_PHY_counter(
+					btcoexist,
+					PHYDM_INFO_CRC32_ERROR_HT);
+	coex_sta->crc_err_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_ERROR_VHT);
+
+#endif
+}
+
+void halbtc8723b2ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+boolean halbtc8723b2ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	boolean			wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean			wifi_connected = false;
+	u8			wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+
+
+		wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+				  &prewifi_rssi_state, 2,
+				  BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+				  coex_dm->switch_thres_offset, 0);
+
+		if ((BTC_RSSI_STATE_HIGH == wifi_rssi_state) ||
+		    (BTC_RSSI_STATE_LOW == wifi_rssi_state))
+			return true;
+
+	}
+
+	return false;
+}
+
+void halbtc8723b2ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8723b2ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8723B_2ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8723B_2ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723B_2ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723B_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8723B_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				{
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8723B_2ANT_COEX_ALGO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8723b2ant_set_fw_dac_swing_level(IN struct btc_coexist *btcoexist,
+		IN u8 dac_swing_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	/* There are several type of dacswing */
+	/* 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6 */
+	h2c_parameter[0] = dac_swing_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
+}
+
+void halbtc8723b2ant_set_fw_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				       IN u8 dec_bt_pwr_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = dec_bt_pwr_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x62, 1, h2c_parameter);
+}
+
+void halbtc8723b2ant_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN u8 dec_bt_pwr_lvl)
+{
+	coex_dm->cur_bt_dec_pwr_lvl = dec_bt_pwr_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_dec_pwr_lvl == coex_dm->cur_bt_dec_pwr_lvl)
+			return;
+	}
+	halbtc8723b2ant_set_fw_dec_bt_pwr(btcoexist,
+					  coex_dm->cur_bt_dec_pwr_lvl);
+
+	coex_dm->pre_bt_dec_pwr_lvl = coex_dm->cur_bt_dec_pwr_lvl;
+}
+
+void halbtc8723b2ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8723b2ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8723b2ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8723b2ant_fw_dac_swing_lvl(IN struct btc_coexist *btcoexist,
+			      IN boolean force_exec, IN u8 fw_dac_swing_lvl)
+{
+	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swing_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_fw_dac_swing_lvl ==
+		    coex_dm->cur_fw_dac_swing_lvl)
+			return;
+	}
+
+	halbtc8723b2ant_set_fw_dac_swing_level(btcoexist,
+					       coex_dm->cur_fw_dac_swing_lvl);
+
+	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
+}
+
+void halbtc8723b2ant_set_sw_rf_rx_lpf_corner(IN struct btc_coexist *btcoexist,
+		IN boolean rx_rf_shrink_on)
+{
+	if (rx_rf_shrink_on) {
+		/* Shrink RF Rx LPF corner */
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Shrink RF Rx LPF corner!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e, 0xfffff,
+					  0xffffc);
+	} else {
+		/* Resume RF Rx LPF corner */
+		/* After initialized, we can use coex_dm->bt_rf_0x1e_backup */
+		if (btcoexist->initilized) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Resume RF Rx LPF corner!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+					  0xfffff, coex_dm->bt_rf_0x1e_backup);
+		}
+	}
+}
+
+void halbtc8723b2ant_rf_shrink(IN struct btc_coexist *btcoexist,
+		       IN boolean force_exec, IN boolean rx_rf_shrink_on)
+{
+	coex_dm->cur_rf_rx_lpf_shrink = rx_rf_shrink_on;
+
+	if (!force_exec) {
+		if (coex_dm->pre_rf_rx_lpf_shrink ==
+		    coex_dm->cur_rf_rx_lpf_shrink)
+			return;
+	}
+	halbtc8723b2ant_set_sw_rf_rx_lpf_corner(btcoexist,
+						coex_dm->cur_rf_rx_lpf_shrink);
+
+	coex_dm->pre_rf_rx_lpf_shrink = coex_dm->cur_rf_rx_lpf_shrink;
+}
+
+void halbtc8723b2ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf4;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf5;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf6;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8723b2ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8723b2ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8723b2ant_set_dac_swing_reg(IN struct btc_coexist *btcoexist,
+				       IN u32 level)
+{
+	u8	val = (u8)level;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Write SwDacSwing = 0x%x\n", level);
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x883, 0x3e, val);
+}
+
+void halbtc8723b2ant_set_sw_full_time_dac_swing(IN struct btc_coexist
+		*btcoexist, IN boolean sw_dac_swing_on, IN u32 sw_dac_swing_lvl)
+{
+	if (sw_dac_swing_on)
+		halbtc8723b2ant_set_dac_swing_reg(btcoexist, sw_dac_swing_lvl);
+	else
+		halbtc8723b2ant_set_dac_swing_reg(btcoexist, 0x18);
+}
+
+
+void halbtc8723b2ant_dac_swing(IN struct btc_coexist *btcoexist,
+	IN boolean force_exec, IN boolean dac_swing_on, IN u32 dac_swing_lvl)
+{
+	coex_dm->cur_dac_swing_on = dac_swing_on;
+	coex_dm->cur_dac_swing_lvl = dac_swing_lvl;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_dac_swing_on == coex_dm->cur_dac_swing_on) &&
+		    (coex_dm->pre_dac_swing_lvl ==
+		     coex_dm->cur_dac_swing_lvl))
+			return;
+	}
+	delay_ms(30);
+	halbtc8723b2ant_set_sw_full_time_dac_swing(btcoexist, dac_swing_on,
+			dac_swing_lvl);
+
+	coex_dm->pre_dac_swing_on = coex_dm->cur_dac_swing_on;
+	coex_dm->pre_dac_swing_lvl = coex_dm->cur_dac_swing_lvl;
+}
+
+void halbtc8723b2ant_set_adc_back_off(IN struct btc_coexist *btcoexist,
+				      IN boolean adc_back_off)
+{
+	if (adc_back_off) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc05, 0x30, 0x3);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc05, 0x30, 0x1);
+	}
+}
+
+void halbtc8723b2ant_adc_back_off(IN struct btc_coexist *btcoexist,
+			  IN boolean force_exec, IN boolean adc_back_off)
+{
+	coex_dm->cur_adc_back_off = adc_back_off;
+
+	if (!force_exec) {
+		if (coex_dm->pre_adc_back_off == coex_dm->cur_adc_back_off)
+			return;
+	}
+	halbtc8723b2ant_set_adc_back_off(btcoexist, coex_dm->cur_adc_back_off);
+
+	coex_dm->pre_adc_back_off = coex_dm->cur_adc_back_off;
+}
+
+void halbtc8723b2ant_set_agc_table(IN struct btc_coexist *btcoexist,
+				   IN boolean agc_table_en)
+{
+	u8		rssi_adjust_val = 0;
+
+	/* =================BB AGC Gain Table */
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6e1A0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6d1B0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6c1C0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6b1D0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6a1E0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x691F0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x68200001);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xaa1A0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa91B0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa81C0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa71D0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa61E0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa51F0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa4200001);
+	}
+
+
+	/* =================RF Gain */
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x02000);
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x38fff);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x38ffe);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x380c3);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x28ce6);
+	}
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xed, 0xfffff, 0x1);
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x38fff);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x38ffe);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x380c3);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x28ce6);
+	}
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xed, 0xfffff, 0x0);
+
+	/* set rssi_adjust_val for wifi module. */
+	if (agc_table_en)
+		rssi_adjust_val = 8;
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON,
+			   &rssi_adjust_val);
+}
+
+void halbtc8723b2ant_agc_table(IN struct btc_coexist *btcoexist,
+			       IN boolean force_exec, IN boolean agc_table_en)
+{
+	coex_dm->cur_agc_table_en = agc_table_en;
+
+	if (!force_exec) {
+		if (coex_dm->pre_agc_table_en == coex_dm->cur_agc_table_en)
+			return;
+	}
+	halbtc8723b2ant_set_agc_table(btcoexist, agc_table_en);
+
+	coex_dm->pre_agc_table_en = coex_dm->cur_agc_table_en;
+}
+
+void halbtc8723b2ant_sw_mechanism1(IN struct btc_coexist *btcoexist,
+			   IN boolean shrink_rx_lpf, IN boolean low_penalty_ra,
+			   IN boolean limited_dig, IN boolean bt_lna_constrain)
+{
+	/*
+	u32	wifi_bw;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if(BTC_WIFI_BW_HT40 != wifi_bw)
+	{
+		if (shrink_rx_lpf)
+			shrink_rx_lpf = false;
+	}
+	*/
+
+	/* halbtc8723b2ant_rf_shrink(btcoexist, NORMAL_EXEC, shrink_rx_lpf); */
+	halbtc8723b2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+
+void halbtc8723b2ant_sw_mechanism2(IN struct btc_coexist *btcoexist,
+			   IN boolean agc_table_shift, IN boolean adc_back_off,
+			   IN boolean sw_dac_swing, IN u32 dac_swing_lvl)
+{
+	/* halbtc8723b2ant_agc_table(btcoexist, NORMAL_EXEC, agc_table_shift); */
+	/* halbtc8723b2ant_adc_back_off(btcoexist, NORMAL_EXEC, adc_back_off); */
+	/* halbtc8723b2ant_dac_swing(btcoexist, NORMAL_EXEC, sw_dac_swing, dac_swing_lvl); */
+}
+
+void halbtc8723b2ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8723b2ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8723b2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8723b2ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	coex_sta->coex_table_type = type;
+
+	switch (type) {
+	case 0:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5afa5afa, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x5ada5ada, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0xffffffff, 0xffffffff, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0x5fff5fff, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55ff55ff, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 8:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 9:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 10:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 11:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 12:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 13:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 14:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 15:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8723b2ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable)
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8723b2ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8723b2ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8723b2ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8723b2ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8723b2ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8723b2ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0x0, 0, 0, 48, 0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			/* halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+				h2c_parameter);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			/* halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+				h2c_parameter);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8723b2ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8723b2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8723b2ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8723b2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+
+void halbtc8723b2ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean		ap_enable = false;
+
+	if ((coex_sta->a2dp_exist) && (coex_sta->hid_exist))
+		byte5 = byte5 | 0x1;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8723b2ant_power_save_state(btcoexist,
+				BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		}
+	} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			halbtc8723b2ant_power_save_state(btcoexist,
+				BTC_PS_LPS_ON, 0x50, 0x4);
+
+	} else {
+			halbtc8723b2ant_power_save_state(btcoexist,
+				BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+	}
+
+	h2c_parameter[0] = byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = byte5;
+
+	coex_dm->ps_tdma_para[0] = byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8723b2ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8			wifi_rssi_state1,  bt_rssi_state;
+	s8			wifi_duration_adjust = 0x0;
+	u8			psTdmaByte4Modify = 0x0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+		&prewifi_rssi_state, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES
+			   - coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], %s turn %s PS TDMA, type=%d\n",
+		(force_exec ? "force to" : ""), (turn_on ? "ON" : "OFF"), type);
+	BTC_TRACE(trace_buf);
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	if (!(BTC_RSSI_HIGH(wifi_rssi_state1) &&
+	      BTC_RSSI_HIGH(bt_rssi_state)) && turn_on)
+		/* if (halbtc8723b2ant_CoexSwitchThresCheck(btcoexist) &&  turn_on) */
+	{
+		type = type + 100; /* for WiFi RSSI low or BT RSSI low */
+		coex_dm->is_switch_to_1dot5_ant = true;
+	} else
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (coex_sta->scan_ap_num <= 5) {
+		if (coex_sta->a2dp_bit_pool >= 45)
+			wifi_duration_adjust = -15;
+		else if (coex_sta->a2dp_bit_pool >= 35)
+			wifi_duration_adjust = -10;
+		else
+			wifi_duration_adjust = 5;
+	} else  if (coex_sta->scan_ap_num <= 20) {
+		if (coex_sta->a2dp_bit_pool >= 45)
+			wifi_duration_adjust = -15;
+		else if (coex_sta->a2dp_bit_pool >= 35)
+			wifi_duration_adjust = -10;
+		else
+			wifi_duration_adjust = 0;
+	} else if (coex_sta->scan_ap_num <= 40) {
+		if (coex_sta->a2dp_bit_pool >= 45)
+			wifi_duration_adjust = -15;
+		else if (coex_sta->a2dp_bit_pool >= 35)
+			wifi_duration_adjust = -10;
+		else
+			wifi_duration_adjust = -5;
+	} else {
+		if (coex_sta->a2dp_bit_pool >= 45)
+			wifi_duration_adjust = -15;
+		else if (coex_sta->a2dp_bit_pool >= 35)
+			wifi_duration_adjust = -10;
+		else
+			wifi_duration_adjust = -10;
+	}
+
+	if ((bt_link_info->slave_role == true)	&& (bt_link_info->a2dp_exist))
+		psTdmaByte4Modify =
+			0x1;  /* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+
+
+	if (turn_on) {
+		switch (type) {
+		case 1:
+		default:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x3c + wifi_duration_adjust, 0x03, 0xf1,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 2:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x2d + wifi_duration_adjust, 0x03, 0xf1,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 3:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf1,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 4:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x03, 0xf1,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 5:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x3c + wifi_duration_adjust, 0x3, 0x70,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 6:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x2d + wifi_duration_adjust, 0x3, 0x70,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 7:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0x70,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 8:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x10, 0x3, 0x70,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 9:
+			/*
+				halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+					      0x3c + wifi_duration_adjust, 0x03, 0xf1,
+							      0x90 | psTdmaByte4Modify);
+			*/
+			/* Bryant Modify for BT no-profile busy case */
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x3c + wifi_duration_adjust, 0x03, 0xf1,
+						      0x91);
+
+			break;
+		case 10:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x2d + wifi_duration_adjust, 0x03, 0xf1,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 11:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf1,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 12:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0xf1,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 13:
+			/*
+				halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+					      0x3c + wifi_duration_adjust, 0x3, 0x70,
+							      0x90 | psTdmaByte4Modify);
+			*/
+			/* Bryant Modify for BT no-profile busy case */
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x3c + wifi_duration_adjust, 0x3, 0x70,
+						      0x91);
+			break;
+		case 14:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x2d + wifi_duration_adjust, 0x3, 0x70,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 15:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0x70,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 16:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0x70,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 17:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x2f, 0x2f, 0x60, 0x90);
+			break;
+		case 18:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x5, 0x5, 0xe1, 0x90);
+			break;
+		case 19:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0xe1, 0x90);
+			break;
+		case 20:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0x60, 0x90);
+			break;
+		case 21:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x03, 0x70, 0x90);
+			break;
+		case 22:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x35, 0x03, 0xf1, 0x90);
+			break;
+		case 23:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x35, 0x03, 0x71, 0x10);
+			break;
+
+		case 25:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x30, 0x03, 0x71, 0x10);
+			break;
+
+		case 33:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf1,  0x91);
+
+			break;
+		case 71:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x3c + wifi_duration_adjust, 0x03, 0xf1,
+						      0x90);
+			break;
+		case 101:
+		case 105:
+		case 113:
+		case 171:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xd3,
+				      0x3a + wifi_duration_adjust, 0x03, 0x70,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 102:
+		case 106:
+		case 110:
+		case 114:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xd3,
+				      0x2d + wifi_duration_adjust, 0x03, 0x70,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 103:
+		case 107:
+		case 111:
+		case 115:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1c, 0x03, 0x70, 0x50 |
+						      psTdmaByte4Modify);
+			break;
+		case 104:
+		case 108:
+		case 112:
+		case 116:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x10, 0x03, 0x70, 0x50 |
+						      psTdmaByte4Modify);
+			break;
+		case 109:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0xf1, 0x90 |
+						      psTdmaByte4Modify);
+			break;
+		/* case 113:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0x70, 0x90 |
+						      psTdmaByte4Modify);
+			break; */
+		case 121:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x03, 0x70, 0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 122:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x35, 0x03, 0x71, 0x11);
+			break;
+		case 123:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x35, 0x03, 0x71, 0x10);
+			break;
+		case 125:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x30, 0x03, 0x70, 0x51);
+			break;
+
+		case 133:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1c, 0x3, 0x70,  0x51);
+
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 0:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		case 1:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x48, 0x0);
+			break;
+		default:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+
+void halbtc8723b2ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean init_hwcfg, IN boolean wifi_off)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u32			fw_ver = 0, u32tmp = 0, cnt_bt_cal_chk = 0;
+	boolean			pg_ext_switch = false;
+	boolean			use_ext_switch = false;
+	u8			h2c_parameter[2] = {0};
+	u32				u32tmp_1[4];
+	boolean		is_fw_ready;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_EXT_SWITCH, &pg_ext_switch);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER,
+			   &fw_ver);	/* [31:16]=fw ver, [15:0]=fw sub ver */
+
+	if ((fw_ver > 0 && fw_ver < 0xc0000) || pg_ext_switch)
+		use_ext_switch = true;
+
+	if (init_hwcfg) {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x39, 0x8, 0x1);
+		btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x944, 0x3, 0x3);
+		btcoexist->btc_write_1byte(btcoexist, 0x930, 0x77);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20, 0x1);
+
+		if (fw_ver >= 0x180000) {
+			/* Use H2C to set GNT_BT to High to avoid A2DP click */
+			h2c_parameter[0] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1,
+						h2c_parameter);
+
+			cnt_bt_cal_chk = 0;
+			while (1) {
+				btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_FW_READY, &is_fw_ready);
+				if (is_fw_ready == false)
+					break;
+
+				if (btcoexist->btc_read_1byte(btcoexist,
+							      0x765) == 0x18)
+					break;
+
+				cnt_bt_cal_chk++;
+				if (cnt_bt_cal_chk > 20)
+					break;
+			}
+		} else
+			btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+		u32tmp_1[0] = btcoexist->btc_read_4byte(btcoexist, 0x948);
+		if ((u32tmp_1[0] == 0x40) || (u32tmp_1[0] == 0x240))
+			btcoexist->btc_write_4byte(btcoexist, 0x948,
+						   u32tmp_1[0]);
+		else
+			btcoexist->btc_write_4byte(btcoexist, 0x948, 0x0);
+
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0); /* WiFi TRx Mask off */
+		/* remove due to interrupt is disabled that polling c2h will fail and delay 100ms. */
+		/* btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x3c, 0x01); */ /*BT TRx Mask off */
+
+		if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT) {
+			/* tell firmware "no antenna inverse" */
+			h2c_parameter[0] = 0;
+		} else {
+			/* tell firmware "antenna inverse" */
+			h2c_parameter[0] = 1;
+		}
+
+		if (use_ext_switch) {
+			/* ext switch type */
+			h2c_parameter[1] = 1;
+		} else {
+			/* int switch type */
+			h2c_parameter[1] = 0;
+		}
+		btcoexist->btc_fill_h2c(btcoexist, 0x65, 2, h2c_parameter);
+	} else {
+		if (fw_ver >= 0x180000) {
+			/* Use H2C to set GNT_BT to "Control by PTA"*/
+			h2c_parameter[0] = 0;
+			btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1,
+						h2c_parameter);
+
+			cnt_bt_cal_chk = 0;
+			while (1) {
+				btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_FW_READY, &is_fw_ready);
+				if (is_fw_ready == false)
+					break;
+
+				if (btcoexist->btc_read_1byte(btcoexist,
+							      0x765) == 0x0)
+					break;
+
+				cnt_bt_cal_chk++;
+				if (cnt_bt_cal_chk > 20)
+					break;
+			}
+		} else
+			btcoexist->btc_write_1byte(btcoexist, 0x765, 0x0);
+	}
+
+	/* ext switch setting */
+	if (use_ext_switch) {
+		if (init_hwcfg) {
+			/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+			u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+			u32tmp &= ~BIT(23);
+			u32tmp |= BIT(24);
+			btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+		}
+		u32tmp_1[0] = btcoexist->btc_read_4byte(btcoexist, 0x948);
+		if ((u32tmp_1[0] == 0x40) || (u32tmp_1[0] == 0x240))
+			btcoexist->btc_write_4byte(btcoexist, 0x948,
+						   u32tmp_1[0]);
+		else
+			btcoexist->btc_write_4byte(btcoexist, 0x948, 0x0);
+
+		switch (ant_pos_type) {
+		case BTC_ANT_WIFI_AT_MAIN:
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0x92c, 0x3,
+					   0x1);	/* ext switch main at wifi */
+			break;
+		case BTC_ANT_WIFI_AT_AUX:
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0x92c, 0x3,
+					   0x2);	/* ext switch aux at wifi */
+			break;
+		}
+	} else {	/* internal switch */
+		if (init_hwcfg) {
+			/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+			u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+			u32tmp |= BIT(23);
+			u32tmp &= ~BIT(24);
+			btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+		}
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x64, 0x1,
+			   0x0); /* fixed external switch S1->Main, S0->Aux */
+		switch (ant_pos_type) {
+		case BTC_ANT_WIFI_AT_MAIN:
+			u32tmp_1[0] = btcoexist->btc_read_4byte(btcoexist,
+								0x948);
+			if ((u32tmp_1[0] == 0x40) || (u32tmp_1[0] == 0x240))
+				btcoexist->btc_write_4byte(btcoexist, 0x948,
+							   u32tmp_1[0]);
+			else
+				btcoexist->btc_write_4byte(btcoexist, 0x948,
+							   0x0);
+			break;
+		case BTC_ANT_WIFI_AT_AUX:
+			u32tmp_1[0] = btcoexist->btc_read_4byte(btcoexist,
+								0x948);
+			if ((u32tmp_1[0] == 0x40) || (u32tmp_1[0] == 0x240))
+				btcoexist->btc_write_4byte(btcoexist, 0x948,
+							   u32tmp_1[0]);
+			else
+				btcoexist->btc_write_4byte(btcoexist, 0x948,
+							   0x280);
+			break;
+		}
+	}
+}
+#if 0
+boolean halbtc8723b2ant_CoexSwitchThresCheck(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8 wifi_rssi_state1, bt_rssi_state;
+	u32 vendor;
+	u8 offset = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_VENDOR, &vendor);
+
+	/* if (vendor == BTC_VENDOR_LENOVO) */
+	/*	offset = 20; */
+
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+		&prewifi_rssi_state, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES
+			   - coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	if (BTC_RSSI_LOW(wifi_rssi_state1) || BTC_RSSI_LOW(bt_rssi_state))
+		return true;
+
+	return false;
+}
+#endif
+
+
+void halbtc8723b2ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* fw all off */
+	halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	/* hw all off */
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); */
+	halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8723b2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+	halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8723b2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 1);
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 6);
+	halbtc8723b2ant_dec_bt_pwr(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	coex_sta->pop_event_cnt = 0;
+
+}
+
+void halbtc8723b2ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	boolean	wifi_connected = false;
+	boolean	low_pwr_disable = true;
+	boolean		scan = false, link = false, roam = false;
+	boolean wifi_busy = false;
+
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+			   &low_pwr_disable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+
+	if (coex_sta->bt_abnormal_scan) {
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+					23);
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	} else if (scan || link || roam) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi link process + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     7);
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+	} else if (wifi_connected) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     7);
+
+		if (wifi_busy)
+			halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						3);
+		else
+			halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi no-link + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	}
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 6);
+	halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+	/*
+		coex_dm->need_recover0x948 = true;
+		coex_dm->backup0x948 = btcoexist->btc_read_4byte(btcoexist, 0x948);
+
+		halbtc8723b2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_AUX, false, false);
+	*/
+}
+
+
+void halbtc8723b2ant_action_wifi_link_process(IN struct btc_coexist *btcoexist)
+{
+	u32	u32tmp;
+	u8	u8tmpa, u8tmpb;
+
+	halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 15);
+	halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+	halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+	u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+	u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x76e=0x%x\n",
+		    u32tmp,  u8tmpa, u8tmpb);
+	BTC_TRACE(trace_buf);
+}
+
+boolean halbtc8723b2ant_action_wifi_idle_process(IN struct btc_coexist
+		*btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u8		ap_num = 0;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	/* wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist, 1, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES-coex_dm->switch_thres_offset-coex_dm->switch_thres_offset, 0); */
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+		coex_dm->switch_thres_offset - coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+		coex_dm->switch_thres_offset - coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM, &ap_num);
+
+	/* define the office environment */
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) &&
+	    (coex_sta->hid_exist == true) &&
+	    (coex_sta->a2dp_exist == true)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi  idle process for BT HID+A2DP exist!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723b2ant_dac_swing(btcoexist, NORMAL_EXEC, true, 0x6);
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		/* sw all off */
+		halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false,
+					      false);
+		halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+		return true;
+	}
+
+	halbtc8723b2ant_dac_swing(btcoexist, NORMAL_EXEC, true, 0x18);
+	return false;
+}
+
+
+
+boolean halbtc8723b2ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+	boolean			bt_hs_on = false, low_pwr_disable = false;
+	boolean			asus_8723b = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected) {
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non-connected idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+		halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false,
+					      false);
+		halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+
+		common = true;
+	} else {
+		if (BT_8723B_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status) {
+			low_pwr_disable = false;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+			halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, false, 0x8);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+			halbtc8723b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+			halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+			halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 0xb);
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false,
+						      false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else if (BT_8723B_2ANT_BT_STATUS_CONNECTED_IDLE ==
+			   coex_dm->bt_status) {
+			low_pwr_disable = true;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+
+			if (bt_hs_on)
+				return false;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, false, 0x8);
+
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+			halbtc8723b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+			halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+			halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 0xb);
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else {
+			low_pwr_disable = true;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+
+			if (wifi_busy) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+				/* btcoexist->btc_get(btcoexist,
+					BTC_GET_BL_IS_ASUS_8723B, &asus_8723b);
+				if (!asus_8723b)
+					common = false;
+				else
+					common = halbtc8723b2ant_action_wifi_idle_process(
+							 btcoexist); */
+				common = false;
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+				/* common = false;	 */
+				common = halbtc8723b2ant_action_wifi_idle_process(
+						 btcoexist);
+			}
+		}
+	}
+
+	return common;
+}
+void halbtc8723b2ant_tdma_duration_adjust(IN struct btc_coexist *btcoexist,
+		IN boolean sco_hid, IN boolean tx_pause, IN u8 max_interval)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0;
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+		{
+			if (sco_hid) {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					} else if (max_interval == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (max_interval == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					} else if (max_interval == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (max_interval == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			} else {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (max_interval == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (max_interval == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (max_interval == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (max_interval == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					}
+				}
+			}
+		}
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* acquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+
+		if ((coex_sta->low_priority_tx) > 1050 ||
+		    (coex_sta->low_priority_rx) > 1250)
+			retry_count++;
+
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if retry count during continuous n*2 seconds is 0, enlarge WiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {/* if continuous 2 retry count(every 2 seconds) >0 and < 3, reduce WiFi duration */
+				if (wait_count <= 2)
+					m++; /* to avoid loop between the two levels */
+				else
+					m = 1;
+
+				if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, once retry count > 3, to reduce WiFi duration */
+			if (wait_count == 1)
+				m++; /* to avoid loop between the two levels */
+			else
+				m = 1;
+
+			if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (max_interval == 1) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 71) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 13);
+					coex_dm->ps_tdma_du_adj_type = 13;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 71);
+					coex_dm->ps_tdma_du_adj_type = 71;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 9);
+					coex_dm->ps_tdma_du_adj_type = 9;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 71) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 71);
+						coex_dm->ps_tdma_du_adj_type =
+							71;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					}
+				}
+			}
+		} else if (max_interval == 2) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					}
+				}
+			}
+		} else if (max_interval == 3) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			}
+		}
+	}
+
+	/* if current PsTdma not match with the recorded one (when scan, dhcp...), */
+	/* then we have to adjust it back to the previous record one. */
+	if (coex_dm->cur_ps_tdma != coex_dm->ps_tdma_du_adj_type) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], PsTdma type dismatch!!!, cur_ps_tdma=%d, recordPsTdma=%d\n",
+			    coex_dm->cur_ps_tdma, coex_dm->ps_tdma_du_adj_type);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (!scan && !link && !roam)
+			halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+}
+
+/* SCO only or SCO+PAN(HS) */
+void halbtc8723b2ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8	wifi_rssi_state, bt_rssi_state;
+	u32	wifi_bw;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 4);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for SCO quality at 11b/g mode */
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else  /* for SCO quality & wifi performance balance at 11n mode */
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+
+	halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+				0); /* for voice quality */
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x4);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x4);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x4);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x4);
+		}
+	}
+}
+
+
+void halbtc8723b2ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8	wifi_rssi_state, bt_rssi_state;
+	u32	wifi_bw;
+
+	btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 25);
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for HID at 11b/g mode */
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	else  /* for HID quality & wifi performance balance at 11n mode */
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 9);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+	else
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8723b2ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+	u8		ap_num = 0;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM, &ap_num);
+
+	/* define the office environment */
+	if ((ap_num >= 10) && BTC_RSSI_HIGH(wifi_rssi_state1) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+		/* dbg_print(" AP#>10(%d)\n", ap_num); */
+
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+		halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+		halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+		/* sw mechanism */
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x18);
+		}
+		return;
+
+	}
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+	}
+
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+		halbtc8723b2ant_tdma_duration_adjust(btcoexist, false, false,
+						     1);
+	else
+		halbtc8723b2ant_tdma_duration_adjust(btcoexist, false, true, 1);
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8723b2ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+	}
+
+	halbtc8723b2ant_tdma_duration_adjust(btcoexist, false, true, 2);
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8723b2ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     10);
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+	}
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 1);
+	else
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+
+/* PAN(HS) only */
+void halbtc8723b2ant_action_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+
+	halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* PAN(EDR)+A2DP */
+void halbtc8723b2ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u8		ap_num = 0;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &ap_num);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     12);
+
+		if (ap_num < 10)
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true,
+							     false, 1);
+		else
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true,
+							     false, 3);
+
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+		if (ap_num < 10)
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true,
+							     true, 1);
+		else
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true,
+							     true, 3);
+	}
+
+	/* sw mechanism	 */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8723b2ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 25);
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     14);
+	}
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		if (BTC_WIFI_BW_HT40 == wifi_bw) {
+			halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 3);
+			/* halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 11); */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x780);
+		} else {
+			halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 6);
+			/* halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7); */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+		}
+		halbtc8723b2ant_tdma_duration_adjust(btcoexist, true, false, 2);
+	} else {
+		halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		/* halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 14); */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+		halbtc8723b2ant_tdma_duration_adjust(btcoexist, true, true, 2);
+	}
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8723b2ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1,  bt_rssi_state;
+	u32		wifi_bw;
+
+	btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 25);
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     14);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true,
+							     true, 3);
+		else
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true,
+							     false, 3);
+	} else
+		halbtc8723b2ant_tdma_duration_adjust(btcoexist, true, true, 3);
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8723b2ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+	u8		ap_num = 0;
+
+	btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 35);
+
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	/* bt_rssi_state = halbtc8723b2ant_bt_rssi_state(2, 29, 0); */
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 3,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 37);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &ap_num);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true, 0x5);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) {
+		if (BTC_RSSI_HIGH(bt_rssi_state))
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	} else {
+		/* only 802.11N mode we have to dec bt power to 4 degree */
+		if (BTC_RSSI_HIGH(bt_rssi_state)) {
+			/* need to check ap Number of Not */
+			if (ap_num < 10)
+				halbtc8723b2ant_dec_bt_pwr(btcoexist,
+							   NORMAL_EXEC, 4);
+			else
+				halbtc8723b2ant_dec_bt_pwr(btcoexist,
+							   NORMAL_EXEC, 2);
+		} else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	}
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     14);
+	}
+
+	if (BTC_RSSI_HIGH(bt_rssi_state)) {
+		if (ap_num < 10)
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true,
+							     false, 2);
+
+		else
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true,
+							     false, 3);
+	} else {
+		halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 18);
+		btcoexist->btc_write_1byte(btcoexist, 0x456, 0x38);
+		btcoexist->btc_write_2byte(btcoexist, 0x42a, 0x0808);
+		btcoexist->btc_write_4byte(btcoexist, 0x430, 0x0);
+		btcoexist->btc_write_4byte(btcoexist, 0x434, 0x01010000);
+
+		if (ap_num < 10)
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true,
+							     true, 2);
+
+		else
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true,
+							     true, 3);
+	}
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8723b2ant_action_bt_whck_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8723b2ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	/* hw all off */
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); */
+	halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+}
+
+void halbtc8723b2ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8				algorithm = 0;
+	u32				num_of_wifi_link = 0;
+	u32				wifi_link_status = 0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean				miracast_plus_bt = false;
+	boolean				scan = false, link = false, roam = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_action_bt_whck_test(btcoexist);
+		return;
+	}
+
+	algorithm = halbtc8723b2ant_action_algorithm(btcoexist);
+	if (coex_sta->c2h_bt_inquiry_page &&
+	    (BT_8723B_2ANT_COEX_ALGO_PANHS != algorithm)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_action_bt_inquiry(btcoexist);
+		return;
+	}
+
+	/*
+		if(coex_dm->need_recover0x948)
+		{
+			coex_dm->need_recover0x948 = false;
+			btcoexist->btc_write_4byte(btcoexist, 0x948, coex_dm->backup0x948);
+		}
+	*/
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+	if (scan || link || roam) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under Link Process !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_action_wifi_link_process(btcoexist);
+		return;
+	}
+
+	/* for P2P */
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist)
+			miracast_plus_bt = true;
+		else
+			miracast_plus_bt = false;
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+		halbtc8723b2ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	}
+
+	miracast_plus_bt = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+			   &miracast_plus_bt);
+
+	coex_dm->cur_algorithm = algorithm;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Algorithm = %d\n",
+		    coex_dm->cur_algorithm);
+	BTC_TRACE(trace_buf);
+
+	if (halbtc8723b2ant_is_common_action(btcoexist)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant common.\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		if (coex_dm->cur_algorithm != coex_dm->pre_algorithm) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], pre_algorithm=%d, cur_algorithm=%d\n",
+				coex_dm->pre_algorithm, coex_dm->cur_algorithm);
+			BTC_TRACE(trace_buf);
+			coex_dm->auto_tdma_adjust = false;
+		}
+		switch (coex_dm->cur_algorithm) {
+		case BT_8723B_2ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_sco(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_hid(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_a2dp(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_a2dp_pan_hs(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_pan_edr(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_pan_hs(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_pan_edr_a2dp(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_pan_edr_hid(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_hid_a2dp_pan_edr(
+				btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_hid_a2dp(btcoexist);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_coex_all_off(btcoexist);
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8723b2ant_wifi_off_hw_cfg(IN struct btc_coexist *btcoexist)
+{
+	boolean	is_in_mp_mode = false;
+	u8 h2c_parameter[2] = {0};
+	u32 fw_ver = 0;
+
+	/* set wlan_act to low */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+			  0x780); /* WiFi goto standby while GNT_BT 0-->1 */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	if (fw_ver >= 0x180000) {
+		/* Use H2C to set GNT_BT to HIGH */
+		h2c_parameter[0] = 1;
+		btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1, h2c_parameter);
+	} else
+		btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_IS_IN_MP_MODE,
+			   &is_in_mp_mode);
+	if (!is_in_mp_mode)
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+			   0x0); /* BT select s0/s1 is controlled by BT */
+	else
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+			   0x1); /* BT select s0/s1 is controlled by WiFi */
+}
+
+void halbtc8723b2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up)
+{
+	u8	u8tmp = 0;
+	u32	 vendor;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 2Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_VENDOR, &vendor);
+	if (vendor == BTC_VENDOR_LENOVO)
+		coex_dm->switch_thres_offset = 0;
+	else if (vendor == BTC_VENDOR_ASUS)
+		coex_dm->switch_thres_offset = 0;
+	else
+		coex_dm->switch_thres_offset = 20;
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	/* backup rf 0x1e value */
+	coex_dm->bt_rf_0x1e_backup =
+		btcoexist->btc_get_rf_reg(btcoexist, BTC_RF_A, 0x1e, 0xfffff);
+
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* Antenna config	 */
+	halbtc8723b2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN, true,
+				     false);
+	coex_sta->dis_ver_info_cnt = 0;
+
+	/* PTA parameter */
+	halbtc8723b2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	/* Enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e,
+			   0x4); /* 0x76e[3] =1, WLAN_Act control by PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x3);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+
+	/* Give bt_coex_supported_version the default value */
+	coex_sta->bt_coex_supported_version = 0;
+
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8723b2ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8723b2ant_
+ * ************************************************************ */
+void ex_halbtc8723b2ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u16 u16tmp = 0x0;
+	u32				value = 0;
+	u32    u32tmp_1[4];
+
+	btcoexist->btc_write_1byte(btcoexist, 0x67, 0x20);
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write 0x948 correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+	btcoexist->btc_write_4byte(btcoexist, 0x948, 0x0);
+
+	if (btcoexist->chip_interface == BTC_INTF_USB) {
+		/* fixed at S0 for USB interface */
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+	} else {
+		/* for PCIE and SDIO interface, we check efuse 0xc3[6] */
+		if (board_info->single_ant_path == 0) {
+			/* set to S1 */
+			board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+		} else if (board_info->single_ant_path == 1) {
+			/* set to S0 */
+			board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+		}
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ANTPOSREGRISTRY_CTRL,
+				   &value);
+	}
+}
+
+void ex_halbtc8723b2ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x4; /* Set BIT2 by default since it's 2ant case */
+
+	/* */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+	if (btcoexist->chip_interface == BTC_INTF_USB) {
+		/* fixed at S0 for USB interface */
+		u8tmp |= 0x1;	/* antenna inverse */
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	} else {
+		if (board_info->single_ant_path == 1) {
+			/* set to S0 */
+			u8tmp |= 0x1;	/* antenna inverse */
+		}
+
+		if (btcoexist->chip_interface == BTC_INTF_PCI)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x384,
+							     u8tmp);
+		else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60,
+							     u8tmp);
+	}
+}
+
+void ex_halbtc8723b2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8723b2ant_init_hw_config(btcoexist, true);
+}
+
+void ex_halbtc8723b2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8723b2ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8723b2ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u32				u32tmp[4];
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+	u32				fw_ver = 0, bt_patch_ver = 0;
+	u32				bt_coex_ver = 0;
+	static u8			pop_report_in_10s = 0;
+	u32				phyver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+	/* btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver); */
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+	bt_coex_ver = coex_sta->bt_coex_supported_version & 0xff;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+		   "CoexVer WL/  BT_Desired/ BT_Report",
+		   glcoex_ver_date_8723b_2ant, glcoex_ver_8723b_2ant,
+		   glcoex_ver_btdesired_8723b_2ant,
+		   bt_coex_ver,
+		   (bt_coex_ver == 0xff ? "Unknown" :
+		    (bt_coex_ver >= glcoex_ver_btdesired_8723b_2ant ?
+		     "Match" : "Mis-Match")));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d/ %c",
+		   "W_FW/ B_FW/ Phy/ Kt",
+		   fw_ver, bt_patch_ver, phyver,
+		   coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Abnormal scan",
+		   (coex_sta->bt_abnormal_scan) ? "Yes" : "No");
+	CL_PRINTF(cli_buf);
+
+	pop_report_in_10s++;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt/ popCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8723B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8723B_2ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi - 100, coex_sta->bt_retry_cnt,
+		   coex_sta->pop_event_cnt);
+	CL_PRINTF(cli_buf);
+
+	if (pop_report_in_10s >= 5) {
+		coex_sta->pop_event_cnt = 0;
+		pop_report_in_10s = 0;
+	}
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d / %d / %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP/NameReq/WHQL",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist,
+		   coex_sta->c2h_bt_remote_name_req,
+		   coex_sta->bt_whck_test);
+	CL_PRINTF(cli_buf);
+
+	{
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+			   "BT Role",
+			   (bt_link_info->slave_role) ? "Slave" : "Master");
+		CL_PRINTF(cli_buf);
+	}
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %d",
+		   "A2DP Rate/Bitpool",
+		(bt_info_ext & BIT(0)) ? "BR" : "EDR", coex_sta->a2dp_bit_pool);
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8723B_2ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8723b_2ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	/* Sw mechanism	 */
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[Sw mechanism] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[Sw mechanism]============");
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ",
+		   "SM1[ShRf/ LpRA/ LimDig]",
+		   coex_dm->cur_rf_rx_lpf_shrink, coex_dm->cur_low_penalty_ra,
+		   coex_dm->limited_dig);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ",
+		   "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]",
+		   coex_dm->cur_agc_table_en, coex_dm->cur_adc_back_off,
+		   coex_dm->cur_dac_swing_on, coex_dm->cur_dac_swing_lvl);
+	CL_PRINTF(cli_buf);
+
+	/* Fw mechanism		 */
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[Fw mechanism] (before Manual) ============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[Fw mechanism]============");
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+
+	if (coex_dm->is_switch_to_1dot5_ant)
+		ps_tdma_case = ps_tdma_case + 100;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (%s,%s)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   (coex_dm->cur_ps_tdma_on ? "On" : "Off"),
+		   (coex_dm->auto_tdma_adjust ? "Adj" : "Fix"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Coex Table Type",
+		   coex_sta->coex_table_type);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "DecBtPwr/ IgnWlanAct",
+		   coex_dm->cur_bt_dec_pwr_lvl, coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x",
+		   "RF-A, 0x1e initVal",
+		   coex_dm->bt_rf_0x1e_backup);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x880);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x778/0x880[29:25]",
+		   u8tmp[0], (u32tmp[0] & 0x3e000000) >> 25);
+	CL_PRINTF(cli_buf);
+
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x948);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x67);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x765);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x948/ 0x67[5] / 0x765",
+		   u32tmp[0], ((u8tmp[0] & 0x20) >> 5), u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x92c);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x930);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x944);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x92c[1:0]/ 0x930[7:0]/0x944[1:0]",
+		   u32tmp[0] & 0x3, u32tmp[1] & 0xff, u32tmp[2] & 0x3);
+	CL_PRINTF(cli_buf);
+
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x39);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0x64);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x38[11]/0x40/0x4c[24:23]/0x64[0]",
+		   ((u8tmp[0] & 0x8) >> 3), u8tmp[1],
+		   ((u32tmp[0] & 0x01800000) >> 23), u8tmp[2] & 0x1);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x49c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xc50(dig)/0x49c(null-drop)",
+		   u32tmp[0] & 0xff, u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8723B_2ANT == 1)
+	/* halbtc8723b2ant_monitor_bt_ctr(btcoexist); */
+#endif
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8723b2ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+		halbtc8723b2ant_wifi_off_hw_cfg(btcoexist);
+		halbtc8723b2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		halbtc8723b2ant_coex_all_off(btcoexist);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+		halbtc8723b2ant_init_hw_config(btcoexist, false);
+		halbtc8723b2ant_init_coex_dm(btcoexist);
+		halbtc8723b2ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8723b2ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8723b2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	u32	u32tmp;
+	u8	u8tmpa, u8tmpb;
+
+
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+	u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+	u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+
+	if (BTC_SCAN_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN,
+					     false, false);
+	} else if (BTC_SCAN_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x76e=0x%x\n",
+		    u32tmp,  u8tmpa, u8tmpb);
+	BTC_TRACE(trace_buf);
+}
+
+void ex_halbtc8723b2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	if (BTC_ASSOCIATE_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN,
+					     false, false);
+	} else if (BTC_ASSOCIATE_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8723b2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	u8			ap_num = 0;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN,
+					     false, false);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] = 0x1;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else {
+			btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+					   &ap_num);
+			if (ap_num < 10)
+				h2c_parameter[2] = 0x30;
+			else
+				h2c_parameter[2] = 0x20;
+		}
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+}
+
+void ex_halbtc8723b2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	if (type == BTC_PACKET_DHCP) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], DHCP Packet notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8723b2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8			bt_info = 0;
+	u8			i, rsp_source = 0;
+	boolean			bt_busy = false, limited_dig = false;
+	boolean			wifi_connected = false;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8723B_2ANT_MAX)
+		rsp_source = BT_INFO_SRC_8723B_2ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), return for Manual CTRL<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	/* if 0xff, it means BT is under WHCK test */
+	if (bt_info == 0xff)
+		coex_sta->bt_whck_test = true;
+	else
+		coex_sta->bt_whck_test = false;
+
+	if (BT_INFO_SRC_8723B_2ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		if (coex_sta->bt_info_c2h[rsp_source][2] & 0x20)
+			coex_sta->c2h_bt_remote_name_req = true;
+		else
+			coex_sta->c2h_bt_remote_name_req = false;
+
+		if (coex_sta->bt_info_c2h[rsp_source][1] == 0x49) {
+			coex_sta->a2dp_bit_pool =
+				coex_sta->bt_info_c2h[rsp_source][6];
+		} else
+			coex_sta->a2dp_bit_pool = 0;
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+		if (coex_sta->bt_tx_rx_mask) {
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x01 => Need to switch BT TRx Mask */
+			/* BT TRx mask off */
+			btcoexist->btc_set_bt_trx_mask(btcoexist, 0);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex], BT TRx Mask off for BT Info Notify\n");
+			BTC_TRACE(trace_buf);
+#if 0
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x01\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+						  0x3c, 0x01);
+#endif
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if ((coex_sta->bt_info_ext & BIT(1))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8723b2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8723b2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if ((coex_sta->bt_info_ext & BIT(3))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_ignore_wlan_act(btcoexist, FORCE_EXEC,
+							false);
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+		}
+#if (BT_AUTO_REPORT_ONLY_8723B_2ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8723b2ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8723B_2ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8723B_2ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8723B_2ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8723B_2ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8723B_2ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8723B_2ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+
+		if ((coex_sta->hid_exist == false) &&
+		    (coex_sta->c2h_bt_inquiry_page == false) &&
+		    (coex_sta->sco_exist == false)) {
+			if (coex_sta->high_priority_tx  +
+			    coex_sta->high_priority_rx >= 160) {
+				coex_sta->hid_exist = true;
+				bt_info = bt_info | 0x28;
+			}
+		}
+	}
+
+	halbtc8723b2ant_update_bt_link_info(btcoexist);
+
+	if (!(bt_info & BT_INFO_8723B_2ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8723B_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8723B_2ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8723B_2ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8723B_2ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8723B_2ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8723B_2ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8723B_2ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8723B_2ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8723B_2ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8723B_2ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8723B_2ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8723B_2ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status)) {
+		bt_busy = true;
+		limited_dig = true;
+	} else {
+		bt_busy = false;
+		limited_dig = false;
+	}
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	coex_dm->limited_dig = limited_dig;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_LIMITED_DIG, &limited_dig);
+
+	halbtc8723b2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8723b2ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8723b2ant_wifi_off_hw_cfg(btcoexist);
+	/* remove due to interrupt is disabled that polling c2h will fail and delay 100ms. */
+	/* btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x3c, 0x15); */ /*BT goto standby while GNT_BT 1-->0 */
+	halbtc8723b2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8723b2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+}
+
+void ex_halbtc8723b2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_init_hw_config(btcoexist, false);
+		halbtc8723b2ant_init_coex_dm(btcoexist);
+		halbtc8723b2ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8723b2ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	u32 bt_patch_ver;
+
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ==========================Periodical===========================\n");
+	BTC_TRACE(trace_buf);
+	if (coex_sta->dis_ver_info_cnt <= 5) {
+		coex_sta->dis_ver_info_cnt += 1;
+		if (coex_sta->dis_ver_info_cnt == 3) {
+			/* Antenna config to set 0x765 = 0x0 (GNT_BT control by PTA) after initial */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Set GNT_BT control by PTA\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_set_ant_path(btcoexist,
+				     BTC_ANT_WIFI_AT_MAIN, false, false);
+		}
+	}
+
+	if (((coex_sta->bt_coex_supported_version == 0) ||
+	     (coex_sta->bt_coex_supported_version == 0xffff)) && (!coex_sta->bt_disabled))
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION, &coex_sta->bt_coex_supported_version);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+
+#if (BT_AUTO_REPORT_ONLY_8723B_2ANT == 0)
+	halbtc8723b2ant_query_bt_info(btcoexist);
+	halbtc8723b2ant_monitor_bt_enable_disable(btcoexist);
+#else
+	halbtc8723b2ant_monitor_bt_ctr(btcoexist);
+	halbtc8723b2ant_monitor_wifi_ctr(btcoexist);
+
+	/* for some BT speaker that Hi-Pri pkt appear begore start play, this will cause HID exist */
+	if ((coex_sta->high_priority_tx  + coex_sta->high_priority_rx < 50) &&
+	    (bt_link_info->hid_exist == true))
+		bt_link_info->hid_exist  = false;
+
+	if (halbtc8723b2ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust)
+		halbtc8723b2ant_run_coexist_mechanism(btcoexist);
+#endif
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
+
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8723b2ant.h
@@ -0,0 +1,217 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8723B_SUPPORT == 1)
+/* *******************************************
+ * The following is for 8723B 2Ant BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8723B_2ANT				1
+
+
+#define	BT_INFO_8723B_2ANT_B_FTP						BIT(7)
+#define	BT_INFO_8723B_2ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8723B_2ANT_B_HID						BIT(5)
+#define	BT_INFO_8723B_2ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8723B_2ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8723B_2ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8723B_2ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8723B_2ANT_B_CONNECTION				BIT(0)
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT		2
+
+
+#define	BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES				42  /* WiFi RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation */
+#define	BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES				46 /* BT RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation */
+
+enum bt_info_src_8723b_2ant {
+	BT_INFO_SRC_8723B_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8723B_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8723B_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8723B_2ANT_MAX
+};
+
+enum bt_8723b_2ant_bt_status {
+	BT_8723B_2ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8723B_2ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8723B_2ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8723B_2ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8723B_2ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8723B_2ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8723B_2ANT_BT_STATUS_MAX
+};
+
+enum bt_8723b_2ant_coex_algo {
+	BT_8723B_2ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8723B_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8723B_2ANT_COEX_ALGO_HID				= 0x2,
+	BT_8723B_2ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8723B_2ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8723B_2ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8723B_2ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8723B_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8723B_2ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8723B_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8723B_2ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8723B_2ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8723b_2ant {
+	/* fw mechanism */
+	u8		pre_bt_dec_pwr_lvl;
+	u8		cur_bt_dec_pwr_lvl;
+	u8		pre_fw_dac_swing_lvl;
+	u8		cur_fw_dac_swing_lvl;
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		reset_tdma_adjust;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+
+	/* sw mechanism */
+	boolean		pre_rf_rx_lpf_shrink;
+	boolean		cur_rf_rx_lpf_shrink;
+	u32		bt_rf_0x1e_backup;
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	boolean		pre_dac_swing_on;
+	u32		pre_dac_swing_lvl;
+	boolean		cur_dac_swing_on;
+	u32		cur_dac_swing_lvl;
+	boolean		pre_adc_back_off;
+	boolean		cur_adc_back_off;
+	boolean	pre_agc_table_en;
+	boolean		cur_agc_table_en;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	boolean		need_recover0x948;
+	u32		backup0x948;
+
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	boolean		is_switch_to_1dot5_ant;
+	u8		switch_thres_offset;
+};
+
+struct coex_sta_8723b_2ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+	boolean					bt_abnormal_scan;
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	u8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8723B_2ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8723B_2ANT_MAX];
+	boolean				bt_whck_test;
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_remote_name_req;
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_vht;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_vht;
+
+	u32					bt_coex_supported_version;
+
+	u8					coex_table_type;
+	boolean					force_lps_on;
+
+	u8					dis_ver_info_cnt;
+
+	u8					a2dp_bit_pool;
+	u8					cut_version;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8723b2ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b2ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8723b2ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8723b2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8723b2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8723b2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8723b2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723b2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723b2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8723b2ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8723b2ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b2ant_display_coex_info(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8723b2ant_power_on_setting(btcoexist)
+#define	ex_halbtc8723b2ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8723b2ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8723b2ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8723b2ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8723b2ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8723b2ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8723b2ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8723b2ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8723b2ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8723b2ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8723b2ant_halt_notify(btcoexist)
+#define	ex_halbtc8723b2ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8723b2ant_periodical(btcoexist)
+#define	ex_halbtc8723b2ant_display_coex_info(btcoexist)
+
+#endif
+
+#endif
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8723bwifionly.c
@@ -0,0 +1,68 @@
+#include "mp_precomp.h"
+
+
+VOID
+ex_hal8723b_wifi_only_hw_config(
+	IN struct wifi_only_cfg *pwifionlycfg
+	)
+{
+	struct wifi_only_haldata *pwifionly_haldata = &pwifionlycfg->haldata_info;
+
+
+	halwifionly_write1byte(pwifionlycfg, 0x778, 0x3); /* Set pta for wifi first priority, 0x1 need to reference pta table to determine wifi and bt priority */
+	halwifionly_bitmaskwrite1byte(pwifionlycfg, 0x40, 0x20, 0x1);
+
+	/* Set Antenna path to Wifi */
+	halwifionly_write2byte(pwifionlycfg, 0x0765, 0x8); /* Set pta for wifi first priority, 0x0 need to reference pta table to determine wifi and bt priority */
+	halwifionly_write2byte(pwifionlycfg, 0x076e, 0xc);
+
+	halwifionly_write4byte(pwifionlycfg, 0x000006c0, 0xaaaaaaaa); /* pta table, 0xaaaaaaaa means wifi is higher priority than bt */
+	halwifionly_write4byte(pwifionlycfg, 0x000006c4, 0xaaaaaaaa);
+
+	halwifionly_bitmaskwrite1byte(pwifionlycfg, 0x67, 0x20, 0x1); /* BT select s0/s1 is controlled by WiFi */
+
+	/* 0x948 setting */
+	if (pwifionlycfg->chip_interface == WIFIONLY_INTF_PCI) {
+		/* HP Foxconn NGFF at S0
+		 not sure HP pg correct or not(EEPROMBluetoothSingleAntPath), so here we just write
+		 0x948=0x280 for HP HW id NIC. */
+		if (pwifionly_haldata->customer_id == CUSTOMER_HP_1) {
+			halwifionly_write4byte(pwifionlycfg, 0x948, 0x280);
+			halwifionly_phy_set_rf_reg(pwifionlycfg, 0, 0x1, 0xfffff, 0x0); /* WiFi TRx Mask off */
+			return;
+		}
+	}
+
+	if (pwifionly_haldata->efuse_pg_antnum == 2) {
+		halwifionly_write4byte(pwifionlycfg, 0x948, 0x0);
+	} else {
+	/* 3Attention !!! For 8723BU  !!!!
+	 For 8723BU single ant case: jira [USB-1237]
+		   Because of 8723BU S1 has HW problem, we only can use S0 instead.
+		   Whether Efuse 0xc3 [6] is 0 or 1, we should always use S0 and write 0x948 to 80/280
+
+	 --------------------------------------------------
+	 BT Team :
+		  When in Single Ant case, Reg[0x948] has two case : 0x80 or 0x200
+		 When in Two Ant case, Reg[0x948] has two case : 0x280 or 0x0
+		  Efuse 0xc3 [6] Antenna Path
+		  0xc3 [6] = 0	 ==>  S1	 ==>   0x948 = 0/40/200
+		  0xc3 [6] = 1	 ==>  S0	 ==>   0x948 = 80/240/280 */
+
+		if (pwifionlycfg->chip_interface == WIFIONLY_INTF_USB)
+			halwifionly_write4byte(pwifionlycfg, 0x948, 0x80);
+		else {
+			if (pwifionly_haldata->efuse_pg_antpath == 0)
+				halwifionly_write4byte(pwifionlycfg, 0x948, 0x0);
+			else
+				halwifionly_write4byte(pwifionlycfg, 0x948, 0x280);
+		}
+
+	}
+
+
+	/* after 8723B F-cut, TRx Mask should be set when 0x948=0x0 or 0x280
+	PHY_SetRFReg(Adapter, 0, 0x1, 0xfffff, 0x780); WiFi TRx Mask on */
+	halwifionly_phy_set_rf_reg(pwifionlycfg, 0, 0x1, 0xfffff, 0x0); /*WiFi TRx Mask off */
+
+}
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8723bwifionly.h
@@ -0,0 +1,8 @@
+#ifndef __INC_HAL8723BWIFIONLYHWCFG_H
+#define __INC_HAL8723BWIFIONLYHWCFG_H
+
+VOID
+ex_hal8723b_wifi_only_hw_config(
+	IN struct wifi_only_cfg *pwifionlycfg
+	);
+#endif
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8723d1ant.c
@@ -0,0 +1,6279 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8723D Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8723D_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	*trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8723d_1ant		glcoex_dm_8723d_1ant;
+static struct  coex_dm_8723d_1ant	*coex_dm = &glcoex_dm_8723d_1ant;
+static struct  coex_sta_8723d_1ant		glcoex_sta_8723d_1ant;
+static struct  coex_sta_8723d_1ant	*coex_sta = &glcoex_sta_8723d_1ant;
+static struct  psdscan_sta_8723d_1ant	gl_psd_scan_8723d_1ant;
+static struct  psdscan_sta_8723d_1ant *psd_scan = &gl_psd_scan_8723d_1ant;
+
+
+const char *const glbt_info_src_8723d_1ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+/* ************************************************************
+ * BtCoex Version Format:
+ * 1. date :			glcoex_ver_date_XXXXX_1ant
+ * 2. WifiCoexVersion : glcoex_ver_XXXX_1ant
+ * 3. BtCoexVersion :	glcoex_ver_btdesired_XXXXX_1ant
+ * 4. others :			glcoex_ver_XXXXXX_XXXXX_1ant
+ *
+ * Variable should be indicated IC and Antenna numbers !!!
+ * Please strictly follow this order and naming style !!!
+ *
+ * ************************************************************ */
+u32	glcoex_ver_date_8723d_1ant = 20161123;
+u32	glcoex_ver_8723d_1ant = 0x11;
+u32 glcoex_ver_btdesired_8723d_1ant = 0x10;
+
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8723d1ant_
+ * ************************************************************ */
+u8 halbtc8723d1ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8723D_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8723D_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8723D_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8723d1ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8723D_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8723D_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8723D_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8723d1ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8723d1ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8723d1ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8723d1ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8723d1ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8723d1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8723d1ant_update_ra_mask(btcoexist, force_exec,
+					       0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8723d1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8723d1ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8723d1ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8723d1ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8723d1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8723d1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], WL query BT info!!\n");
+	BTC_TRACE(trace_buf);
+}
+
+void halbtc8723d1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32 reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32 reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u8		num_of_bt_counter_chk = 0, cnt_slave = 0, cnt_overhead = 0,
+				cnt_autoslot_hang = 0;
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* to avoid 0x76e[3] = 1 (WLAN_Act control by PTA) during IPS */
+	/* if (! (btcoexist->btc_read_1byte(btcoexist, 0x76e) & 0x8) ) */
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if (BT_8723D_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		coex_dm->bt_status) {
+
+			if (coex_sta->high_priority_rx >= 15) {
+					if (cnt_overhead < 3)
+						cnt_overhead++;
+
+					if (cnt_overhead == 3)
+						coex_sta->is_hiPri_rx_overhead = true;
+			} else {
+					if (cnt_overhead > 0)
+						cnt_overhead--;
+
+					if (cnt_overhead == 0)
+						coex_sta->is_hiPri_rx_overhead = false;
+			}
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Hi-Pri Rx/Tx: %d/%d, Lo-Pri Rx/Tx: %d/%d\n",
+			reg_hp_rx, reg_hp_tx, reg_lp_rx, reg_lp_tx);
+
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	if ((coex_sta->low_priority_tx > 1150)	&&
+		(!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	if ((coex_sta->low_priority_rx >= 1150) &&
+		(coex_sta->low_priority_rx >= coex_sta->low_priority_tx)
+		&& (!coex_sta->under_ips)  && (!coex_sta->c2h_bt_inquiry_page) &&
+		(coex_sta->bt_link_exist))	{
+		if (cnt_slave >= 2) {
+			bt_link_info->slave_role = true;
+			cnt_slave = 2;
+		} else
+			cnt_slave++;
+	} else {
+		if (cnt_slave == 0) {
+			bt_link_info->slave_role = false;
+			cnt_slave = 0;
+		} else
+			cnt_slave--;
+
+	}
+
+	if (coex_sta->is_tdma_btautoslot) {
+		if ((coex_sta->low_priority_tx >= 1300) &&
+			(coex_sta->low_priority_rx <= 150)) {
+			if (cnt_autoslot_hang >= 2) {
+				coex_sta->is_tdma_btautoslot_hang = true;
+				cnt_autoslot_hang = 2;
+			} else
+				cnt_autoslot_hang++;
+		} else {
+			if (cnt_autoslot_hang == 0)	{
+				coex_sta->is_tdma_btautoslot_hang = false;
+				cnt_autoslot_hang = 0;
+			} else
+				cnt_autoslot_hang--;
+		}
+	}
+
+	if (!coex_sta->bt_disabled) {
+
+		if ((coex_sta->high_priority_tx == 0) &&
+			(coex_sta->high_priority_rx == 0) &&
+			(coex_sta->low_priority_tx == 0) &&
+			(coex_sta->low_priority_rx == 0)) {
+			num_of_bt_counter_chk++;
+			if (num_of_bt_counter_chk >= 3) {
+				halbtc8723d1ant_query_bt_info(btcoexist);
+				num_of_bt_counter_chk = 0;
+			}
+		}
+	}
+
+}
+
+void halbtc8723d1ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+#if 1
+		s32 wifi_rssi = 0;
+		boolean wifi_busy = false, wifi_under_b_mode = false,
+			    wifi_scan = false;
+		boolean	bt_idle = false, wl_idle = false;
+	    static u8 cck_lock_counter = 0, wl_noisy_count0 = 0,
+		       wl_noisy_count1 = 3, wl_noisy_count2 = 0;
+		u32 total_cnt, reg_val1, reg_val2, cck_cnt;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+		btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+
+		coex_sta->crc_ok_cck = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_OK_CCK);
+		coex_sta->crc_ok_11g = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_OK_LEGACY);
+		coex_sta->crc_ok_11n = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_OK_HT);
+		coex_sta->crc_ok_11n_vht = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_OK_VHT);
+
+		coex_sta->crc_err_cck = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_ERROR_CCK);
+		coex_sta->crc_err_11g =  btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_ERROR_LEGACY);
+		coex_sta->crc_err_11n = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_ERROR_HT);
+		coex_sta->crc_err_11n_vht = btcoexist->btc_phydm_query_PHY_counter(
+									btcoexist, PHYDM_INFO_CRC32_ERROR_VHT);
+
+		cck_cnt = coex_sta->crc_ok_cck + coex_sta->crc_err_cck;
+
+		if (cck_cnt > 250) {
+			if (wl_noisy_count2 < 3)
+				wl_noisy_count2++;
+
+			if (wl_noisy_count2 == 3) {
+				wl_noisy_count0 = 0;
+				wl_noisy_count1 = 0;
+			}
+		} else if (cck_cnt < 50) {
+			if (wl_noisy_count0 < 3)
+				wl_noisy_count0++;
+
+			if (wl_noisy_count0 == 3) {
+				wl_noisy_count1 = 0;
+				wl_noisy_count2 = 0;
+			}
+		} else {
+			if (wl_noisy_count1 < 3)
+				wl_noisy_count1++;
+
+			if (wl_noisy_count1 == 3) {
+				wl_noisy_count0 = 0;
+				wl_noisy_count2 = 0;
+			}
+		}
+
+		if (wl_noisy_count2 == 3)
+			coex_sta->wl_noisy_level = 2;
+		else if (wl_noisy_count1 == 3)
+			coex_sta->wl_noisy_level = 1;
+		else
+			coex_sta->wl_noisy_level = 0;
+
+		if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+			total_cnt = coex_sta->crc_ok_cck + coex_sta->crc_ok_11g +
+					coex_sta->crc_ok_11n + coex_sta->crc_ok_11n_vht;
+
+			if ((coex_dm->bt_status == BT_8723D_1ANT_BT_STATUS_ACL_BUSY) ||
+				(coex_dm->bt_status == BT_8723D_1ANT_BT_STATUS_ACL_SCO_BUSY) ||
+				(coex_dm->bt_status == BT_8723D_1ANT_BT_STATUS_SCO_BUSY)) {
+				if (coex_sta->crc_ok_cck > (total_cnt -
+								coex_sta->crc_ok_cck)) {
+					if (cck_lock_counter < 3)
+						cck_lock_counter++;
+				} else {
+					if (cck_lock_counter > 0)
+						cck_lock_counter--;
+				}
+
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+
+		if (!coex_sta->pre_ccklock) {
+
+			if (cck_lock_counter >= 3)
+				coex_sta->cck_lock = true;
+			else
+				coex_sta->cck_lock = false;
+		} else {
+			if (cck_lock_counter == 0)
+				coex_sta->cck_lock = false;
+			else
+				coex_sta->cck_lock = true;
+		}
+
+		if (coex_sta->cck_lock)
+			coex_sta->cck_ever_lock = true;
+
+		coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+#endif
+}
+
+void halbtc8723d1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct	btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean		bt_hs_on = false;
+	boolean		bt_busy = false;
+
+
+	coex_sta->num_of_profile = 0;
+
+	/* set link exist status */
+	if (!(coex_sta->bt_info & BT_INFO_8723D_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (coex_sta->bt_info & BT_INFO_8723D_1ANT_B_FTP) {
+			coex_sta->pan_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->pan_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8723D_1ANT_B_A2DP) {
+			coex_sta->a2dp_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->a2dp_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8723D_1ANT_B_HID) {
+			coex_sta->hid_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->hid_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8723D_1ANT_B_SCO_ESCO) {
+			coex_sta->sco_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->sco_exist = false;
+
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+	bt_link_info->acl_busy = coex_sta->acl_busy;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+
+	if (coex_sta->bt_info & BT_INFO_8723D_1ANT_B_INQ_PAGE) {
+		coex_dm->bt_status = BT_8723D_1ANT_BT_STATUS_INQ_PAGE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Inq/page!!!\n");
+	} else if (!(coex_sta->bt_info & BT_INFO_8723D_1ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8723D_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+	} else if (coex_sta->bt_info == BT_INFO_8723D_1ANT_B_CONNECTION) {
+		/* connection exists but no busy */
+		coex_dm->bt_status = BT_8723D_1ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+	} else if (((coex_sta->bt_info & BT_INFO_8723D_1ANT_B_SCO_ESCO) ||
+		    (coex_sta->bt_info & BT_INFO_8723D_1ANT_B_SCO_BUSY)) &&
+		   (coex_sta->bt_info & BT_INFO_8723D_1ANT_B_ACL_BUSY)) {
+		coex_dm->bt_status = BT_8723D_1ANT_BT_STATUS_ACL_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL SCO busy!!!\n");
+	} else if ((coex_sta->bt_info & BT_INFO_8723D_1ANT_B_SCO_ESCO) ||
+		   (coex_sta->bt_info & BT_INFO_8723D_1ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8723D_1ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+	} else if (coex_sta->bt_info & BT_INFO_8723D_1ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8723D_1ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+	} else {
+		coex_dm->bt_status = BT_8723D_1ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+	}
+
+	BTC_TRACE(trace_buf);
+
+	if ((BT_8723D_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8723D_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8723D_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+}
+
+
+void halbtc8723d1ant_update_wifi_channel_info(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] =
+			0x1;  /* enable BT AFH skip WL channel for 8723d because BT Rx LO interference */
+		/* h2c_parameter[0] = 0x0; */
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+
+}
+
+u8 halbtc8723d1ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8723D_1ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Profile = SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8723D_1ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723D_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723D_1ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_1ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_1ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723D_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723D_1ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8723D_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723D_1ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_1ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_1ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723D_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8723D_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_1ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! BT Profile = SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8723d1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8723d1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8723d1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8723d1ant_set_fw_low_penalty_ra(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+#if 1
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf7;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf8;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf9;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+#endif
+}
+
+void halbtc8723d1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+#if 1
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+
+	halbtc8723d1ant_set_fw_low_penalty_ra(btcoexist,
+					      coex_dm->cur_low_penalty_ra);
+
+#if 0
+	if (low_penalty_ra)
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 15);
+	else
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 0);
+#endif
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+
+#endif
+
+}
+
+void halbtc8723d1ant_write_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16				bitpos,
+	IN	boolean		state
+)
+{
+
+	static u16 originalval = 0x8002;
+
+	if (state)
+		originalval = originalval | bitpos;
+	else
+		originalval = originalval & (~bitpos);
+
+
+	btcoexist->btc_write_2byte(btcoexist, 0xaa, originalval);
+
+}
+
+void halbtc8723d1ant_read_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN   u16				*score_board_val
+)
+{
+
+	*score_board_val = (btcoexist->btc_read_2byte(btcoexist,
+			    0xaa)) & 0x7fff;
+}
+
+void halbtc8723d1ant_post_state_to_bt(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16						type,
+	IN  boolean                 state
+)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], halbtc8723d1ant_post_state_to_bt: type = %d, state =%d\n",
+		type, state);
+	BTC_TRACE(trace_buf);
+
+	halbtc8723d1ant_write_score_board(btcoexist, (u16) type, state);
+}
+
+boolean halbtc8723d1ant_is_wifibt_status_changed(IN struct btc_coexist
+		*btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false, pre_bt_off = false, pre_bt_slave = false;
+	static u8 pre_hid_busy_num = 0, pre_wl_noisy_level = 0;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (coex_sta->bt_disabled != pre_bt_off) {
+		pre_bt_off = coex_sta->bt_disabled;
+
+		if (coex_sta->bt_disabled)
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+		else
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is enabled !!\n");
+
+		BTC_TRACE(trace_buf);
+
+		coex_sta->bt_coex_supported_feature = 0;
+		coex_sta->bt_coex_supported_version = 0;
+		coex_sta->bt_ble_scan_type = 0;
+		coex_sta->bt_ble_scan_para[0] = 0;
+		coex_sta->bt_ble_scan_para[1] = 0;
+		coex_sta->bt_ble_scan_para[2] = 0;
+		coex_sta->bt_reg_vendor_ac = 0xffff;
+		coex_sta->bt_reg_vendor_ae = 0xffff;
+		return true;
+	}
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+
+			if (wifi_busy)
+				halbtc8723d1ant_post_state_to_bt(btcoexist,
+						BT_8723D_1ANT_SCOREBOARD_UNDERTEST, true);
+			else
+				halbtc8723d1ant_post_state_to_bt(btcoexist,
+						BT_8723D_1ANT_SCOREBOARD_UNDERTEST, false);
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+		if (coex_sta->wl_noisy_level != pre_wl_noisy_level) {
+			pre_wl_noisy_level = coex_sta->wl_noisy_level;
+			return true;
+		}
+	}
+
+	if (!coex_sta->bt_disabled) {
+	    if (coex_sta->hid_busy_num != pre_hid_busy_num) {
+			pre_hid_busy_num = coex_sta->hid_busy_num;
+			return true;
+		}
+	}
+
+	if (bt_link_info->slave_role != pre_bt_slave) {
+			pre_bt_slave = bt_link_info->slave_role;
+			return true;
+		}
+
+	return false;
+}
+
+void halbtc8723d1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+	u16			u16tmp;
+
+	/* This function check if bt is disabled */
+#if 0
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+
+
+#else
+
+	/* Read BT on/off status from scoreboard[1], enable this only if BT patch support this feature */
+	halbtc8723d1ant_read_score_board(btcoexist,	&u16tmp);
+
+	bt_active = u16tmp & BIT(1);
+
+
+#endif
+
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	} else {
+
+		bt_disable_cnt++;
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			bt_disable_cnt = 2;
+		}
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	}
+
+	if (bt_disabled)
+		halbtc8723d1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, false);
+	else
+		halbtc8723d1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, true);
+
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+	}
+
+}
+
+
+
+void halbtc8723d1ant_enable_gnt_to_gpio(IN struct btc_coexist *btcoexist,
+					boolean isenable)
+{
+#if BT_8723D_1ANT_COEX_DBG
+	if (isenable) {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x1);
+
+		/* enable GNT_BT to GPIO debug */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e, 0x40, 0x0);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x1, 0x0);
+
+		/* 0x48[20] = 0  for GPIO14 =  GNT_WL*/
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4a, 0x10, 0x0);
+		/* 0x40[17] = 0  for GPIO14 =  GNT_WL*/
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x42, 0x02, 0x0);
+
+		/* 0x66[9] = 0   for GPIO15 =  GNT_B T*/
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x02, 0x0);
+		/* 0x66[7] = 0
+		for GPIO15 =  GNT_BT*/
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x66, 0x80, 0x0);
+		/* 0x8[8] = 0    for GPIO15 =  GNT_BT*/
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x9, 0x1, 0x0);
+
+		/* BT Vendor Reg 0x76[0] = 0  for GPIO15 =  GNT_BT, this is not set here*/
+	} else {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x0);
+
+		/* Disable GNT_BT debug to GPIO, and enable chip_wakeup_host */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e, 0x40, 0x1);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x1, 0x1);
+
+		/* 0x48[20] = 0  for GPIO14 =  GNT_WL*/
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4a, 0x10, 0x1);
+	}
+
+#endif
+}
+
+u32 halbtc8723d1ant_ltecoex_indirect_read_reg(IN struct btc_coexist *btcoexist,
+		IN u16 reg_addr)
+{
+	u32 j = 0, delay_count = 0;
+
+
+	/* wait for ready bit before access 0x7c0		 */
+	btcoexist->btc_write_4byte(btcoexist, 0x7c0, 0x800F0000 | reg_addr);
+
+	while (1) {
+		if ((btcoexist->btc_read_1byte(btcoexist, 0x7c3)&BIT(5)) == 0) {
+			delay_ms(50);
+			delay_count++;
+			if (delay_count >= 10) {
+				delay_count = 0;
+				break;
+			}
+		} else
+			break;
+	}
+
+	return btcoexist->btc_read_4byte(btcoexist,
+					 0x7c8);  /* get read data */
+
+}
+
+void halbtc8723d1ant_ltecoex_indirect_write_reg(IN struct btc_coexist
+		*btcoexist,
+		IN u16 reg_addr, IN u32 bit_mask, IN u32 reg_value)
+{
+	u32 val, i = 0, j = 0, bitpos = 0, delay_count = 0;
+
+
+	if (bit_mask == 0x0)
+		return;
+	if (bit_mask == 0xffffffff) {
+		btcoexist->btc_write_4byte(btcoexist, 0x7c4,
+					   reg_value); /* put write data */
+
+		/* wait for ready bit before access 0x7c0 */
+		while (1) {
+			if ((btcoexist->btc_read_1byte(btcoexist, 0x7c3) & BIT(5)) == 0) {
+				delay_ms(50);
+				delay_count++;
+				if (delay_count >= 10) {
+					delay_count = 0;
+					break;
+				}
+			} else {
+				break;
+			}
+		}
+
+		btcoexist->btc_write_4byte(btcoexist, 0x7c0,
+					   0xc00F0000 | reg_addr);
+	} else {
+		for (i = 0; i <= 31; i++) {
+			if (((bit_mask >> i) & 0x1) == 0x1) {
+				bitpos = i;
+				break;
+			}
+		}
+
+		/* read back register value before write */
+		val = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist,
+				reg_addr);
+		val = (val & (~bit_mask)) | (reg_value << bitpos);
+
+		btcoexist->btc_write_4byte(btcoexist, 0x7c4,
+					   val); /* put write data */
+
+		/* wait for ready bit before access 0x7c0		 */
+		while (1) {
+			if ((btcoexist->btc_read_1byte(btcoexist, 0x7c3) & BIT(5)) == 0) {
+				delay_ms(50);
+				delay_count++;
+				if (delay_count >= 10) {
+					delay_count = 0;
+					break;
+				}
+			} else
+				break;
+		}
+
+		btcoexist->btc_write_4byte(btcoexist, 0x7c0,
+					   0xc00F0000 | reg_addr);
+
+	}
+
+}
+
+void halbtc8723d1ant_ltecoex_enable(IN struct btc_coexist *btcoexist,
+				    IN boolean enable)
+{
+	u8 val;
+
+	val = (enable) ? 1 : 0;
+	halbtc8723d1ant_ltecoex_indirect_write_reg(btcoexist, 0x38, 0x80,
+			val);  /* 0x38[7] */
+
+}
+
+void halbtc8723d1ant_ltecoex_pathcontrol_owner(IN struct btc_coexist *btcoexist,
+		IN boolean wifi_control)
+{
+	u8 val;
+
+	val = (wifi_control) ? 1 : 0;
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x4,
+					   val); /* 0x70[26] */
+
+}
+
+void halbtc8723d1ant_ltecoex_set_gnt_bt(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, val_orig = 0;
+
+	if (!sw_control)
+		val = 0x0;
+	else if (state & 0x1)
+		val = 0x3;
+	else
+		val = 0x1;
+
+	val_orig = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist,
+				0x38);
+
+	switch (control_block) {
+	case BT_8723D_1ANT_GNT_BLOCK_RFC_BB:
+	default:
+		val = ((val << 14) | (val << 10)) | (val_orig & 0xffff33ff);
+		break;
+	case BT_8723D_1ANT_GNT_BLOCK_RFC:
+		val = (val << 14) | (val_orig & 0xffff3fff);
+		break;
+	case BT_8723D_1ANT_GNT_BLOCK_BB:
+		val = (val << 10) | (val_orig & 0xfffff3ff);
+		break;
+	}
+
+	halbtc8723d1ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, 0xffffffff, val);
+}
+
+
+void halbtc8723d1ant_ltecoex_set_gnt_wl(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, val_orig = 0;
+
+	if (!sw_control)
+		val = 0x0;
+	else if (state & 0x1)
+		val = 0x3;
+	else
+		val = 0x1;
+
+	val_orig = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist,
+				0x38);
+
+	switch (control_block) {
+	case BT_8723D_1ANT_GNT_BLOCK_RFC_BB:
+	default:
+		val = ((val << 12) | (val << 8)) | (val_orig & 0xffffccff);
+		break;
+	case BT_8723D_1ANT_GNT_BLOCK_RFC:
+		val = (val << 12) | (val_orig & 0xffffcfff);
+		break;
+	case BT_8723D_1ANT_GNT_BLOCK_BB:
+		val = (val << 8) | (val_orig & 0xfffffcff);
+		break;
+	}
+
+	halbtc8723d1ant_ltecoex_indirect_write_reg(btcoexist, 0x38,
+		0xffffffff, val);
+}
+
+
+void halbtc8723d1ant_ltecoex_set_coex_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u16 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8723D_1ANT_CTT_WL_VS_LTE:
+		reg_addr = 0xa0;
+		break;
+	case BT_8723D_1ANT_CTT_BT_VS_LTE:
+		reg_addr = 0xa4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8723d1ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xffff, table_content); /* 0xa0[15:0] or 0xa4[15:0] */
+
+
+}
+
+
+void halbtc8723d1ant_ltecoex_set_break_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u8 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8723D_1ANT_LBTT_WL_BREAK_LTE:
+		reg_addr = 0xa8;
+		break;
+	case BT_8723D_1ANT_LBTT_BT_BREAK_LTE:
+		reg_addr = 0xac;
+		break;
+	case BT_8723D_1ANT_LBTT_LTE_BREAK_WL:
+		reg_addr = 0xb0;
+		break;
+	case BT_8723D_1ANT_LBTT_LTE_BREAK_BT:
+		reg_addr = 0xb4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8723d1ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xff, table_content); /* 0xa8[15:0] or 0xb4[15:0] */
+
+}
+
+void halbtc8723d1ant_set_wltoggle_coex_table(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec,  IN u8 interval,
+		IN u8 val0x6c4_b0, IN u8 val0x6c4_b1, IN u8 val0x6c4_b2,
+		IN u8 val0x6c4_b3)
+{
+	static u8 pre_h2c_parameter[6] = {0};
+	u8	cur_h2c_parameter[6] = {0};
+	u8 i, match_cnt = 0;
+
+	cur_h2c_parameter[0] = 0x7;	/* op_code, 0x7= wlan toggle slot*/
+
+	cur_h2c_parameter[1] = interval;
+	cur_h2c_parameter[2] = val0x6c4_b0;
+	cur_h2c_parameter[3] = val0x6c4_b1;
+	cur_h2c_parameter[4] = val0x6c4_b2;
+	cur_h2c_parameter[5] = val0x6c4_b3;
+
+	if (!force_exec) {
+		for (i = 1; i <= 5; i++) {
+			if (cur_h2c_parameter[i] != pre_h2c_parameter[i])
+				break;
+
+			match_cnt++;
+		}
+
+		if (match_cnt == 5)
+			return;
+	}
+
+	for (i = 1; i <= 5; i++)
+		pre_h2c_parameter[i] = cur_h2c_parameter[i];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, cur_h2c_parameter);
+}
+
+
+void halbtc8723d1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8723d1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+
+	halbtc8723d1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8723d1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	u32	break_table;
+	u8	select_table;
+
+	coex_sta->coex_table_type = type;
+
+	if (coex_sta->concurrent_rx_mode_on == true) {
+		break_table = 0xf0ffffff;  /* set WL hi-pri can break BT */
+		select_table =
+			0xb;		/* set Tx response = Hi-Pri (ex: Transmitting ACK,BA,CTS) */
+	} else {
+		break_table = 0xffffff;
+		select_table = 0x3;
+	}
+
+		switch (type) {
+		case 0:
+			halbtc8723d1ant_coex_table(btcoexist, force_exec,
+							0x55555555, 0x55555555, break_table,
+							select_table);
+			break;
+		case 1:
+			halbtc8723d1ant_coex_table(btcoexist, force_exec,
+							0x55555555, 0x5a5a5a5a, break_table,
+							select_table);
+			break;
+		case 2:
+			halbtc8723d1ant_coex_table(btcoexist, force_exec,
+							0xaa5a5a5a, 0xaa5a5a5a, break_table,
+							select_table);
+			break;
+		case 3:
+			halbtc8723d1ant_coex_table(btcoexist, force_exec,
+							0x55555555, 0x5a5a5a5a, break_table,
+							select_table);
+			break;
+		case 4:
+			halbtc8723d1ant_coex_table(btcoexist, force_exec,
+							0xa5555555, 0x5a5a5a5a, break_table,
+							select_table);
+			break;
+		case 5:
+			halbtc8723d1ant_coex_table(btcoexist, force_exec,
+							0x5a5a5a5a, 0x5a5a5a5a, break_table,
+							select_table);
+			break;
+		case 6:
+			halbtc8723d1ant_coex_table(btcoexist, force_exec,
+							0xa5555555, 0x5a5a5a5a, break_table,
+							select_table);
+			break;
+		case 7:
+			halbtc8723d1ant_coex_table(btcoexist, force_exec,
+							0xaaaaaaaa, 0xaaaaaaaa, break_table,
+							select_table);
+			break;
+		case 8:
+			halbtc8723d1ant_coex_table(btcoexist, force_exec,
+							0xa5555555, 0xaaaaaaaa, break_table,
+							select_table);
+			break;
+		case 9:
+			halbtc8723d1ant_coex_table(btcoexist, force_exec,
+							0x5a5a5a5a, 0xaaaa5aaa, break_table,
+							select_table);
+			break;
+		default:
+			break;
+		}
+}
+
+void halbtc8723d1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable) {
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8723d1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8723d1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8723d1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8723d1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8723d1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8723d1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0x8, 0, 0, 0, 0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			/*halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			/*halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);*/
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8723d1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		coex_sta->force_lps_on = false;
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+
+		break;
+	case BTC_PS_LPS_ON:
+		coex_sta->force_lps_on = true;
+		halbtc8723d1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8723d1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+
+		break;
+	case BTC_PS_LPS_OFF:
+		coex_sta->force_lps_on = false;
+		halbtc8723d1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+
+		break;
+	default:
+		break;
+	}
+}
+
+
+void halbtc8723d1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	if (byte5 & BIT(2))
+		coex_sta->is_tdma_btautoslot = true;
+	else
+		coex_sta->is_tdma_btautoslot = false;
+
+	/* release bt-auto slot for auto-slot hang is detected!! */
+	if (coex_sta->is_tdma_btautoslot)
+		if ((coex_sta->is_tdma_btautoslot_hang) ||
+			(bt_link_info->slave_role))
+			byte5 = byte5 & 0xfb;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8723d1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0,
+							 0x0);
+		}
+	} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+
+		halbtc8723d1ant_power_save_state(
+			btcoexist, BTC_PS_LPS_ON, 0x50,
+			0x4);
+	} else {
+		halbtc8723d1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0,
+						 0x0);
+	}
+
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+
+void halbtc8723d1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	boolean			wifi_busy = false;
+	static u8			psTdmaByte4Modify = 0x0, pre_psTdmaByte4Modify = 0x0;
+	static boolean	 pre_wifi_busy = false;
+
+
+#if BT_8723D_1ANT_ANTDET_ENABLE
+
+	if (board_info->btdm_ant_num_by_ant_det == 2) {
+#if 0
+		if (turn_on)
+			type = type +
+			       100;
+#endif
+	}
+
+#endif
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (wifi_busy != pre_wifi_busy) {
+		force_exec = true;
+		pre_wifi_busy = wifi_busy;
+	}
+
+	/* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+	if ((bt_link_info->slave_role) && (bt_link_info->a2dp_exist))
+		psTdmaByte4Modify = 0x1;
+	else
+		psTdmaByte4Modify = 0x0;
+
+	if (pre_psTdmaByte4Modify != psTdmaByte4Modify) {
+
+		force_exec = true;
+		pre_psTdmaByte4Modify = psTdmaByte4Modify;
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+
+	if (turn_on) {
+		switch (type) {
+		default:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x35, 0x03, 0x11, 0x11);
+			break;
+		case 3:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x3a, 0x03, 0x10, 0x50);
+			break;
+		case 4:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x21, 0x03, 0x10, 0x50);
+			break;
+		case 5:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x15, 0x03, 0x11, 0x11);
+			break;
+		case 6:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x20, 0x03, 0x11, 0x11);
+			break;
+		case 7:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x10, 0x03, 0x10,  0x54 |
+							psTdmaByte4Modify);
+			break;
+		case 8:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x10, 0x03, 0x10,  0x54 |
+							psTdmaByte4Modify);
+			break;
+		case 9:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x55, 0x10, 0x03, 0x10,  0x54 |
+							psTdmaByte4Modify);
+			break;
+		case 10:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x30, 0x03, 0x11, 0x10);
+			break;
+		case 11:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x65, 0x25, 0x03, 0x11,  0x11 |
+							psTdmaByte4Modify);
+			break;
+		case 12:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x55, 0x30, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 13:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x25, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 14:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x15, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 15:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x20, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 16:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x10, 0x03, 0x11,  0x15 |
+							psTdmaByte4Modify);
+			break;
+		case 17:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x10, 0x03, 0x11, 0x14);
+			break;
+		case 18:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x30, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 19:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x15, 0x03, 0x11, 0x10);
+			break;
+		case 20:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x30, 0x03, 0x11, 0x10);
+			break;
+		case 21:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x30, 0x03, 0x11, 0x10);
+			break;
+		case 22:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x25, 0x03, 0x11, 0x10);
+			break;
+		case 23:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x10, 0x03, 0x11, 0x10);
+			break;
+		case 27:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x10, 0x03, 0x11, 0x15);
+			break;
+		case 32:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x35, 0x03, 0x11, 0x11);
+			break;
+		case 33:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x35, 0x03, 0x11, 0x10);
+			break;
+		case 57:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x10, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 58:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x51, 0x10, 0x03, 0x10,  0x50 |
+							psTdmaByte4Modify);
+			break;
+		case 67:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0x61, 0x10, 0x03, 0x11,  0x10 |
+							psTdmaByte4Modify);
+			break;
+		/*     1-Ant to 2-Ant      TDMA case */
+		case 103:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xd3, 0x3a, 0x03, 0x70, 0x10);
+			break;
+		case 104:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xd3, 0x21, 0x03, 0x70, 0x10);
+			break;
+		case 105:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xe3, 0x15, 0x03, 0x71, 0x11);
+			break;
+		case 106:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xe3, 0x20, 0x03, 0x71, 0x11);
+			break;
+		case 107:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xd3, 0x10, 0x03, 0x70,  0x14 |
+							psTdmaByte4Modify);
+			break;
+		case 108:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xd3, 0x10, 0x03, 0x70,  0x14 |
+							psTdmaByte4Modify);
+			break;
+		case 113:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xd3, 0x25, 0x03, 0x70,  0x10 |
+							psTdmaByte4Modify);
+			break;
+		case 114:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xd3, 0x15, 0x03, 0x70,  0x10 |
+							psTdmaByte4Modify);
+			break;
+		case 115:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xd3, 0x20, 0x03, 0x70,  0x10 |
+							psTdmaByte4Modify);
+			break;
+		case 117:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xe3, 0x10, 0x03, 0x71,  0x14 |
+							psTdmaByte4Modify);
+			break;
+		case 119:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xe3, 0x15, 0x03, 0x71, 0x10);
+			break;
+		case 120:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xe3, 0x30, 0x03, 0x71, 0x10);
+			break;
+		case 121:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xe3, 0x30, 0x03, 0x71, 0x10);
+			break;
+		case 122:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xe3, 0x25, 0x03, 0x71, 0x10);
+			break;
+		case 132:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xe3, 0x35, 0x03, 0x71, 0x11);
+			break;
+		case 133:
+			halbtc8723d1ant_set_fw_pstdma(btcoexist,
+							0xe3, 0x35, 0x03, 0x71, 0x10);
+			break;
+		}
+	} else {
+
+		/* disable PS tdma */
+		switch (type) {
+		case 8: /* PTA Control */
+			halbtc8723d1ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 0:
+		default:  /* Software control, Antenna at BT side */
+			halbtc8723d1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 1: /* 2-Ant, 0x778=3, antenna control by antenna diversity */
+			halbtc8723d1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x48, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+
+void halbtc8723d1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+				  IN u8 ant_pos_type, IN boolean force_exec,
+				  IN u8 phase)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u32			cnt_bt_cal_chk = 0;
+	boolean			is_in_mp_mode = false, is_hw_ant_div_on = false;
+	u8			u8tmp0 = 0, u8tmp1 = 0;
+	u32			u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+	u16			u16tmp0, u16tmp1 = 0;
+
+#if BT_8723D_1ANT_ANTDET_ENABLE
+
+	if (ant_pos_type == BTC_ANT_PATH_PTA) {
+		if ((board_info->btdm_ant_det_finish) &&
+		    (board_info->btdm_ant_num_by_ant_det == 2)) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type = BTC_ANT_PATH_WIFI;
+			else
+				ant_pos_type = BTC_ANT_PATH_BT;
+		}
+	}
+
+#endif
+
+	u32tmp1 = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist,
+				0x38);
+
+	/* To avoid indirect access fail	*/
+	if (((u32tmp1 & 0xf000) >> 12) != ((u32tmp1 & 0x0f00) >> 8)) {
+		force_exec = true;
+		coex_sta->gnt_error_cnt++;
+	}
+
+#if BT_8723D_1ANT_COEX_DBG
+	u32tmp2 = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u16tmp0 = btcoexist->btc_read_2byte(btcoexist, 0xaa);
+	u16tmp1 = btcoexist->btc_read_2byte(btcoexist, 0x948);
+	u8tmp1  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+	u8tmp0 =  btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** 0x67 = 0x%x, 0x948 = 0x%x, 0x73 = 0x%x(Before Set Ant Pat)\n",
+		    u8tmp0, u16tmp1, u8tmp1);
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********0x38= 0x%x, 0x54= 0x%x, 0xaa = 0x%x(Before Set Ant Path)\n",
+		    u32tmp1, u32tmp2, u16tmp0);
+	BTC_TRACE(trace_buf);
+#endif
+
+	coex_dm->cur_ant_pos_type = ant_pos_type;
+
+	if (!force_exec) {
+		if (coex_dm->cur_ant_pos_type == coex_dm->pre_ant_pos_type) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** Skip Antenna Path Setup because no change!!**********\n");
+			BTC_TRACE(trace_buf);
+			return;
+		}
+	}
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+
+
+	switch (phase) {
+	case BT_8723D_1ANT_PHASE_COEX_POWERON:
+		/* Set Path control to WL */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67,
+						   0x80, 0x0);
+
+		/* set Path control owner to WL at initial step */
+		halbtc8723d1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8723D_1ANT_PCO_BTSIDE);
+
+		/* set GNT_BT to SW high */
+		halbtc8723d1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8723D_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_1ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW low */
+		halbtc8723d1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8723D_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_1ANT_SIG_STA_SET_TO_HIGH);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		coex_sta->run_time_state = false;
+
+		break;
+	case BT_8723D_1ANT_PHASE_COEX_INIT:
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8723d1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8723d1ant_ltecoex_set_coex_table(btcoexist,
+				       BT_8723D_1ANT_CTT_WL_VS_LTE, 0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8723d1ant_ltecoex_set_coex_table(btcoexist,
+				       BT_8723D_1ANT_CTT_BT_VS_LTE, 0xffff);
+
+		/* Wait If BT IQK running, because Path control owner is at BT during BT IQK (setup by WiFi firmware) */
+		while (cnt_bt_cal_chk <= 20) {
+			u8tmp0 = btcoexist->btc_read_1byte(btcoexist,
+							   0x49d);
+			cnt_bt_cal_chk++;
+			if (u8tmp0 & BIT(0)) {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ########### BT is calibrating (wait cnt=%d) ###########\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				delay_ms(50);
+			} else {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ********** WL is NOT calibrating (wait cnt=%d)**********\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				break;
+			}
+		}
+
+		/* Set Path control to WL */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67,
+						   0x80, 0x1);
+
+		/* set Path control owner to WL at initial step */
+		halbtc8723d1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8723D_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW high */
+		halbtc8723d1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8723D_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_1ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW low */
+		halbtc8723d1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8723D_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_1ANT_SIG_STA_SET_TO_HIGH);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		coex_sta->run_time_state = false;
+		break;
+	case BT_8723D_1ANT_PHASE_WLANONLY_INIT:
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8723d1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8723d1ant_ltecoex_set_coex_table(btcoexist,
+				       BT_8723D_1ANT_CTT_WL_VS_LTE, 0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8723d1ant_ltecoex_set_coex_table(btcoexist,
+				       BT_8723D_1ANT_CTT_BT_VS_LTE, 0xffff);
+
+		/* Set Path control to WL */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67,
+						   0x80, 0x1);
+
+		/* set Path control owner to WL at initial step */
+		halbtc8723d1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8723D_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW low */
+		halbtc8723d1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8723D_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_1ANT_SIG_STA_SET_TO_LOW);
+		/* Set GNT_WL to SW high */
+		halbtc8723d1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8723D_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_1ANT_SIG_STA_SET_TO_HIGH);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_WIFI;
+
+		coex_sta->run_time_state = false;
+		break;
+	case BT_8723D_1ANT_PHASE_WLAN_OFF:
+		/* Disable LTE Coex Function in WiFi side */
+		halbtc8723d1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* Set Path control to BT */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67,
+						   0x80, 0x0);
+
+		/* set Path control owner to BT */
+		halbtc8723d1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8723D_1ANT_PCO_BTSIDE);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		coex_sta->run_time_state = false;
+		break;
+	case BT_8723D_1ANT_PHASE_2G_RUNTIME:
+
+		/* wait for WL/BT IQK finish, keep 0x38 = 0xff00 for WL IQK */
+		while (cnt_bt_cal_chk <= 20) {
+			u8tmp0 = btcoexist->btc_read_1byte(btcoexist,
+							   0x1e6);
+
+			u8tmp1 = btcoexist->btc_read_1byte(btcoexist,
+							   0x49d);
+
+			cnt_bt_cal_chk++;
+			if ((u8tmp0 & BIT(0)) || (u8tmp1 & BIT(0))) {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ########### WL or BT is IQK (wait cnt=%d)\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				delay_ms(50);
+			} else {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ********** WL and BT is NOT IQK (wait cnt=%d)\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				break;
+			}
+		}
+
+
+		/* Set Path control to WL */
+		/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x80, 0x1); */
+
+		halbtc8723d1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8723D_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to PTA */
+		halbtc8723d1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8723D_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_1ANT_GNT_TYPE_CTRL_BY_PTA,
+					   BT_8723D_1ANT_SIG_STA_SET_BY_HW);
+		/* Set GNT_WL to PTA */
+		halbtc8723d1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8723D_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_1ANT_GNT_TYPE_CTRL_BY_PTA,
+					   BT_8723D_1ANT_SIG_STA_SET_BY_HW);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_PTA;
+
+		coex_sta->run_time_state = true;
+		break;
+	case BT_8723D_1ANT_PHASE_BTMPMODE:
+		halbtc8723d1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8723D_1ANT_PCO_WLSIDE);
+
+		/* Set Path control to WL */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67,
+						   0x80, 0x1);
+
+		/* set GNT_BT to high */
+		halbtc8723d1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8723D_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_1ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to low */
+		halbtc8723d1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8723D_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_1ANT_SIG_STA_SET_TO_LOW);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		coex_sta->run_time_state = false;
+		break;
+	case BT_8723D_1ANT_PHASE_ANTENNA_DET:
+		halbtc8723d1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8723D_1ANT_PCO_WLSIDE);
+
+		/* Set Path control to WL */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67,
+						   0x80, 0x1);
+
+		/* set GNT_BT to high */
+		halbtc8723d1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8723D_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_1ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to high */
+		halbtc8723d1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8723D_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_1ANT_SIG_STA_SET_TO_HIGH);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		coex_sta->run_time_state = false;
+
+		break;
+	}
+
+
+	is_hw_ant_div_on = board_info->ant_div_cfg;
+
+	if ((is_hw_ant_div_on) && (phase != BT_8723D_1ANT_PHASE_ANTENNA_DET))
+
+		if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT)
+			/* 0x948 = 0x200, 0x0 while antenna diversity */
+			btcoexist->btc_write_2byte(btcoexist, 0x948, 0x100);
+		else /* 0x948 = 0x80, 0x0 while antenna diversity */
+			btcoexist->btc_write_2byte(btcoexist, 0x948, 0x40);
+
+	else if ((is_hw_ant_div_on == false) &&
+		(phase != BT_8723D_1ANT_PHASE_WLAN_OFF)) {  /* internal switch setting */
+
+		switch (ant_pos_type) {
+
+		case BTC_ANT_PATH_WIFI:
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+
+				btcoexist->btc_write_2byte(
+					btcoexist, 0x948, 0x0);
+			else
+				btcoexist->btc_write_2byte(
+					btcoexist, 0x948, 0x280);
+
+			break;
+		case BTC_ANT_PATH_BT:
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+
+				btcoexist->btc_write_2byte(
+					btcoexist, 0x948, 0x280);
+			else
+				btcoexist->btc_write_2byte(
+					btcoexist, 0x948, 0x0);
+
+			break;
+		default:
+		case BTC_ANT_PATH_PTA:
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				btcoexist->btc_write_2byte(
+					btcoexist, 0x948,
+					0x200);
+			else
+				btcoexist->btc_write_2byte(
+					btcoexist, 0x948, 0x80);
+			break;
+		}
+	}
+
+
+#if BT_8723D_1ANT_COEX_DBG
+	u32tmp1 = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u16tmp0 = btcoexist->btc_read_2byte(btcoexist, 0xaa);
+	u16tmp1 = btcoexist->btc_read_2byte(btcoexist, 0x948);
+	u8tmp1  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+	u8tmp0 =  btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** 0x67 = 0x%x, 0x948 = 0x%x, 0x73 = 0x%x(After Set Ant Pat)\n",
+		    u8tmp0, u16tmp1, u8tmp1);
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********0x38= 0x%x, 0x54= 0x%x, 0xaa = 0x%x(After Set Ant Path)\n",
+		    u32tmp1, u32tmp2, u16tmp0);
+	BTC_TRACE(trace_buf);
+#endif
+
+}
+
+
+boolean halbtc8723d1ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected &&
+	    BT_8723D_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8723D_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		common = true;
+	} else if (!wifi_connected &&
+		   (BT_8723D_1ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8723D_1ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		common = true;
+	} else if (!wifi_connected &&
+		   (BT_8723D_1ANT_BT_STATUS_CONNECTED_IDLE !=
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non connected-idle + BT Busy!!\n");
+		BTC_TRACE(trace_buf);
+		common = true;
+	} else {
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		common = false;
+	}
+
+	return common;
+}
+
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+void halbtc8723d1ant_action_bt_whql_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8723D_1ANT_PHASE_2G_RUNTIME);
+	halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8723d1ant_action_bt_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8723d1ant_action_bt_relink(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+	coex_sta->bt_relink_downcount = 2;
+}
+
+void halbtc8723d1ant_action_bt_idle(IN struct btc_coexist *btcoexist)
+{
+	boolean wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_busy) {
+		halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 6);
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	} else {
+	/* if wl busy */
+	if (BT_8723D_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		coex_dm->bt_status) {
+		halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+
+		halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+	} else {
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+		halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+	}
+}
+
+}
+
+void halbtc8723d1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean wifi_connected = false, wifi_busy = false, bt_busy = false;
+	boolean wifi_scan = false, wifi_link = false, wifi_roam = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &wifi_link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &wifi_roam);
+
+
+	if ((coex_sta->bt_create_connection) && ((wifi_link) || (wifi_roam)
+		|| (wifi_scan) || (wifi_busy) || (coex_sta->wifi_is_high_pri_task))) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi link/roam/Scan/busy/hi-pri-task + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+
+		if ((bt_link_info->a2dp_exist) && (!bt_link_info->pan_exist))
+			halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 17);
+		else
+			halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+		} else if ((!wifi_connected) && (!wifi_scan)) {
+
+		halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (bt_link_info->pan_exist) {
+
+		halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	} else if (bt_link_info->a2dp_exist) {
+
+		halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 16);
+
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+
+		if ((wifi_link) || (wifi_roam) || (wifi_scan) || (wifi_busy)
+			|| (coex_sta->wifi_is_high_pri_task))
+			halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+		else
+			halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 23);
+
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	}
+}
+
+
+void halbtc8723d1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, wifi_busy = false;
+	u32  wifi_bw = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,
+			   &wifi_bw);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+
+	if (bt_link_info->sco_exist) {
+			halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						true, 5);
+			halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 5);
+		} else if (coex_sta->hid_busy_num >= 2) {
+		 /*for 4/18 hid */
+		 /* if 11bg mode */
+		if (wifi_bw == 0) {
+
+		halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+		halbtc8723d1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x1, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+		halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							11);
+		} else {
+
+		if (wifi_busy) {
+
+		     halbtc8723d1ant_coex_table_with_type(btcoexist,
+								NORMAL_EXEC, 6);
+		     halbtc8723d1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+		     halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							11);
+		  } else {
+
+		     halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						true, 6);
+			 halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 3);
+
+		  }
+		}
+	} else {
+			halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						true, 6);
+			halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 3);
+	}
+}
+
+
+void halbtc8723d1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723d1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+				     BT_8723D_1ANT_PHASE_2G_RUNTIME);
+	halbtc8723d1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+}
+
+void halbtc8723d1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8723D_1ANT_PHASE_2G_RUNTIME);
+
+	if (!bt_link_info->pan_exist)
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	else
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8723d1ant_action_wifi_linkscan_process(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	if (bt_link_info->pan_exist) {
+
+		halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	} else if (bt_link_info->a2dp_exist) {
+
+		halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 27);
+
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+
+		halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	}
+}
+
+void halbtc8723d1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_busy = false, wifi_turbo = false;
+	u32 wifi_bw = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM, &coex_sta->scan_ap_num);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "############# [BTCoex],  scan_ap_num = %d, wl_noisy_level = %d\n",
+		    coex_sta->scan_ap_num, coex_sta->wl_noisy_level);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->wl_noisy_level == 0))
+		wifi_turbo = true;
+#endif
+
+	if ((coex_sta->bt_relink_downcount != 0)
+			&& (!bt_link_info->pan_exist) && (wifi_busy)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  BT Re-Link + A2DP + WL busy\n");
+		BTC_TRACE(trace_buf);
+
+		/*halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);*/
+		halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	} else if (bt_link_info->a2dp_only) { /* A2DP		 */
+		if (!wifi_busy) {
+			/*halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);*/
+			halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						27);
+			halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+
+			if (coex_sta->wl_noisy_level == 2)
+				halbtc8723d1ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 17);
+			else
+				halbtc8723d1ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+
+			if (wifi_turbo)
+				halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+			else
+				halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if (((bt_link_info->a2dp_exist) &&
+		    (bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+
+		if ((bt_link_info->hid_exist) && (coex_sta->hid_busy_num >= 2)) {
+			halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+			if (wifi_bw == 0) /* 11bg mode  */
+				halbtc8723d1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x1, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+			else
+				halbtc8723d1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+			halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							12);
+		} else if (wifi_busy)	{
+			if (((coex_sta->a2dp_bit_pool > 40) &&
+			     (coex_sta->a2dp_bit_pool < 255)) ||
+			    (!coex_sta->is_A2DP_3M))
+				halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 15);
+			else if (wifi_turbo)
+				halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 18);
+			else
+				halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 13);
+		} else
+			halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+
+		if (bt_link_info->hid_exist)
+			halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+		else if (wifi_turbo)
+			halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+		else
+			halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+	} else if (bt_link_info->hid_exist &&
+		   bt_link_info->a2dp_exist) { /* HID+A2DP */
+
+			if ((wifi_busy) && (coex_sta->hid_busy_num >= 2)) { /*for 4/18 hid */
+				halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+				if (wifi_bw == 0) /* 11bg mode  */
+					halbtc8723d1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x1, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+				else
+					halbtc8723d1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+				halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							9);
+			} else {
+				halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							8);
+				halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+			}
+
+	} else if ((bt_link_info->pan_only)
+	   || (bt_link_info->hid_exist && bt_link_info->pan_exist)) {
+	   /* PAN(OPP,FTP), HID+PAN(OPP,FTP) */
+
+		if ((bt_link_info->hid_exist) && (bt_link_info->pan_exist) &&
+			(coex_sta->hid_busy_num >= 2)) {
+
+				halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+				if (wifi_bw == 0) /* 11bg mode  */
+					halbtc8723d1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x1, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+				else
+					halbtc8723d1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+				halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							12);
+		} else {
+			if (!wifi_busy)
+				halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							4);
+			else
+				halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							3);
+
+			if (bt_link_info->hid_exist)
+				halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+			else if (wifi_turbo)
+				halbtc8723d1ant_coex_table_with_type(btcoexist,
+								     NORMAL_EXEC, 8);
+			else
+				halbtc8723d1ant_coex_table_with_type(btcoexist,
+								     NORMAL_EXEC, 4);
+		}
+	} else {
+		/* BT no-profile busy (0x9) */
+		halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	}
+}
+
+void halbtc8723d1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	/* tdma and coex table */
+	halbtc8723d1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8723D_1ANT_PHASE_2G_RUNTIME);
+	halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+
+void halbtc8723d1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean wifi_busy = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					 NORMAL_EXEC,
+					 BT_8723D_1ANT_PHASE_2G_RUNTIME);
+
+	if (BT_8723D_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+
+		if (bt_link_info->hid_only)  /* HID only */
+		   halbtc8723d1ant_action_bt_sco_hid_only_busy(btcoexist);
+		else
+			halbtc8723d1ant_action_wifi_connected_bt_acl_busy(btcoexist);
+
+	} else if ((BT_8723D_1ANT_BT_STATUS_SCO_BUSY ==
+				coex_dm->bt_status) ||
+			   (BT_8723D_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+				coex_dm->bt_status)) {
+			halbtc8723d1ant_action_bt_sco_hid_only_busy(btcoexist);
+	} else
+			halbtc8723d1ant_action_bt_idle(btcoexist);
+}
+
+
+void halbtc8723d1ant_run_sw_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8				algorithm = 0;
+
+	algorithm = halbtc8723d1ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+
+	if (halbtc8723d1ant_is_common_action(btcoexist)) {
+
+	} else {
+		switch (coex_dm->cur_algorithm) {
+		case BT_8723D_1ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8723D_1ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8723D_1ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8723D_1ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8723D_1ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8723D_1ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8723D_1ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8723D_1ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8723D_1ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		case BT_8723D_1ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+
+void halbtc8723d1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean wifi_connected = false, bt_hs_on = false;
+	boolean increase_scan_dev_num = false;
+	boolean bt_ctrl_agg_buf_size = false;
+	boolean miracast_plus_bt = false, wifi_under_5g = false;
+	u8	agg_buf_size = 5;
+	u32 wifi_link_status = 0;
+	u32 num_of_wifi_link = 0, wifi_bw;
+	u8	iot_peer = BTC_IOT_PEER_UNKNOWN;
+	boolean scan = false, link = false, roam = false, under_4way = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (!coex_sta->run_time_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], return for run_time_state = false !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->freeze_coexrun_by_btinfo) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), return for freeze_coexrun_by_btinfo\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d1ant_action_bt_whql_test(btcoexist);
+		return;
+	}
+
+	if (coex_sta->bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT is disabled !!!\n");
+		halbtc8723d1ant_action_wifi_only(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT is under inquiry/page scan !!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723d1ant_action_bt_inquiry(btcoexist);
+			return;
+	}
+
+	if (coex_sta->is_setupLink) {
+		 BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		 "[BTCoex], BT is re-link !!!\n");
+		 halbtc8723d1ant_action_bt_relink(btcoexist);
+		 return;
+	}
+
+	if ((BT_8723D_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+		(BT_8723D_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		(BT_8723D_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+			   &increase_scan_dev_num);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+		(wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+				num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist)
+			miracast_plus_bt = true;
+		else
+			miracast_plus_bt = false;
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+
+		halbtc8723d1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					false, 0x5);
+
+		if (scan || link || roam || under_4way) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], scan = %d, link = %d, roam = %d 4way = %d!!!\n",
+				    scan, link, roam, under_4way);
+			BTC_TRACE(trace_buf);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], wifi is under linkscan process + Multi-Port !!\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8723d1ant_action_wifi_linkscan_process(btcoexist);
+		} else
+
+			halbtc8723d1ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	} else {
+
+	miracast_plus_bt = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				&miracast_plus_bt);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+				&wifi_connected);
+
+	if ((bt_link_info->bt_link_exist) && (wifi_connected)) {
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_IOT_PEER, &iot_peer);
+
+		if (BTC_IOT_PEER_CISCO == iot_peer) {
+
+			if (BTC_WIFI_BW_HT40 == wifi_bw)
+				halbtc8723d1ant_limited_rx(btcoexist,
+						NORMAL_EXEC, false, true, 0x10);
+			else
+				halbtc8723d1ant_limited_rx(btcoexist,
+						NORMAL_EXEC, false, true, 0x8);
+			}  else
+			halbtc8723d1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x5);
+	}
+
+	halbtc8723d1ant_run_sw_coexist_mechanism(
+			btcoexist);  /* just print debug message */
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (bt_hs_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is hs\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d1ant_action_bt_hs(btcoexist);
+		return;
+	}
+
+	if ((BT_8723D_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		coex_dm->bt_status) ||
+		(BT_8723D_1ANT_BT_STATUS_CONNECTED_IDLE ==
+		coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is idle\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d1ant_action_bt_idle(btcoexist);
+		return;
+	}
+
+	if (scan || link || roam || under_4way) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		   "[BTCoex], scan = %d, link = %d, roam = %d 4way = %d!!!\n",
+					scan, link, roam, under_4way);
+		BTC_TRACE(trace_buf);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		   "[BTCoex], wifi is under linkscan process!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d1ant_action_wifi_linkscan_process(btcoexist);
+	} else if (wifi_connected) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		   "[BTCoex], wifi is under connected!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d1ant_action_wifi_connected(btcoexist);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		   "[BTCoex], wifi is under not-connected!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d1ant_action_wifi_not_connected(btcoexist);
+	 }
+}
+
+
+void halbtc8723d1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+	halbtc8723d1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, false);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	coex_sta->pop_event_cnt = 0;
+	coex_sta->cnt_RemoteNameReq = 0;
+	coex_sta->cnt_ReInit = 0;
+	coex_sta->cnt_setupLink = 0;
+	coex_sta->cnt_IgnWlanAct = 0;
+	coex_sta->cnt_Page = 0;
+	coex_sta->cnt_RoleSwitch = 0;
+
+	halbtc8723d1ant_query_bt_info(btcoexist);
+}
+
+void halbtc8723d1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up, IN boolean wifi_only)
+{
+	u32			u32tmp1 = 0, u32tmp2 = 0;
+	u16			u16tmp1 = 0;
+	u8	u8tmp0 = 0, u8tmp1 = 0;
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u8 i = 0;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+#if BT_8723D_1ANT_COEX_DBG
+	u32tmp1 = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist,
+			0x38);
+	u32tmp2 = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist,
+			0x54);
+	u16tmp1 = btcoexist->btc_read_2byte(btcoexist, 0x948);
+	u8tmp1	= btcoexist->btc_read_1byte(btcoexist, 0x73);
+	u8tmp0 =  btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** 0x67 = 0x%x, 0x948 = 0x%x, 0x73 = 0x%x(Before init_hw_config)\n",
+		    u8tmp0, u16tmp1, u8tmp1);
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********0x38= 0x%x, 0x54= 0x%x (Before init_hw_config)\n",
+		    u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+#endif
+
+
+	coex_sta->bt_coex_supported_feature = 0;
+	coex_sta->bt_coex_supported_version = 0;
+	coex_sta->bt_ble_scan_type = 0;
+	coex_sta->bt_ble_scan_para[0] = 0;
+	coex_sta->bt_ble_scan_para[1] = 0;
+	coex_sta->bt_ble_scan_para[2] = 0;
+	coex_sta->bt_reg_vendor_ac = 0xffff;
+	coex_sta->bt_reg_vendor_ae = 0xffff;
+	coex_sta->isolation_btween_wb = BT_8723D_1ANT_DEFAULT_ISOLATION;
+	coex_sta->gnt_error_cnt = 0;
+	coex_sta->bt_relink_downcount = 0;
+
+	for (i = 0; i <= 9; i++)
+		coex_sta->bt_afh_map[i] = 0;
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+
+	/* BT report packet sample rate	 */
+	btcoexist->btc_write_1byte(btcoexist, 0x790, 0x5);
+
+	/* Init 0x778 = 0x1 for 1-Ant */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+
+	/* Enable PTA (3-wire function form BT side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x41, 0x02, 0x1);
+
+	/* Enable PTA (tx/rx signal form WiFi side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4c6, 0x10, 0x1);
+
+	halbtc8723d1ant_enable_gnt_to_gpio(btcoexist, true);
+
+#if 0
+	/* check if WL firmware download ok */
+	if (btcoexist->btc_read_1byte(btcoexist, 0x80) == 0xc6)
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_ONOFF, true);
+#endif
+
+	/* PTA parameter */
+	halbtc8723d1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+
+	halbtc8723d1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	psd_scan->ant_det_is_ant_det_available = true;
+
+	/* Antenna config */
+	if (wifi_only) {
+		coex_sta->concurrent_rx_mode_on = false;
+		halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_WIFI,
+					     FORCE_EXEC,
+					     BT_8723D_1ANT_PHASE_WLANONLY_INIT);
+
+		btcoexist->stop_coex_dm = true;
+	} else {
+		/*Set BT polluted packet on for Tx rate adaptive not including Tx retry break by PTA, 0x45c[19] =1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x45e, 0x8, 0x1);
+
+		coex_sta->concurrent_rx_mode_on = true;
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x953, 0x2, 0x1);
+		/* RF 0x1[0] = 0->Set GNT_WL_RF_Rx always = 1 for con-current Rx */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0x1, 0x0);
+		halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_1ANT_PHASE_COEX_INIT);
+
+		btcoexist->stop_coex_dm = false;
+	}
+
+	if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], **********  Single Antenna, Antenna at Main Port: S1**********\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], **********  Single Antenna, Antenna at Aux Port: S0**********\n");
+		BTC_TRACE(trace_buf);
+	}
+
+}
+
+u32 halbtc8723d1ant_psd_log2base(IN struct btc_coexist *btcoexist, IN u32 val)
+{
+	u8	j;
+	u32	tmp, tmp2, val_integerd_b = 0, tindex, shiftcount = 0;
+	u32	result, val_fractiond_b = 0, table_fraction[21] = {0, 432, 332, 274, 232, 200,
+				   174, 151, 132, 115, 100, 86, 74, 62, 51, 42,
+							   32, 23, 15, 7, 0
+							      };
+
+	if (val == 0)
+		return 0;
+
+	tmp = val;
+
+	while (1) {
+		if (tmp == 1)
+			break;
+		else {
+			tmp = (tmp >> 1);
+			shiftcount++;
+		}
+	}
+
+
+	val_integerd_b = shiftcount + 1;
+
+	tmp2 = 1;
+	for (j = 1; j <= val_integerd_b; j++)
+		tmp2 = tmp2 * 2;
+
+	tmp = (val * 100) / tmp2;
+	tindex = tmp / 5;
+
+	if (tindex > 20)
+		tindex = 20;
+
+	val_fractiond_b = table_fraction[tindex];
+
+	result = val_integerd_b * 100 - val_fractiond_b;
+
+	return result;
+
+
+}
+
+void halbtc8723d1ant_psd_show_antenna_detect_result(IN struct btc_coexist
+		*btcoexist)
+{
+	u8		*cli_buf = btcoexist->cli_buf;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n============[Antenna Detection info]  ============\n");
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->ant_det_result == 12) { /* Get Ant Det from BT  */
+
+		if (board_info->btdm_ant_num_by_ant_det == 1)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n %-35s = %s (%d~%d)",
+				   "Ant Det Result", "1-Antenna",
+				   BT_8723D_1ANT_ANTDET_PSDTHRES_1ANT,
+				BT_8723D_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION);
+		else {
+
+			if (psd_scan->ant_det_psd_scan_peak_val >
+			    (BT_8723D_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION)
+			    * 100)
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					   "\r\n %-35s = %s (>%d)",
+					"Ant Det Result", "2-Antenna (Bad-Isolation)",
+					BT_8723D_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION);
+			else
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					   "\r\n %-35s = %s (%d~%d)",
+					"Ant Det Result", "2-Antenna (Good-Isolation)",
+					BT_8723D_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION,
+					BT_8723D_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION);
+		}
+	} else if (psd_scan->ant_det_result == 1)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (>%d)",
+			   "Ant Det Result", "2-Antenna (Bad-Isolation)",
+			   BT_8723D_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION);
+	else if (psd_scan->ant_det_result == 2)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (%d~%d)",
+			   "Ant Det Result", "2-Antenna (Good-Isolation)",
+			   BT_8723D_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION
+			   + psd_scan->ant_det_thres_offset,
+			   BT_8723D_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION);
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (%d~%d)",
+			   "Ant Det Result", "1-Antenna",
+			   BT_8723D_1ANT_ANTDET_PSDTHRES_1ANT,
+			   BT_8723D_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION
+			   + psd_scan->ant_det_thres_offset);
+
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s ",
+		   "Antenna Detection Finish",
+		   (board_info->btdm_ant_det_finish
+		    ? "Yes" : "No"));
+	CL_PRINTF(cli_buf);
+
+	switch (psd_scan->ant_det_result) {
+	case 0:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is not available)");
+		break;
+	case 1:  /* 2-Ant bad-isolation */
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available)");
+		break;
+	case 2:  /* 2-Ant good-isolation */
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available)");
+		break;
+	case 3:  /* 1-Ant */
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available)");
+		break;
+	case 4:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(Uncertainty result)");
+		break;
+	case 5:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "(Pre-Scan fai)");
+		break;
+	case 6:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(WiFi is Scanning)");
+		break;
+	case 7:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is not idle)");
+		break;
+	case 8:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(Abort by WiFi Scanning)");
+		break;
+	case 9:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(Antenna Init is not ready)");
+		break;
+	case 10:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is Inquiry or page)");
+		break;
+	case 11:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is Disabled)");
+	case 12:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available, result from BT");
+		break;
+	}
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->ant_det_result == 12) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d dB",
+			   "PSD Scan Peak Value",
+			   psd_scan->ant_det_psd_scan_peak_val / 100);
+		CL_PRINTF(cli_buf);
+		return;
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Ant Detect Total Count", psd_scan->ant_det_try_count);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Ant Detect Fail Count", psd_scan->ant_det_fail_count);
+	CL_PRINTF(cli_buf);
+
+	if ((!board_info->btdm_ant_det_finish) &&
+	    (psd_scan->ant_det_result != 5))
+		return;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "BT Response",
+		   (psd_scan->ant_det_result ? "ok" : "fail"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ms", "BT Tx Time",
+		   psd_scan->ant_det_bt_tx_time);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "BT Tx Ch",
+		   psd_scan->ant_det_bt_le_channel);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d",
+		   "WiFi PSD Cent-Ch/Offset/Span",
+		   psd_scan->real_cent_freq, psd_scan->real_offset,
+		   psd_scan->real_span);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d dB",
+		   "PSD Pre-Scan Peak Value",
+		   psd_scan->ant_det_pre_psdscan_peak_val / 100);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (<= %d)",
+		   "PSD Pre-Scan result",
+		   (psd_scan->ant_det_result != 5 ? "ok" : "fail"),
+		   BT_8723D_1ANT_ANTDET_PSDTHRES_BACKGROUND
+		   + psd_scan->ant_det_thres_offset);
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->ant_det_result == 5)
+		return;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s dB",
+		   "PSD Scan Peak Value", psd_scan->ant_det_peak_val);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s MHz",
+		   "PSD Scan Peak Freq", psd_scan->ant_det_peak_freq);
+	CL_PRINTF(cli_buf);
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "TFBGA Package",
+		   (board_info->tfbga_package) ?  "Yes" : "No");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "PSD Threshold Offset", psd_scan->ant_det_thres_offset);
+	CL_PRINTF(cli_buf);
+
+}
+
+
+
+void halbtc8723d1ant_psd_showdata(IN struct btc_coexist *btcoexist)
+{
+	u8		*cli_buf = btcoexist->cli_buf;
+	u32		delta_freq_per_point;
+	u32		freq, freq1, freq2, n = 0, i = 0, j = 0, m = 0, psd_rep1, psd_rep2;
+
+	if (psd_scan->ant_det_result == 12)
+		return;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n\n============[PSD info]  (%d)============\n",
+		   psd_scan->psd_gen_count);
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->psd_gen_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n No data !!\n");
+		CL_PRINTF(cli_buf);
+		return;
+	}
+
+	if (psd_scan->psd_point == 0)
+		delta_freq_per_point = 0;
+	else
+		delta_freq_per_point = psd_scan->psd_band_width /
+				       psd_scan->psd_point;
+
+	/* if (psd_scan->is_psd_show_max_only) */
+	if (0) {
+		psd_rep1 = psd_scan->psd_max_value / 100;
+		psd_rep2 = psd_scan->psd_max_value - psd_rep1 * 100;
+
+		freq = ((psd_scan->real_cent_freq - 20) * 1000000 +
+			psd_scan->psd_max_value_point * delta_freq_per_point);
+		freq1 = freq / 1000000;
+		freq2 = freq / 1000 - freq1 * 1000;
+
+		if (freq2 < 100)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n Freq = %d.0%d MHz",
+				   freq1, freq2);
+		else
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n Freq = %d.%d MHz",
+				   freq1, freq2);
+
+		if (psd_rep2 < 10)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   ", Value = %d.0%d dB, (%d)\n",
+				   psd_rep1, psd_rep2, psd_scan->psd_max_value);
+		else
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   ", Value = %d.%d dB, (%d)\n",
+				   psd_rep1, psd_rep2, psd_scan->psd_max_value);
+
+		CL_PRINTF(cli_buf);
+	} else {
+		m = psd_scan->psd_start_point;
+		n = psd_scan->psd_start_point;
+		i = 1;
+		j = 1;
+
+		while (1) {
+			do {
+				freq = ((psd_scan->real_cent_freq - 20) *
+					1000000 + m *
+					delta_freq_per_point);
+				freq1 = freq / 1000000;
+				freq2 = freq / 1000 - freq1 * 1000;
+
+				if (i == 1) {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Freq%6d.000",
+							   freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Freq%6d.0%2d",
+							   freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Freq%6d.%3d",
+							   freq1,
+							   freq2);
+				} else if ((i % 8 == 0) ||
+					   (m == psd_scan->psd_stop_point)) {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.000\n", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.0%2d\n", freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.%3d\n", freq1,
+							   freq2);
+				} else {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.000", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.0%2d", freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.%3d", freq1,
+							   freq2);
+				}
+
+				i++;
+				m++;
+				CL_PRINTF(cli_buf);
+
+			} while ((i <= 8) && (m <= psd_scan->psd_stop_point));
+
+
+			do {
+				psd_rep1 = psd_scan->psd_report_max_hold[n] /
+					   100;
+				psd_rep2 = psd_scan->psd_report_max_hold[n] -
+					   psd_rep1 *
+					   100;
+
+				if (j == 1) {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Val %7d.0%d",
+							   psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Val %7d.%d",
+							   psd_rep1,
+							   psd_rep2);
+				} else if ((j % 8 == 0)  ||
+					   (n == psd_scan->psd_stop_point)) {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							"%7d.0%d\n", psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%7d.%d\n", psd_rep1,
+							   psd_rep2);
+				} else {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%7d.0%d", psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%7d.%d", psd_rep1,
+							   psd_rep2);
+				}
+
+				j++;
+				n++;
+				CL_PRINTF(cli_buf);
+
+			} while ((j <= 8) && (n <= psd_scan->psd_stop_point));
+
+			if ((m > psd_scan->psd_stop_point) ||
+			    (n > psd_scan->psd_stop_point))
+				break;
+			else {
+				i = 1;
+				j = 1;
+			}
+
+		}
+	}
+
+
+}
+
+
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+void halbtc8723d1ant_psd_maxholddata(IN struct btc_coexist *btcoexist,
+				     IN u32 gen_count)
+{
+	u32	i = 0;
+	u32 loop_i_max = 0, loop_val_max = 0;
+
+	if (gen_count == 1) {
+		memcpy(psd_scan->psd_report_max_hold,
+		       psd_scan->psd_report,
+		       BT_8723D_1ANT_ANTDET_PSD_POINTS * sizeof(u32));
+	}
+
+	for (i = psd_scan->psd_start_point;
+	     i <= psd_scan->psd_stop_point; i++) {
+
+		/* update max-hold value at each freq point */
+		if (psd_scan->psd_report[i] > psd_scan->psd_report_max_hold[i])
+			psd_scan->psd_report_max_hold[i] =
+				psd_scan->psd_report[i];
+
+		/*  search the max value in this seep */
+		if (psd_scan->psd_report[i] > loop_val_max) {
+			loop_val_max = psd_scan->psd_report[i];
+			loop_i_max = i;
+		}
+	}
+
+	if (gen_count <= BT_8723D_1ANT_ANTDET_PSD_SWWEEPCOUNT)
+		psd_scan->psd_loop_max_value[gen_count - 1] = loop_val_max;
+}
+
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+u32 halbtc8723d1ant_psd_getdata(IN struct btc_coexist *btcoexist, IN u32 point)
+{
+	/* reg 0x808[9:0]: FFT data x */
+	/* reg 0x808[22]: 0-->1 to get 1 FFT data y */
+	/* reg 0x8b4[15:0]: FFT data y report */
+
+	u32 val = 0, psd_report = 0;
+	int k = 0;
+
+	val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+
+	val &= 0xffbffc00;
+	val |= point;
+
+	btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+	val |= 0x00400000;
+	btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+	while (1) {
+		if (k++ > BT_8723D_1ANT_ANTDET_SWEEPPOINT_DELAY)
+			break;
+	}
+
+	val = btcoexist->btc_read_4byte(btcoexist, 0x8b4);
+
+	psd_report = val & 0x0000ffff;
+
+	return psd_report;
+}
+
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+boolean halbtc8723d1ant_psd_sweep_point(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN s32 offset, IN u32 span, IN u32 points,
+					IN u32 avgnum, IN u32 loopcnt)
+{
+	u32	 i = 0, val = 0, n = 0, k = 0, j, point_index = 0;
+	u32	points1 = 0, psd_report = 0;
+	u32	start_p = 0, stop_p = 0, delta_freq_per_point = 156250;
+	u32    psd_center_freq = 20 * 10 ^ 6;
+	boolean outloop = false, scan , roam, is_sweep_ok = true;
+	u8	 flag = 0;
+	u32	tmp = 0, u32tmp1 = 0;
+	u32	wifi_original_channel = 1;
+	u32 psd_sum = 0, avg_cnt = 0;
+	u32	i_max = 0, val_max = 0, val_max2 = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx PSD Sweep Start!!\n");
+	BTC_TRACE(trace_buf);
+
+	do {
+		switch (flag) {
+		case 0:  /* Get PSD parameters */
+		default:
+
+			psd_scan->psd_band_width = 40 * 1000000;
+			psd_scan->psd_point = points;
+			psd_scan->psd_start_base = points / 2;
+			psd_scan->psd_avg_num = avgnum;
+			psd_scan->real_cent_freq = cent_freq;
+			psd_scan->real_offset = offset;
+			psd_scan->real_span = span;
+
+
+			points1 = psd_scan->psd_point;
+			delta_freq_per_point = psd_scan->psd_band_width /
+					       psd_scan->psd_point;
+
+			/* PSD point setup */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+			val &= 0xffff0fff;
+
+			switch (psd_scan->psd_point) {
+			case 128:
+				val |= 0x0;
+				break;
+			case 256:
+			default:
+				val |= 0x00004000;
+				break;
+			case 512:
+				val |= 0x00008000;
+				break;
+			case 1024:
+				val |= 0x0000c000;
+				break;
+			}
+
+			switch (psd_scan->psd_avg_num) {
+			case 1:
+				val |= 0x0;
+				break;
+			case 8:
+				val |= 0x00001000;
+				break;
+			case 16:
+				val |= 0x00002000;
+				break;
+			case 32:
+			default:
+				val |= 0x00003000;
+				break;
+			}
+			btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+			flag = 1;
+			break;
+		case 1:	  /* calculate the PSD point index from freq/offset/span */
+			psd_center_freq = psd_scan->psd_band_width / 2 +
+					  offset * (1000000);
+
+			start_p = psd_scan->psd_start_base + (psd_center_freq -
+				span * (1000000) / 2) / delta_freq_per_point;
+			psd_scan->psd_start_point = start_p -
+						    psd_scan->psd_start_base;
+
+			stop_p = psd_scan->psd_start_base + (psd_center_freq +
+				span * (1000000) / 2) / delta_freq_per_point;
+			psd_scan->psd_stop_point = stop_p -
+						   psd_scan->psd_start_base - 1;
+
+			flag = 2;
+			break;
+		case 2:  /* set RF channel/BW/Mode */
+
+			/* set 3-wire off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x88c);
+			val |= 0x00300000;
+			btcoexist->btc_write_4byte(btcoexist, 0x88c, val);
+
+			/* CCK off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x800);
+			val &= 0xfeffffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x800, val);
+
+			/* Tx-pause on */
+			btcoexist->btc_write_1byte(btcoexist, 0x522, 0x6f);
+
+			/* store WiFi original channel */
+			wifi_original_channel = btcoexist->btc_get_rf_reg(
+					btcoexist, BTC_RF_A, 0x18, 0x3ff);
+
+			/* Set RF channel */
+			if (cent_freq == 2484)
+				btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A,
+							  0x18, 0x3ff, 0xe);
+			else
+				btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A,
+					  0x18, 0x3ff, (cent_freq - 2412) / 5 +
+						  1); /* WiFi TRx Mask on */
+
+			/* save original RCK value */
+			u32tmp1 =  btcoexist->btc_get_rf_reg(
+					   btcoexist, BTC_RF_A, 0x1d, 0xfffff);
+
+			/* Enter debug mode */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xde,
+						  0x2, 0x1);
+
+			/* Set RF Rx filter corner */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1d,
+						  0xfffff, 0x2e);
+
+
+			/* Set  RF mode = Rx, RF Gain = 0x320a0 */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x0,
+						  0xfffff, 0x320a0);
+
+			while (1) {
+				if (k++ > BT_8723D_1ANT_ANTDET_SWEEPPOINT_DELAY)
+					break;
+			}
+			flag = 3;
+			break;
+		case 3:
+			psd_scan->psd_gen_count = 0;
+			for (j = 1; j <= loopcnt; j++) {
+
+				btcoexist->btc_get(btcoexist,
+						   BTC_GET_BL_WIFI_SCAN, &scan);
+				btcoexist->btc_get(btcoexist,
+						   BTC_GET_BL_WIFI_ROAM, &roam);
+
+				if (scan || roam) {
+					is_sweep_ok = false;
+					break;
+				}
+				memset(psd_scan->psd_report, 0,
+				       psd_scan->psd_point * sizeof(u32));
+				start_p = psd_scan->psd_start_point +
+					  psd_scan->psd_start_base;
+				stop_p = psd_scan->psd_stop_point +
+					 psd_scan->psd_start_base + 1;
+
+				i = start_p;
+				point_index = 0;
+
+				while (i < stop_p) {
+					if (i >= points1)
+						psd_report =
+							halbtc8723d1ant_psd_getdata(
+							btcoexist, i - points1);
+					else
+						psd_report =
+							halbtc8723d1ant_psd_getdata(
+								btcoexist, i);
+
+					if (psd_report == 0)
+						tmp = 0;
+					else
+						/* tmp =  20*log10((double)psd_report); */
+						/* 20*log2(x)/log2(10), log2Base return theresult of the psd_report*100 */
+						tmp = 6 * halbtc8723d1ant_psd_log2base(
+							btcoexist, psd_report);
+
+					n = i - psd_scan->psd_start_base;
+					psd_scan->psd_report[n] =  tmp;
+
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"Point=%d, psd_dB_data = %d\n",
+						    i, psd_scan->psd_report[n]);
+					BTC_TRACE(trace_buf);
+
+					i++;
+
+				}
+
+				halbtc8723d1ant_psd_maxholddata(btcoexist, j);
+
+				psd_scan->psd_gen_count = j;
+
+				/*Accumulate Max PSD value in this loop if the value > threshold */
+				if (psd_scan->psd_loop_max_value[j - 1] >=
+				    4000) {
+					psd_sum = psd_sum +
+						psd_scan->psd_loop_max_value[j -
+								       1];
+					avg_cnt++;
+				}
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "Loop=%d, Max_dB_data = %d\n",
+					    j, psd_scan->psd_loop_max_value[j
+							    - 1]);
+				BTC_TRACE(trace_buf);
+
+			}
+
+			if (loopcnt == BT_8723D_1ANT_ANTDET_PSD_SWWEEPCOUNT) {
+
+				/* search the Max Value between each-freq-point-max-hold value of all sweep*/
+				for (i = 1;
+				     i <= BT_8723D_1ANT_ANTDET_PSD_SWWEEPCOUNT;
+				     i++) {
+
+					if (i == 1) {
+						i_max = i;
+						val_max = psd_scan->psd_loop_max_value[i
+								       - 1];
+						val_max2 =
+							psd_scan->psd_loop_max_value[i
+								     - 1];
+					} else if (
+						psd_scan->psd_loop_max_value[i -
+							     1] > val_max) {
+						val_max2 = val_max;
+						i_max = i;
+						val_max = psd_scan->psd_loop_max_value[i
+								       - 1];
+					} else if (
+						psd_scan->psd_loop_max_value[i -
+							     1] > val_max2)
+						val_max2 =
+							psd_scan->psd_loop_max_value[i
+								     - 1];
+
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"i = %d, val_hold= %d, val_max = %d, val_max2 = %d\n",
+						i, psd_scan->psd_loop_max_value[i
+								    - 1],
+						    val_max, val_max2);
+
+					BTC_TRACE(trace_buf);
+				}
+
+				psd_scan->psd_max_value_point = i_max;
+				psd_scan->psd_max_value = val_max;
+				psd_scan->psd_max_value2 = val_max2;
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "val_max = %d, val_max2 = %d\n",
+					    psd_scan->psd_max_value,
+					    psd_scan->psd_max_value2);
+				BTC_TRACE(trace_buf);
+			}
+
+			if (avg_cnt != 0) {
+				psd_scan->psd_avg_value = (psd_sum / avg_cnt);
+				if ((psd_sum % avg_cnt) >= (avg_cnt / 2))
+					psd_scan->psd_avg_value++;
+			} else
+				psd_scan->psd_avg_value = 0;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "AvgLoop=%d, Avg_dB_data = %d\n",
+				    avg_cnt, psd_scan->psd_avg_value);
+			BTC_TRACE(trace_buf);
+
+			flag = 100;
+			break;
+		case 99:	/* error */
+
+			outloop = true;
+			break;
+		case 100: /* recovery */
+
+			/* set 3-wire on */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x88c);
+			val &= 0xffcfffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x88c, val);
+
+			/* CCK on */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x800);
+			val |= 0x01000000;
+			btcoexist->btc_write_4byte(btcoexist, 0x800, val);
+
+			/* Tx-pause off */
+			btcoexist->btc_write_1byte(btcoexist, 0x522, 0x0);
+
+			/* PSD off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+			val &= 0xffbfffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+			/* restore RF Rx filter corner */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1d,
+						  0xfffff, u32tmp1);
+
+			/* Exit debug mode */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xde,
+						  0x2, 0x0);
+
+			/* restore WiFi original channel */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x18,
+						  0x3ff, wifi_original_channel);
+
+			outloop = true;
+			break;
+
+		}
+
+	} while (!outloop);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx PSD Sweep Stop!!\n");
+	BTC_TRACE(trace_buf);
+	return is_sweep_ok;
+
+}
+
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+boolean halbtc8723d1ant_psd_antenna_detection(IN struct btc_coexist
+		*btcoexist)
+{
+	u32	i = 0;
+	u32	wlpsd_cent_freq = 2484, wlpsd_span = 2;
+	s32	wlpsd_offset = -4;
+	u32 bt_tx_time, bt_le_channel;
+	u8	bt_le_ch[13] = {3, 6, 8, 11, 13, 16, 18, 21, 23, 26, 28, 31, 33};
+
+	u8	h2c_parameter[3] = {0}, u8tmpa, u8tmpb;
+
+	u8	state = 0;
+	boolean		outloop = false, bt_resp = false, ant_det_finish = false;
+	u32		freq, freq1, freq2, psd_rep1, psd_rep2, delta_freq_per_point,
+			u32tmp, u32tmp0, u32tmp1, u32tmp2 ;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	memset(psd_scan->ant_det_peak_val, 0, 16 * sizeof(u8));
+	memset(psd_scan->ant_det_peak_freq, 0, 16 * sizeof(u8));
+
+	psd_scan->ant_det_bt_tx_time =
+		BT_8723D_1ANT_ANTDET_BTTXTIME;	   /* 0.42ms*50 = 20ms (0.42ms = 1 PSD sweep) */
+	psd_scan->ant_det_bt_le_channel = BT_8723D_1ANT_ANTDET_BTTXCHANNEL;
+
+	bt_tx_time = psd_scan->ant_det_bt_tx_time;
+	bt_le_channel = psd_scan->ant_det_bt_le_channel;
+
+	if (board_info->tfbga_package) /* for TFBGA */
+		psd_scan->ant_det_thres_offset = 5;
+	else
+		psd_scan->ant_det_thres_offset = 0;
+
+	do {
+		switch (state) {
+		case 0:
+			if (bt_le_channel == 39)
+				wlpsd_cent_freq = 2484;
+			else {
+				for (i = 1; i <= 13; i++) {
+					if (bt_le_ch[i - 1] ==
+					    bt_le_channel) {
+						wlpsd_cent_freq = 2412
+								  + (i - 1) * 5;
+						break;
+					}
+				}
+
+				if (i == 14) {
+
+					BTC_SPRINTF(trace_buf,
+						    BT_TMP_BUF_SIZE,
+						"xxxxxxxxxxxxxxxx AntennaDetect(), Abort!!, Invalid LE channel = %d\n ",
+						    bt_le_channel);
+					BTC_TRACE(trace_buf);
+					outloop = true;
+					break;
+				}
+			}
+#if 0
+			wlpsd_sweep_count = bt_tx_time * 238 /
+					    100; /* bt_tx_time/0.42								 */
+			wlpsd_sweep_count = wlpsd_sweep_count / 5;
+
+			if (wlpsd_sweep_count % 5 != 0)
+				wlpsd_sweep_count = (wlpsd_sweep_count /
+						     5 + 1) * 5;
+#endif
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), BT_LETxTime=%d,  BT_LECh = %d\n",
+				    bt_tx_time, bt_le_channel);
+			BTC_TRACE(trace_buf);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), wlpsd_cent_freq=%d,  wlpsd_offset = %d, wlpsd_span = %d, wlpsd_sweep_count = %d\n",
+				    wlpsd_cent_freq,
+				    wlpsd_offset,
+				    wlpsd_span,
+				    BT_8723D_1ANT_ANTDET_PSD_SWWEEPCOUNT);
+			BTC_TRACE(trace_buf);
+
+			state = 1;
+			break;
+		case 1: /* stop coex DM & set antenna path */
+			/* Stop Coex DM */
+			btcoexist->stop_coex_dm = true;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Stop Coex DM!!\n");
+			BTC_TRACE(trace_buf);
+
+			/* Set TDMA off,				 */
+			halbtc8723d1ant_ps_tdma(btcoexist, FORCE_EXEC,
+						false, 0);
+
+			/* Set coex table */
+			halbtc8723d1ant_coex_table_with_type(btcoexist,
+							     FORCE_EXEC, 0);
+
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna at Main Port\n");
+				BTC_TRACE(trace_buf);
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna at Aux Port\n");
+				BTC_TRACE(trace_buf);
+			}
+
+			/* Set Antenna path, switch WiFi to un-certain antenna port */
+			/* Set Antenna Path,  both GNT_WL/GNT_BT = 1, and control by SW */
+			halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+						     FORCE_EXEC,
+					     BT_8723D_1ANT_PHASE_ANTENNA_DET);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set Antenna to BT!!\n");
+			BTC_TRACE(trace_buf);
+
+			/* Set AFH mask on at WiFi channel 2472MHz +/- 10MHz */
+			h2c_parameter[0] = 0x1;
+			h2c_parameter[1] = 0xd;
+			h2c_parameter[2] = 0x14;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set AFH on, Cent-Ch= %d,  Mask=%d\n",
+				    h2c_parameter[1],
+				    h2c_parameter[2]);
+			BTC_TRACE(trace_buf);
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x66, 3,
+						h2c_parameter);
+
+			u32tmp = btcoexist->btc_read_2byte(btcoexist, 0x948);
+			u32tmp0 = btcoexist->btc_read_4byte(btcoexist, 0x70);
+			u32tmp1 = halbtc8723d1ant_ltecoex_indirect_read_reg(
+					  btcoexist, 0x38);
+			u32tmp2 = halbtc8723d1ant_ltecoex_indirect_read_reg(
+					  btcoexist, 0x54);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** 0x948 = 0x%x, 0x70 = 0x%x, 0x38= 0x%x, 0x54= 0x%x (Before Ant Det)\n",
+				    u32tmp, u32tmp0, u32tmp1, u32tmp2);
+			BTC_TRACE(trace_buf);
+
+			state = 2;
+			break;
+		case 2:	/* Pre-sweep background psd */
+			if (!halbtc8723d1ant_psd_sweep_point(btcoexist,
+				     wlpsd_cent_freq, wlpsd_offset, wlpsd_span,
+					     BT_8723D_1ANT_ANTDET_PSD_POINTS,
+				     BT_8723D_1ANT_ANTDET_PSD_AVGNUM, 3)) {
+				ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				psd_scan->ant_det_result = 8;
+				state = 99;
+				break;
+			}
+
+			psd_scan->ant_det_pre_psdscan_peak_val =
+				psd_scan->psd_max_value;
+
+			if (psd_scan->ant_det_pre_psdscan_peak_val >
+			    (BT_8723D_1ANT_ANTDET_PSDTHRES_BACKGROUND
+			     + psd_scan->ant_det_thres_offset) * 100) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Abort Antenna Detection!! becaus background = %d > thres (%d)\n",
+					psd_scan->ant_det_pre_psdscan_peak_val /
+					    100,
+					BT_8723D_1ANT_ANTDET_PSDTHRES_BACKGROUND
+					    + psd_scan->ant_det_thres_offset);
+				BTC_TRACE(trace_buf);
+				ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				psd_scan->ant_det_result = 5;
+				state = 99;
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Start Antenna Detection!! becaus background = %d <= thres (%d)\n",
+					psd_scan->ant_det_pre_psdscan_peak_val /
+					    100,
+					BT_8723D_1ANT_ANTDET_PSDTHRES_BACKGROUND
+					    + psd_scan->ant_det_thres_offset);
+				BTC_TRACE(trace_buf);
+				state = 3;
+			}
+			break;
+		case 3:
+
+			bt_resp = btcoexist->btc_set_bt_ant_detection(
+					  btcoexist, (u8)(bt_tx_time & 0xff),
+					  (u8)(bt_le_channel & 0xff));
+
+			/* Sync WL Rx PSD with BT Tx time because H2C->Mailbox delay */
+			delay_ms(20);
+
+			if (!halbtc8723d1ant_psd_sweep_point(btcoexist,
+					     wlpsd_cent_freq, wlpsd_offset,
+							     wlpsd_span,
+					     BT_8723D_1ANT_ANTDET_PSD_POINTS,
+					     BT_8723D_1ANT_ANTDET_PSD_AVGNUM,
+				     BT_8723D_1ANT_ANTDET_PSD_SWWEEPCOUNT)) {
+				ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				psd_scan->ant_det_result = 8;
+				state = 99;
+				break;
+			}
+
+#if 1
+			psd_scan->ant_det_psd_scan_peak_val =
+				psd_scan->psd_max_value;
+#endif
+#if 0
+			psd_scan->ant_det_psd_scan_peak_val =
+				((psd_scan->psd_max_value - psd_scan->psd_avg_value) <
+				 800) ?
+				psd_scan->psd_max_value : ((
+						psd_scan->psd_max_value -
+					psd_scan->psd_max_value2 <= 300) ?
+						   psd_scan->psd_avg_value :
+						   psd_scan->psd_max_value2);
+#endif
+			psd_scan->ant_det_psd_scan_peak_freq =
+				psd_scan->psd_max_value_point;
+			state = 4;
+			break;
+		case 4:
+
+			if (psd_scan->psd_point == 0)
+				delta_freq_per_point = 0;
+			else
+				delta_freq_per_point =
+					psd_scan->psd_band_width /
+					psd_scan->psd_point;
+
+			psd_rep1 = psd_scan->ant_det_psd_scan_peak_val / 100;
+			psd_rep2 = psd_scan->ant_det_psd_scan_peak_val -
+				   psd_rep1 *
+				   100;
+
+			freq = ((psd_scan->real_cent_freq - 20) *
+				1000000 + psd_scan->psd_max_value_point
+				* delta_freq_per_point);
+			freq1 = freq / 1000000;
+			freq2 = freq / 1000 - freq1 * 1000;
+
+			if (freq2 < 100) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Max Value: Freq = %d.0%d MHz",
+					    freq1, freq2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_freq,
+					   BT_8723D_1ANT_ANTDET_BUF_LEN,
+					   "%d.0%d", freq1, freq2);
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Max Value: Freq = %d.%d MHz",
+					    freq1, freq2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_freq,
+					   BT_8723D_1ANT_ANTDET_BUF_LEN,
+					   "%d.%d", freq1, freq2);
+			}
+
+			if (psd_rep2 < 10) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    ", Value = %d.0%d dB\n",
+					    psd_rep1, psd_rep2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_val,
+					   BT_8723D_1ANT_ANTDET_BUF_LEN,
+					   "%d.0%d", psd_rep1, psd_rep2);
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    ", Value = %d.%d dB\n",
+					    psd_rep1, psd_rep2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_val,
+					   BT_8723D_1ANT_ANTDET_BUF_LEN,
+					   "%d.%d", psd_rep1, psd_rep2);
+			}
+
+			psd_scan->ant_det_is_btreply_available = true;
+
+			if (bt_resp == false) {
+				psd_scan->ant_det_is_btreply_available =
+					false;
+				psd_scan->ant_det_result = 0;
+				ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), BT Response = Fail\n ");
+				BTC_TRACE(trace_buf);
+			} else if (psd_scan->ant_det_psd_scan_peak_val >
+				(BT_8723D_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION)
+				   * 100) {
+				psd_scan->ant_det_result = 1;
+				ant_det_finish = true;
+				board_info->btdm_ant_num_by_ant_det = 2;
+				coex_sta->isolation_btween_wb = (u8)(85 -
+					psd_scan->ant_det_psd_scan_peak_val /
+							     100) & 0xff;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 2-Ant, Bad-Isolation!!\n");
+				BTC_TRACE(trace_buf);
+			} else if (psd_scan->ant_det_psd_scan_peak_val >
+				(BT_8723D_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION
+				    + psd_scan->ant_det_thres_offset) * 100) {
+				psd_scan->ant_det_result = 2;
+				ant_det_finish = true;
+				board_info->btdm_ant_num_by_ant_det = 2;
+				coex_sta->isolation_btween_wb = (u8)(85 -
+					psd_scan->ant_det_psd_scan_peak_val /
+							     100) & 0xff;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 2-Ant, Good-Isolation!!\n");
+				BTC_TRACE(trace_buf);
+			} else if (psd_scan->ant_det_psd_scan_peak_val >
+				   (BT_8723D_1ANT_ANTDET_PSDTHRES_1ANT) *
+				   100) {
+				psd_scan->ant_det_result = 3;
+				ant_det_finish = true;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				coex_sta->isolation_btween_wb = (u8)(85 -
+					psd_scan->ant_det_psd_scan_peak_val /
+							     100) & 0xff;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 1-Ant!!\n");
+				BTC_TRACE(trace_buf);
+			} else {
+				psd_scan->ant_det_result = 4;
+				ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 1-Ant, un-certainity!!\n");
+				BTC_TRACE(trace_buf);
+			}
+
+			state = 99;
+			break;
+		case 99:  /* restore setup */
+
+			/* Set AFH mask off at WiFi channel 2472MHz +/- 10MHz */
+			h2c_parameter[0] = 0x0;
+			h2c_parameter[1] = 0x0;
+			h2c_parameter[2] = 0x0;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set AFH on, Cent-Ch= %d,  Mask=%d\n",
+				    h2c_parameter[1], h2c_parameter[2]);
+			BTC_TRACE(trace_buf);
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x66, 3,
+						h2c_parameter);
+
+			/* Set Antenna Path, GNT_WL/GNT_BT control by PTA */
+			/* Set Antenna path, switch WiFi to certain antenna port */
+			halbtc8723d1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO, FORCE_EXEC,
+					     BT_8723D_1ANT_PHASE_2G_RUNTIME);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set Antenna to PTA\n!!");
+			BTC_TRACE(trace_buf);
+
+			btcoexist->stop_coex_dm = false;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Resume Coex DM\n!!");
+			BTC_TRACE(trace_buf);
+
+			outloop = true;
+			break;
+		}
+
+	} while (!outloop);
+
+	return ant_det_finish;
+
+}
+
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+boolean halbtc8723d1ant_psd_antenna_detection_check(IN struct btc_coexist
+		*btcoexist)
+{
+	static u32 ant_det_count = 0, ant_det_fail_count = 0;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	boolean scan, roam, ant_det_finish = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+	ant_det_count++;
+
+	psd_scan->ant_det_try_count = ant_det_count;
+
+	if (scan || roam) {
+		ant_det_finish = false;
+		psd_scan->ant_det_result = 6;
+	} else if (coex_sta->bt_disabled) {
+		ant_det_finish = false;
+		psd_scan->ant_det_result = 11;
+	} else if (coex_sta->num_of_profile >= 1) {
+		ant_det_finish = false;
+		psd_scan->ant_det_result = 7;
+	} else if (
+		!psd_scan->ant_det_is_ant_det_available) { /* Antenna initial setup is not ready */
+		ant_det_finish = false;
+		psd_scan->ant_det_result = 9;
+	} else if (coex_sta->c2h_bt_inquiry_page) {
+		ant_det_finish = false;
+		psd_scan->ant_det_result = 10;
+	} else {
+
+		ant_det_finish = halbtc8723d1ant_psd_antenna_detection(
+					 btcoexist);
+
+		delay_ms(psd_scan->ant_det_bt_tx_time);
+	}
+
+	/* board_info->ant_det_result = psd_scan->ant_det_result; */
+
+	if (!ant_det_finish)
+		ant_det_fail_count++;
+
+	psd_scan->ant_det_fail_count = ant_det_fail_count;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"xxxxxxxxxxxxxxxx AntennaDetect(), result = %d, fail_count = %d, finish = %s\n",
+		    psd_scan->ant_det_result,
+		    psd_scan->ant_det_fail_count,
+		    ant_det_finish == true ? "Yes" : "No");
+	BTC_TRACE(trace_buf);
+
+	return ant_det_finish;
+
+}
+
+
+
+/* ************************************************************
+ * work around function start with wa_halbtc8723d1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8723d1ant_
+ * ************************************************************ */
+void ex_halbtc8723d1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x0;
+	u16 u16tmp = 0x0;
+	u32	value = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"xxxxxxxxxxxxxxxx Execute 8723d 1-Ant PowerOn Setting xxxxxxxxxxxxxxxx!!\n");
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "Ant Det Finish = %s, Ant Det Number  = %d\n",
+		    (board_info->btdm_ant_det_finish ? "Yes" : "No"),
+		    board_info->btdm_ant_num_by_ant_det);
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = true;
+	psd_scan->ant_det_is_ant_det_available = false;
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write BB Register correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+
+	/* Set Antenna Path to BT side */
+	/* Check efuse 0xc3[6] for Single Antenna Path */
+	if (board_info->single_ant_path == 0) {
+		/* set to S1 */
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+		u8tmp = 0;
+		value = 1;
+	} else if (board_info->single_ant_path == 1) {
+		/* set to S0 */
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+		u8tmp = 1;
+		value = 0;
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (Power On) single_ant_path  = %d, btdm_ant_pos = %d **********\n",
+		    board_info->single_ant_path , board_info->btdm_ant_pos);
+	BTC_TRACE(trace_buf);
+
+	/* Set Antenna Path to BT side */
+	halbtc8723d1ant_set_ant_path(btcoexist,
+				     BTC_ANT_PATH_AUTO,
+				     FORCE_EXEC,
+				     BT_8723D_1ANT_PHASE_COEX_POWERON);
+
+	/* Write Single Antenna Position to Registry to tell BT for 8723d. This line can be removed
+	since BT EFuse also add "single antenna position" in EFuse for 8723d*/
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_ANTPOSREGRISTRY_CTRL,
+			   &value);
+
+	/* Save"single antenna position" info in Local register setting for FW reading, because FW may not ready at  power on */
+	if (btcoexist->chip_interface == BTC_INTF_PCI)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x3e0, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_USB)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60, u8tmp);
+
+	/* enable GNT_WL/GNT_BT debug signal to GPIO14/15 */
+	halbtc8723d1ant_enable_gnt_to_gpio(btcoexist, true);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********  LTE coex Reg 0x38 (Power-On) = 0x%x**********\n",
+		    halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist, 0x38));
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********  MAC Reg 0x70/ BB Reg 0x948 (Power-On) = 0x%x / 0x%x**********\n",
+		    btcoexist->btc_read_4byte(btcoexist, 0x70),
+		    btcoexist->btc_read_2byte(btcoexist, 0x948));
+	BTC_TRACE(trace_buf);
+
+}
+
+void ex_halbtc8723d1ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8723d1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8723d1ant_init_hw_config(btcoexist, true, wifi_only);
+}
+
+void ex_halbtc8723d1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723d1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8723d1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_stack_info		*stack_info = &btcoexist->stack_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+	u32				fw_ver = 0, bt_patch_ver = 0, bt_coex_ver = 0;
+	static u8			pop_report_in_10s = 0;
+	u32			phyver = 0;
+	boolean			lte_coex_on = false;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	if (psd_scan->ant_det_try_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %s",
+			   "Ant PG Num/ Mech/ Pos",
+			   board_info->pg_ant_num, board_info->btdm_ant_num,
+			   (board_info->btdm_ant_pos == 1 ? "S1" : "S0"));
+		CL_PRINTF(cli_buf);
+	} else {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %s  (%d/%d/%d)",
+			   "Ant PG Num/ Mech(Ant_Det)/ Pos",
+			   board_info->pg_ant_num,
+			   board_info->btdm_ant_num_by_ant_det,
+			   (board_info->btdm_ant_pos == 1 ? "S1" : "S0"),
+			   psd_scan->ant_det_try_count,
+			   psd_scan->ant_det_fail_count,
+			   psd_scan->ant_det_result);
+		CL_PRINTF(cli_buf);
+
+		if (board_info->btdm_ant_det_finish) {
+
+			if (psd_scan->ant_det_result != 12)
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					   "\r\n %-35s = %s",
+					   "Ant Det PSD Value",
+					   psd_scan->ant_det_peak_val);
+			else
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					   "\r\n %-35s = %d",
+					   "Ant Det PSD Value",
+					   psd_scan->ant_det_psd_scan_peak_val
+					   / 100);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	if (board_info->ant_det_result_five_complete) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d",
+			   "AntDet(Registry) Num/PSD Value",
+			   board_info->btdm_ant_num_by_ant_det,
+			   (board_info->antdetval & 0x7f));
+		CL_PRINTF(cli_buf);
+	}
+
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+
+	bt_coex_ver = ((coex_sta->bt_coex_supported_version & 0xff00) >> 8);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+				"CoexVer WL/  BT_Desired/ BT_Report",
+				glcoex_ver_date_8723d_1ant, glcoex_ver_8723d_1ant,
+				glcoex_ver_btdesired_8723d_1ant,
+				bt_coex_ver,
+				(bt_coex_ver == 0xff ? "Unknown" :
+				(coex_sta->bt_disabled ? "BT-disable" :
+				(bt_coex_ver >= glcoex_ver_btdesired_8723d_1ant ?
+				"Match" : "Mis-Match"))));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d/ %c",
+		   "W_FW/ B_FW/ Phy/ Kt",
+		   fw_ver, bt_patch_ver, phyver,
+		   coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	pop_report_in_10s++;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = [%s/ %d dBm/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt/ popCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+			   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page")
+			   : ((BT_8723D_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8723D_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi - 100, coex_sta->bt_retry_cnt,
+		   coex_sta->pop_event_cnt);
+	CL_PRINTF(cli_buf);
+
+	if (pop_report_in_10s >= 5) {
+		coex_sta->pop_event_cnt = 0;
+		pop_report_in_10s = 0;
+	}
+
+	if (coex_sta->num_of_profile != 0)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %s%s%s%s%s",
+			   "Profiles",
+			   ((bt_link_info->a2dp_exist) ? "A2DP," : ""),
+			   ((bt_link_info->sco_exist) ?  "SCO," : ""),
+			   ((bt_link_info->hid_exist) ?
+			    ((coex_sta->hid_busy_num >= 2) ? "HID(4/18)," :
+			     "HID(2/18),") : ""),
+			   ((bt_link_info->pan_exist) ?  "PAN," : ""),
+			   ((coex_sta->voice_over_HOGP) ? "Voice" : ""));
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = None",
+			   "Profiles");
+
+	CL_PRINTF(cli_buf);
+
+	if (bt_link_info->a2dp_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %d/ %s",
+			   "A2DP Rate/Bitpool/Auto_Slot",
+			   ((coex_sta->is_A2DP_3M) ? "3M" : "No_3M"),
+			   coex_sta->a2dp_bit_pool,
+			   ((coex_sta->is_autoslot) ? "On" : "Off")
+			  );
+		CL_PRINTF(cli_buf);
+	}
+
+	if (bt_link_info->hid_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+			   "HID PairNum/Forbid_Slot",
+			   coex_sta->hid_pair_cnt,
+			   coex_sta->forbidden_slot
+			  );
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %d/ %s/ 0x%x",
+				"Role/RoleSwCnt/IgnWlact/Feature",
+				((bt_link_info->slave_role) ? "Slave" : "Master"),
+				coex_sta->cnt_RoleSwitch,
+				((coex_dm->cur_ignore_wlan_act) ? "Yes" : "No"),
+				coex_sta->bt_coex_supported_feature);
+	CL_PRINTF(cli_buf);
+
+	if ((coex_sta->bt_ble_scan_type & 0x7) != 0x0) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+				"BLEScan Type/TV/Init/Ble",
+				coex_sta->bt_ble_scan_type,
+				(coex_sta->bt_ble_scan_type & 0x1 ?
+				coex_sta->bt_ble_scan_para[0] : 0x0),
+				(coex_sta->bt_ble_scan_type & 0x2 ?
+				coex_sta->bt_ble_scan_para[1] : 0x0),
+				(coex_sta->bt_ble_scan_type & 0x4 ?
+				coex_sta->bt_ble_scan_para[2] : 0x0));
+			CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d",
+		   "ReInit/ReLink/IgnWlact/Page/NameReq",
+		   coex_sta->cnt_ReInit,
+		   coex_sta->cnt_setupLink,
+		   coex_sta->cnt_IgnWlanAct,
+		   coex_sta->cnt_Page,
+		   coex_sta->cnt_RemoteNameReq
+		  );
+	CL_PRINTF(cli_buf);
+
+	halbtc8723d1ant_read_score_board(btcoexist,	&u16tmp[0]);
+
+	if ((coex_sta->bt_reg_vendor_ae == 0xffff) ||
+	    (coex_sta->bt_reg_vendor_ac == 0xffff))
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = x/ x/ %04x",
+			   "0xae[4]/0xac[1:0]/Scoreboard", u16tmp[0]);
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = 0x%x/ 0x%x/ %04x",
+			   "0xae[4]/0xac[1:0]/Scoreboard",
+			   ((coex_sta->bt_reg_vendor_ae & BIT(4)) >> 4),
+			   coex_sta->bt_reg_vendor_ac & 0x3, u16tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	if (coex_sta->num_of_profile > 0) {
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
+			"AFH MAP",
+			coex_sta->bt_afh_map[0],
+			coex_sta->bt_afh_map[1],
+			coex_sta->bt_afh_map[2],
+			coex_sta->bt_afh_map[3],
+			coex_sta->bt_afh_map[4],
+			coex_sta->bt_afh_map[5],
+			coex_sta->bt_afh_map[6],
+			coex_sta->bt_afh_map[7],
+			coex_sta->bt_afh_map[8],
+			coex_sta->bt_afh_map[9]
+			   );
+		CL_PRINTF(cli_buf);
+	}
+
+	for (i = 0; i < BT_INFO_SRC_8723D_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x (%d)",
+				   glbt_info_src_8723d_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[mechanisms] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[Mechanisms]============");
+
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x (case-%d, %s)",
+		   "TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   (coex_dm->cur_ps_tdma_on ? "TDMA On" : "TDMA Off"));
+
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d/ 0x%x/ 0x%x/ 0x%x",
+		   "Table/0x6c0/0x6c4/0x6c8",
+		   coex_sta->coex_table_type, u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x778/0x6cc",
+		   u8tmp[0], u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s",
+		   "AntDiv/ ForceLPS",
+		   ((board_info->ant_div_cfg) ? "On" : "Off"),
+		   ((coex_sta->force_lps_on) ? "On" : "Off"));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	lte_coex_on = ((u32tmp[0] & BIT(7)) >> 7) ?  true : false;
+
+	if (lte_coex_on) {
+
+		u32tmp[0] = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa0);
+		u32tmp[1] = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa4);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+			   "LTE Coex  Table W_L/B_L",
+			   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff);
+		CL_PRINTF(cli_buf);
+
+		u32tmp[0] = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa8);
+		u32tmp[1] = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xac);
+		u32tmp[2] = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xb0);
+		u32tmp[3] = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xb4);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+			   "LTE Break Table W_L/B_L/L_W/L_B",
+			   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff,
+			   u32tmp[2] & 0xffff, u32tmp[3] & 0xffff);
+		CL_PRINTF(cli_buf);
+
+	}
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+	/*
+		u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+		u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+		u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+		u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+			   "0x430/0x434/0x42a/0x456",
+			   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+		CL_PRINTF(cli_buf);
+	*/
+
+	u32tmp[0] = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp[1] = halbtc8723d1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s",
+		   "LTE Coex/Path Owner",
+		   ((lte_coex_on) ? "On" : "Off") ,
+		   ((u8tmp[0] & BIT(2)) ? "WL" : "BT"));
+	CL_PRINTF(cli_buf);
+
+	if (lte_coex_on) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %d/ %d",
+			   "LTE 3Wire/OPMode/UART/UARTMode",
+			   (int)((u32tmp[0] & BIT(6)) >> 6),
+			   (int)((u32tmp[0] & (BIT(5) | BIT(4))) >> 4),
+			   (int)((u32tmp[0] & BIT(3)) >> 3),
+			   (int)(u32tmp[0] & (BIT(2) | BIT(1) | BIT(0))));
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+			   "LTE_Busy/UART_Busy",
+			(int)((u32tmp[1] & BIT(1)) >> 1), (int)(u32tmp[1] & BIT(0)));
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %s (BB:%s)/ %s (BB:%s)/ %s %d",
+			   "GNT_WL_Ctrl/GNT_BT_Ctrl/Dbg",
+			   ((u32tmp[0] & BIT(12)) ? "SW" : "HW"),
+			   ((u32tmp[0] & BIT(8)) ?	"SW" : "HW"),
+			   ((u32tmp[0] & BIT(14)) ? "SW" : "HW"),
+			   ((u32tmp[0] & BIT(10)) ?  "SW" : "HW"),
+			   ((u8tmp[0] & BIT(3)) ? "On" : "Off"),
+			   coex_sta->gnt_error_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "GNT_WL/GNT_BT",
+		   (int)((u32tmp[1] & BIT(2)) >> 2),
+		   (int)((u32tmp[1] & BIT(3)) >> 3));
+	CL_PRINTF(cli_buf);
+
+	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x948);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x948/0x67[7]",
+		   u16tmp[0], (int)((u8tmp[0] & BIT(7)) >> 7));
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x964);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x864);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0xab7);
+	u8tmp[3] = btcoexist->btc_read_1byte(btcoexist, 0xa01);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x964[1]/0x864[0]/0xab7[5]/0xa01[7]",
+		   (int)((u8tmp[0] & BIT(1)) >> 1), (int)((u8tmp[1] & BIT(0))),
+		   (int)((u8tmp[2] & BIT(3)) >> 3),
+		   (int)((u8tmp[3] & BIT(7)) >> 7));
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x4c6);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0x45e);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x4c6[4]/0x40[5]/0x45e[3](TxRetry)",
+		   (int)((u8tmp[0] & BIT(4)) >> 4),
+		   (int)((u8tmp[1] & BIT(5)) >> 5),
+		   (int)((u8tmp[2] & BIT(3)) >> 3));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x953);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ %s",
+		   "0x550/0x522/4-RxAGC",
+		   u32tmp[0], u8tmp[0], (u8tmp[1] & 0x2) ? "On" : "Off");
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist, PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist, PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist, PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist, PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+#if 1
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+#endif
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s/ %d",
+		   "WlHiPri/ Locking/ Locked/ Noisy",
+		   (coex_sta->wifi_is_high_pri_task ? "Yes" : "No"),
+		   (coex_sta->cck_lock ? "Yes" : "No"),
+		   (coex_sta->cck_ever_lock ? "Yes" : "No"),
+		   coex_sta->wl_noisy_level);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d %s",
+		   "0x770(Hi-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx,
+		   (coex_sta->is_hiPri_rx_overhead ? "(scan overhead!!)" : ""));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d %s",
+		   "0x774(Lo-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx,
+		   (bt_link_info->slave_role ? "(Slave!!)" : (
+		   coex_sta->is_tdma_btautoslot_hang ? "(auto-slot hang!!)" : "")));
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8723d1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+
+		/* Write WL "Active" in Score-board for LPS off */
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+				BT_8723D_1ANT_SCOREBOARD_ACTIVE |
+				BT_8723D_1ANT_SCOREBOARD_ONOFF |
+				BT_8723D_1ANT_SCOREBOARD_SCAN |
+				BT_8723D_1ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+		halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_1ANT_PHASE_WLAN_OFF);
+
+		halbtc8723d1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+#if 0
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_ACTIVE, true);
+
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+				 BT_8723D_1ANT_SCOREBOARD_ONOFF, true);
+#endif
+
+		halbtc8723d1ant_init_hw_config(btcoexist, false, false);
+		halbtc8723d1ant_init_coex_dm(btcoexist);;
+
+		coex_sta->under_ips = false;
+	}
+}
+
+void ex_halbtc8723d1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+
+		if (coex_sta->force_lps_on == true) { /* LPS No-32K */
+			/* Write WL "Active" in Score-board for PS-TDMA */
+			halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_ACTIVE, true);
+
+		} else { /* LPS-32K, need check if this h2c 0x71 can work?? (2015/08/28) */
+			/* Write WL "Non-Active" in Score-board for Native-PS */
+			halbtc8723d1ant_post_state_to_bt(btcoexist,
+				 BT_8723D_1ANT_SCOREBOARD_ACTIVE, false);
+
+		}
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+
+		/* Write WL "Active" in Score-board for LPS off */
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_ACTIVE, true);
+
+	}
+}
+
+void ex_halbtc8723d1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	coex_sta->freeze_coexrun_by_btinfo = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	halbtc8723d1ant_query_bt_info(btcoexist);
+
+	if (BTC_SCAN_START == type) {
+
+		if (!wifi_connected)
+			coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					BT_8723D_1ANT_SCOREBOARD_ACTIVE |
+					BT_8723D_1ANT_SCOREBOARD_SCAN |
+					BT_8723D_1ANT_SCOREBOARD_ONOFF,
+					true);
+
+		/* Force antenna setup for no scan result issue */
+		halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_1ANT_PHASE_2G_RUNTIME);
+
+		halbtc8723d1ant_run_coexist_mechanism(btcoexist);
+
+	} else {
+
+		coex_sta->wifi_is_high_pri_task = false;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify  (Scan-AP = %d)\n",
+			    coex_sta->scan_ap_num);
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d1ant_run_coexist_mechanism(btcoexist);
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], SCAN Notify() end\n");
+	BTC_TRACE(trace_buf);
+
+}
+
+void ex_halbtc8723d1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	boolean	wifi_connected = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	if (BTC_ASSOCIATE_START == type) {
+
+		coex_sta->wifi_is_high_pri_task = true;
+
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_ACTIVE |
+					 BT_8723D_1ANT_SCOREBOARD_SCAN |
+					 BT_8723D_1ANT_SCOREBOARD_ONOFF,
+					 true);
+
+		/* Force antenna setup for no scan result issue */
+		halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_1ANT_PHASE_2G_RUNTIME);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+
+		coex_dm->arp_cnt = 0;
+
+		halbtc8723d1ant_run_coexist_mechanism(btcoexist);
+
+		/* To keep TDMA case during connect process,
+		to avoid changed by Btinfo and runcoexmechanism */
+		coex_sta->freeze_coexrun_by_btinfo = true;
+	} else {
+
+		coex_sta->wifi_is_high_pri_task = false;
+		coex_sta->freeze_coexrun_by_btinfo = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d1ant_run_coexist_mechanism(btcoexist);
+	}
+
+}
+
+void ex_halbtc8723d1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean			wifi_under_b_mode = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_ACTIVE |
+					 BT_8723D_1ANT_SCOREBOARD_ONOFF,
+					 true);
+
+		/* Force antenna setup for no scan result issue */
+		halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_1ANT_PHASE_2G_RUNTIME);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+			/* btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x10); */ /*CCK Tx */
+			/* btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x10); */ /*CCK Rx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+				 BT_8723D_1ANT_SCOREBOARD_ACTIVE, false);
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+
+		coex_sta->cck_ever_lock = false;
+	}
+
+	halbtc8723d1ant_update_wifi_channel_info(btcoexist, type);
+
+}
+
+void ex_halbtc8723d1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	under_4way = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (under_4way) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ---- under_4way!!\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+	} else if (BTC_PACKET_ARP == type) {
+
+		coex_dm->arp_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ARP notify -cnt = %d\n",
+			    coex_dm->arp_cnt);
+		BTC_TRACE(trace_buf);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet DHCP or EAPOL notify [Type = %d]\n",
+			    type);
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+	}
+
+	if (coex_sta->wifi_is_high_pri_task) {
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_SCAN, true);
+		halbtc8723d1ant_run_coexist_mechanism(btcoexist);
+	}
+}
+
+void ex_halbtc8723d1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8			i, rsp_source = 0;
+	boolean	wifi_connected = false;
+	boolean	wifi_scan = false, wifi_link = false, wifi_roam = false,
+		    wifi_busy = false;
+	static boolean is_scoreboard_scan = false;
+
+	if (psd_scan->is_AntDet_running == true) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], bt_info_notify return for AntDet is running\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8723D_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8723D_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt_info[%d], len=%d, data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	coex_sta->bt_info = coex_sta->bt_info_c2h[rsp_source][1];
+	coex_sta->bt_info_ext = coex_sta->bt_info_c2h[rsp_source][4];
+	coex_sta->bt_info_ext2 = coex_sta->bt_info_c2h[rsp_source][5];
+
+	if (BT_INFO_SRC_8723D_1ANT_WIFI_FW != rsp_source) {
+
+		/* if 0xff, it means BT is under WHCK test */
+		coex_sta->bt_whck_test = ((coex_sta->bt_info == 0xff) ? true :
+					  false);
+
+		coex_sta->bt_create_connection = ((
+			coex_sta->bt_info_c2h[rsp_source][2] & 0x80) ? true :
+						  false);
+
+		/* unit: %, value-100 to translate to unit: dBm */
+		coex_sta->bt_rssi = coex_sta->bt_info_c2h[rsp_source][3] * 2 +
+				    10;
+
+		coex_sta->c2h_bt_remote_name_req = ((
+			coex_sta->bt_info_c2h[rsp_source][2] & 0x20) ? true :
+						    false);
+
+		coex_sta->is_A2DP_3M = ((coex_sta->bt_info_c2h[rsp_source][2] &
+					 0x10) ? true : false);
+
+		coex_sta->acl_busy = ((coex_sta->bt_info_c2h[rsp_source][1] &
+				       0x9) ? true : false);
+
+		coex_sta->voice_over_HOGP = ((coex_sta->bt_info_ext & 0x10) ?
+					     true : false);
+
+		coex_sta->c2h_bt_inquiry_page = ((coex_sta->bt_info &
+			  BT_INFO_8723D_1ANT_B_INQ_PAGE) ? true : false);
+
+		coex_sta->a2dp_bit_pool = (((
+			coex_sta->bt_info_c2h[rsp_source][1] & 0x49) == 0x49) ?
+				   coex_sta->bt_info_c2h[rsp_source][6] : 0);
+
+		coex_sta->bt_retry_cnt = coex_sta->bt_info_c2h[rsp_source][2] &
+					 0xf;
+
+		coex_sta->is_autoslot = coex_sta->bt_info_ext2 & 0x8;
+
+		coex_sta->forbidden_slot = coex_sta->bt_info_ext2 & 0x7;
+
+		coex_sta->hid_busy_num = (coex_sta->bt_info_ext2 & 0x30) >> 4;
+
+		coex_sta->hid_pair_cnt = (coex_sta->bt_info_ext2 & 0xc0) >> 6;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->c2h_bt_remote_name_req)
+			coex_sta->cnt_RemoteNameReq++;
+
+		if (coex_sta->bt_info_ext & BIT(1))
+			coex_sta->cnt_ReInit++;
+
+		if (coex_sta->bt_info_ext & BIT(2)) {
+			coex_sta->cnt_setupLink++;
+			coex_sta->is_setupLink = true;
+		} else
+			coex_sta->is_setupLink = false;
+
+		if (coex_sta->bt_info_ext & BIT(3))
+			coex_sta->cnt_IgnWlanAct++;
+
+		if (coex_sta->bt_info_ext & BIT(6))
+			coex_sta->cnt_RoleSwitch++;
+
+		if (coex_sta->bt_create_connection) {
+			coex_sta->cnt_Page++;
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY,
+					   &wifi_busy);
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &wifi_link);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &wifi_roam);
+
+			if ((wifi_link) || (wifi_roam) || (wifi_scan) ||
+			    (coex_sta->wifi_is_high_pri_task) || (wifi_busy)) {
+
+				is_scoreboard_scan = true;
+				halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_SCAN, true);
+
+			} else
+				halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_SCAN, false);
+
+		} else {
+				if (is_scoreboard_scan) {
+					halbtc8723d1ant_post_state_to_bt(btcoexist,
+						 BT_8723D_1ANT_SCOREBOARD_SCAN, false);
+					is_scoreboard_scan = false;
+				}
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+
+		if ((!btcoexist->manual_control) &&
+		    (!btcoexist->stop_coex_dm)) {
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+
+			/*	Re-Init */
+			if ((coex_sta->bt_info_ext & BIT(1))) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+				BTC_TRACE(trace_buf);
+				if (wifi_connected)
+					halbtc8723d1ant_update_wifi_channel_info(
+						btcoexist, BTC_MEDIA_CONNECT);
+				else
+					halbtc8723d1ant_update_wifi_channel_info(
+						btcoexist,
+						BTC_MEDIA_DISCONNECT);
+			}
+
+
+	  /*	If Ignore_WLanAct && not SetUp_Link or Role_Switch */
+			if ((coex_sta->bt_info_ext & BIT(3)) &&
+				(!(coex_sta->bt_info_ext & BIT(2))) &&
+				(!(coex_sta->bt_info_ext & BIT(6)))) {
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8723d1ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			} else {
+				if (coex_sta->bt_info_ext & BIT(2)) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ignore Wlan active because Re-link!!\n");
+					BTC_TRACE(trace_buf);
+				} else if (coex_sta->bt_info_ext & BIT(6)) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ignore Wlan active because Role-Switch!!\n");
+					BTC_TRACE(trace_buf);
+				}
+			}
+		}
+
+	}
+
+	if ((coex_sta->bt_info_ext & BIT(5))) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit4 check, query BLE Scan type!!\n");
+				BTC_TRACE(trace_buf);
+	coex_sta->bt_ble_scan_type = btcoexist->btc_get_ble_scan_type_from_bt(btcoexist);
+
+	if ((coex_sta->bt_ble_scan_type & 0x1) == 0x1)
+		coex_sta->bt_ble_scan_para[0]  = btcoexist->btc_get_ble_scan_para_from_bt(btcoexist, 0x1);
+	if ((coex_sta->bt_ble_scan_type & 0x2) == 0x2)
+		coex_sta->bt_ble_scan_para[1]  = btcoexist->btc_get_ble_scan_para_from_bt(btcoexist, 0x2);
+	if ((coex_sta->bt_ble_scan_type & 0x4) == 0x4)
+		coex_sta->bt_ble_scan_para[2]  = btcoexist->btc_get_ble_scan_para_from_bt(btcoexist, 0x4);
+	}
+
+	halbtc8723d1ant_update_bt_link_info(btcoexist);
+
+	halbtc8723d1ant_run_coexist_mechanism(btcoexist);
+}
+
+
+
+void ex_halbtc8723d1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->stop_coex_dm = false;
+#if 0
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_ONOFF, true);
+#endif
+
+	} else if (BTC_RF_OFF == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+				BT_8723D_1ANT_SCOREBOARD_ACTIVE |
+				BT_8723D_1ANT_SCOREBOARD_ONOFF |
+				BT_8723D_1ANT_SCOREBOARD_SCAN |
+				BT_8723D_1ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		halbtc8723d1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+
+		halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_1ANT_PHASE_WLAN_OFF);
+
+		btcoexist->stop_coex_dm = true;
+	}
+}
+
+void ex_halbtc8723d1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8723d1ant_post_state_to_bt(btcoexist,
+				BT_8723D_1ANT_SCOREBOARD_ACTIVE |
+				BT_8723D_1ANT_SCOREBOARD_ONOFF |
+				BT_8723D_1ANT_SCOREBOARD_SCAN |
+				BT_8723D_1ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+	halbtc8723d1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+
+	halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+				     BT_8723D_1ANT_PHASE_WLAN_OFF);
+
+	halbtc8723d1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8723d1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	btcoexist->stop_coex_dm = true;
+}
+
+void ex_halbtc8723d1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if ((BTC_WIFI_PNP_SLEEP == pnp_state) ||
+	    (BTC_WIFI_PNP_SLEEP_KEEP_ANT == pnp_state)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+				BT_8723D_1ANT_SCOREBOARD_ACTIVE |
+				BT_8723D_1ANT_SCOREBOARD_ONOFF |
+				BT_8723D_1ANT_SCOREBOARD_SCAN |
+				BT_8723D_1ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		if (BTC_WIFI_PNP_SLEEP_KEEP_ANT == pnp_state) {
+
+			halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+						     FORCE_EXEC,
+					     BT_8723D_1ANT_PHASE_2G_RUNTIME);
+		} else {
+
+			halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+						     FORCE_EXEC,
+					     BT_8723D_1ANT_PHASE_WLAN_OFF);
+		}
+
+		btcoexist->stop_coex_dm = true;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+#if 0
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_ONOFF, true);
+#endif
+		btcoexist->stop_coex_dm = false;
+	}
+}
+
+
+void ex_halbtc8723d1ant_coex_dm_reset(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], *****************Coex DM Reset*****************\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8723d1ant_init_hw_config(btcoexist, false, false);
+	halbtc8723d1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8723d1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	boolean wifi_busy = false;
+	u4Byte	value = 0;
+	u32	bt_patch_ver;
+	static u8 cnt = 0;
+	boolean bt_relink_finish = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ************* Periodical *************\n");
+	BTC_TRACE(trace_buf);
+
+#if (BT_AUTO_REPORT_ONLY_8723D_1ANT == 0)
+	halbtc8723d1ant_query_bt_info(btcoexist);
+
+#endif
+
+	halbtc8723d1ant_monitor_bt_ctr(btcoexist);
+	halbtc8723d1ant_monitor_wifi_ctr(btcoexist);
+
+	halbtc8723d1ant_monitor_bt_enable_disable(btcoexist);
+
+#if 0
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	/* halbtc8723d1ant_read_score_board(btcoexist, &bt_scoreboard_val); */
+
+	if (wifi_busy) {
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+				BT_8723D_1ANT_SCOREBOARD_UNDERTEST, true);
+		/*
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					 BT_8723D_1ANT_SCOREBOARD_WLBUSY, true);
+
+		if (bt_scoreboard_val & BIT(6))
+			halbtc8723d1ant_query_bt_info(btcoexist); */
+	} else {
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					BT_8723D_1ANT_SCOREBOARD_UNDERTEST, false);
+		/*
+		halbtc8723d1ant_post_state_to_bt(btcoexist,
+					BT_8723D_1ANT_SCOREBOARD_WLBUSY,
+					false);  */
+	}
+#endif
+
+	if (coex_sta->bt_relink_downcount != 0) {
+		coex_sta->bt_relink_downcount--;
+
+		if (coex_sta->bt_relink_downcount == 0)
+			bt_relink_finish = true;
+	}
+
+	/* for 4-way, DHCP, EAPOL packet */
+	if (coex_sta->specific_pkt_period_cnt > 0) {
+
+		coex_sta->specific_pkt_period_cnt--;
+
+		if ((coex_sta->specific_pkt_period_cnt == 0) &&
+		    (coex_sta->wifi_is_high_pri_task))
+			coex_sta->wifi_is_high_pri_task = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ***************** Hi-Pri Task = %s*****************\n",
+			    (coex_sta->wifi_is_high_pri_task ? "Yes" :
+			     "No"));
+		BTC_TRACE(trace_buf);
+
+	}
+
+	if (!coex_sta->bt_disabled) {
+		if (coex_sta->bt_coex_supported_feature == 0)
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_FEATURE,
+						&coex_sta->bt_coex_supported_feature);
+
+		if ((coex_sta->bt_coex_supported_version == 0) ||
+			 (coex_sta->bt_coex_supported_version == 0xffff))
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION,
+						&coex_sta->bt_coex_supported_version);
+
+		if (coex_sta->bt_reg_vendor_ac == 0xffff)
+			coex_sta->bt_reg_vendor_ac = (u16)(
+						btcoexist->btc_get_bt_reg(btcoexist, 3,
+						0xac) & 0xffff);
+
+		if (coex_sta->bt_reg_vendor_ae == 0xffff)
+			coex_sta->bt_reg_vendor_ae = (u16)(
+						btcoexist->btc_get_bt_reg(btcoexist, 3,
+						0xae) & 0xffff);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER,
+						&bt_patch_ver);
+		btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+
+		if (coex_sta->num_of_profile > 0) {
+			cnt++;
+
+			if (cnt >= 3) {
+				btcoexist->btc_get_bt_afh_map_from_bt(btcoexist, 0,
+					&coex_sta->bt_afh_map[0]);
+				cnt = 0;
+			}
+		}
+
+#if BT_8723D_1ANT_ANTDET_ENABLE
+
+		if (board_info->btdm_ant_det_finish) {
+			if ((psd_scan->ant_det_result == 12) &&
+			    (psd_scan->ant_det_psd_scan_peak_val == 0)
+			    && (!psd_scan->is_AntDet_running)) {
+				psd_scan->ant_det_psd_scan_peak_val =
+					btcoexist->btc_get_ant_det_val_from_bt(
+					btcoexist) * 100;
+
+				board_info->antdetval = psd_scan->ant_det_psd_scan_peak_val/100;
+				value = board_info->antdetval;
+
+#ifdef PLATFORM_WINDOWS
+				{
+					PWCHAR	registryName;
+
+					registryName = L"antdetval";
+					PlatformWriteCommonDwordRegistry(registryName, &value);
+				}
+#endif
+			}
+		}
+
+#endif
+	}
+
+	if (halbtc8723d1ant_is_wifibt_status_changed(btcoexist))
+		halbtc8723d1ant_run_coexist_mechanism(btcoexist);
+
+
+}
+
+void ex_halbtc8723d1ant_set_antenna_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (type == 2) { /* two antenna */
+		board_info->ant_div_cfg = true;
+		halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_WIFI,
+					     FORCE_EXEC,
+					     BT_8723D_1ANT_PHASE_2G_RUNTIME);
+	} else { /* one antenna */
+		halbtc8723d1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_1ANT_PHASE_2G_RUNTIME);
+	}
+}
+
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+void ex_halbtc8723d1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+	static u32 ant_det_count = 0, ant_det_fail_count = 0;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u16		u16tmp;
+	u8			AntDetval = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx Ext Call AntennaDetect()!!\n");
+	BTC_TRACE(trace_buf);
+
+#if BT_8723D_1ANT_ANTDET_ENABLE
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx Call AntennaDetect()!!\n");
+	BTC_TRACE(trace_buf);
+
+	if (seconds == 0) {
+		psd_scan->ant_det_try_count	= 0;
+		psd_scan->ant_det_fail_count	= 0;
+		ant_det_count = 0;
+		ant_det_fail_count = 0;
+		board_info->btdm_ant_det_finish = false;
+		board_info->btdm_ant_num_by_ant_det = 1;
+		return;
+	}
+
+	if (!board_info->btdm_ant_det_finish) {
+		psd_scan->ant_det_inteval_count =
+			psd_scan->ant_det_inteval_count + 2;
+
+		if (psd_scan->ant_det_inteval_count >=
+		    BT_8723D_2ANT_ANTDET_RETRY_INTERVAL) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Timer is up, Try Detect!!\n");
+			BTC_TRACE(trace_buf);
+
+			psd_scan->is_AntDet_running = true;
+
+			halbtc8723d1ant_read_score_board(btcoexist,	&u16tmp);
+
+			if (u16tmp & BIT(
+				2)) { /* Antenna detection is already done before last WL power on   */
+				board_info->btdm_ant_det_finish = true;
+				psd_scan->ant_det_try_count = 1;
+				psd_scan->ant_det_fail_count = 0;
+				board_info->btdm_ant_num_by_ant_det = (u16tmp &
+							       BIT(3)) ? 1 : 2;
+				psd_scan->ant_det_result = 12;
+
+				psd_scan->ant_det_psd_scan_peak_val =
+					btcoexist->btc_get_ant_det_val_from_bt(
+						btcoexist) * 100;
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Result from BT (%d-Ant)\n",
+					board_info->btdm_ant_num_by_ant_det);
+				BTC_TRACE(trace_buf);
+			} else
+				board_info->btdm_ant_det_finish =
+					halbtc8723d1ant_psd_antenna_detection_check(
+						btcoexist);
+
+			board_info->ant_det_result = psd_scan->ant_det_result;
+			btcoexist->bdontenterLPS = false;
+
+			if (board_info->btdm_ant_det_finish) {
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Success!!\n");
+				BTC_TRACE(trace_buf);
+
+				if (board_info->btdm_ant_num_by_ant_det == 2) {
+					board_info->ant_div_cfg = true;
+					halbtc8723d1ant_set_ant_path(btcoexist,
+						BTC_ANT_PATH_WIFI, FORCE_EXEC,
+						BT_8723D_1ANT_PHASE_2G_RUNTIME);
+				} else
+					halbtc8723d1ant_set_ant_path(btcoexist,
+						BTC_ANT_PATH_AUTO, FORCE_EXEC,
+						BT_8723D_1ANT_PHASE_2G_RUNTIME);
+
+				/*for 8723d, btc_set_bt_trx_mask is just used to
+					notify BT stop le tx and Ant Det Result , not set BT RF TRx Mask  */
+				if (psd_scan->ant_det_result != 12) {
+
+					AntDetval = (u8)(
+						psd_scan->ant_det_psd_scan_peak_val
+							    / 100) & 0x7f;
+
+					AntDetval =
+						(board_info->btdm_ant_num_by_ant_det
+						 == 1) ? (AntDetval | 0x80) :
+						AntDetval;
+					board_info->antdetval = AntDetval;
+
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"xxxxxx AntennaDetect(), Ant Count = %d, PSD Val = %d\n",
+						    ((AntDetval &
+						      0x80) ? 1
+						     : 2), AntDetval
+						    & 0x7f);
+					BTC_TRACE(trace_buf);
+
+					if (btcoexist->btc_set_bt_trx_mask(
+						    btcoexist, AntDetval))
+						BTC_SPRINTF(trace_buf,
+							    BT_TMP_BUF_SIZE,
+							"xxxxxx AntennaDetect(), Notify BT stop le tx by set_bt_trx_mask ok!\n");
+					else
+						BTC_SPRINTF(trace_buf,
+							    BT_TMP_BUF_SIZE,
+							"xxxxxx AntennaDetect(), Notify BT stop le tx by set_bt_trx_mask fail!\n");
+
+					BTC_TRACE(trace_buf);
+				} else
+					board_info->antdetval =
+						psd_scan->ant_det_psd_scan_peak_val/100;
+
+				board_info->btdm_ant_det_complete_fail = false;
+
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Fail!!\n");
+				BTC_TRACE(trace_buf);
+
+				board_info->btdm_ant_det_complete_fail = true;
+			}
+
+			psd_scan->ant_det_inteval_count = 0;
+			psd_scan->is_AntDet_running = false;
+			/* stimulate coex running */
+			halbtc8723d1ant_run_coexist_mechanism(
+				btcoexist);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Stimulate Coex running\n!!");
+			BTC_TRACE(trace_buf);
+
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Timer is not up! (%d)\n",
+				    psd_scan->ant_det_inteval_count);
+			BTC_TRACE(trace_buf);
+
+			if (psd_scan->ant_det_inteval_count == 8)
+				btcoexist->bdontenterLPS = true;
+			else
+				btcoexist->bdontenterLPS = false;
+		}
+
+	}
+#endif
+
+
+}
+
+
+void ex_halbtc8723d1ant_display_ant_detection(IN struct btc_coexist *btcoexist)
+{
+#if BT_8723D_1ANT_ANTDET_ENABLE
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	if (psd_scan->ant_det_try_count != 0)	{
+		halbtc8723d1ant_psd_show_antenna_detect_result(btcoexist);
+
+		if (board_info->btdm_ant_det_finish)
+			halbtc8723d1ant_psd_showdata(btcoexist);
+	}
+#endif
+
+}
+
+void ex_halbtc8723d1ant_antenna_isolation(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+
+}
+
+void ex_halbtc8723d1ant_psd_scan(IN struct btc_coexist *btcoexist,
+		 IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+
+}
+
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8723d1ant.h
@@ -0,0 +1,413 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8723D_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8723D 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_8723D_1ANT_COEX_DBG					0
+#define	BT_AUTO_REPORT_ONLY_8723D_1ANT				1
+
+#define	BT_INFO_8723D_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8723D_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8723D_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8723D_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8723D_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8723D_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8723D_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8723D_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8723D_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+	(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8723D_1ANT		2
+
+#define  BT_8723D_1ANT_WIFI_NOISY_THRESH							30   /* max: 255 */
+#define  BT_8723D_1ANT_DEFAULT_ISOLATION						15	 /*  unit: dB */
+
+
+/* for Antenna detection */
+#define	BT_8723D_1ANT_ANTDET_PSDTHRES_BACKGROUND					50
+#define	BT_8723D_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION				70
+#define	BT_8723D_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION			55
+#define	BT_8723D_1ANT_ANTDET_PSDTHRES_1ANT							35
+#define	BT_8723D_1ANT_ANTDET_RETRY_INTERVAL							10	/* retry timer if ant det is fail, unit: second */
+#define	BT_8723D_1ANT_ANTDET_SWEEPPOINT_DELAY							60000
+#define	BT_8723D_1ANT_ANTDET_ENABLE									1
+#define	BT_8723D_1ANT_ANTDET_BTTXTIME									100
+#define	BT_8723D_1ANT_ANTDET_BTTXCHANNEL								39
+#define	BT_8723D_1ANT_ANTDET_PSD_SWWEEPCOUNT						50
+
+#define	BT_8723D_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT		30000
+
+enum bt_8723d_1ant_signal_state {
+	BT_8723D_1ANT_SIG_STA_SET_TO_LOW		= 0x0,
+	BT_8723D_1ANT_SIG_STA_SET_BY_HW		= 0x0,
+	BT_8723D_1ANT_SIG_STA_SET_TO_HIGH		= 0x1,
+	BT_8723D_1ANT_SIG_STA_MAX
+};
+
+enum bt_8723d_1ant_path_ctrl_owner {
+	BT_8723D_1ANT_PCO_BTSIDE		= 0x0,
+	BT_8723D_1ANT_PCO_WLSIDE	= 0x1,
+	BT_8723D_1ANT_PCO_MAX
+};
+
+enum bt_8723d_1ant_gnt_ctrl_type {
+	BT_8723D_1ANT_GNT_TYPE_CTRL_BY_PTA		= 0x0,
+	BT_8723D_1ANT_GNT_TYPE_CTRL_BY_SW		= 0x1,
+	BT_8723D_1ANT_GNT_TYPE_MAX
+};
+
+enum bt_8723d_1ant_gnt_ctrl_block {
+	BT_8723D_1ANT_GNT_BLOCK_RFC_BB		= 0x0,
+	BT_8723D_1ANT_GNT_BLOCK_RFC			= 0x1,
+	BT_8723D_1ANT_GNT_BLOCK_BB			= 0x2,
+	BT_8723D_1ANT_GNT_BLOCK_MAX
+};
+
+enum bt_8723d_1ant_lte_coex_table_type {
+	BT_8723D_1ANT_CTT_WL_VS_LTE			= 0x0,
+	BT_8723D_1ANT_CTT_BT_VS_LTE			= 0x1,
+	BT_8723D_1ANT_CTT_MAX
+};
+
+enum bt_8723d_1ant_lte_break_table_type {
+	BT_8723D_1ANT_LBTT_WL_BREAK_LTE			= 0x0,
+	BT_8723D_1ANT_LBTT_BT_BREAK_LTE				= 0x1,
+	BT_8723D_1ANT_LBTT_LTE_BREAK_WL			= 0x2,
+	BT_8723D_1ANT_LBTT_LTE_BREAK_BT				= 0x3,
+	BT_8723D_1ANT_LBTT_MAX
+};
+
+enum bt_info_src_8723d_1ant {
+	BT_INFO_SRC_8723D_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8723D_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8723D_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8723D_1ANT_MAX
+};
+
+enum bt_8723d_1ant_bt_status {
+	BT_8723D_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8723D_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8723D_1ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8723D_1ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8723D_1ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8723D_1ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8723D_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8723d_1ant_wifi_status {
+	BT_8723D_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8723D_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8723D_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8723D_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT				= 0x3,
+	BT_8723D_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8723D_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8723D_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8723d_1ant_coex_algo {
+	BT_8723D_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8723D_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8723D_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8723D_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8723D_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8723D_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8723D_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8723D_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8723D_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8723D_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8723D_1ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8723D_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+enum bt_8723d_1ant_phase {
+	BT_8723D_1ANT_PHASE_COEX_INIT								= 0x0,
+	BT_8723D_1ANT_PHASE_WLANONLY_INIT							= 0x1,
+	BT_8723D_1ANT_PHASE_WLAN_OFF								= 0x2,
+	BT_8723D_1ANT_PHASE_2G_RUNTIME								= 0x3,
+	BT_8723D_1ANT_PHASE_5G_RUNTIME								= 0x4,
+	BT_8723D_1ANT_PHASE_BTMPMODE								= 0x5,
+	BT_8723D_1ANT_PHASE_ANTENNA_DET								= 0x6,
+	BT_8723D_1ANT_PHASE_COEX_POWERON							= 0x7,
+	BT_8723D_1ANT_PHASE_MAX
+};
+
+enum bt_8723d_1ant_Scoreboard {
+	BT_8723D_1ANT_SCOREBOARD_ACTIVE								= BIT(0),
+	BT_8723D_1ANT_SCOREBOARD_ONOFF								= BIT(1),
+	BT_8723D_1ANT_SCOREBOARD_SCAN								= BIT(2),
+	BT_8723D_1ANT_SCOREBOARD_UNDERTEST							= BIT(3),
+	BT_8723D_1ANT_SCOREBOARD_WLBUSY								= BIT(6)
+};
+
+struct coex_dm_8723d_1ant {
+	/* hw setting */
+	u8		pre_ant_pos_type;
+	u8		cur_ant_pos_type;
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8723d_1ant {
+	boolean				bt_disabled;
+	boolean				bt_link_exist;
+	boolean				sco_exist;
+	boolean				a2dp_exist;
+	boolean				hid_exist;
+	boolean				pan_exist;
+	boolean				bt_hi_pri_link_exist;
+	u8					num_of_profile;
+
+	boolean				under_lps;
+	boolean				under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	boolean             is_hiPri_rx_overhead;
+	s8					bt_rssi;
+	boolean				bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	u8					bt_info_c2h[BT_INFO_SRC_8723D_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8723D_1ANT_MAX];
+	boolean				bt_whck_test;
+	boolean				c2h_bt_inquiry_page;
+	boolean				c2h_bt_remote_name_req;
+	boolean				c2h_bt_page;				/* Add for win8.1 page out issue */
+	boolean				wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u8					bt_info_ext2;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_vht;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_vht;
+
+	boolean				cck_lock;
+	boolean				pre_ccklock;
+	boolean				cck_ever_lock;
+	u8					coex_table_type;
+
+	boolean				force_lps_on;
+
+	boolean				concurrent_rx_mode_on;
+
+	u16					score_board;
+	u8					isolation_btween_wb;   /* 0~ 50 */
+
+	u8					a2dp_bit_pool;
+	u8					cut_version;
+	boolean				acl_busy;
+	boolean				bt_create_connection;
+
+	u32					bt_coex_supported_feature;
+	u32					bt_coex_supported_version;
+
+	u8					bt_ble_scan_type;
+	u32					bt_ble_scan_para[3];
+
+	boolean				run_time_state;
+	boolean				freeze_coexrun_by_btinfo;
+
+	boolean				is_A2DP_3M;
+	boolean				voice_over_HOGP;
+	u8                  bt_info;
+	boolean				is_autoslot;
+	u8					forbidden_slot;
+	u8					hid_busy_num;
+	u8					hid_pair_cnt;
+
+	u32					cnt_RemoteNameReq;
+	u32					cnt_setupLink;
+	u32					cnt_ReInit;
+	u32					cnt_IgnWlanAct;
+	u32					cnt_Page;
+	u32					cnt_RoleSwitch;
+
+	u16					bt_reg_vendor_ac;
+	u16					bt_reg_vendor_ae;
+
+	boolean				is_setupLink;
+	u8					wl_noisy_level;
+	u32                 gnt_error_cnt;
+
+	u8					bt_afh_map[10];
+	u8					bt_relink_downcount;
+	boolean				is_tdma_btautoslot;
+	boolean				is_tdma_btautoslot_hang;
+};
+
+#define  BT_8723D_1ANT_ANTDET_PSD_POINTS			256	/* MAX:1024 */
+#define  BT_8723D_1ANT_ANTDET_PSD_AVGNUM			1	/* MAX:3 */
+#define	BT_8723D_1ANT_ANTDET_BUF_LEN				16
+
+struct psdscan_sta_8723d_1ant {
+
+	u32			ant_det_bt_le_channel;  /* BT LE Channel ex:2412 */
+	u32			ant_det_bt_tx_time;
+	u32			ant_det_pre_psdscan_peak_val;
+	boolean			ant_det_is_ant_det_available;
+	u32			ant_det_psd_scan_peak_val;
+	boolean			ant_det_is_btreply_available;
+	u32			ant_det_psd_scan_peak_freq;
+
+	u8			ant_det_result;
+	u8			ant_det_peak_val[BT_8723D_1ANT_ANTDET_BUF_LEN];
+	u8			ant_det_peak_freq[BT_8723D_1ANT_ANTDET_BUF_LEN];
+	u32			ant_det_try_count;
+	u32			ant_det_fail_count;
+	u32			ant_det_inteval_count;
+	u32			ant_det_thres_offset;
+
+	u32			real_cent_freq;
+	s32			real_offset;
+	u32			real_span;
+
+	u32			psd_band_width;  /* unit: Hz */
+	u32			psd_point;		/* 128/256/512/1024 */
+	u32			psd_report[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_report_max_hold[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_start_point;
+	u32			psd_stop_point;
+	u32			psd_max_value_point;
+	u32			psd_max_value;
+	u32			psd_max_value2;
+	u32			psd_avg_value;   /* filter loop_max_value that below BT_8723D_1ANT_ANTDET_PSDTHRES_1ANT, and average the rest*/
+	u32			psd_loop_max_value[BT_8723D_1ANT_ANTDET_PSD_SWWEEPCOUNT];  /*max value in each loop */
+	u32			psd_start_base;
+	u32			psd_avg_num;	/* 1/8/16/32 */
+	u32			psd_gen_count;
+	boolean			is_AntDet_running;
+	boolean			is_psd_show_max_only;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8723d1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723d1ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723d1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8723d1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723d1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8723d1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8723d1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8723d1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8723d1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723d1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723d1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8723d1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723d1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723d1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8723d1ant_coex_dm_reset(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723d1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723d1ant_set_antenna_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723d1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723d1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+void ex_halbtc8723d1ant_antenna_isolation(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+
+void ex_halbtc8723d1ant_psd_scan(IN struct btc_coexist *btcoexist,
+		 IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+void ex_halbtc8723d1ant_display_ant_detection(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8723d1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8723d1ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8723d1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8723d1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8723d1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8723d1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8723d1ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8723d1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8723d1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8723d1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8723d1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8723d1ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8723d1ant_halt_notify(btcoexist)
+#define	ex_halbtc8723d1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8723d1ant_coex_dm_reset(btcoexist)
+#define	ex_halbtc8723d1ant_periodical(btcoexist)
+#define	ex_halbtc8723d1ant_display_coex_info(btcoexist)
+#define	ex_halbtc8723d1ant_set_antenna_notify(btcoexist, type)
+#define	ex_halbtc8723d1ant_antenna_detection(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8723d1ant_antenna_isolation(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8723d1ant_psd_scan(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8723d1ant_display_ant_detection(btcoexist)
+#endif
+
+#endif
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8723d2ant.c
@@ -0,0 +1,6821 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8723D Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8723D_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	*trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8723d_2ant		glcoex_dm_8723d_2ant;
+static struct  coex_dm_8723d_2ant	*coex_dm = &glcoex_dm_8723d_2ant;
+static struct  coex_sta_8723d_2ant		glcoex_sta_8723d_2ant;
+static struct  coex_sta_8723d_2ant	*coex_sta = &glcoex_sta_8723d_2ant;
+static struct  psdscan_sta_8723d_2ant	gl_psd_scan_8723d_2ant;
+static struct  psdscan_sta_8723d_2ant *psd_scan = &gl_psd_scan_8723d_2ant;
+
+const char *const glbt_info_src_8723d_2ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+/* ************************************************************
+ * BtCoex Version Format:
+ * 1. date :			glcoex_ver_date_XXXXX_1ant
+ * 2. WifiCoexVersion : glcoex_ver_XXXX_1ant
+ * 3. BtCoexVersion :	glcoex_ver_btdesired_XXXXX_1ant
+ * 4. others :			glcoex_ver_XXXXXX_XXXXX_1ant
+ *
+ * Variable should be indicated IC and Antenna numbers !!!
+ * Please strictly follow this order and naming style !!!
+ *
+ * ************************************************************ */
+u32	glcoex_ver_date_8723d_2ant = 20161123;
+u32	glcoex_ver_8723d_2ant = 0x11;
+u32 glcoex_ver_btdesired_8723d_2ant = 0x10;
+
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8723d2ant_
+ * ************************************************************ */
+u8 halbtc8723d2ant_bt_rssi_state(u8 *ppre_bt_rssi_state, u8 level_num,
+				 u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = *ppre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8723D_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return *ppre_bt_rssi_state;
+		}
+
+		if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8723D_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+			(*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8723D_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	*ppre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8723d2ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 *pprewifi_rssi_state, IN u8 level_num, IN u8 rssi_thresh,
+				   IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = *pprewifi_rssi_state;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((*pprewifi_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8723D_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return *pprewifi_rssi_state;
+		}
+
+		if ((*pprewifi_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8723D_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((*pprewifi_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+			(*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8723D_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	*pprewifi_rssi_state = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8723d2ant_coex_switch_threshold(IN struct btc_coexist *btcoexist,
+		IN u8 isolation_measuared)
+{
+	s8	interference_wl_tx = 0, interference_bt_tx = 0;
+
+
+	interference_wl_tx = BT_8723D_2ANT_WIFI_MAX_TX_POWER -
+			     isolation_measuared;
+	interference_bt_tx = BT_8723D_2ANT_BT_MAX_TX_POWER -
+			     isolation_measuared;
+
+
+
+	coex_sta->wifi_coex_thres		 = BT_8723D_2ANT_WIFI_RSSI_COEXSWITCH_THRES1;
+	coex_sta->wifi_coex_thres2	 = BT_8723D_2ANT_WIFI_RSSI_COEXSWITCH_THRES2;
+
+	coex_sta->bt_coex_thres		 = BT_8723D_2ANT_BT_RSSI_COEXSWITCH_THRES1;
+	coex_sta->bt_coex_thres2		 = BT_8723D_2ANT_BT_RSSI_COEXSWITCH_THRES2;
+
+
+	/*
+		coex_sta->wifi_coex_thres		= interference_wl_tx + BT_8723D_2ANT_WIFI_SIR_THRES1;
+		coex_sta->wifi_coex_thres2		= interference_wl_tx + BT_8723D_2ANT_WIFI_SIR_THRES2;
+
+		coex_sta->bt_coex_thres		= interference_bt_tx + BT_8723D_2ANT_BT_SIR_THRES1;
+		coex_sta->bt_coex_thres2		= interference_bt_tx + BT_8723D_2ANT_BT_SIR_THRES2;
+	*/
+
+
+
+
+
+	/*
+		if  ( BT_8723D_2ANT_WIFI_RSSI_COEXSWITCH_THRES1 < (isolation_measuared -
+					BT_8723D_2ANT_DEFAULT_ISOLATION) )
+			coex_sta->wifi_coex_thres	 = BT_8723D_2ANT_WIFI_RSSI_COEXSWITCH_THRES1;
+		else
+			coex_sta->wifi_coex_thres =  BT_8723D_2ANT_WIFI_RSSI_COEXSWITCH_THRES1 -  (isolation_measuared -
+					BT_8723D_2ANT_DEFAULT_ISOLATION);
+
+		if  ( BT_8723D_2ANT_BT_RSSI_COEXSWITCH_THRES1 < (isolation_measuared -
+					BT_8723D_2ANT_DEFAULT_ISOLATION) )
+			coex_sta->bt_coex_thres	 = BT_8723D_2ANT_BT_RSSI_COEXSWITCH_THRES1;
+		else
+			coex_sta->bt_coex_thres =  BT_8723D_2ANT_BT_RSSI_COEXSWITCH_THRES1 -  (isolation_measuared -
+					BT_8723D_2ANT_DEFAULT_ISOLATION);
+
+	*/
+}
+
+
+void halbtc8723d2ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+}
+
+void halbtc8723d2ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+void halbtc8723d2ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u8		num_of_bt_counter_chk = 0, cnt_slave = 0, cnt_overhead = 0,
+				cnt_autoslot_hang = 0;
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if (BT_8723D_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		coex_dm->bt_status) {
+
+			if (coex_sta->high_priority_rx >= 15) {
+					if (cnt_overhead < 3)
+						cnt_overhead++;
+
+					if (cnt_overhead == 3)
+						coex_sta->is_hiPri_rx_overhead = true;
+			 } else {
+					if (cnt_overhead > 0)
+						cnt_overhead--;
+
+					if (cnt_overhead == 0)
+						coex_sta->is_hiPri_rx_overhead = false;
+			}
+	}
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	if ((coex_sta->low_priority_tx > 1050)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	if ((coex_sta->low_priority_rx >= 950) &&
+	    (coex_sta->low_priority_rx >= coex_sta->low_priority_tx)
+	    && (!coex_sta->under_ips)  && (!coex_sta->c2h_bt_inquiry_page) &&
+	    (coex_sta->bt_link_exist))	{
+		if (cnt_slave >= 2) {
+			bt_link_info->slave_role = true;
+			cnt_slave = 2;
+		} else
+			cnt_slave++;
+	} else {
+		if (cnt_slave == 0)	{
+			bt_link_info->slave_role = false;
+			cnt_slave = 0;
+		} else
+			cnt_slave--;
+
+	}
+
+	if (coex_sta->is_tdma_btautoslot) {
+		if ((coex_sta->low_priority_tx >= 1300) &&
+			(coex_sta->low_priority_rx <= 150)) {
+			if (cnt_autoslot_hang >= 2) {
+				coex_sta->is_tdma_btautoslot_hang = true;
+				cnt_autoslot_hang = 2;
+			} else
+				cnt_autoslot_hang++;
+		} else {
+			if (cnt_autoslot_hang == 0)	{
+				coex_sta->is_tdma_btautoslot_hang = false;
+				cnt_autoslot_hang = 0;
+			} else
+				cnt_autoslot_hang--;
+		}
+	}
+
+	if (!coex_sta->bt_disabled) {
+
+		if ((coex_sta->high_priority_tx == 0) &&
+		    (coex_sta->high_priority_rx == 0) &&
+		    (coex_sta->low_priority_tx == 0) &&
+		    (coex_sta->low_priority_rx == 0)) {
+			num_of_bt_counter_chk++;
+			if (num_of_bt_counter_chk >= 3) {
+				halbtc8723d2ant_query_bt_info(btcoexist);
+				num_of_bt_counter_chk = 0;
+			}
+		}
+	}
+
+}
+
+void halbtc8723d2ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+#if 1
+		s32 wifi_rssi = 0;
+		boolean wifi_busy = false, wifi_under_b_mode = false,
+				wifi_scan = false;
+		boolean bt_idle = false, wl_idle = false;
+		static u8 cck_lock_counter = 0, wl_noisy_count0 = 0,
+				wl_noisy_count1 = 3, wl_noisy_count2 = 0;
+		u32 total_cnt, reg_val1, reg_val2, cck_cnt;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+		btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		coex_sta->crc_ok_cck = btcoexist->btc_phydm_query_PHY_counter(
+								btcoexist, PHYDM_INFO_CRC32_OK_CCK);
+		coex_sta->crc_ok_11g = btcoexist->btc_phydm_query_PHY_counter(
+								btcoexist, PHYDM_INFO_CRC32_OK_LEGACY);
+		coex_sta->crc_ok_11n = btcoexist->btc_phydm_query_PHY_counter(
+								btcoexist, PHYDM_INFO_CRC32_OK_HT);
+		coex_sta->crc_ok_11n_vht = btcoexist->btc_phydm_query_PHY_counter(
+								btcoexist, PHYDM_INFO_CRC32_OK_VHT);
+
+		coex_sta->crc_err_cck = btcoexist->btc_phydm_query_PHY_counter(
+								btcoexist, PHYDM_INFO_CRC32_ERROR_CCK);
+		coex_sta->crc_err_11g =  btcoexist->btc_phydm_query_PHY_counter(
+								btcoexist, PHYDM_INFO_CRC32_ERROR_LEGACY);
+		coex_sta->crc_err_11n = btcoexist->btc_phydm_query_PHY_counter(
+								btcoexist, PHYDM_INFO_CRC32_ERROR_HT);
+		coex_sta->crc_err_11n_vht = btcoexist->btc_phydm_query_PHY_counter(
+								btcoexist, PHYDM_INFO_CRC32_ERROR_VHT);
+
+		cck_cnt = coex_sta->crc_ok_cck + coex_sta->crc_err_cck;
+
+		if (cck_cnt > 250) {
+			if (wl_noisy_count2 < 3)
+				wl_noisy_count2++;
+
+			if (wl_noisy_count2 == 3) {
+				wl_noisy_count0 = 0;
+				wl_noisy_count1 = 0;
+			}
+		} else if (cck_cnt < 50) {
+			if (wl_noisy_count0 < 3)
+				wl_noisy_count0++;
+
+			if (wl_noisy_count0 == 3) {
+				wl_noisy_count1 = 0;
+				wl_noisy_count2 = 0;
+			}
+		} else {
+			if (wl_noisy_count1 < 3)
+				wl_noisy_count1++;
+
+			if (wl_noisy_count1 == 3) {
+				wl_noisy_count0 = 0;
+				wl_noisy_count2 = 0;
+			}
+		}
+
+		if (wl_noisy_count2 == 3)
+			coex_sta->wl_noisy_level = 2;
+		else if (wl_noisy_count1 == 3)
+			coex_sta->wl_noisy_level = 1;
+		else
+			coex_sta->wl_noisy_level = 0;
+
+		if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+			total_cnt = coex_sta->crc_ok_cck + coex_sta->crc_ok_11g +
+					coex_sta->crc_ok_11n + coex_sta->crc_ok_11n_vht;
+
+			if ((coex_dm->bt_status == BT_8723D_2ANT_BT_STATUS_ACL_BUSY) ||
+				(coex_dm->bt_status == BT_8723D_2ANT_BT_STATUS_ACL_SCO_BUSY) ||
+				(coex_dm->bt_status == BT_8723D_2ANT_BT_STATUS_SCO_BUSY)) {
+				if (coex_sta->crc_ok_cck > (total_cnt -
+								coex_sta->crc_ok_cck)) {
+					if (cck_lock_counter < 3)
+						cck_lock_counter++;
+				} else {
+					if (cck_lock_counter > 0)
+						cck_lock_counter--;
+				}
+
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+
+		if (!coex_sta->pre_ccklock) {
+
+			if (cck_lock_counter >= 3)
+				coex_sta->cck_lock = true;
+			else
+				coex_sta->cck_lock = false;
+		} else {
+			if (cck_lock_counter == 0)
+				coex_sta->cck_lock = false;
+			else
+				coex_sta->cck_lock = true;
+		}
+
+		if (coex_sta->cck_lock)
+			coex_sta->cck_ever_lock = true;
+
+		coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+#endif
+}
+
+void halbtc8723d2ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean			bt_hs_on = false;
+	boolean			bt_busy = false;
+
+
+	coex_sta->num_of_profile = 0;
+
+	/* set link exist status */
+	if (!(coex_sta->bt_info & BT_INFO_8723D_2ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (coex_sta->bt_info & BT_INFO_8723D_2ANT_B_FTP) {
+			coex_sta->pan_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->pan_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8723D_2ANT_B_A2DP) {
+			coex_sta->a2dp_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->a2dp_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8723D_2ANT_B_HID) {
+			coex_sta->hid_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->hid_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8723D_2ANT_B_SCO_ESCO) {
+			coex_sta->sco_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->sco_exist = false;
+
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+	bt_link_info->acl_busy = coex_sta->acl_busy;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+
+	if (coex_sta->bt_info & BT_INFO_8723D_2ANT_B_INQ_PAGE) {
+		coex_dm->bt_status = BT_8723D_2ANT_BT_STATUS_INQ_PAGE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Inq/page!!!\n");
+	} else if (!(coex_sta->bt_info & BT_INFO_8723D_2ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8723D_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+	} else if (coex_sta->bt_info == BT_INFO_8723D_2ANT_B_CONNECTION) {
+		/* connection exists but no busy */
+		coex_dm->bt_status = BT_8723D_2ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+	} else if (((coex_sta->bt_info & BT_INFO_8723D_2ANT_B_SCO_ESCO) ||
+		    (coex_sta->bt_info & BT_INFO_8723D_2ANT_B_SCO_BUSY)) &&
+		   (coex_sta->bt_info & BT_INFO_8723D_2ANT_B_ACL_BUSY)) {
+		coex_dm->bt_status = BT_8723D_2ANT_BT_STATUS_ACL_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL SCO busy!!!\n");
+	} else if ((coex_sta->bt_info & BT_INFO_8723D_2ANT_B_SCO_ESCO) ||
+		   (coex_sta->bt_info & BT_INFO_8723D_2ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8723D_2ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+	} else if (coex_sta->bt_info & BT_INFO_8723D_2ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8723D_2ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+	} else {
+		coex_dm->bt_status = BT_8723D_2ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+	}
+
+	BTC_TRACE(trace_buf);
+
+	if ((BT_8723D_2ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8723D_2ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8723D_2ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+}
+
+void halbtc8723d2ant_update_wifi_channel_info(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] =
+			0x1;  /* enable BT AFH skip WL channel for 8723d because BT Rx LO interference */
+		/* h2c_parameter[0] = 0x0; */
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+
+}
+
+void halbtc8723d2ant_set_fw_dac_swing_level(IN struct btc_coexist *btcoexist,
+		IN u8 dac_swing_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	/* There are several type of dacswing */
+	/* 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6 */
+	h2c_parameter[0] = dac_swing_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
+}
+
+void halbtc8723d2ant_fw_dac_swing_lvl(IN struct btc_coexist *btcoexist,
+			      IN boolean force_exec, IN u8 fw_dac_swing_lvl)
+{
+	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swing_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_fw_dac_swing_lvl ==
+		    coex_dm->cur_fw_dac_swing_lvl)
+			return;
+	}
+
+	halbtc8723d2ant_set_fw_dac_swing_level(btcoexist,
+					       coex_dm->cur_fw_dac_swing_lvl);
+
+	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
+}
+
+void halbtc8723d2ant_set_fw_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				       IN u8 dec_bt_pwr_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = dec_bt_pwr_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x62, 1, h2c_parameter);
+}
+
+void halbtc8723d2ant_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN u8 dec_bt_pwr_lvl)
+{
+	coex_dm->cur_bt_dec_pwr_lvl = dec_bt_pwr_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_dec_pwr_lvl == coex_dm->cur_bt_dec_pwr_lvl)
+			return;
+	}
+	halbtc8723d2ant_set_fw_dec_bt_pwr(btcoexist,
+					  coex_dm->cur_bt_dec_pwr_lvl);
+
+	coex_dm->pre_bt_dec_pwr_lvl = coex_dm->cur_bt_dec_pwr_lvl;
+}
+
+void halbtc8723d2ant_set_fw_low_penalty_ra(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+#if 1
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf7;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf8;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf9;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+#endif
+}
+
+void halbtc8723d2ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+#if 1
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+
+	halbtc8723d2ant_set_fw_low_penalty_ra(btcoexist,
+							  coex_dm->cur_low_penalty_ra);
+
+#if 0
+	if (low_penalty_ra)
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 15);
+	else
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 0);
+#endif
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+
+#endif
+}
+
+void halbtc8723d2ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8723d2ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8723d2ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8723d2ant_write_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16				bitpos,
+	IN	boolean		state
+)
+{
+
+	static u16 originalval = 0x8002;
+
+	if (state)
+		originalval = originalval | bitpos;
+	else
+		originalval = originalval & (~bitpos);
+
+
+	btcoexist->btc_write_2byte(btcoexist, 0xaa, originalval);
+
+}
+
+void halbtc8723d2ant_read_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN   u16				*score_board_val
+)
+{
+
+	*score_board_val = (btcoexist->btc_read_2byte(btcoexist,
+			    0xaa)) & 0x7fff;
+}
+
+
+void halbtc8723d2ant_post_state_to_bt(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16						type,
+	IN  boolean                 state
+)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], halbtc8723d2ant_post_state_to_bt: type = %d, state =%d\n",
+		type, state);
+	BTC_TRACE(trace_buf);
+
+	halbtc8723d2ant_write_score_board(btcoexist, (u16) type, state);
+
+}
+
+boolean halbtc8723d2ant_is_wifibt_status_changed(IN struct btc_coexist
+		*btcoexist)
+{
+
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+		pre_bt_hs_on = false, pre_bt_off = false, pre_bt_slave = false;
+	static u8 pre_hid_busy_num = 0, pre_wl_noisy_level = 0;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (coex_sta->bt_disabled != pre_bt_off) {
+		pre_bt_off = coex_sta->bt_disabled;
+
+		if (coex_sta->bt_disabled)
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+		else
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is enabled !!\n");
+
+		BTC_TRACE(trace_buf);
+
+		coex_sta->bt_coex_supported_feature = 0;
+		coex_sta->bt_coex_supported_version = 0;
+		coex_sta->bt_ble_scan_type = 0;
+		coex_sta->bt_ble_scan_para[0] = 0;
+		coex_sta->bt_ble_scan_para[1] = 0;
+		coex_sta->bt_ble_scan_para[2] = 0;
+		coex_sta->bt_reg_vendor_ac = 0xffff;
+		coex_sta->bt_reg_vendor_ae = 0xffff;
+		return true;
+	}
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+
+			if (wifi_busy)
+				halbtc8723d2ant_post_state_to_bt(btcoexist,
+						BT_8723D_2ANT_SCOREBOARD_UNDERTEST, true);
+			else
+				halbtc8723d2ant_post_state_to_bt(btcoexist,
+						BT_8723D_2ANT_SCOREBOARD_UNDERTEST, false);
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+		if (coex_sta->wl_noisy_level != pre_wl_noisy_level) {
+			pre_wl_noisy_level = coex_sta->wl_noisy_level;
+			return true;
+		}
+	}
+
+	if (!coex_sta->bt_disabled) {
+		if (coex_sta->hid_busy_num != pre_hid_busy_num) {
+			pre_hid_busy_num = coex_sta->hid_busy_num;
+			return true;
+		}
+	}
+
+	if (bt_link_info->slave_role != pre_bt_slave) {
+			pre_bt_slave = bt_link_info->slave_role;
+			return true;
+	}
+
+	return false;
+}
+
+void halbtc8723d2ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+	u16			u16tmp;
+
+	/* This function check if bt is disabled */
+#if 0
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+
+
+#else
+
+	/* Read BT on/off status from scoreboard[1], enable this only if BT patch support this feature */
+	halbtc8723d2ant_read_score_board(btcoexist,	&u16tmp);
+
+	bt_active = u16tmp & BIT(1);
+
+
+#endif
+
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	} else {
+
+		bt_disable_cnt++;
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			bt_disable_cnt = 2;
+		}
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	}
+
+	if (bt_disabled)
+		halbtc8723d2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, false);
+	else
+		halbtc8723d2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, true);
+
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+	}
+
+}
+
+
+
+void halbtc8723d2ant_enable_gnt_to_gpio(IN struct btc_coexist *btcoexist,
+					boolean isenable)
+{
+#if BT_8723D_2ANT_COEX_DBG
+	if (isenable) {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x1);
+
+		/* enable GNT_BT to GPIO debug */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e, 0x40, 0x0);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x1, 0x0);
+
+		/* 0x48[20] = 0  for GPIO14 =  GNT_WL*/
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4a, 0x10, 0x0);
+		/* 0x40[17] = 0  for GPIO14 =  GNT_WL*/
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x42, 0x02, 0x0);
+
+		/* 0x66[9] = 0   for GPIO15 =  GNT_BT*/
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x02, 0x0);
+		/* 0x66[7] = 0
+		for GPIO15 =  GNT_BT*/
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x66, 0x80, 0x0);
+		/* 0x8[8] = 0    for GPIO15 =  GNT_BT*/
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x9, 0x1, 0x0);
+
+		/* BT Vendor Reg 0x76[0] = 0  for GPIO15 =  GNT_BT, this is not set here*/
+	} else {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x0);
+
+		/* Disable GNT_BT debug to GPIO, and enable chip_wakeup_host */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e, 0x40, 0x1);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x1, 0x1);
+
+		/* 0x48[20] = 0  for GPIO14 =  GNT_WL*/
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4a, 0x10, 0x1);
+	}
+
+#endif
+}
+
+u32 halbtc8723d2ant_ltecoex_indirect_read_reg(IN struct btc_coexist *btcoexist,
+		IN u16 reg_addr)
+{
+	u32 j = 0, delay_count = 0;
+
+
+	/* wait for ready bit before access 0x7c0		 */
+	btcoexist->btc_write_4byte(btcoexist, 0x7c0, 0x800F0000 | reg_addr);
+
+	while (1) {
+		if ((btcoexist->btc_read_1byte(btcoexist, 0x7c3) & BIT(5)) == 0) {
+			delay_ms(50);
+			delay_count++;
+			if (delay_count >= 10) {
+				delay_count = 0;
+				break;
+			}
+		} else
+			break;
+	}
+
+	return btcoexist->btc_read_4byte(btcoexist,
+					 0x7c8);  /* get read data */
+
+}
+
+void halbtc8723d2ant_ltecoex_indirect_write_reg(IN struct btc_coexist
+		*btcoexist,
+		IN u16 reg_addr, IN u32 bit_mask, IN u32 reg_value)
+{
+	u32 val, i = 0, j = 0, bitpos = 0, delay_count = 0;
+
+
+	if (bit_mask == 0x0)
+		return;
+	if (bit_mask == 0xffffffff) {
+		btcoexist->btc_write_4byte(btcoexist, 0x7c4,
+					   reg_value); /* put write data */
+
+		/* wait for ready bit before access 0x7c0 */
+		while (1) {
+			if ((btcoexist->btc_read_1byte(btcoexist, 0x7c3) & BIT(5)) == 0) {
+				delay_ms(50);
+				delay_count++;
+				if (delay_count >= 10) {
+					delay_count = 0;
+					break;
+				}
+			} else
+				break;
+		}
+
+		btcoexist->btc_write_4byte(btcoexist, 0x7c0,
+					   0xc00F0000 | reg_addr);
+	} else {
+		for (i = 0; i <= 31; i++) {
+			if (((bit_mask >> i) & 0x1) == 0x1) {
+				bitpos = i;
+				break;
+			}
+		}
+
+		/* read back register value before write */
+		val = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist,
+				reg_addr);
+		val = (val & (~bit_mask)) | (reg_value << bitpos);
+
+		btcoexist->btc_write_4byte(btcoexist, 0x7c4,
+					   val); /* put write data */
+
+		/* wait for ready bit before access 0x7c0		 */
+		while (1) {
+			if ((btcoexist->btc_read_1byte(btcoexist, 0x7c3) & BIT(5)) == 0) {
+				delay_ms(50);
+				delay_count++;
+				if (delay_count >= 10) {
+					delay_count = 0;
+					break;
+				}
+			} else
+				break;
+		}
+
+		btcoexist->btc_write_4byte(btcoexist, 0x7c0,
+					   0xc00F0000 | reg_addr);
+
+	}
+
+}
+
+void halbtc8723d2ant_ltecoex_enable(IN struct btc_coexist *btcoexist,
+				    IN boolean enable)
+{
+	u8 val;
+
+	val = (enable) ? 1 : 0;
+	halbtc8723d2ant_ltecoex_indirect_write_reg(btcoexist, 0x38, 0x80,
+			val);  /* 0x38[7] */
+
+}
+
+void halbtc8723d2ant_ltecoex_pathcontrol_owner(IN struct btc_coexist *btcoexist,
+		IN boolean wifi_control)
+{
+	u8 val;
+
+	val = (wifi_control) ? 1 : 0;
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x4,
+					   val); /* 0x70[26] */
+
+}
+
+void halbtc8723d2ant_ltecoex_set_gnt_bt(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, val_orig = 0;
+
+	if (!sw_control)
+		val = 0x0;
+	else if (state & 0x1)
+		val = 0x3;
+	else
+		val = 0x1;
+
+	val_orig = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist,
+				0x38);
+
+	switch (control_block) {
+	case BT_8723D_2ANT_GNT_BLOCK_RFC_BB:
+	default:
+		val = ((val << 14) | (val << 10)) | (val_orig & 0xffff33ff);
+		break;
+	case BT_8723D_2ANT_GNT_BLOCK_RFC:
+		val = (val << 14) | (val_orig & 0xffff3fff);
+		break;
+	case BT_8723D_2ANT_GNT_BLOCK_BB:
+		val = (val << 10) | (val_orig & 0xfffff3ff);
+		break;
+	}
+
+	halbtc8723d2ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, 0xffffffff, val);
+}
+
+
+void halbtc8723d2ant_ltecoex_set_gnt_wl(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, val_orig = 0;
+
+	if (!sw_control)
+		val = 0x0;
+	else if (state & 0x1)
+		val = 0x3;
+	else
+		val = 0x1;
+
+	val_orig = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist,
+				0x38);
+
+	switch (control_block) {
+	case BT_8723D_2ANT_GNT_BLOCK_RFC_BB:
+	default:
+		val = ((val << 12) | (val << 8)) | (val_orig & 0xffffccff);
+		break;
+	case BT_8723D_2ANT_GNT_BLOCK_RFC:
+		val = (val << 12) | (val_orig & 0xffffcfff);
+		break;
+	case BT_8723D_2ANT_GNT_BLOCK_BB:
+		val = (val << 8) | (val_orig & 0xfffffcff);
+		break;
+	}
+
+	halbtc8723d2ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, 0xffffffff, val);
+}
+
+void halbtc8723d2ant_ltecoex_set_coex_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u16 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8723D_2ANT_CTT_WL_VS_LTE:
+		reg_addr = 0xa0;
+		break;
+	case BT_8723D_2ANT_CTT_BT_VS_LTE:
+		reg_addr = 0xa4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8723d2ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xffff, table_content); /* 0xa0[15:0] or 0xa4[15:0] */
+
+
+}
+
+
+void halbtc8723d2ant_ltecoex_set_break_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u8 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8723D_2ANT_LBTT_WL_BREAK_LTE:
+		reg_addr = 0xa8;
+		break;
+	case BT_8723D_2ANT_LBTT_BT_BREAK_LTE:
+		reg_addr = 0xac;
+		break;
+	case BT_8723D_2ANT_LBTT_LTE_BREAK_WL:
+		reg_addr = 0xb0;
+		break;
+	case BT_8723D_2ANT_LBTT_LTE_BREAK_BT:
+		reg_addr = 0xb4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8723d2ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xff, table_content); /* 0xa8[15:0] or 0xb4[15:0] */
+
+
+}
+
+void halbtc8723d2ant_set_wltoggle_coex_table(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec,  IN u8 interval,
+		IN u8 val0x6c4_b0, IN u8 val0x6c4_b1, IN u8 val0x6c4_b2,
+		IN u8 val0x6c4_b3)
+{
+	static u8 pre_h2c_parameter[6] = {0};
+	u8	cur_h2c_parameter[6] = {0};
+	u8 i, match_cnt = 0;
+
+	cur_h2c_parameter[0] = 0x7;	/* op_code, 0x7= wlan toggle slot*/
+
+	cur_h2c_parameter[1] = interval;
+	cur_h2c_parameter[2] = val0x6c4_b0;
+	cur_h2c_parameter[3] = val0x6c4_b1;
+	cur_h2c_parameter[4] = val0x6c4_b2;
+	cur_h2c_parameter[5] = val0x6c4_b3;
+
+	if (!force_exec) {
+		for (i = 1; i <= 5; i++) {
+			if (cur_h2c_parameter[i] != pre_h2c_parameter[i])
+				break;
+
+			match_cnt++;
+		}
+
+		if (match_cnt == 5)
+			return;
+	}
+
+	for (i = 1; i <= 5; i++)
+		pre_h2c_parameter[i] = cur_h2c_parameter[i];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, cur_h2c_parameter);
+}
+
+void halbtc8723d2ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8723d2ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8723d2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8723d2ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	u32	break_table;
+	u8	select_table;
+
+	coex_sta->coex_table_type = type;
+
+	if (coex_sta->concurrent_rx_mode_on == true) {
+		break_table = 0xf0ffffff;  /* set WL hi-pri can break BT */
+		select_table =
+			0xb;		/* set Tx response = Hi-Pri (ex: Transmitting ACK,BA,CTS) */
+	} else {
+		break_table = 0xffffff;
+		select_table = 0x3;
+	}
+
+		switch (type) {
+		case 0:
+			halbtc8723d2ant_coex_table(btcoexist, force_exec,
+				   0xffffffff, 0xffffffff, break_table, select_table);
+			break;
+		case 1:
+			halbtc8723d2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, break_table, select_table);
+			break;
+		case 2:
+			halbtc8723d2ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0x5a5a5a5a, break_table, select_table);
+			break;
+		case 3:
+			halbtc8723d2ant_coex_table(btcoexist, force_exec,
+				   0xaa555555, 0xaa5a5a5a, break_table, select_table);
+			break;
+		case 4:
+			halbtc8723d2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, break_table, select_table);
+			break;
+		case 5:
+			halbtc8723d2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, break_table, select_table);
+			break;
+		case 6:
+			halbtc8723d2ant_coex_table(btcoexist, force_exec,
+				   0xa5555555, 0xfafafafa, break_table, select_table);
+			break;
+		case 7:
+			halbtc8723d2ant_coex_table(btcoexist, force_exec,
+				   0xa5555555, 0xaa5a5a5a, break_table, select_table);
+			break;
+		case 8:
+			halbtc8723d2ant_coex_table(btcoexist, force_exec,
+				   0xa5555555, 0xfafafafa, break_table, select_table);
+			break;
+		case 9:
+			halbtc8723d2ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0xaaaa5aaa, break_table, select_table);
+			break;
+		default:
+			break;
+		}
+}
+
+void halbtc8723d2ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable) {
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8723d2ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8723d2ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8723d2ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8723d2ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8723d2ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8723d2ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0, 0, 0, 0x40, 0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			/*halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			/*halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);*/
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8723d2ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8723d2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8723d2ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8723d2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+
+
+void halbtc8723d2ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	if (byte5 & BIT(2))
+		coex_sta->is_tdma_btautoslot = true;
+	else
+		coex_sta->is_tdma_btautoslot = false;
+
+	/* release bt-auto slot for auto-slot hang is detected!! */
+	if (coex_sta->is_tdma_btautoslot)
+		if ((coex_sta->is_tdma_btautoslot_hang) ||
+			(bt_link_info->slave_role))
+			byte5 = byte5 & 0xfb;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8723d2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0,
+							 0x0);
+		}
+	} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+
+		halbtc8723d2ant_power_save_state(
+			btcoexist, BTC_PS_LPS_ON, 0x50,
+			0x4);
+	} else {
+		halbtc8723d2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0,
+						 0x0);
+	}
+
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8723d2ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+
+	static u8			psTdmaByte4Modify = 0x0, pre_psTdmaByte4Modify = 0x0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	/* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+	if ((bt_link_info->slave_role) && (bt_link_info->a2dp_exist))
+		psTdmaByte4Modify = 0x1;
+	else
+		psTdmaByte4Modify = 0x0;
+
+	if (pre_psTdmaByte4Modify != psTdmaByte4Modify) {
+
+		force_exec = true;
+		pre_psTdmaByte4Modify = psTdmaByte4Modify;
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+
+	if (turn_on) {
+		switch (type) {
+		case 1:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x10, 0x03, 0x91,
+								0x54 | psTdmaByte4Modify);
+			break;
+		case 2:
+		default:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x35, 0x03, 0x11,
+								0x11 | psTdmaByte4Modify);
+			break;
+		case 3:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x3a, 0x3, 0x91,
+								0x10 | psTdmaByte4Modify);
+			break;
+		case 4:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x21, 0x3, 0x91,
+								0x10 | psTdmaByte4Modify);
+			break;
+		case 5:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x25, 0x3, 0x91,
+								0x10 | psTdmaByte4Modify);
+			break;
+		case 6:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x10, 0x3, 0x91,
+								0x10 | psTdmaByte4Modify);
+			break;
+		case 7:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x20, 0x3, 0x91,
+								0x10 | psTdmaByte4Modify);
+			break;
+		case 8:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x15, 0x03, 0x11,
+								0x11);
+			break;
+		case 10:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x30, 0x03, 0x11,
+								0x10);
+			break;
+		case 11:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x35, 0x03, 0x11,
+								0x10 | psTdmaByte4Modify);
+			break;
+		case 12:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x35, 0x03, 0x11, 0x11);
+			break;
+		case 13:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x1c, 0x03, 0x11,
+								0x10 | psTdmaByte4Modify);
+			break;
+		case 14:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x20, 0x03, 0x11,
+								0x11);
+			break;
+		case 15:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x10, 0x03, 0x11,
+								0x14);
+			break;
+		case 16:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x10, 0x03, 0x11,
+								0x15);
+			break;
+		case 21:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x30, 0x03, 0x11,
+								0x10);
+			break;
+		case 22:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x25, 0x03, 0x11,
+								0x10);
+			break;
+		case 23:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x10, 0x03, 0x11,
+								0x10);
+			break;
+		case 51:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x10, 0x03, 0x91,
+								0x10 | psTdmaByte4Modify);
+			break;
+		case 101:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x51,
+								0x10, 0x03, 0x10,
+								0x54 | psTdmaByte4Modify);
+			break;
+		case 102:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x61,
+								0x35, 0x03, 0x11,
+								0x11 | psTdmaByte4Modify);
+			break;
+		case 103:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x51,
+								0x3a, 0x3, 0x10,
+								0x50 | psTdmaByte4Modify);
+			break;
+		case 104:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x51,
+								0x21, 0x3, 0x10,
+								0x50 | psTdmaByte4Modify);
+			break;
+		case 105:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x51,
+								0x25, 0x3, 0x10,
+								0x50 | psTdmaByte4Modify);
+			break;
+		case 106:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x51,
+								0x10, 0x3, 0x10,
+								0x50 | psTdmaByte4Modify);
+			break;
+		case 107:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x51,
+								0x20, 0x3, 0x10,
+								0x50 | psTdmaByte4Modify);
+			break;
+		case 108:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x51,
+								0x30, 0x3, 0x10,
+								0x50 | psTdmaByte4Modify);
+			break;
+		case 109:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x55,
+								0x10, 0x03, 0x10,
+								0x54 | psTdmaByte4Modify);
+			break;
+		case 110:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x55,
+								0x30, 0x03, 0x10,
+								0x50 | psTdmaByte4Modify);
+			break;
+		case 111:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x65,
+								0x25, 0x03, 0x11,
+								0x11 | psTdmaByte4Modify);
+			break;
+		case 151:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x51,
+								0x10, 0x03, 0x10,
+								0x50 | psTdmaByte4Modify);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 0:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		case 1:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x48, 0x0);
+			break;
+		default:
+			halbtc8723d2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8723d2ant_set_ant_path(IN struct btc_coexist *btcoexist,
+				  IN u8 ant_pos_type, IN boolean force_exec,
+				  IN u8 phase)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u32			u32tmp = 0;
+	boolean			pg_ext_switch = false,  is_hw_ant_div_on = false;
+	u8			h2c_parameter[2] = {0};
+	u32			cnt_bt_cal_chk = 0;
+	u8			u8tmp0 = 0, u8tmp1 = 0;
+	boolean			is_in_mp_mode = false;
+	u32				u32tmp0 = 0, u32tmp1 = 0, u32tmp2 = 0;
+	u16				u16tmp0 = 0,  u16tmp1 = 0;
+
+
+	u32tmp1 = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist,
+			0x38);
+
+     /* To avoid indirect access fail   */
+	if (((u32tmp1 & 0xf000) >> 12) != ((u32tmp1 & 0x0f00) >> 8)) {
+		force_exec = true;
+		coex_sta->gnt_error_cnt++;
+	}
+
+
+#if BT_8723D_2ANT_COEX_DBG
+	u32tmp2 = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u16tmp0 = btcoexist->btc_read_2byte(btcoexist, 0xaa);
+	u16tmp1 = btcoexist->btc_read_2byte(btcoexist, 0x948);
+	u8tmp1  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+	u8tmp0 =  btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** 0x67 = 0x%x, 0x948 = 0x%x, 0x73 = 0x%x(Before Set Ant Pat)\n",
+		    u8tmp0, u16tmp1, u8tmp1);
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********0x38= 0x%x, 0x54= 0x%x, 0xaa = 0x%x (Before Set Ant Path)\n",
+		    u32tmp1, u32tmp2, u16tmp0);
+	BTC_TRACE(trace_buf);
+#endif
+
+	coex_dm->cur_ant_pos_type = ant_pos_type;
+
+	if (!force_exec) {
+		if (coex_dm->cur_ant_pos_type == coex_dm->pre_ant_pos_type) {
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** Skip Antenna Path Setup because no change!!**********\n");
+			BTC_TRACE(trace_buf);
+			return;
+		}
+	}
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+
+	switch (phase) {
+	case BT_8723D_2ANT_PHASE_COEX_POWERON:
+		/* Set Path control to WL */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67,
+						   0x80, 0x0);
+
+		/* set Path control owner to WL at initial step */
+		halbtc8723d2ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8723D_2ANT_PCO_BTSIDE);
+
+		/* set GNT_BT to SW high */
+		halbtc8723d2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8723D_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_2ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW low */
+		halbtc8723d2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8723D_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_2ANT_SIG_STA_SET_TO_HIGH);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_WIFI;
+
+		coex_sta->run_time_state = false;
+
+		break;
+	case BT_8723D_2ANT_PHASE_COEX_INIT:
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8723d2ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8723d2ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8723D_2ANT_CTT_WL_VS_LTE,
+			0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8723d2ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8723D_2ANT_CTT_BT_VS_LTE,
+			0xffff);
+
+		/* Wait If BT IQK running, because Path control owner is at BT during BT IQK (setup by WiFi firmware) */
+		while (cnt_bt_cal_chk <= 20) {
+			u8tmp0 = btcoexist->btc_read_1byte(
+					 btcoexist,
+					 0x49d);
+			cnt_bt_cal_chk++;
+			if (u8tmp0 & BIT(0)) {
+				BTC_SPRINTF(
+					trace_buf,
+					BT_TMP_BUF_SIZE,
+					"[BTCoex], ########### BT is calibrating (wait cnt=%d) ###########\n",
+					cnt_bt_cal_chk);
+				BTC_TRACE(
+					trace_buf);
+				delay_ms(50);
+			} else {
+				BTC_SPRINTF(
+					trace_buf,
+					BT_TMP_BUF_SIZE,
+					"[BTCoex], ********** BT is NOT calibrating (wait cnt=%d)**********\n",
+					cnt_bt_cal_chk);
+				BTC_TRACE(
+					trace_buf);
+				break;
+			}
+		}
+
+
+		/* Set Path control to WL */
+		btcoexist->btc_write_1byte_bitmask(btcoexist,
+						   0x67, 0x80, 0x1);
+
+		/* set Path control owner to WL at initial step */
+		halbtc8723d2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8723D_2ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW high */
+		halbtc8723d2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8723D_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_2ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW high */
+		halbtc8723d2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8723D_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_2ANT_SIG_STA_SET_TO_HIGH);
+
+		coex_sta->run_time_state = false;
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_MAIN;
+			else
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_AUX;
+		}
+
+		break;
+	case BT_8723D_2ANT_PHASE_WLANONLY_INIT:
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8723d2ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8723d2ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8723D_2ANT_CTT_WL_VS_LTE,
+			0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8723d2ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8723D_2ANT_CTT_BT_VS_LTE,
+			0xffff);
+
+		/* Set Path control to WL */
+		btcoexist->btc_write_1byte_bitmask(btcoexist,
+						   0x67, 0x80, 0x1);
+
+		/* set Path control owner to WL at initial step */
+		halbtc8723d2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8723D_2ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW Low */
+		halbtc8723d2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8723D_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_2ANT_SIG_STA_SET_TO_LOW);
+		/* Set GNT_WL to SW high */
+		halbtc8723d2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8723D_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_2ANT_SIG_STA_SET_TO_HIGH);
+
+		coex_sta->run_time_state = false;
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_MAIN;
+			else
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_AUX;
+		}
+
+		break;
+	case BT_8723D_2ANT_PHASE_WLAN_OFF:
+		/* Disable LTE Coex Function in WiFi side */
+		halbtc8723d2ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* Set Path control to BT */
+		btcoexist->btc_write_1byte_bitmask(btcoexist,
+						   0x67, 0x80, 0x0);
+
+		/* set Path control owner to BT */
+		halbtc8723d2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8723D_2ANT_PCO_BTSIDE);
+
+		coex_sta->run_time_state = false;
+		break;
+	case BT_8723D_2ANT_PHASE_2G_RUNTIME:
+
+		/* wait for WL/BT IQK finish, keep 0x38 = 0xff00 for WL IQK */
+		while (cnt_bt_cal_chk <= 20) {
+			u8tmp0 = btcoexist->btc_read_1byte(
+					 btcoexist,
+					 0x1e6);
+
+			u8tmp1 = btcoexist->btc_read_1byte(
+					 btcoexist,
+					 0x49d);
+
+			cnt_bt_cal_chk++;
+			if ((u8tmp0 & BIT(0)) ||
+			    (u8tmp1 & BIT(0))) {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ########### WL or BT is IQK (wait cnt=%d)\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				delay_ms(50);
+			} else {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ********** WL and BT is NOT IQK (wait cnt=%d)\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				break;
+			}
+		}
+
+		/* Set Path control to WL */
+		/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x80, 0x1);*/
+
+		/* set Path control owner to WL at runtime step */
+		halbtc8723d2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8723D_2ANT_PCO_WLSIDE);
+
+
+		halbtc8723d2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8723D_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_2ANT_GNT_TYPE_CTRL_BY_PTA,
+					   BT_8723D_2ANT_SIG_STA_SET_TO_HIGH);
+
+		/* Set GNT_WL to PTA */
+		halbtc8723d2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8723D_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_2ANT_GNT_TYPE_CTRL_BY_PTA,
+					   BT_8723D_2ANT_SIG_STA_SET_BY_HW);
+
+		coex_sta->run_time_state = true;
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_MAIN;
+			else
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_AUX;
+		}
+
+		break;
+	case BT_8723D_2ANT_PHASE_BTMPMODE:
+		/* Disable LTE Coex Function in WiFi side */
+		halbtc8723d2ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* Set Path control to WL */
+		btcoexist->btc_write_1byte_bitmask(btcoexist,
+						   0x67, 0x80, 0x1);
+
+		/* set Path control owner to WL */
+		halbtc8723d2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8723D_2ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW Hi */
+		halbtc8723d2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8723D_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_2ANT_SIG_STA_SET_TO_HIGH);
+
+		/* Set GNT_WL to SW Lo */
+		halbtc8723d2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8723D_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_2ANT_SIG_STA_SET_TO_LOW);
+
+		coex_sta->run_time_state = false;
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_MAIN;
+			else
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_AUX;
+		}
+
+		break;
+	case BT_8723D_2ANT_PHASE_ANTENNA_DET:
+
+		/* Set Path control to WL */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67,
+						   0x80, 0x1);
+
+		/* set Path control owner to WL */
+		halbtc8723d2ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8723D_2ANT_PCO_WLSIDE);
+
+		/* Set Antenna Path,  both GNT_WL/GNT_BT = 1, and control by SW */
+		/* set GNT_BT to SW high */
+		halbtc8723d2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8723D_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_2ANT_SIG_STA_SET_TO_HIGH);
+
+		/* Set GNT_WL to SW high */
+		halbtc8723d2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8723D_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8723D_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8723D_2ANT_SIG_STA_SET_TO_HIGH);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_WIFI_AT_AUX;
+
+		coex_sta->run_time_state = false;
+
+		break;
+	}
+
+	is_hw_ant_div_on = board_info->ant_div_cfg;
+
+	if ((is_hw_ant_div_on) && (phase != BT_8723D_2ANT_PHASE_ANTENNA_DET))
+		btcoexist->btc_write_2byte(btcoexist, 0x948, 0x140);
+	else if ((is_hw_ant_div_on == false) &&
+		 (phase != BT_8723D_2ANT_PHASE_WLAN_OFF)) {
+
+		switch (ant_pos_type) {
+		case BTC_ANT_WIFI_AT_MAIN:
+
+			btcoexist->btc_write_2byte(btcoexist,
+						   0x948, 0x0);
+			break;
+		case BTC_ANT_WIFI_AT_AUX:
+
+			btcoexist->btc_write_2byte(btcoexist,
+						   0x948, 0x280);
+			break;
+		}
+	}
+
+
+#if BT_8723D_2ANT_COEX_DBG
+	u32tmp1 = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u16tmp0 = btcoexist->btc_read_2byte(btcoexist, 0xaa);
+	u16tmp1 = btcoexist->btc_read_2byte(btcoexist, 0x948);
+	u8tmp1  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+	u8tmp0 =  btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** 0x67 = 0x%x, 0x948 = 0x%x, 0x73 = 0x%x(After Set Ant Pat)\n",
+		    u8tmp0, u16tmp1, u8tmp1);
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********0x38= 0x%x, 0x54= 0x%x, 0xaa= 0x%x (After Set Ant Path)\n",
+		    u32tmp1, u32tmp2, u16tmp0);
+	BTC_TRACE(trace_buf);
+#endif
+
+}
+
+u8 halbtc8723d2ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8723D_2ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 0) {
+
+		if (bt_link_info->acl_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], No-Profile busy\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8723D_2ANT_COEX_ALGO_NOPROFILEBUSY;
+		}
+	} else if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8723D_2ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723D_2ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723D_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723D_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + A2DP ==> A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723D_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8723D_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				{
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8723D_2ANT_COEX_ALGO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], SCO + HID + A2DP ==> HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723D_2ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_PANEDR_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_PANEDR_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723D_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+
+
+void halbtc8723d2ant_action_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* fw all off */
+	halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+	halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+	halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8723d2ant_action_bt_whql_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+	halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+}
+
+void halbtc8723d2ant_action_bt_hs(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  scan_ap_num = %d, wl_noisy = %d\n",
+			coex_sta->scan_ap_num, coex_sta->wl_noisy_level);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->wl_noisy_level == 0))
+		wifi_turbo = true;
+#endif
+
+
+	wifi_rssi_state = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x6);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+
+	} else {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}
+
+}
+
+
+void halbtc8723d2ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+
+	boolean wifi_connected = false;
+	boolean wifi_scan = false, wifi_link = false, wifi_roam = false;
+	boolean wifi_busy = false;
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &wifi_link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &wifi_roam);
+
+	if ((coex_sta->bt_create_connection) && ((wifi_link) || (wifi_roam)
+		|| (wifi_scan) || (wifi_busy) || (coex_sta->wifi_is_high_pri_task))) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi link/roam/Scan/busy/hi-pri-task + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+							 8);
+
+		if ((bt_link_info->a2dp_exist) && (!bt_link_info->pan_exist))
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						15);
+		else
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						11);
+	}  else if ((!wifi_connected) && (!wifi_scan)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi no-link + no-scan + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (bt_link_info->pan_exist) {
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+
+	} else if (bt_link_info->a2dp_exist) {
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 16);
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+	} else {
+
+		if ((wifi_link) || (wifi_roam) || (wifi_scan) || (wifi_busy)
+			|| (coex_sta->wifi_is_high_pri_task))
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+		else
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 23);
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+	}
+
+	halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 0x18);
+	halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+}
+
+
+void halbtc8723d2ant_action_bt_relink(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 8);
+	halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+
+	halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 0x18);
+	halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	coex_sta->bt_relink_downcount = 2;
+}
+
+void halbtc8723d2ant_action_bt_idle(IN struct btc_coexist *btcoexist)
+{
+	boolean wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_busy) {
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist,
+						     NORMAL_EXEC, 8);
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+	} else {  /* if wl busy */
+
+		if (BT_8723D_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			coex_dm->bt_status) {
+
+			halbtc8723d2ant_coex_table_with_type(btcoexist,
+								 NORMAL_EXEC, 0);
+
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	   } else {
+
+			halbtc8723d2ant_coex_table_with_type(btcoexist,
+									NORMAL_EXEC, 8);
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							12);
+		}
+	}
+
+	halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 0x18);
+	halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+}
+
+
+
+/* SCO only or SCO+PAN(HS) */
+void halbtc8723d2ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8	wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8	wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false;
+	u32  wifi_bw = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,
+			   &wifi_bw);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}  else {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+								 1);
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 8);
+	}
+
+}
+
+
+void halbtc8723d2ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean wifi_busy = false;
+	u32  wifi_bw = 1;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,  &wifi_bw);
+
+	wifi_rssi_state = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}  else {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		/*for 4/18 hid */
+		if (coex_sta->hid_busy_num >= 2) {
+			if (wifi_bw == 0) {   /* if 11bg mode */
+
+				 halbtc8723d2ant_coex_table_with_type(btcoexist,
+								 NORMAL_EXEC, 8);
+				 halbtc8723d2ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x1, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+				 halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							111);
+			} else {
+
+			  if (wifi_busy) {
+					  halbtc8723d2ant_coex_table_with_type(btcoexist,
+									 NORMAL_EXEC, 8);
+					  halbtc8723d2ant_set_wltoggle_coex_table(btcoexist,
+									 NORMAL_EXEC,
+									 0x2, 0xaa,
+									 0x5a, 0xaa,
+									 0xaa);
+					  halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+									 111);
+				} else {
+
+					  halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+								 3);
+					  halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+				}
+			}
+		} else {
+
+			halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+								 3);
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+		}
+	}
+
+}
+
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8723d2ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  scan_ap_num = %d, wl_noisy = %d\n",
+			coex_sta->scan_ap_num, coex_sta->wl_noisy_level);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->wl_noisy_level == 0))
+		wifi_turbo = true;
+#endif
+
+	wifi_rssi_state = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x6);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy)
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 1);
+		else
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						16);
+	} else {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if ((coex_sta->bt_relink_downcount != 0)
+			&& (wifi_busy)) {
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Re-Link + A2DP + WL busy\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+			halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+
+		} else {
+
+			if (wifi_turbo)
+				halbtc8723d2ant_coex_table_with_type(btcoexist,
+									 NORMAL_EXEC, 6);
+			else
+				halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+									 7);
+
+			if (wifi_busy)
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+								true, 101);
+			else
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							16);
+				/*halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							102);*/
+		}
+
+	}
+
+}
+
+
+void halbtc8723d2ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  scan_ap_num = %d, wl_noisy = %d\n",
+			coex_sta->scan_ap_num, coex_sta->wl_noisy_level);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->wl_noisy_level == 0))
+		wifi_turbo = true;
+#endif
+
+	wifi_rssi_state = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+#if 0
+	halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+	halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	coex_dm->is_switch_to_1dot5_ant = false;
+
+	halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+#endif
+
+
+#if 1
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x6);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy)
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						3);
+		else
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						4);
+	} else {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (wifi_turbo)
+			halbtc8723d2ant_coex_table_with_type(btcoexist,
+								 NORMAL_EXEC, 6);
+		else
+			halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+								 7);
+
+		if (wifi_busy)
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						103);
+		else
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						104);
+
+	}
+
+#endif
+
+}
+
+void halbtc8723d2ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean wifi_busy = false;
+	u32 wifi_bw = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,
+			   &wifi_bw);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x6);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy)
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 1);
+		else
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						16);
+	} else {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if ((coex_sta->bt_relink_downcount != 0)
+			&& (wifi_busy)) {
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Re-Link + A2DP + WL busy\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+			halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+		} else if (wifi_busy) {
+			if (coex_sta->hid_busy_num >= 2) {
+				halbtc8723d2ant_coex_table_with_type(btcoexist,
+								 NORMAL_EXEC, 8);
+				if (wifi_bw == 0)  /*11bg mode */
+					halbtc8723d2ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x1, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+				else
+					halbtc8723d2ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+					halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							109);
+			} else {
+				halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 101);
+			}
+		} else {
+			halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+								 1);
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						16);
+		}
+
+	}
+
+}
+
+
+void halbtc8723d2ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  scan_ap_num = %d, wl_noisy = %d\n",
+			coex_sta->scan_ap_num, coex_sta->wl_noisy_level);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->wl_noisy_level == 0))
+		wifi_turbo = true;
+#endif
+
+
+	wifi_rssi_state = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x6);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy) {
+
+			if ((coex_sta->a2dp_bit_pool > 40) &&
+				(coex_sta->a2dp_bit_pool < 255))
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 7);
+			else
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 5);
+		} else
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						6);
+
+	} else {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (wifi_turbo)
+			halbtc8723d2ant_coex_table_with_type(btcoexist,
+								 NORMAL_EXEC, 6);
+		else
+			halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+								 7);
+
+		if (wifi_busy) {
+
+			if ((coex_sta->a2dp_bit_pool > 40) &&
+				(coex_sta->a2dp_bit_pool < 255))
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 107);
+			else
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 105);
+		} else
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						106);
+
+	}
+
+}
+
+
+/* PAN(EDR)+A2DP */
+void halbtc8723d2ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  scan_ap_num = %d, wl_noisy = %d\n",
+			coex_sta->scan_ap_num, coex_sta->wl_noisy_level);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->wl_noisy_level == 0))
+		wifi_turbo = true;
+#endif
+
+
+	wifi_rssi_state = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x6);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy) {
+
+			if (((coex_sta->a2dp_bit_pool > 40) &&
+				 (coex_sta->a2dp_bit_pool < 255)) ||
+				(!coex_sta->is_A2DP_3M))
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 7);
+			else
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 5);
+		} else
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						6);
+	} else {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (wifi_turbo)
+			halbtc8723d2ant_coex_table_with_type(btcoexist,
+								 NORMAL_EXEC, 6);
+		else
+			halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+								 7);
+
+		if (wifi_busy) {
+
+			if ((coex_sta->a2dp_bit_pool > 40) &&
+				(coex_sta->a2dp_bit_pool < 255))
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 107);
+			else if (wifi_turbo)
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 108);
+			else
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 105);
+		} else
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						106);
+
+	}
+
+}
+
+
+void halbtc8723d2ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8	wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false;
+	u32 wifi_bw = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,
+			   &wifi_bw);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x6);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy)
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						3);
+		else
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						4);
+	} else {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (coex_sta->hid_busy_num >= 2) {
+
+			halbtc8723d2ant_coex_table_with_type(btcoexist,
+							 NORMAL_EXEC, 8);
+			if (wifi_bw == 0)  /*11bg mode */
+				halbtc8723d2ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x1, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+			else
+				halbtc8723d2ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						110);
+		} else {
+
+			halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+
+			if (wifi_busy)
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							103);
+			else
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							104);
+		}
+
+	}
+
+}
+
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8723d2ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8	wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8	wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false;
+	u32 wifi_bw = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,
+			   &wifi_bw);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8723d2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8723d2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x6);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy) {
+
+			if (((coex_sta->a2dp_bit_pool > 40) &&
+				 (coex_sta->a2dp_bit_pool < 255)) ||
+				(!coex_sta->is_A2DP_3M))
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 7);
+			else
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 5);
+		} else
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						6);
+	} else {
+
+		halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+		halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (coex_sta->hid_busy_num >= 2) {
+			halbtc8723d2ant_coex_table_with_type(btcoexist,
+							 NORMAL_EXEC, 8);
+			if (wifi_bw == 0)  /*11bg mode */
+				halbtc8723d2ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x1, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+			else
+				halbtc8723d2ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+			halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						110);
+		} else {
+			halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+
+			if (wifi_busy) {
+
+				if ((coex_sta->a2dp_bit_pool > 40) &&
+					(coex_sta->a2dp_bit_pool < 255))
+					halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+								true, 107);
+				else
+					halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+								true, 105);
+			} else
+				halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							106);
+		}
+	}
+
+}
+
+
+void halbtc8723d2ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+	halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* hw all off */
+	halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+}
+
+void halbtc8723d2ant_action_wifi_linkscan_process(IN struct btc_coexist *btcoexist)
+{
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 0x18);
+	halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+
+	if (bt_link_info->pan_exist) {
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+
+	} else if (bt_link_info->a2dp_exist) {
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 16);
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+	} else {
+
+		halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+
+		halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+	}
+
+}
+
+void halbtc8723d2ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723d2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* fw all off */
+	halbtc8723d2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+	halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+	halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8723d2ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	switch (coex_dm->cur_algorithm) {
+
+	case BT_8723D_2ANT_COEX_ALGO_SCO:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = SCO.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_sco(btcoexist);
+		break;
+	case BT_8723D_2ANT_COEX_ALGO_HID:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = HID.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_hid(btcoexist);
+		break;
+	case BT_8723D_2ANT_COEX_ALGO_A2DP:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = A2DP.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_a2dp(btcoexist);
+		break;
+	case BT_8723D_2ANT_COEX_ALGO_A2DP_PANHS:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_a2dp_pan_hs(btcoexist);
+		break;
+	case BT_8723D_2ANT_COEX_ALGO_PANEDR:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_pan_edr(btcoexist);
+		break;
+	case BT_8723D_2ANT_COEX_ALGO_PANEDR_A2DP:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_pan_edr_a2dp(btcoexist);
+		break;
+	case BT_8723D_2ANT_COEX_ALGO_PANEDR_HID:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_pan_edr_hid(btcoexist);
+		break;
+	case BT_8723D_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_hid_a2dp_pan_edr(
+			btcoexist);
+		break;
+	case BT_8723D_2ANT_COEX_ALGO_HID_A2DP:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_hid_a2dp(btcoexist);
+		break;
+	case BT_8723D_2ANT_COEX_ALGO_NOPROFILEBUSY:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = No-Profile busy.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_bt_idle(btcoexist);
+		break;
+	default:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_coex_all_off(btcoexist);
+		break;
+		}
+
+	 coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+
+}
+
+
+void halbtc8723d2ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8	algorithm = 0;
+	u32	num_of_wifi_link = 0;
+	u32	wifi_link_status = 0;
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean miracast_plus_bt = false;
+	boolean	scan = false, link = false, roam = false,
+			under_4way = false,
+			wifi_connected = false, wifi_under_5g = false,
+			bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (!coex_sta->run_time_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], return for run_time_state = false !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->freeze_coexrun_by_btinfo) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), return for freeze_coexrun_by_btinfo\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_bt_whql_test(btcoexist);
+		return;
+	}
+
+	if (coex_sta->bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				 "[BTCoex], BT is disabled!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_coex_all_off(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_bt_inquiry(btcoexist);
+		return;
+	}
+
+	if (coex_sta->is_setupLink) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				 "[BTCoex], BT is re-link !!!\n");
+		halbtc8723d2ant_action_bt_relink(btcoexist);
+		return;
+	}
+
+	/* for P2P */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+		(wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+				num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist)
+			miracast_plus_bt = true;
+		else
+			miracast_plus_bt = false;
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+
+		if (scan || link || roam || under_4way) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], scan = %d, link = %d, roam = %d 4way = %d!!!\n",
+				    scan, link, roam, under_4way);
+			BTC_TRACE(trace_buf);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], wifi is under linkscan process + Multi-Port !!\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8723d2ant_action_wifi_linkscan_process(btcoexist);
+		} else
+			halbtc8723d2ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	} else {
+		miracast_plus_bt = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (bt_hs_on) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"############# [BTCoex],  BT Is hs\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723d2ant_action_bt_hs(btcoexist);
+			return;
+	}
+
+	if ((BT_8723D_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			coex_dm->bt_status) ||
+		   (BT_8723D_2ANT_BT_STATUS_CONNECTED_IDLE ==
+			coex_dm->bt_status)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, bt idle!!.\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d2ant_action_bt_idle(btcoexist);
+		return;
+	}
+
+	algorithm = halbtc8723d2ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Algorithm = %d\n",
+			coex_dm->cur_algorithm);
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	if (scan || link || roam || under_4way) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], WiFi is under Link Process !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_wifi_linkscan_process(btcoexist);
+	} else if (wifi_connected) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, wifi connected!!.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_wifi_connected(btcoexist);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, wifi not-connected!!.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723d2ant_action_wifi_not_connected(btcoexist);
+	}
+}
+
+
+void halbtc8723d2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8723d2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0x18);
+	halbtc8723d2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8723d2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, false);
+
+	coex_sta->pop_event_cnt = 0;
+	coex_sta->cnt_RemoteNameReq = 0;
+	coex_sta->cnt_ReInit = 0;
+	coex_sta->cnt_setupLink = 0;
+	coex_sta->cnt_IgnWlanAct = 0;
+	coex_sta->cnt_Page = 0;
+
+	halbtc8723d2ant_query_bt_info(btcoexist);
+}
+
+
+void halbtc8723d2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean wifi_only)
+{
+	u8	u8tmp0 = 0, u8tmp1 = 0;
+	u32	vendor;
+	u32	u32tmp0 = 0, u32tmp1 = 0, u32tmp2 = 0;
+	u16 u16tmp1 = 0;
+	u8 i = 0;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 2Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+#if BT_8723D_2ANT_COEX_DBG
+	u32tmp1 = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist,
+			0x38);
+	u32tmp2 = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist,
+			0x54);
+	u16tmp1 = btcoexist->btc_read_2byte(btcoexist, 0x948);
+	u8tmp1	= btcoexist->btc_read_1byte(btcoexist, 0x73);
+	u8tmp0 =  btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** 0x67 = 0x%x, 0x948 = 0x%x, 0x73 = 0x%x(Before init_hw_config)\n",
+		    u8tmp0, u16tmp1, u8tmp1);
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********0x38= 0x%x, 0x54= 0x%x (Before init_hw_config)\n",
+		    u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+#endif
+
+
+	coex_sta->bt_coex_supported_feature = 0;
+	coex_sta->bt_coex_supported_version = 0;
+	coex_sta->bt_ble_scan_type = 0;
+	coex_sta->bt_ble_scan_para[0] = 0;
+	coex_sta->bt_ble_scan_para[1] = 0;
+	coex_sta->bt_ble_scan_para[2] = 0;
+	coex_sta->bt_reg_vendor_ac = 0xffff;
+	coex_sta->bt_reg_vendor_ae = 0xffff;
+	coex_sta->gnt_error_cnt = 0;
+	coex_sta->bt_relink_downcount = 0;
+
+	for (i = 0; i <= 9; i++)
+		coex_sta->bt_afh_map[i] = 0;
+
+#if 0
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_VENDOR, &vendor);
+	if (vendor == BTC_VENDOR_LENOVO)
+		coex_dm->switch_thres_offset = 0;
+	else
+		coex_dm->switch_thres_offset = 20;
+#endif
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	coex_sta->dis_ver_info_cnt = 0;
+
+	/* default isolation = 15dB */
+	coex_sta->isolation_btween_wb = BT_8723D_2ANT_DEFAULT_ISOLATION;
+	halbtc8723d2ant_coex_switch_threshold(btcoexist,
+					      coex_sta->isolation_btween_wb);
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+
+	/* BT report packet sample rate	 */
+	btcoexist->btc_write_1byte(btcoexist, 0x790, 0x5);
+
+	/* Init 0x778 = 0x1 for 2-Ant */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+
+	/* Enable PTA (3-wire function form BT side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x41, 0x02, 0x1);
+
+	/* Enable PTA (tx/rx signal form WiFi side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4c6, 0x10, 0x1);
+
+	halbtc8723d2ant_enable_gnt_to_gpio(btcoexist, true);
+
+#if 0
+	/* check if WL firmware download ok */
+	if (btcoexist->btc_read_1byte(btcoexist, 0x80) == 0xc6)
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+					 BT_8723D_2ANT_SCOREBOARD_ONOFF, true);
+#endif
+
+	/* Enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e,
+			   0x4); /* 0x76e[3] =1, WLAN_Act control by PTA */
+
+	/* WLAN_Tx by GNT_WL  0x950[29] = 0 */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x953, 0x20, 0x0);
+
+	halbtc8723d2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8723d2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+
+	psd_scan->ant_det_is_ant_det_available = true;
+
+	if (wifi_only) {
+		coex_sta->concurrent_rx_mode_on = false;
+		/* Path config	 */
+		/* Set Antenna Path */
+		halbtc8723d2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_2ANT_PHASE_WLANONLY_INIT);
+
+		btcoexist->stop_coex_dm = true;
+	} else {
+		/*Set BT polluted packet on for Tx rate adaptive not including Tx retry break by PTA, 0x45c[19] =1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x45e, 0x8, 0x1);
+
+		coex_sta->concurrent_rx_mode_on = true;
+		/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x953, 0x2, 0x1); */
+
+		/* RF 0x1[0] = 0->Set GNT_WL_RF_Rx always = 1 for con-current Rx */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0x1, 0x0);
+
+		/* Path config	 */
+		halbtc8723d2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_2ANT_PHASE_COEX_INIT);
+
+		btcoexist->stop_coex_dm = false;
+	}
+
+
+}
+
+u32 halbtc8723d2ant_psd_log2base(IN struct btc_coexist *btcoexist, IN u32 val)
+{
+	u8	j;
+	u32	tmp, tmp2, val_integerd_b = 0, tindex, shiftcount = 0;
+	u32	result, val_fractiond_b = 0, table_fraction[21] = {0, 432, 332, 274, 232, 200,
+				   174, 151, 132, 115, 100, 86, 74, 62, 51, 42,
+							   32, 23, 15, 7, 0
+							      };
+
+	if (val == 0)
+		return 0;
+
+	tmp = val;
+
+	while (1) {
+		if (tmp == 1)
+			break;
+		else {
+			tmp = (tmp >> 1);
+			shiftcount++;
+		}
+	}
+
+
+	val_integerd_b = shiftcount + 1;
+
+	tmp2 = 1;
+	for (j = 1; j <= val_integerd_b; j++)
+		tmp2 = tmp2 * 2;
+
+	tmp = (val * 100) / tmp2;
+	tindex = tmp / 5;
+
+	if (tindex > 20)
+		tindex = 20;
+
+	val_fractiond_b = table_fraction[tindex];
+
+	result = val_integerd_b * 100 - val_fractiond_b;
+
+	return result;
+
+
+}
+
+void halbtc8723d2ant_psd_show_antenna_detect_result(IN struct btc_coexist
+		*btcoexist)
+{
+	u8		*cli_buf = btcoexist->cli_buf;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n============[Antenna Detection info]  ============\n");
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->ant_det_result == 12) { /* Get Ant Det from BT  */
+
+		if (board_info->btdm_ant_num_by_ant_det == 1)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n %-35s = %s (%d~%d)",
+				   "Ant Det Result", "1-Antenna",
+				   BT_8723D_2ANT_ANTDET_PSDTHRES_1ANT,
+				BT_8723D_2ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION);
+		else {
+
+			if (psd_scan->ant_det_psd_scan_peak_val >
+			    (BT_8723D_2ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION)
+			    * 100)
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					   "\r\n %-35s = %s (>%d)",
+					"Ant Det Result", "2-Antenna (Bad-Isolation)",
+					BT_8723D_2ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION);
+			else
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					   "\r\n %-35s = %s (%d~%d)",
+					"Ant Det Result", "2-Antenna (Good-Isolation)",
+					BT_8723D_2ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION
+					   + psd_scan->ant_det_thres_offset,
+					BT_8723D_2ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION);
+		}
+
+	} else if (psd_scan->ant_det_result == 1)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (>%d)",
+			   "Ant Det Result", "2-Antenna (Bad-Isolation)",
+			   BT_8723D_2ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION);
+	else if (psd_scan->ant_det_result == 2)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (%d~%d)",
+			   "Ant Det Result", "2-Antenna (Good-Isolation)",
+			   BT_8723D_2ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION
+			   + psd_scan->ant_det_thres_offset,
+			   BT_8723D_2ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION);
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (%d~%d)",
+			   "Ant Det Result", "1-Antenna",
+			   BT_8723D_2ANT_ANTDET_PSDTHRES_1ANT,
+			   BT_8723D_2ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION
+			   + psd_scan->ant_det_thres_offset);
+
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s ",
+		   "Antenna Detection Finish",
+		   (board_info->btdm_ant_det_finish
+		    ? "Yes" : "No"));
+	CL_PRINTF(cli_buf);
+
+	switch (psd_scan->ant_det_result) {
+	case 0:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is not available)");
+		break;
+	case 1:  /* 2-Ant bad-isolation */
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available)");
+		break;
+	case 2:  /* 2-Ant good-isolation */
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available)");
+		break;
+	case 3:  /* 1-Ant */
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available)");
+		break;
+	case 4:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(Uncertainty result)");
+		break;
+	case 5:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "(Pre-Scan fai)");
+		break;
+	case 6:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(WiFi is Scanning)");
+		break;
+	case 7:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is not idle)");
+		break;
+	case 8:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(Abort by WiFi Scanning)");
+		break;
+	case 9:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(Antenna Init is not ready)");
+		break;
+	case 10:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is Inquiry or page)");
+		break;
+	case 11:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is Disabled)");
+	case 12:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available, result from BT");
+		break;
+	}
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->ant_det_result == 12) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d dB",
+			   "PSD Scan Peak Value",
+			   psd_scan->ant_det_psd_scan_peak_val / 100);
+		CL_PRINTF(cli_buf);
+		return;
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Ant Detect Total Count", psd_scan->ant_det_try_count);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Ant Detect Fail Count", psd_scan->ant_det_fail_count);
+	CL_PRINTF(cli_buf);
+
+	if ((!board_info->btdm_ant_det_finish) &&
+	    (psd_scan->ant_det_result != 5))
+		return;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "BT Response",
+		   (psd_scan->ant_det_result ? "ok" : "fail"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ms", "BT Tx Time",
+		   psd_scan->ant_det_bt_tx_time);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "BT Tx Ch",
+		   psd_scan->ant_det_bt_le_channel);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d",
+		   "WiFi PSD Cent-Ch/Offset/Span",
+		   psd_scan->real_cent_freq, psd_scan->real_offset,
+		   psd_scan->real_span);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d dB",
+		   "PSD Pre-Scan Peak Value",
+		   psd_scan->ant_det_pre_psdscan_peak_val / 100);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (<= %d)",
+		   "PSD Pre-Scan result",
+		   (psd_scan->ant_det_result != 5 ? "ok" : "fail"),
+		   BT_8723D_2ANT_ANTDET_PSDTHRES_BACKGROUND
+		   + psd_scan->ant_det_thres_offset);
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->ant_det_result == 5)
+		return;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s dB",
+		   "PSD Scan Peak Value", psd_scan->ant_det_peak_val);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s MHz",
+		   "PSD Scan Peak Freq", psd_scan->ant_det_peak_freq);
+	CL_PRINTF(cli_buf);
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "TFBGA Package",
+		   (board_info->tfbga_package) ?  "Yes" : "No");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "PSD Threshold Offset", psd_scan->ant_det_thres_offset);
+	CL_PRINTF(cli_buf);
+
+}
+
+void halbtc8723d2ant_psd_showdata(IN struct btc_coexist *btcoexist)
+{
+	u8		*cli_buf = btcoexist->cli_buf;
+	u32		delta_freq_per_point;
+	u32		freq, freq1, freq2, n = 0, i = 0, j = 0, m = 0, psd_rep1, psd_rep2;
+
+	if (psd_scan->ant_det_result == 12)
+		return;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n\n============[PSD info]  (%d)============\n",
+		   psd_scan->psd_gen_count);
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->psd_gen_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n No data !!\n");
+		CL_PRINTF(cli_buf);
+		return;
+	}
+
+	if (psd_scan->psd_point == 0)
+		delta_freq_per_point = 0;
+	else
+		delta_freq_per_point = psd_scan->psd_band_width /
+				       psd_scan->psd_point;
+
+	/* if (psd_scan->is_psd_show_max_only) */
+	if (0) {
+		psd_rep1 = psd_scan->psd_max_value / 100;
+		psd_rep2 = psd_scan->psd_max_value - psd_rep1 * 100;
+
+		freq = ((psd_scan->real_cent_freq - 20) * 1000000 +
+			psd_scan->psd_max_value_point * delta_freq_per_point);
+		freq1 = freq / 1000000;
+		freq2 = freq / 1000 - freq1 * 1000;
+
+		if (freq2 < 100)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n Freq = %d.0%d MHz",
+				   freq1, freq2);
+		else
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n Freq = %d.%d MHz",
+				   freq1, freq2);
+
+		if (psd_rep2 < 10)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   ", Value = %d.0%d dB, (%d)\n",
+				   psd_rep1, psd_rep2, psd_scan->psd_max_value);
+		else
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   ", Value = %d.%d dB, (%d)\n",
+				   psd_rep1, psd_rep2, psd_scan->psd_max_value);
+
+		CL_PRINTF(cli_buf);
+	} else {
+		m = psd_scan->psd_start_point;
+		n = psd_scan->psd_start_point;
+		i = 1;
+		j = 1;
+
+		while (1) {
+			do {
+				freq = ((psd_scan->real_cent_freq - 20) *
+					1000000 + m *
+					delta_freq_per_point);
+				freq1 = freq / 1000000;
+				freq2 = freq / 1000 - freq1 * 1000;
+
+				if (i == 1) {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Freq%6d.000",
+							   freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Freq%6d.0%2d",
+							   freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Freq%6d.%3d",
+							   freq1,
+							   freq2);
+				} else if ((i % 8 == 0) ||
+					   (m == psd_scan->psd_stop_point)) {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.000\n", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.0%2d\n", freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.%3d\n", freq1,
+							   freq2);
+				} else {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.000", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.0%2d", freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.%3d", freq1,
+							   freq2);
+				}
+
+				i++;
+				m++;
+				CL_PRINTF(cli_buf);
+
+			} while ((i <= 8) && (m <= psd_scan->psd_stop_point));
+
+
+			do {
+				psd_rep1 = psd_scan->psd_report_max_hold[n] /
+					   100;
+				psd_rep2 = psd_scan->psd_report_max_hold[n] -
+					   psd_rep1 *
+					   100;
+
+				if (j == 1) {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Val %7d.0%d",
+							   psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Val %7d.%d",
+							   psd_rep1,
+							   psd_rep2);
+				} else if ((j % 8 == 0)  ||
+					   (n == psd_scan->psd_stop_point)) {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							"%7d.0%d\n", psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%7d.%d\n", psd_rep1,
+							   psd_rep2);
+				} else {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%7d.0%d", psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%7d.%d", psd_rep1,
+							   psd_rep2);
+				}
+
+				j++;
+				n++;
+				CL_PRINTF(cli_buf);
+
+			} while ((j <= 8) && (n <= psd_scan->psd_stop_point));
+
+			if ((m > psd_scan->psd_stop_point) ||
+			    (n > psd_scan->psd_stop_point))
+				break;
+			else {
+				i = 1;
+				j = 1;
+			}
+
+		}
+	}
+
+
+}
+
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+void halbtc8723d2ant_psd_maxholddata(IN struct btc_coexist *btcoexist,
+				     IN u32 gen_count)
+{
+	u32 i = 0;
+	u32 loop_i_max = 0, loop_val_max = 0;
+
+	if (gen_count == 1) {
+		memcpy(psd_scan->psd_report_max_hold,
+		       psd_scan->psd_report,
+		       BT_8723D_2ANT_ANTDET_PSD_POINTS * sizeof(u32));
+	}
+
+	for (i = psd_scan->psd_start_point;
+	     i <= psd_scan->psd_stop_point; i++) {
+
+		/* update max-hold value at each freq point */
+		if (psd_scan->psd_report[i] > psd_scan->psd_report_max_hold[i])
+			psd_scan->psd_report_max_hold[i] =
+				psd_scan->psd_report[i];
+
+		/*	search the max value in this seep */
+		if (psd_scan->psd_report[i] > loop_val_max) {
+			loop_val_max = psd_scan->psd_report[i];
+			loop_i_max = i;
+		}
+	}
+
+	if (gen_count <= BT_8723D_2ANT_ANTDET_PSD_SWWEEPCOUNT)
+		psd_scan->psd_loop_max_value[gen_count - 1] = loop_val_max;
+
+}
+
+
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+u32 halbtc8723d2ant_psd_getdata(IN struct btc_coexist *btcoexist, IN u32 point)
+{
+	/* reg 0x808[9:0]: FFT data x */
+	/* reg 0x808[22]: 0-->1 to get 1 FFT data y */
+	/* reg 0x8b4[15:0]: FFT data y report */
+
+	u32 val = 0, psd_report = 0;
+	int k = 0;
+
+	val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+
+	val &= 0xffbffc00;
+	val |= point;
+
+	btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+	val |= 0x00400000;
+	btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+	while (1) {
+		if (k++ > BT_8723D_2ANT_ANTDET_SWEEPPOINT_DELAY)
+			break;
+	}
+
+	val = btcoexist->btc_read_4byte(btcoexist, 0x8b4);
+
+	psd_report = val & 0x0000ffff;
+
+	return psd_report;
+}
+
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+boolean halbtc8723d2ant_psd_sweep_point(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN s32 offset, IN u32 span, IN u32 points,
+					IN u32 avgnum, IN u32 loopcnt)
+{
+	u32	 i = 0, val = 0, n = 0, k = 0, j, point_index = 0;
+	u32	points1 = 0, psd_report = 0;
+	u32	start_p = 0, stop_p = 0, delta_freq_per_point = 156250;
+	u32    psd_center_freq = 20 * 10 ^ 6;
+	boolean outloop = false, scan , roam, is_sweep_ok = true;
+	u8	 flag = 0;
+	u32	tmp = 0, u32tmp1 = 0;
+	u32	wifi_original_channel = 1;
+	u32 psd_sum = 0, avg_cnt = 0;
+	u32	i_max = 0, val_max = 0, val_max2 = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx PSD Sweep Start!!\n");
+	BTC_TRACE(trace_buf);
+
+	do {
+		switch (flag) {
+		case 0:  /* Get PSD parameters */
+		default:
+
+			psd_scan->psd_band_width = 40 * 1000000;
+			psd_scan->psd_point = points;
+			psd_scan->psd_start_base = points / 2;
+			psd_scan->psd_avg_num = avgnum;
+			psd_scan->real_cent_freq = cent_freq;
+			psd_scan->real_offset = offset;
+			psd_scan->real_span = span;
+
+
+			points1 = psd_scan->psd_point;
+			delta_freq_per_point = psd_scan->psd_band_width /
+					       psd_scan->psd_point;
+
+			/* PSD point setup */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+			val &= 0xffff0fff;
+
+			switch (psd_scan->psd_point) {
+			case 128:
+				val |= 0x0;
+				break;
+			case 256:
+			default:
+				val |= 0x00004000;
+				break;
+			case 512:
+				val |= 0x00008000;
+				break;
+			case 1024:
+				val |= 0x0000c000;
+				break;
+			}
+
+			switch (psd_scan->psd_avg_num) {
+			case 1:
+				val |= 0x0;
+				break;
+			case 8:
+				val |= 0x00001000;
+				break;
+			case 16:
+				val |= 0x00002000;
+				break;
+			case 32:
+			default:
+				val |= 0x00003000;
+				break;
+			}
+			btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+			flag = 1;
+			break;
+		case 1:	  /* calculate the PSD point index from freq/offset/span */
+			psd_center_freq = psd_scan->psd_band_width / 2 +
+					  offset * (1000000);
+
+			start_p = psd_scan->psd_start_base + (psd_center_freq -
+				span * (1000000) / 2) / delta_freq_per_point;
+			psd_scan->psd_start_point = start_p -
+						    psd_scan->psd_start_base;
+
+			stop_p = psd_scan->psd_start_base + (psd_center_freq +
+				span * (1000000) / 2) / delta_freq_per_point;
+			psd_scan->psd_stop_point = stop_p -
+						   psd_scan->psd_start_base - 1;
+
+			flag = 2;
+			break;
+		case 2:  /* set RF channel/BW/Mode */
+
+			/* set 3-wire off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x88c);
+			val |= 0x00300000;
+			btcoexist->btc_write_4byte(btcoexist, 0x88c, val);
+
+			/* CCK off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x800);
+			val &= 0xfeffffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x800, val);
+
+			/* Tx-pause on */
+			btcoexist->btc_write_1byte(btcoexist, 0x522, 0x6f);
+
+			/* store WiFi original channel */
+			wifi_original_channel = btcoexist->btc_get_rf_reg(
+					btcoexist, BTC_RF_A, 0x18, 0x3ff);
+
+			/* Set RF channel */
+			if (cent_freq == 2484)
+				btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A,
+							  0x18, 0x3ff, 0xe);
+			else
+				btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A,
+					  0x18, 0x3ff, (cent_freq - 2412) / 5 +
+						  1); /* WiFi TRx Mask on */
+
+			/* save original RCK value */
+			u32tmp1 =  btcoexist->btc_get_rf_reg(
+					   btcoexist, BTC_RF_A, 0x1d, 0xfffff);
+
+			/* Enter debug mode */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xde,
+						  0x2, 0x1);
+
+			/* Set RF Rx filter corner */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1d,
+						  0xfffff, 0x2e);
+
+
+			/* Set  RF mode = Rx, RF Gain = 0x320a0 */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x0,
+						  0xfffff, 0x320a0);
+
+			while (1) {
+				if (k++ > BT_8723D_2ANT_ANTDET_SWEEPPOINT_DELAY)
+					break;
+			}
+			flag = 3;
+			break;
+		case 3:
+			psd_scan->psd_gen_count = 0;
+			for (j = 1; j <= loopcnt; j++) {
+
+				btcoexist->btc_get(btcoexist,
+						   BTC_GET_BL_WIFI_SCAN, &scan);
+				btcoexist->btc_get(btcoexist,
+						   BTC_GET_BL_WIFI_ROAM, &roam);
+
+				if (scan || roam) {
+					is_sweep_ok = false;
+					break;
+				}
+				memset(psd_scan->psd_report, 0,
+				       psd_scan->psd_point * sizeof(u32));
+				start_p = psd_scan->psd_start_point +
+					  psd_scan->psd_start_base;
+				stop_p = psd_scan->psd_stop_point +
+					 psd_scan->psd_start_base + 1;
+
+				i = start_p;
+				point_index = 0;
+
+				while (i < stop_p) {
+					if (i >= points1)
+						psd_report =
+							halbtc8723d2ant_psd_getdata(
+							btcoexist, i - points1);
+					else
+						psd_report =
+							halbtc8723d2ant_psd_getdata(
+								btcoexist, i);
+
+					if (psd_report == 0)
+						tmp = 0;
+					else
+						/* tmp =  20*log10((double)psd_report); */
+						/* 20*log2(x)/log2(10), log2Base return theresult of the psd_report*100 */
+						tmp = 6 * halbtc8723d2ant_psd_log2base(
+							btcoexist, psd_report);
+
+					n = i - psd_scan->psd_start_base;
+					psd_scan->psd_report[n] =  tmp;
+
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"Point=%d, psd_dB_data = %d\n",
+						    i, psd_scan->psd_report[n]);
+					BTC_TRACE(trace_buf);
+
+					i++;
+
+				}
+
+				halbtc8723d2ant_psd_maxholddata(btcoexist, j);
+
+				psd_scan->psd_gen_count = j;
+
+				/*Accumulate Max PSD value in this loop if the value > threshold */
+				if (psd_scan->psd_loop_max_value[j - 1] >=
+				    4000) {
+					psd_sum = psd_sum +
+						psd_scan->psd_loop_max_value[j -
+								       1];
+					avg_cnt++;
+				}
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "Loop=%d, Max_dB_data = %d\n",
+					    j, psd_scan->psd_loop_max_value[j
+							    - 1]);
+				BTC_TRACE(trace_buf);
+
+			}
+
+			if (loopcnt == BT_8723D_2ANT_ANTDET_PSD_SWWEEPCOUNT) {
+
+				/* search the Max Value between each-freq-point-max-hold value of all sweep*/
+				for (i = 1;
+				     i <= BT_8723D_2ANT_ANTDET_PSD_SWWEEPCOUNT;
+				     i++) {
+
+					if (i == 1) {
+						i_max = i;
+						val_max = psd_scan->psd_loop_max_value[i
+								       - 1];
+						val_max2 =
+							psd_scan->psd_loop_max_value[i
+								     - 1];
+					} else if (
+						psd_scan->psd_loop_max_value[i -
+							     1] > val_max) {
+						val_max2 = val_max;
+						i_max = i;
+						val_max = psd_scan->psd_loop_max_value[i
+								       - 1];
+					} else if (
+						psd_scan->psd_loop_max_value[i -
+							     1] > val_max2)
+						val_max2 =
+							psd_scan->psd_loop_max_value[i
+								     - 1];
+
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"i = %d, val_hold= %d, val_max = %d, val_max2 = %d\n",
+						i, psd_scan->psd_loop_max_value[i
+								    - 1],
+						    val_max, val_max2);
+
+					BTC_TRACE(trace_buf);
+				}
+
+				psd_scan->psd_max_value_point = i_max;
+				psd_scan->psd_max_value = val_max;
+				psd_scan->psd_max_value2 = val_max2;
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "val_max = %d, val_max2 = %d\n",
+					    psd_scan->psd_max_value,
+					    psd_scan->psd_max_value2);
+				BTC_TRACE(trace_buf);
+			}
+
+			if (avg_cnt != 0) {
+				psd_scan->psd_avg_value = (psd_sum / avg_cnt);
+				if ((psd_sum % avg_cnt) >= (avg_cnt / 2))
+					psd_scan->psd_avg_value++;
+			} else
+				psd_scan->psd_avg_value = 0;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "AvgLoop=%d, Avg_dB_data = %d\n",
+				    avg_cnt, psd_scan->psd_avg_value);
+			BTC_TRACE(trace_buf);
+
+			flag = 100;
+			break;
+		case 99:	/* error */
+
+			outloop = true;
+			break;
+		case 100: /* recovery */
+
+			/* set 3-wire on */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x88c);
+			val &= 0xffcfffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x88c, val);
+
+			/* CCK on */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x800);
+			val |= 0x01000000;
+			btcoexist->btc_write_4byte(btcoexist, 0x800, val);
+
+			/* Tx-pause off */
+			btcoexist->btc_write_1byte(btcoexist, 0x522, 0x0);
+
+			/* PSD off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+			val &= 0xffbfffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+			/* restore RF Rx filter corner */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1d,
+						  0xfffff, u32tmp1);
+
+			/* Exit debug mode */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xde,
+						  0x2, 0x0);
+
+			/* restore WiFi original channel */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x18,
+						  0x3ff, wifi_original_channel);
+
+			outloop = true;
+			break;
+
+		}
+
+	} while (!outloop);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx PSD Sweep Stop!!\n");
+	BTC_TRACE(trace_buf);
+	return is_sweep_ok;
+
+}
+
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+boolean halbtc8723d2ant_psd_antenna_detection(IN struct btc_coexist
+		*btcoexist)
+{
+	u32	i = 0;
+	u32	wlpsd_cent_freq = 2484, wlpsd_span = 2;
+	s32	wlpsd_offset = -4;
+	u32 bt_tx_time, bt_le_channel;
+	u8	bt_le_ch[13] = {3, 6, 8, 11, 13, 16, 18, 21, 23, 26, 28, 31, 33};
+
+	u8	h2c_parameter[3] = {0}, u8tmpa, u8tmpb;
+
+	u8	state = 0;
+	boolean		outloop = false, bt_resp = false, ant_det_finish = false;
+	u32		freq, freq1, freq2, psd_rep1, psd_rep2, delta_freq_per_point,
+			u32tmp, u32tmp0, u32tmp1, u32tmp2 ;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	memset(psd_scan->ant_det_peak_val, 0, 16 * sizeof(u8));
+	memset(psd_scan->ant_det_peak_freq, 0, 16 * sizeof(u8));
+
+	psd_scan->ant_det_bt_tx_time =
+		BT_8723D_2ANT_ANTDET_BTTXTIME;	   /* 0.42ms*50 = 20ms (0.42ms = 1 PSD sweep) */
+	psd_scan->ant_det_bt_le_channel = BT_8723D_2ANT_ANTDET_BTTXCHANNEL;
+
+	bt_tx_time = psd_scan->ant_det_bt_tx_time;
+	bt_le_channel = psd_scan->ant_det_bt_le_channel;
+
+	if (board_info->tfbga_package) /* for TFBGA */
+		psd_scan->ant_det_thres_offset = 5;
+	else
+		psd_scan->ant_det_thres_offset = 0;
+
+	do {
+		switch (state) {
+		case 0:
+			if (bt_le_channel == 39)
+				wlpsd_cent_freq = 2484;
+			else {
+				for (i = 1; i <= 13; i++) {
+					if (bt_le_ch[i - 1] ==
+					    bt_le_channel) {
+						wlpsd_cent_freq = 2412
+								  + (i - 1) * 5;
+						break;
+					}
+				}
+
+				if (i == 14) {
+
+					BTC_SPRINTF(trace_buf,
+						    BT_TMP_BUF_SIZE,
+						"xxxxxxxxxxxxxxxx AntennaDetect(), Abort!!, Invalid LE channel = %d\n ",
+						    bt_le_channel);
+					BTC_TRACE(trace_buf);
+					outloop = true;
+					break;
+				}
+			}
+#if 0
+			wlpsd_sweep_count = bt_tx_time * 238 /
+					    100; /* bt_tx_time/0.42								 */
+			wlpsd_sweep_count = wlpsd_sweep_count / 5;
+
+			if (wlpsd_sweep_count % 5 != 0)
+				wlpsd_sweep_count = (wlpsd_sweep_count /
+						     5 + 1) * 5;
+#endif
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), BT_LETxTime=%d,  BT_LECh = %d\n",
+				    bt_tx_time, bt_le_channel);
+			BTC_TRACE(trace_buf);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), wlpsd_cent_freq=%d,  wlpsd_offset = %d, wlpsd_span = %d, wlpsd_sweep_count = %d\n",
+				    wlpsd_cent_freq,
+				    wlpsd_offset,
+				    wlpsd_span,
+				    BT_8723D_2ANT_ANTDET_PSD_SWWEEPCOUNT);
+			BTC_TRACE(trace_buf);
+
+			state = 1;
+			break;
+		case 1: /* stop coex DM & set antenna path */
+			/* Stop Coex DM */
+			btcoexist->stop_coex_dm = true;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Stop Coex DM!!\n");
+			BTC_TRACE(trace_buf);
+
+			/* Set TDMA off,				 */
+			halbtc8723d2ant_ps_tdma(btcoexist, FORCE_EXEC,
+						false, 0);
+
+			/* Set coex table */
+			halbtc8723d2ant_coex_table_with_type(btcoexist,
+							     FORCE_EXEC, 0);
+
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna at Main Port\n");
+				BTC_TRACE(trace_buf);
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna at Aux Port\n");
+				BTC_TRACE(trace_buf);
+			}
+
+			/* Set Antenna path, switch WiFi to un-certain antenna port */
+			/* Set Antenna Path,  both GNT_WL/GNT_BT = 1, and control by SW */
+			halbtc8723d2ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+						     FORCE_EXEC,
+					     BT_8723D_2ANT_PHASE_ANTENNA_DET);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set Antenna to BT!!\n");
+			BTC_TRACE(trace_buf);
+
+			/* Set AFH mask on at WiFi channel 2472MHz +/- 10MHz */
+			h2c_parameter[0] = 0x1;
+			h2c_parameter[1] = 0xd;
+			h2c_parameter[2] = 0x14;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set AFH on, Cent-Ch= %d,  Mask=%d\n",
+				    h2c_parameter[1],
+				    h2c_parameter[2]);
+			BTC_TRACE(trace_buf);
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x66, 3,
+						h2c_parameter);
+
+			u32tmp = btcoexist->btc_read_2byte(btcoexist, 0x948);
+			u32tmp0 = btcoexist->btc_read_4byte(btcoexist, 0x70);
+			u32tmp1 = halbtc8723d2ant_ltecoex_indirect_read_reg(
+					  btcoexist, 0x38);
+			u32tmp2 = halbtc8723d2ant_ltecoex_indirect_read_reg(
+					  btcoexist, 0x54);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** 0x948 = 0x%x, 0x70 = 0x%x, 0x38= 0x%x, 0x54= 0x%x (Before Ant Det)\n",
+				    u32tmp, u32tmp0, u32tmp1, u32tmp2);
+			BTC_TRACE(trace_buf);
+
+			state = 2;
+			break;
+		case 2:	/* Pre-sweep background psd */
+			if (!halbtc8723d2ant_psd_sweep_point(btcoexist,
+				     wlpsd_cent_freq, wlpsd_offset, wlpsd_span,
+					     BT_8723D_2ANT_ANTDET_PSD_POINTS,
+				     BT_8723D_2ANT_ANTDET_PSD_AVGNUM, 3)) {
+				ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				psd_scan->ant_det_result = 8;
+				state = 99;
+				break;
+			}
+
+			psd_scan->ant_det_pre_psdscan_peak_val =
+				psd_scan->psd_max_value;
+
+			if (psd_scan->ant_det_pre_psdscan_peak_val >
+			    (BT_8723D_2ANT_ANTDET_PSDTHRES_BACKGROUND
+			     + psd_scan->ant_det_thres_offset) * 100) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Abort Antenna Detection!! becaus background = %d > thres (%d)\n",
+					psd_scan->ant_det_pre_psdscan_peak_val /
+					    100,
+					BT_8723D_2ANT_ANTDET_PSDTHRES_BACKGROUND
+					    + psd_scan->ant_det_thres_offset);
+				BTC_TRACE(trace_buf);
+				ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				psd_scan->ant_det_result = 5;
+				state = 99;
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Start Antenna Detection!! becaus background = %d <= thres (%d)\n",
+					psd_scan->ant_det_pre_psdscan_peak_val /
+					    100,
+					BT_8723D_2ANT_ANTDET_PSDTHRES_BACKGROUND
+					    + psd_scan->ant_det_thres_offset);
+				BTC_TRACE(trace_buf);
+				state = 3;
+			}
+			break;
+		case 3:
+			bt_resp = btcoexist->btc_set_bt_ant_detection(
+					  btcoexist, (u8)(bt_tx_time & 0xff),
+					  (u8)(bt_le_channel & 0xff));
+
+			/* Sync WL Rx PSD with BT Tx time because H2C->Mailbox delay */
+			delay_ms(20);
+
+			if (!halbtc8723d2ant_psd_sweep_point(btcoexist,
+					     wlpsd_cent_freq, wlpsd_offset,
+							     wlpsd_span,
+					     BT_8723D_2ANT_ANTDET_PSD_POINTS,
+					     BT_8723D_2ANT_ANTDET_PSD_AVGNUM,
+				     BT_8723D_2ANT_ANTDET_PSD_SWWEEPCOUNT)) {
+				ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				psd_scan->ant_det_result = 8;
+				state = 99;
+				break;
+			}
+
+#if 1
+			psd_scan->ant_det_psd_scan_peak_val =
+				psd_scan->psd_max_value;
+#endif
+#if 0
+			psd_scan->ant_det_psd_scan_peak_val =
+				((psd_scan->psd_max_value - psd_scan->psd_avg_value) <
+				 800) ?
+				psd_scan->psd_max_value : ((
+						psd_scan->psd_max_value -
+					psd_scan->psd_max_value2 <= 300) ?
+						   psd_scan->psd_avg_value :
+						   psd_scan->psd_max_value2);
+#endif
+			psd_scan->ant_det_psd_scan_peak_freq =
+				psd_scan->psd_max_value_point;
+			state = 4;
+			break;
+		case 4:
+
+			if (psd_scan->psd_point == 0)
+				delta_freq_per_point = 0;
+			else
+				delta_freq_per_point =
+					psd_scan->psd_band_width /
+					psd_scan->psd_point;
+
+			psd_rep1 = psd_scan->ant_det_psd_scan_peak_val / 100;
+			psd_rep2 = psd_scan->ant_det_psd_scan_peak_val -
+				   psd_rep1 *
+				   100;
+
+			freq = ((psd_scan->real_cent_freq - 20) *
+				1000000 + psd_scan->psd_max_value_point
+				* delta_freq_per_point);
+			freq1 = freq / 1000000;
+			freq2 = freq / 1000 - freq1 * 1000;
+
+			if (freq2 < 100) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Max Value: Freq = %d.0%d MHz",
+					    freq1, freq2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_freq,
+					   BT_8723D_2ANT_ANTDET_BUF_LEN,
+					   "%d.0%d", freq1, freq2);
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Max Value: Freq = %d.%d MHz",
+					    freq1, freq2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_freq,
+					   BT_8723D_2ANT_ANTDET_BUF_LEN,
+					   "%d.%d", freq1, freq2);
+			}
+
+			if (psd_rep2 < 10) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    ", Value = %d.0%d dB\n",
+					    psd_rep1, psd_rep2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_val,
+					   BT_8723D_2ANT_ANTDET_BUF_LEN,
+					   "%d.0%d", psd_rep1, psd_rep2);
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    ", Value = %d.%d dB\n",
+					    psd_rep1, psd_rep2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_val,
+					   BT_8723D_2ANT_ANTDET_BUF_LEN,
+					   "%d.%d", psd_rep1, psd_rep2);
+			}
+
+			psd_scan->ant_det_is_btreply_available = true;
+
+			if (bt_resp == false) {
+				psd_scan->ant_det_is_btreply_available =
+					false;
+				psd_scan->ant_det_result = 0;
+				ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), BT Response = Fail\n ");
+				BTC_TRACE(trace_buf);
+			} else if (psd_scan->ant_det_psd_scan_peak_val >
+				(BT_8723D_2ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION)
+				   * 100) {
+				psd_scan->ant_det_result = 1;
+				ant_det_finish = true;
+				board_info->btdm_ant_num_by_ant_det = 2;
+				coex_sta->isolation_btween_wb = (u8)(85 -
+					psd_scan->ant_det_psd_scan_peak_val /
+							     100) & 0xff;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 2-Ant, Bad-Isolation!!\n");
+				BTC_TRACE(trace_buf);
+			} else if (psd_scan->ant_det_psd_scan_peak_val >
+				(BT_8723D_2ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION
+				    + psd_scan->ant_det_thres_offset) * 100) {
+				psd_scan->ant_det_result = 2;
+				ant_det_finish = true;
+				board_info->btdm_ant_num_by_ant_det = 2;
+				coex_sta->isolation_btween_wb = (u8)(85 -
+					psd_scan->ant_det_psd_scan_peak_val /
+							     100) & 0xff;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 2-Ant, Good-Isolation!!\n");
+				BTC_TRACE(trace_buf);
+			} else if (psd_scan->ant_det_psd_scan_peak_val >
+				   (BT_8723D_2ANT_ANTDET_PSDTHRES_1ANT) *
+				   100) {
+				psd_scan->ant_det_result = 3;
+				ant_det_finish = true;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				coex_sta->isolation_btween_wb = (u8)(85 -
+					psd_scan->ant_det_psd_scan_peak_val /
+							     100) & 0xff;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 1-Ant!!\n");
+				BTC_TRACE(trace_buf);
+			} else {
+				psd_scan->ant_det_result = 4;
+				ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 1-Ant, un-certainity!!\n");
+				BTC_TRACE(trace_buf);
+			}
+
+			state = 99;
+			break;
+		case 99:  /* restore setup */
+
+			/* Set AFH mask off at WiFi channel 2472MHz +/- 10MHz */
+			h2c_parameter[0] = 0x0;
+			h2c_parameter[1] = 0x0;
+			h2c_parameter[2] = 0x0;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set AFH on, Cent-Ch= %d,  Mask=%d\n",
+				    h2c_parameter[1], h2c_parameter[2]);
+			BTC_TRACE(trace_buf);
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x66, 3,
+						h2c_parameter);
+
+			/* Set Antenna Path, GNT_WL/GNT_BT control by PTA */
+			/* Set Antenna path, switch WiFi to certain antenna port */
+			halbtc8723d2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO, FORCE_EXEC,
+					     BT_8723D_2ANT_PHASE_2G_RUNTIME);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set Antenna to PTA\n!!");
+			BTC_TRACE(trace_buf);
+
+			btcoexist->stop_coex_dm = false;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Resume Coex DM\n!!");
+			BTC_TRACE(trace_buf);
+
+			outloop = true;
+			break;
+		}
+
+	} while (!outloop);
+
+	return ant_det_finish;
+
+}
+
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+boolean halbtc8723d2ant_psd_antenna_detection_check(IN struct btc_coexist
+		*btcoexist)
+{
+	static u32 ant_det_count = 0, ant_det_fail_count = 0;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	boolean scan, roam, ant_det_finish = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+	ant_det_count++;
+
+	psd_scan->ant_det_try_count = ant_det_count;
+
+	if (scan || roam) {
+		ant_det_finish = false;
+		psd_scan->ant_det_result = 6;
+	} else if (coex_sta->bt_disabled) {
+		ant_det_finish = false;
+		psd_scan->ant_det_result = 11;
+	} else if (coex_sta->num_of_profile >= 1) {
+		ant_det_finish = false;
+		psd_scan->ant_det_result = 7;
+	} else if (
+		!psd_scan->ant_det_is_ant_det_available) { /* Antenna initial setup is not ready */
+		ant_det_finish = false;
+		psd_scan->ant_det_result = 9;
+	} else if (coex_sta->c2h_bt_inquiry_page) {
+		ant_det_finish = false;
+		psd_scan->ant_det_result = 10;
+	} else {
+
+		ant_det_finish = halbtc8723d2ant_psd_antenna_detection(
+					 btcoexist);
+
+		delay_ms(psd_scan->ant_det_bt_tx_time);
+	}
+
+
+	if (!ant_det_finish)
+		ant_det_fail_count++;
+
+	psd_scan->ant_det_fail_count = ant_det_fail_count;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"xxxxxxxxxxxxxxxx AntennaDetect(), result = %d, fail_count = %d, finish = %s\n",
+		    psd_scan->ant_det_result,
+		    psd_scan->ant_det_fail_count,
+		    ant_det_finish == true ? "Yes" : "No");
+	BTC_TRACE(trace_buf);
+
+	return ant_det_finish;
+
+}
+
+
+/* ************************************************************
+ * work around function start with wa_halbtc8723d2ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8723d2ant_
+ * ************************************************************ */
+void ex_halbtc8723d2ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x0;
+	u16 u16tmp = 0x0;
+	u32	value = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"xxxxxxxxxxxxxxxx Execute 8723d 2-Ant PowerOn Setting xxxxxxxxxxxxxxxx!!\n");
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "Ant Det Finish = %s, Ant Det Number  = %d\n",
+		    (board_info->btdm_ant_det_finish ? "Yes" : "No"),
+		    board_info->btdm_ant_num_by_ant_det);
+	BTC_TRACE(trace_buf);
+
+
+	btcoexist->stop_coex_dm = true;
+	psd_scan->ant_det_is_ant_det_available = false;
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write BB Register correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+
+	/* Set path control to WL */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x80, 0x1);
+	btcoexist->btc_write_2byte(btcoexist, 0x948, 0x0);
+
+	/* Check efuse 0xc3[6] for Single Antenna Path */
+	if (board_info->single_ant_path == 0) {
+		/* set to S1 */
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+		u8tmp = 4;
+		value = 1;
+	} else if (board_info->single_ant_path == 1) {
+		/* set to S0 */
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+		u8tmp = 5;
+		value = 0;
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (Power On) single_ant_path  = %d, btdm_ant_pos = %d **********\n",
+		    board_info->single_ant_path , board_info->btdm_ant_pos);
+	BTC_TRACE(trace_buf);
+
+	/* Set Antenna Path to BT side */
+	halbtc8723d2ant_set_ant_path(btcoexist,
+				     BTC_ANT_PATH_AUTO,
+				     FORCE_EXEC,
+				     BT_8723D_1ANT_PHASE_COEX_POWERON);
+
+	/* Write Single Antenna Position to Registry to tell BT for 872db. This line can be removed
+	since BT EFuse also add "single antenna position" in EFuse for 8723d*/
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_ANTPOSREGRISTRY_CTRL,
+			   &value);
+
+	/* Save"single antenna position" info in Local register setting for FW reading, because FW may not ready at  power on */
+	if (btcoexist->chip_interface == BTC_INTF_PCI)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x3e0, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_USB)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60, u8tmp);
+
+	/* enable GNT_WL/GNT_BT debug signal to GPIO14/15 */
+	halbtc8723d2ant_enable_gnt_to_gpio(btcoexist, true);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********  LTE coex Reg 0x38 (Power-On) = 0x%x**********\n",
+		    halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist, 0x38));
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********  MAC Reg 0x70/ BB Reg 0x948 (Power-On) = 0x%x / 0x%x**********\n",
+		    btcoexist->btc_read_4byte(btcoexist, 0x70),
+		    btcoexist->btc_read_2byte(btcoexist, 0x948));
+	BTC_TRACE(trace_buf);
+}
+
+void ex_halbtc8723d2ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x4; /* Set BIT2 by default since it's 2ant case */
+
+	/* */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+	if (btcoexist->chip_interface == BTC_INTF_USB) {
+		/* fixed at S0 for USB interface */
+		u8tmp |= 0x1;	/* antenna inverse */
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	} else {
+		/* for PCIE and SDIO interface, we check efuse 0xc3[6] */
+		if (board_info->single_ant_path == 0) {
+		} else if (board_info->single_ant_path == 1) {
+			/* set to S0 */
+			u8tmp |= 0x1;	/* antenna inverse */
+		}
+
+		if (btcoexist->chip_interface == BTC_INTF_PCI)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x3e0,
+							     u8tmp);
+		else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60,
+							     u8tmp);
+	}
+}
+
+
+void ex_halbtc8723d2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8723d2ant_init_hw_config(btcoexist, wifi_only);
+}
+
+void ex_halbtc8723d2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8723d2ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8723d2ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, ps_tdma_case = 0;
+	u32				u32tmp[4];
+	u16				u16tmp[4];
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck, bt_coex_ver = 0;
+	u32				fw_ver = 0, bt_patch_ver = 0;
+	static u8			pop_report_in_10s = 0;
+	u32			phyver = 0;
+	boolean			lte_coex_on = false;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	if (psd_scan->ant_det_try_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %s",
+			   "Ant PG Num/ Mech/ Pos",
+			   board_info->pg_ant_num, board_info->btdm_ant_num,
+			   (board_info->btdm_ant_pos == 1 ? "S1" : "S0"));
+		CL_PRINTF(cli_buf);
+	} else {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n %-35s = %d/ %d/ %s  (retry=%d/fail=%d/result=%d)",
+			   "Ant PG Num/ Mech(Ant_Det)/ Pos",
+			   board_info->pg_ant_num,
+			   board_info->btdm_ant_num_by_ant_det,
+			   (board_info->btdm_ant_pos == 1 ? "S1" : "S0"),
+			   psd_scan->ant_det_try_count,
+			   psd_scan->ant_det_fail_count,
+			   psd_scan->ant_det_result);
+		CL_PRINTF(cli_buf);
+
+		if (board_info->btdm_ant_det_finish) {
+
+			if (psd_scan->ant_det_result != 12)
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					   "\r\n %-35s = %s",
+					   "Ant Det PSD Value",
+					   psd_scan->ant_det_peak_val);
+			else
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					   "\r\n %-35s = %d",
+					   "Ant Det PSD Value",
+					   psd_scan->ant_det_psd_scan_peak_val
+					   / 100);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	if (board_info->ant_det_result_five_complete) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d",
+			   "AntDet(Registry) Num/PSD Value",
+			   board_info->btdm_ant_num_by_ant_det,
+			   (board_info->antdetval & 0x7f));
+		CL_PRINTF(cli_buf);
+	}
+
+
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+
+	bt_coex_ver = coex_sta->bt_coex_supported_version & 0xff;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+				"CoexVer WL/  BT_Desired/ BT_Report",
+				glcoex_ver_date_8723d_2ant, glcoex_ver_8723d_2ant,
+				glcoex_ver_btdesired_8723d_2ant,
+				bt_coex_ver,
+				(bt_coex_ver == 0xff ? "Unknown" :
+				(coex_sta->bt_disabled ? "BT-disable" :
+				(bt_coex_ver >= glcoex_ver_btdesired_8723d_2ant ?
+				"Match" : "Mis-Match"))));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d/ %c",
+		   "W_FW/ B_FW/ Phy/ Kt",
+		   fw_ver, bt_patch_ver, phyver,
+		   coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d ",
+		   "Isolation/WL_Thres/BT_Thres",
+		   coex_sta->isolation_btween_wb,
+		   coex_sta->wifi_coex_thres,
+		   coex_sta->bt_coex_thres);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	pop_report_in_10s++;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = [%s/ %d dBm/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt/ popCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+			   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page")
+			   : ((BT_8723D_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8723D_2ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi - 100, coex_sta->bt_retry_cnt,
+		   coex_sta->pop_event_cnt);
+	CL_PRINTF(cli_buf);
+
+	if (pop_report_in_10s >= 5) {
+		coex_sta->pop_event_cnt = 0;
+		pop_report_in_10s = 0;
+	}
+
+
+	if (coex_sta->num_of_profile != 0)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %s%s%s%s%s",
+			   "Profiles",
+			   ((bt_link_info->a2dp_exist) ? "A2DP," : ""),
+			   ((bt_link_info->sco_exist) ?  "SCO," : ""),
+			   ((bt_link_info->hid_exist) ?
+			    ((coex_sta->hid_busy_num >= 2) ? "HID(4/18)," :
+			     "HID(2/18),") : ""),
+			   ((bt_link_info->pan_exist) ?  "PAN," : ""),
+			   ((coex_sta->voice_over_HOGP) ? "Voice" : ""));
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = None",
+			   "Profiles");
+
+	CL_PRINTF(cli_buf);
+
+
+	if (bt_link_info->a2dp_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %d/ %s",
+			   "A2DP Rate/Bitpool/Auto_Slot",
+			   ((coex_sta->is_A2DP_3M) ? "3M" : "No_3M"),
+			   coex_sta->a2dp_bit_pool,
+			   ((coex_sta->is_autoslot) ? "On" : "Off")
+			  );
+		CL_PRINTF(cli_buf);
+	}
+
+	if (bt_link_info->hid_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+			   "HID PairNum/Forbid_Slot",
+			   coex_sta->hid_pair_cnt,
+			   coex_sta->forbidden_slot
+			  );
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ 0x%x/ 0x%x",
+			"Role/IgnWlanAct/Feature/BLEScan",
+			((bt_link_info->slave_role) ? "Slave" : "Master"),
+			((coex_dm->cur_ignore_wlan_act) ? "Yes" : "No"),
+			coex_sta->bt_coex_supported_feature,
+			coex_sta->bt_ble_scan_type);
+	CL_PRINTF(cli_buf);
+
+	if ((coex_sta->bt_ble_scan_type & 0x7) != 0x0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n %-35s = 0x%08x/ 0x%08x/ 0x%08x",
+			"BLEScan Intv-Win TV/Init/Ble",
+			(coex_sta->bt_ble_scan_type & 0x1 ?
+			coex_sta->bt_ble_scan_para[0] : 0x0),
+			(coex_sta->bt_ble_scan_type & 0x2 ?
+			coex_sta->bt_ble_scan_para[1] : 0x0),
+			(coex_sta->bt_ble_scan_type & 0x4 ?
+			coex_sta->bt_ble_scan_para[2] : 0x0));
+
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d",
+		   "ReInit/ReLink/IgnWlact/Page/NameReq",
+		   coex_sta->cnt_ReInit,
+		   coex_sta->cnt_setupLink,
+		   coex_sta->cnt_IgnWlanAct,
+		   coex_sta->cnt_Page,
+		   coex_sta->cnt_RemoteNameReq
+		  );
+	CL_PRINTF(cli_buf);
+
+	halbtc8723d2ant_read_score_board(btcoexist,	&u16tmp[0]);
+
+	if ((coex_sta->bt_reg_vendor_ae == 0xffff) ||
+	    (coex_sta->bt_reg_vendor_ac == 0xffff))
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = x/ x/ %04x",
+			   "0xae[4]/0xac[1:0]/Scoreboard", u16tmp[0]);
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = 0x%x/ 0x%x/ %04x",
+			   "0xae[4]/0xac[1:0]/Scoreboard",
+			   ((coex_sta->bt_reg_vendor_ae & BIT(4)) >> 4),
+			   coex_sta->bt_reg_vendor_ac & 0x3, u16tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	if (coex_sta->num_of_profile > 0) {
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
+			"AFH MAP",
+			coex_sta->bt_afh_map[0],
+			coex_sta->bt_afh_map[1],
+			coex_sta->bt_afh_map[2],
+			coex_sta->bt_afh_map[3],
+			coex_sta->bt_afh_map[4],
+			coex_sta->bt_afh_map[5],
+			coex_sta->bt_afh_map[6],
+			coex_sta->bt_afh_map[7],
+			coex_sta->bt_afh_map[8],
+			coex_sta->bt_afh_map[9]
+			   );
+		CL_PRINTF(cli_buf);
+	}
+
+	for (i = 0; i < BT_INFO_SRC_8723D_2ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x (%d)",
+				   glbt_info_src_8723d_2ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	/* Sw mechanism	 */
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[mechanism] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[Mechanism]============");
+
+	CL_PRINTF(cli_buf);
+
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x (case-%d, %s, %s)",
+		   "TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   (coex_dm->cur_ps_tdma_on ? "TDMA On" : "TDMA Off"),
+		   (coex_dm->is_switch_to_1dot5_ant ? "1.5Ant" : "2Ant"));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d/ 0x%x/ 0x%x/ 0x%x",
+		   "Table/0x6c0/0x6c4/0x6c8",
+		   coex_sta->coex_table_type, u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x778/0x6cc",
+		   u8tmp[0], u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s",
+		   "AntDiv/ ForceLPS",
+		   ((board_info->ant_div_cfg) ? "On" : "Off"),
+		   ((coex_sta->force_lps_on) ? "On" : "Off"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "WL_DACSwing/ BT_Dec_Pwr", coex_dm->cur_fw_dac_swing_lvl,
+		   coex_dm->cur_bt_dec_pwr_lvl);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	lte_coex_on = ((u32tmp[0] & BIT(7)) >> 7) ?  true : false;
+
+	if (lte_coex_on) {
+
+		u32tmp[0] = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa0);
+		u32tmp[1] = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa4);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+			   "LTE Coex  Table W_L/B_L",
+			   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff);
+		CL_PRINTF(cli_buf);
+
+		u32tmp[0] = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa8);
+		u32tmp[1] = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xac);
+		u32tmp[2] = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xb0);
+		u32tmp[3] = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xb4);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+			   "LTE Break Table W_L/B_L/L_W/L_B",
+			   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff,
+			   u32tmp[2] & 0xffff, u32tmp[3] & 0xffff);
+		CL_PRINTF(cli_buf);
+
+	}
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+	/*
+		u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+		u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+		u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+		u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+			   "0x430/0x434/0x42a/0x456",
+			   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+		CL_PRINTF(cli_buf);
+	*/
+	u32tmp[0] = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp[1] = halbtc8723d2ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s",
+		   "LTE Coex/Path Owner",
+		   ((lte_coex_on) ? "On" : "Off") ,
+		   ((u8tmp[0] & BIT(2)) ? "WL" : "BT"));
+	CL_PRINTF(cli_buf);
+
+	if (lte_coex_on) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %d/ %d",
+			   "LTE 3Wire/OPMode/UART/UARTMode",
+			   (int)((u32tmp[0] & BIT(6)) >> 6),
+			   (int)((u32tmp[0] & (BIT(5) | BIT(4))) >> 4),
+			   (int)((u32tmp[0] & BIT(3)) >> 3),
+			   (int)(u32tmp[0] & (BIT(2) | BIT(1) | BIT(0))));
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+			   "LTE_Busy/UART_Busy",
+			(int)((u32tmp[1] & BIT(1)) >> 1), (int)(u32tmp[1] & BIT(0)));
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %s (BB:%s)/ %s (BB:%s)/ %s %d",
+			   "GNT_WL_Ctrl/GNT_BT_Ctrl/Dbg",
+			   ((u32tmp[0] & BIT(12)) ? "SW" : "HW"),
+			   ((u32tmp[0] & BIT(8)) ?	"SW" : "HW"),
+			   ((u32tmp[0] & BIT(14)) ? "SW" : "HW"),
+			   ((u32tmp[0] & BIT(10)) ?  "SW" : "HW"),
+			   ((u8tmp[0] & BIT(3)) ? "On" : "Off"),
+			   coex_sta->gnt_error_cnt);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "GNT_WL/GNT_BT",
+		   (int)((u32tmp[1] & BIT(2)) >> 2),
+		   (int)((u32tmp[1] & BIT(3)) >> 3));
+	CL_PRINTF(cli_buf);
+
+	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x948);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x948/0x67[7]",
+		   u16tmp[0], (int)((u8tmp[0] & BIT(7)) >> 7));
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x964);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x864);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0xab7);
+	u8tmp[3] = btcoexist->btc_read_1byte(btcoexist, 0xa01);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x964[1]/0x864[0]/0xab7[5]/0xa01[7]",
+		   (int)((u8tmp[0] & BIT(1)) >> 1), (int)((u8tmp[1] & BIT(0))),
+		   (int)((u8tmp[2] & BIT(3)) >> 3),
+		   (int)((u8tmp[3] & BIT(7)) >> 7));
+	CL_PRINTF(cli_buf);
+
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x4c6);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0x45e);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x4c6[4]/0x40[5]/0x45e[3](TxRetry)",
+		   (int)((u8tmp[0] & BIT(4)) >> 4),
+		   (int)((u8tmp[1] & BIT(5)) >> 5),
+		   (int)((u8tmp[2] & BIT(3)) >> 3));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x953);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ %s",
+		   "0x550/0x522/4-RxAGC",
+		   u32tmp[0], u8tmp[0], (u8tmp[1] & 0x2) ? "On" : "Off");
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist, PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist, PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist, PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist, PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+#if 1
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+#endif
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s/ %d",
+		   "WlHiPri/ Locking/ Locked/ Noisy",
+		   (coex_sta->wifi_is_high_pri_task ? "Yes" : "No"),
+		   (coex_sta->cck_lock ? "Yes" : "No"),
+		   (coex_sta->cck_ever_lock ? "Yes" : "No"),
+		   coex_sta->wl_noisy_level);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d %s",
+		   "0x770(Hi-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx,
+		   (coex_sta->is_hiPri_rx_overhead ? "(scan overhead!!)" : ""));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d %s",
+		   "0x774(Lo-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx,
+		   (bt_link_info->slave_role ? "(Slave!!)" : (
+		   coex_sta->is_tdma_btautoslot_hang ? "(auto-slot hang!!)" : "")));
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8723d2ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+		coex_sta->under_lps = false;
+
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+				BT_8723D_2ANT_SCOREBOARD_ACTIVE |
+				BT_8723D_2ANT_SCOREBOARD_ONOFF |
+				BT_8723D_2ANT_SCOREBOARD_SCAN |
+				BT_8723D_2ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		halbtc8723d2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_2ANT_PHASE_WLAN_OFF);
+
+		halbtc8723d2ant_action_coex_all_off(btcoexist);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+#if 0
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+					 BT_8723D_2ANT_SCOREBOARD_ACTIVE, true);
+
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+					BT_8723D_2ANT_SCOREBOARD_ONOFF, true);
+#endif
+		halbtc8723d2ant_init_hw_config(btcoexist, false);
+		halbtc8723d2ant_init_coex_dm(btcoexist);
+		halbtc8723d2ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8723d2ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+		coex_sta->under_ips = false;
+
+		if (coex_sta->force_lps_on == true) { /* LPS No-32K */
+			/* Write WL "Active" in Score-board for PS-TDMA */
+			halbtc8723d2ant_post_state_to_bt(btcoexist,
+					 BT_8723D_2ANT_SCOREBOARD_ACTIVE, true);
+
+		} else { /* LPS-32K, need check if this h2c 0x71 can work?? (2015/08/28) */
+			/* Write WL "Non-Active" in Score-board for Native-PS */
+			halbtc8723d2ant_post_state_to_bt(btcoexist,
+				 BT_8723D_2ANT_SCOREBOARD_ACTIVE, false);
+		}
+
+
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+					 BT_8723D_2ANT_SCOREBOARD_ACTIVE, true);
+	}
+}
+
+void ex_halbtc8723d2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	u32	u32tmp;
+	u8	u8tmpa, u8tmpb;
+	boolean	wifi_connected = false;
+
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	/*  this can't be removed for RF off_on event, or BT would dis-connect */
+	halbtc8723d2ant_query_bt_info(btcoexist);
+
+	if (BTC_SCAN_START == type) {
+
+		if (!wifi_connected)
+			coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+					BT_8723D_2ANT_SCOREBOARD_ACTIVE |
+					BT_8723D_2ANT_SCOREBOARD_SCAN |
+					BT_8723D_2ANT_SCOREBOARD_ONOFF,
+					true);
+
+		halbtc8723d2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_2ANT_PHASE_2G_RUNTIME);
+
+		halbtc8723d2ant_run_coexist_mechanism(btcoexist);
+
+	} else if (BTC_SCAN_FINISH == type) {
+
+		coex_sta->wifi_is_high_pri_task = false;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify  (Scan-AP = %d)\n",
+			    coex_sta->scan_ap_num);
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+					 BT_8723D_2ANT_SCOREBOARD_SCAN, false);
+
+		halbtc8723d2ant_run_coexist_mechanism(btcoexist);
+	}
+
+}
+
+void ex_halbtc8723d2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_ASSOCIATE_START == type) {
+
+		coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+					 BT_8723D_2ANT_SCOREBOARD_ACTIVE |
+					 BT_8723D_2ANT_SCOREBOARD_SCAN |
+					 BT_8723D_2ANT_SCOREBOARD_ONOFF,
+					 true);
+
+		halbtc8723d2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_2ANT_PHASE_2G_RUNTIME);
+
+		halbtc8723d2ant_run_coexist_mechanism(btcoexist);
+		/* To keep TDMA case during connect process,
+		to avoid changed by Btinfo and runcoexmechanism */
+		coex_sta->freeze_coexrun_by_btinfo = true;
+
+		coex_dm->arp_cnt = 0;
+
+	} else if (BTC_ASSOCIATE_FINISH == type) {
+
+		coex_sta->wifi_is_high_pri_task = false;
+		coex_sta->freeze_coexrun_by_btinfo = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d2ant_run_coexist_mechanism(btcoexist);
+	}
+}
+
+void ex_halbtc8723d2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	u8			ap_num = 0;
+	boolean		wifi_under_b_mode = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+					 BT_8723D_2ANT_SCOREBOARD_ACTIVE |
+					 BT_8723D_2ANT_SCOREBOARD_ONOFF,
+					 true);
+
+		halbtc8723d2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_2ANT_PHASE_2G_RUNTIME);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+				 BT_8723D_2ANT_SCOREBOARD_ACTIVE, false);
+	}
+
+
+	halbtc8723d2ant_update_wifi_channel_info(btcoexist, type);
+}
+
+void ex_halbtc8723d2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean under_4way = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (under_4way) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ---- under_4way!!\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+
+	} else if (BTC_PACKET_ARP == type) {
+
+		coex_dm->arp_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ARP notify -cnt = %d\n",
+			    coex_dm->arp_cnt);
+		BTC_TRACE(trace_buf);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet DHCP or EAPOL notify [Type = %d]\n",
+			    type);
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+	}
+
+	if (coex_sta->wifi_is_high_pri_task) {
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+					 BT_8723D_2ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8723d2ant_run_coexist_mechanism(btcoexist);
+	}
+
+}
+
+void ex_halbtc8723d2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8			i, rsp_source = 0;
+	boolean		wifi_connected = false;
+	boolean	wifi_scan = false, wifi_link = false, wifi_roam = false,
+		    wifi_busy = false;
+	static boolean is_scoreboard_scan = false;
+
+	if (psd_scan->is_AntDet_running == true) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], bt_info_notify return for AntDet is running\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8723D_2ANT_MAX)
+		rsp_source = BT_INFO_SRC_8723D_2ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt_info[%d], len=%d, data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	coex_sta->bt_info = coex_sta->bt_info_c2h[rsp_source][1];
+	coex_sta->bt_info_ext = coex_sta->bt_info_c2h[rsp_source][4];
+	coex_sta->bt_info_ext2 = coex_sta->bt_info_c2h[rsp_source][5];
+
+	if (BT_INFO_SRC_8723D_2ANT_WIFI_FW != rsp_source) {
+
+		/* if 0xff, it means BT is under WHCK test */
+		coex_sta->bt_whck_test = ((coex_sta->bt_info == 0xff) ? true :
+					  false);
+
+		coex_sta->bt_create_connection = ((
+			coex_sta->bt_info_c2h[rsp_source][2] & 0x80) ? true :
+						  false);
+
+		/* unit: %, value-100 to translate to unit: dBm */
+		coex_sta->bt_rssi = coex_sta->bt_info_c2h[rsp_source][3] * 2 +
+				    10;
+
+		coex_sta->c2h_bt_remote_name_req = ((
+			coex_sta->bt_info_c2h[rsp_source][2] & 0x20) ? true :
+						    false);
+
+		coex_sta->is_A2DP_3M = ((coex_sta->bt_info_c2h[rsp_source][2] &
+					 0x10) ? true : false);
+
+		coex_sta->acl_busy = ((coex_sta->bt_info_c2h[rsp_source][1] &
+				       0x9) ? true : false);
+
+		coex_sta->voice_over_HOGP = ((coex_sta->bt_info_ext & 0x10) ?
+					     true : false);
+
+		coex_sta->c2h_bt_inquiry_page = ((coex_sta->bt_info &
+			  BT_INFO_8723D_2ANT_B_INQ_PAGE) ? true : false);
+
+		coex_sta->a2dp_bit_pool = (((
+			coex_sta->bt_info_c2h[rsp_source][1] & 0x49) == 0x49) ?
+				   coex_sta->bt_info_c2h[rsp_source][6] : 0);
+
+		coex_sta->bt_retry_cnt = coex_sta->bt_info_c2h[rsp_source][2] &
+					 0xf;
+
+		coex_sta->is_autoslot = coex_sta->bt_info_ext2 & 0x8;
+
+		coex_sta->forbidden_slot = coex_sta->bt_info_ext2 & 0x7;
+
+		coex_sta->hid_busy_num = (coex_sta->bt_info_ext2 & 0x30) >> 4;
+
+		coex_sta->hid_pair_cnt = (coex_sta->bt_info_ext2 & 0xc0) >> 6;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->c2h_bt_remote_name_req)
+			coex_sta->cnt_RemoteNameReq++;
+
+		if (coex_sta->bt_info_ext & BIT(1))
+			coex_sta->cnt_ReInit++;
+
+		if (coex_sta->bt_info_ext & BIT(2)) {
+			coex_sta->cnt_setupLink++;
+			coex_sta->is_setupLink = true;
+		} else
+			coex_sta->is_setupLink = false;
+
+		if (coex_sta->bt_info_ext & BIT(3))
+			coex_sta->cnt_IgnWlanAct++;
+
+		if (coex_sta->bt_create_connection) {
+			coex_sta->cnt_Page++;
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY,
+					   &wifi_busy);
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &wifi_link);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &wifi_roam);
+
+			if ((wifi_link) || (wifi_roam) || (wifi_scan) ||
+			    (coex_sta->wifi_is_high_pri_task) || (wifi_busy)) {
+
+				is_scoreboard_scan = true;
+				halbtc8723d2ant_post_state_to_bt(btcoexist,
+					 BT_8723D_2ANT_SCOREBOARD_SCAN, true);
+
+			} else
+				halbtc8723d2ant_post_state_to_bt(btcoexist,
+					 BT_8723D_2ANT_SCOREBOARD_SCAN, false);
+
+		} else {
+				if (is_scoreboard_scan) {
+					halbtc8723d2ant_post_state_to_bt(btcoexist,
+						 BT_8723D_2ANT_SCOREBOARD_SCAN, false);
+					is_scoreboard_scan = false;
+				}
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+
+		if ((!btcoexist->manual_control) &&
+		    (!btcoexist->stop_coex_dm)) {
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+
+			/*  Re-Init */
+			if ((coex_sta->bt_info_ext & BIT(1))) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+				BTC_TRACE(trace_buf);
+				if (wifi_connected)
+					halbtc8723d2ant_update_wifi_channel_info(
+						btcoexist, BTC_MEDIA_CONNECT);
+				else
+					halbtc8723d2ant_update_wifi_channel_info(
+						btcoexist,
+						BTC_MEDIA_DISCONNECT);
+			}
+
+
+			/*  If Ignore_WLanAct && not SetUp_Link or Role_Switch */
+			if ((coex_sta->bt_info_ext & BIT(3)) &&
+				(!(coex_sta->bt_info_ext & BIT(2))) &&
+				(!(coex_sta->bt_info_ext & BIT(6)))) {
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8723d2ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			} else {
+				if (coex_sta->bt_info_ext & BIT(2)) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ignore Wlan active because Re-link!!\n");
+					BTC_TRACE(trace_buf);
+				} else if (coex_sta->bt_info_ext & BIT(6)) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ignore Wlan active because Role-Switch!!\n");
+					BTC_TRACE(trace_buf);
+				}
+			}
+		}
+
+	}
+
+	if ((coex_sta->bt_info_ext & BIT(5))) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit4 check, query BLE Scan type!!\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_ble_scan_type = btcoexist->btc_get_ble_scan_type_from_bt(btcoexist);
+
+		if ((coex_sta->bt_ble_scan_type & 0x1) == 0x1)
+			coex_sta->bt_ble_scan_para[0]  = btcoexist->btc_get_ble_scan_para_from_bt(btcoexist, 0x1);
+		if ((coex_sta->bt_ble_scan_type & 0x2) == 0x2)
+			coex_sta->bt_ble_scan_para[1]  = btcoexist->btc_get_ble_scan_para_from_bt(btcoexist, 0x2);
+		if ((coex_sta->bt_ble_scan_type & 0x4) == 0x4)
+			coex_sta->bt_ble_scan_para[2]  = btcoexist->btc_get_ble_scan_para_from_bt(btcoexist, 0x4);
+	}
+
+	halbtc8723d2ant_update_bt_link_info(btcoexist);
+
+	halbtc8723d2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8723d2ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->stop_coex_dm = false;
+#if 0
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+					 BT_8723D_2ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+					 BT_8723D_2ANT_SCOREBOARD_ONOFF, true);
+#endif
+	} else if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723d2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_2ANT_PHASE_WLAN_OFF);
+
+		halbtc8723d2ant_action_coex_all_off(btcoexist);
+
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+				BT_8723D_2ANT_SCOREBOARD_ACTIVE |
+				BT_8723D_2ANT_SCOREBOARD_ONOFF |
+				BT_8723D_2ANT_SCOREBOARD_SCAN |
+				BT_8723D_2ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		btcoexist->stop_coex_dm = true;
+
+	}
+}
+
+void ex_halbtc8723d2ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8723d2ant_set_ant_path(btcoexist,
+				     BTC_ANT_PATH_AUTO,
+				     FORCE_EXEC,
+				     BT_8723D_2ANT_PHASE_WLAN_OFF);
+
+	ex_halbtc8723d2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	halbtc8723d2ant_post_state_to_bt(btcoexist,
+				BT_8723D_2ANT_SCOREBOARD_ACTIVE |
+				BT_8723D_2ANT_SCOREBOARD_ONOFF |
+				BT_8723D_2ANT_SCOREBOARD_SCAN |
+				BT_8723D_2ANT_SCOREBOARD_UNDERTEST,
+				false);
+}
+
+void ex_halbtc8723d2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if ((BTC_WIFI_PNP_SLEEP == pnp_state) ||
+	    (BTC_WIFI_PNP_SLEEP_KEEP_ANT == pnp_state)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+				BT_8723D_2ANT_SCOREBOARD_ACTIVE |
+				BT_8723D_2ANT_SCOREBOARD_ONOFF |
+				BT_8723D_2ANT_SCOREBOARD_SCAN |
+				BT_8723D_2ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		if (BTC_WIFI_PNP_SLEEP_KEEP_ANT == pnp_state) {
+
+			halbtc8723d2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+						     FORCE_EXEC,
+					     BT_8723D_2ANT_PHASE_2G_RUNTIME);
+		} else {
+
+			halbtc8723d2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+						     FORCE_EXEC,
+					     BT_8723D_2ANT_PHASE_WLAN_OFF);
+		}
+
+
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+#if 0
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+					BT_8723D_2ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8723d2ant_post_state_to_bt(btcoexist,
+					BT_8723D_2ANT_SCOREBOARD_ONOFF, true);
+#endif
+	}
+}
+
+void ex_halbtc8723d2ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	boolean wifi_busy = false;
+	u32	bt_patch_ver;
+	static u8 cnt = 0;
+	boolean bt_relink_finish = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ************* Periodical *************\n");
+	BTC_TRACE(trace_buf);
+
+#if (BT_AUTO_REPORT_ONLY_8723D_2ANT == 0)
+	halbtc8723d2ant_query_bt_info(btcoexist);
+#endif
+
+	halbtc8723d2ant_monitor_bt_ctr(btcoexist);
+	halbtc8723d2ant_monitor_wifi_ctr(btcoexist);
+	halbtc8723d2ant_monitor_bt_enable_disable(btcoexist);
+
+#if 0
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+		/* halbtc8723d2ant_read_score_board(btcoexist, &bt_scoreboard_val); */
+
+		if (wifi_busy) {
+			halbtc8723d2ant_post_state_to_bt(btcoexist,
+					BT_8723D_2ANT_SCOREBOARD_UNDERTEST, true);
+			/*
+			halbtc8723d2ant_post_state_to_bt(btcoexist,
+						 BT_8723D_2ANT_SCOREBOARD_WLBUSY, true);
+
+			if (bt_scoreboard_val & BIT(6))
+				halbtc8723d2ant_query_bt_info(btcoexist); */
+		} else {
+			halbtc8723d2ant_post_state_to_bt(btcoexist,
+						BT_8723D_2ANT_SCOREBOARD_UNDERTEST, false);
+			/*
+			halbtc8723d2ant_post_state_to_bt(btcoexist,
+						BT_8723D_2ANT_SCOREBOARD_WLBUSY,
+						false);  */
+		}
+#endif
+
+	if (coex_sta->bt_relink_downcount != 0) {
+		coex_sta->bt_relink_downcount--;
+
+		if (coex_sta->bt_relink_downcount == 0)
+			bt_relink_finish = true;
+	}
+
+	/* for 4-way, DHCP, EAPOL packet */
+	if (coex_sta->specific_pkt_period_cnt > 0) {
+
+		coex_sta->specific_pkt_period_cnt--;
+
+		if ((coex_sta->specific_pkt_period_cnt == 0) &&
+		    (coex_sta->wifi_is_high_pri_task))
+			coex_sta->wifi_is_high_pri_task = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ***************** Hi-Pri Task = %s*****************\n",
+			    (coex_sta->wifi_is_high_pri_task ? "Yes" :
+			     "No"));
+		BTC_TRACE(trace_buf);
+
+	}
+
+	if (!coex_sta->bt_disabled) {
+		if (coex_sta->bt_coex_supported_feature == 0)
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_FEATURE,
+						&coex_sta->bt_coex_supported_feature);
+
+		if ((coex_sta->bt_coex_supported_version == 0) ||
+			 (coex_sta->bt_coex_supported_version == 0xffff))
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION,
+						&coex_sta->bt_coex_supported_version);
+
+		if (coex_sta->bt_reg_vendor_ac == 0xffff)
+			coex_sta->bt_reg_vendor_ac = (u16)(
+						btcoexist->btc_get_bt_reg(btcoexist, 3,
+						0xac) & 0xffff);
+
+		if (coex_sta->bt_reg_vendor_ae == 0xffff)
+			coex_sta->bt_reg_vendor_ae = (u16)(
+						btcoexist->btc_get_bt_reg(btcoexist, 3,
+						0xae) & 0xffff);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER,
+						&bt_patch_ver);
+		btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+
+		if (coex_sta->num_of_profile > 0) {
+			cnt++;
+
+			if (cnt >= 3) {
+				btcoexist->btc_get_bt_afh_map_from_bt(btcoexist, 0,
+					&coex_sta->bt_afh_map[0]);
+				cnt = 0;
+			}
+		}
+
+#if BT_8723D_2ANT_ANTDET_ENABLE
+
+		if (board_info->btdm_ant_det_finish) {
+			if ((psd_scan->ant_det_result == 12) &&
+			    (psd_scan->ant_det_psd_scan_peak_val == 0)
+			    && (!psd_scan->is_AntDet_running))
+				psd_scan->ant_det_psd_scan_peak_val =
+					btcoexist->btc_get_ant_det_val_from_bt(
+						btcoexist) * 100;
+		}
+
+#endif
+	}
+
+
+	if (halbtc8723d2ant_is_wifibt_status_changed(btcoexist))
+		halbtc8723d2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8723d2ant_set_antenna_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (type == 2) { /* two antenna */
+		board_info->ant_div_cfg = true;
+
+		halbtc8723d2ant_set_ant_path(btcoexist, BTC_ANT_PATH_WIFI,
+					     FORCE_EXEC,
+					     BT_8723D_2ANT_PHASE_2G_RUNTIME);
+
+	} else { /* one antenna */
+
+		halbtc8723d2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8723D_2ANT_PHASE_2G_RUNTIME);
+
+	}
+}
+
+#ifdef PLATFORM_WINDOWS
+#pragma optimize("", off)
+#endif
+void ex_halbtc8723d2ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+	static u32 ant_det_count = 0, ant_det_fail_count = 0;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u16		u16tmp;
+	u8			AntDetval = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx Ext Call AntennaDetect()!!\n");
+	BTC_TRACE(trace_buf);
+
+#if BT_8723D_2ANT_ANTDET_ENABLE
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx Call AntennaDetect()!!\n");
+	BTC_TRACE(trace_buf);
+
+	if (seconds == 0) {
+		psd_scan->ant_det_try_count	= 0;
+		psd_scan->ant_det_fail_count	= 0;
+		ant_det_count = 0;
+		ant_det_fail_count = 0;
+		board_info->btdm_ant_det_finish = false;
+		board_info->btdm_ant_num_by_ant_det = 1;
+		return;
+	}
+
+	if (!board_info->btdm_ant_det_finish) {
+		psd_scan->ant_det_inteval_count =
+			psd_scan->ant_det_inteval_count + 2;
+
+		if (psd_scan->ant_det_inteval_count >=
+		    BT_8723D_2ANT_ANTDET_RETRY_INTERVAL) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Timer is up, Try Detect!!\n");
+			BTC_TRACE(trace_buf);
+
+			psd_scan->is_AntDet_running = true;
+
+			halbtc8723d2ant_read_score_board(btcoexist,	&u16tmp);
+
+			if (u16tmp & BIT(
+				2)) { /* Antenna detection is already done before last WL power on   */
+				board_info->btdm_ant_det_finish = true;
+				psd_scan->ant_det_try_count = 1;
+				psd_scan->ant_det_fail_count = 0;
+				board_info->btdm_ant_num_by_ant_det = (u16tmp &
+							       BIT(3)) ? 1 : 2;
+				psd_scan->ant_det_result = 12;
+
+				psd_scan->ant_det_psd_scan_peak_val =
+					btcoexist->btc_get_ant_det_val_from_bt(
+						btcoexist) * 100;
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Result from BT (%d-Ant)\n",
+					board_info->btdm_ant_num_by_ant_det);
+				BTC_TRACE(trace_buf);
+			} else
+				board_info->btdm_ant_det_finish =
+					halbtc8723d2ant_psd_antenna_detection_check(
+						btcoexist);
+
+			btcoexist->bdontenterLPS = false;
+
+			if (board_info->btdm_ant_det_finish) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Success!!\n");
+				BTC_TRACE(trace_buf);
+
+				/*for 8723d, btc_set_bt_trx_mask is just used to
+					notify BT stop le tx and Ant Det Result , not set BT RF TRx Mask  */
+				if (psd_scan->ant_det_result != 12) {
+
+					AntDetval = (u8)(
+						psd_scan->ant_det_psd_scan_peak_val
+							    / 100) & 0x7f;
+
+					AntDetval =
+						(board_info->btdm_ant_num_by_ant_det
+						 == 1) ? (AntDetval | 0x80) :
+						AntDetval;
+
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"xxxxxx AntennaDetect(), Ant Count = %d, PSD Val = %d\n",
+						    ((AntDetval &
+						      0x80) ? 1
+						     : 2), AntDetval
+						    & 0x7f);
+					BTC_TRACE(trace_buf);
+
+					if (btcoexist->btc_set_bt_trx_mask(
+						    btcoexist, AntDetval))
+						BTC_SPRINTF(trace_buf,
+							    BT_TMP_BUF_SIZE,
+							"xxxxxx AntennaDetect(), Notify BT stop le tx by set_bt_trx_mask ok!\n");
+					else
+						BTC_SPRINTF(trace_buf,
+							    BT_TMP_BUF_SIZE,
+							"xxxxxx AntennaDetect(), Notify BT stop le tx by set_bt_trx_mask fail!\n");
+
+					BTC_TRACE(trace_buf);
+				} else
+					board_info->antdetval =
+						psd_scan->ant_det_psd_scan_peak_val/100;
+				
+				board_info->btdm_ant_det_complete_fail = false;
+
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Fail!!\n");
+				BTC_TRACE(trace_buf);
+			}
+
+			psd_scan->ant_det_inteval_count = 0;
+			psd_scan->is_AntDet_running = false;
+
+			/* stimulate coex running */
+			halbtc8723d2ant_run_coexist_mechanism(
+				btcoexist);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Stimulate Coex running\n!!");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Timer is not up! (%d)\n",
+				    psd_scan->ant_det_inteval_count);
+			BTC_TRACE(trace_buf);
+
+			if (psd_scan->ant_det_inteval_count == 8)
+				btcoexist->bdontenterLPS = true;
+			else
+				btcoexist->bdontenterLPS = false;
+		}
+
+	}
+#endif
+
+
+}
+
+
+void ex_halbtc8723d2ant_display_ant_detection(IN struct btc_coexist *btcoexist)
+{
+
+#if BT_8723D_2ANT_ANTDET_ENABLE
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	if (psd_scan->ant_det_try_count != 0)	{
+		halbtc8723d2ant_psd_show_antenna_detect_result(btcoexist);
+
+		if (board_info->btdm_ant_det_finish)
+			halbtc8723d2ant_psd_showdata(btcoexist);
+	}
+#endif
+
+}
+
+
+#endif
+
+#endif	/*  #if (RTL8723D_SUPPORT == 1) */
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8723d2ant.h
@@ -0,0 +1,418 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8723D_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8723D 2Ant BT Co-exist definition
+ * ******************************************* */
+#define	BT_8723D_2ANT_COEX_DBG					0
+#define	BT_AUTO_REPORT_ONLY_8723D_2ANT				1
+
+
+#define	BT_INFO_8723D_2ANT_B_FTP						BIT(7)
+#define	BT_INFO_8723D_2ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8723D_2ANT_B_HID						BIT(5)
+#define	BT_INFO_8723D_2ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8723D_2ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8723D_2ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8723D_2ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8723D_2ANT_B_CONNECTION				BIT(0)
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8723D_2ANT		2
+
+
+#define	BT_8723D_2ANT_WIFI_RSSI_COEXSWITCH_THRES1				80  /* unit: % WiFi RSSI Threshold for   2-Ant free-run/2-Ant TDMA translation, default = 42 */
+#define	BT_8723D_2ANT_BT_RSSI_COEXSWITCH_THRES1				80 /*  unit: % BT RSSI Threshold for      2-Ant free-run/2-Ant TDMA translation, default = 46 */
+#define	BT_8723D_2ANT_WIFI_RSSI_COEXSWITCH_THRES2				80  /* unit: % WiFi RSSI Threshold for   1-Ant TDMA/1-Ant PS-TDMA translation, default = 42 */
+#define	BT_8723D_2ANT_BT_RSSI_COEXSWITCH_THRES2				80 /*  unit: % BT RSSI Threshold for      1-Ant TDMA/1-Ant PS-TDMA translation, default = 46 */
+#define	BT_8723D_2ANT_DEFAULT_ISOLATION						15	 /*  unit: dB */
+#define   BT_8723D_2ANT_WIFI_MAX_TX_POWER						15	 /*  unit: dBm */
+#define   BT_8723D_2ANT_BT_MAX_TX_POWER							3	 /*  unit: dBm */
+#define   BT_8723D_2ANT_WIFI_SIR_THRES1							-15  /*  unit: dB */
+#define   BT_8723D_2ANT_WIFI_SIR_THRES2							-30  /*  unit: dB */
+#define   BT_8723D_2ANT_BT_SIR_THRES1							-15		 /*  unit: dB */
+#define   BT_8723D_2ANT_BT_SIR_THRES2							-30		 /*  unit: dB */
+
+
+/* for Antenna detection */
+#define	BT_8723D_2ANT_ANTDET_PSDTHRES_BACKGROUND						50
+#define	BT_8723D_2ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION				70
+#define	BT_8723D_2ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION			52
+#define	BT_8723D_2ANT_ANTDET_PSDTHRES_1ANT							40
+#define	BT_8723D_2ANT_ANTDET_RETRY_INTERVAL							10	/* retry timer if ant det is fail, unit: second */
+#define	BT_8723D_2ANT_ANTDET_SWEEPPOINT_DELAY							60000
+#define	BT_8723D_2ANT_ANTDET_ENABLE										1
+#define	BT_8723D_2ANT_ANTDET_BTTXTIME									100
+#define	BT_8723D_2ANT_ANTDET_BTTXCHANNEL								39
+#define	BT_8723D_2ANT_ANTDET_PSD_SWWEEPCOUNT						50
+
+
+#define	BT_8723D_2ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT		30000
+
+enum bt_8723d_2ant_signal_state {
+	BT_8723D_2ANT_SIG_STA_SET_TO_LOW		= 0x0,
+	BT_8723D_2ANT_SIG_STA_SET_BY_HW		= 0x0,
+	BT_8723D_2ANT_SIG_STA_SET_TO_HIGH		= 0x1,
+	BT_8723D_2ANT_SIG_STA_MAX
+};
+
+enum bt_8723d_2ant_path_ctrl_owner {
+	BT_8723D_2ANT_PCO_BTSIDE		= 0x0,
+	BT_8723D_2ANT_PCO_WLSIDE	= 0x1,
+	BT_8723D_2ANT_PCO_MAX
+};
+
+enum bt_8723d_2ant_gnt_ctrl_type {
+	BT_8723D_2ANT_GNT_TYPE_CTRL_BY_PTA		= 0x0,
+	BT_8723D_2ANT_GNT_TYPE_CTRL_BY_SW		= 0x1,
+	BT_8723D_2ANT_GNT_TYPE_MAX
+};
+
+enum bt_8723d_2ant_gnt_ctrl_block {
+	BT_8723D_2ANT_GNT_BLOCK_RFC_BB		= 0x0,
+	BT_8723D_2ANT_GNT_BLOCK_RFC			= 0x1,
+	BT_8723D_2ANT_GNT_BLOCK_BB			= 0x2,
+	BT_8723D_2ANT_GNT_BLOCK_MAX
+};
+
+enum bt_8723d_2ant_lte_coex_table_type {
+	BT_8723D_2ANT_CTT_WL_VS_LTE			= 0x0,
+	BT_8723D_2ANT_CTT_BT_VS_LTE			= 0x1,
+	BT_8723D_2ANT_CTT_MAX
+};
+
+enum bt_8723d_2ant_lte_break_table_type {
+	BT_8723D_2ANT_LBTT_WL_BREAK_LTE			= 0x0,
+	BT_8723D_2ANT_LBTT_BT_BREAK_LTE				= 0x1,
+	BT_8723D_2ANT_LBTT_LTE_BREAK_WL			= 0x2,
+	BT_8723D_2ANT_LBTT_LTE_BREAK_BT				= 0x3,
+	BT_8723D_2ANT_LBTT_MAX
+};
+
+enum bt_info_src_8723d_2ant {
+	BT_INFO_SRC_8723D_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8723D_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8723D_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8723D_2ANT_MAX
+};
+
+enum bt_8723d_2ant_bt_status {
+	BT_8723D_2ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8723D_2ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8723D_2ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8723D_2ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8723D_2ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8723D_2ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8723D_2ANT_BT_STATUS_MAX
+};
+
+enum bt_8723d_2ant_coex_algo {
+	BT_8723D_2ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8723D_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8723D_2ANT_COEX_ALGO_HID				= 0x2,
+	BT_8723D_2ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8723D_2ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8723D_2ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8723D_2ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8723D_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8723D_2ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8723D_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8723D_2ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8723D_2ANT_COEX_ALGO_NOPROFILEBUSY		= 0xb,
+	BT_8723D_2ANT_COEX_ALGO_MAX
+};
+
+enum bt_8723d_2ant_phase {
+	BT_8723D_2ANT_PHASE_COEX_INIT								= 0x0,
+	BT_8723D_2ANT_PHASE_WLANONLY_INIT							= 0x1,
+	BT_8723D_2ANT_PHASE_WLAN_OFF								= 0x2,
+	BT_8723D_2ANT_PHASE_2G_RUNTIME								= 0x3,
+	BT_8723D_2ANT_PHASE_5G_RUNTIME								= 0x4,
+	BT_8723D_2ANT_PHASE_BTMPMODE								= 0x5,
+	BT_8723D_2ANT_PHASE_ANTENNA_DET								= 0x6,
+	BT_8723D_2ANT_PHASE_COEX_POWERON							= 0x7,
+	BT_8723D_2ANT_PHASE_MAX
+};
+
+enum bt_8723d_2ant_Scoreboard {
+	BT_8723D_2ANT_SCOREBOARD_ACTIVE								= BIT(0),
+	BT_8723D_2ANT_SCOREBOARD_ONOFF								= BIT(1),
+	BT_8723D_2ANT_SCOREBOARD_SCAN								= BIT(2),
+	BT_8723D_2ANT_SCOREBOARD_UNDERTEST							= BIT(3),
+	BT_8723D_2ANT_SCOREBOARD_WLBUSY								= BIT(6)
+};
+
+
+
+struct coex_dm_8723d_2ant {
+	/* fw mechanism */
+	u8		pre_bt_dec_pwr_lvl;
+	u8		cur_bt_dec_pwr_lvl;
+	u8		pre_fw_dac_swing_lvl;
+	u8		cur_fw_dac_swing_lvl;
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		reset_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+
+	/* sw mechanism */
+	boolean		pre_rf_rx_lpf_shrink;
+	boolean		cur_rf_rx_lpf_shrink;
+	u32		bt_rf_0x1e_backup;
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	boolean		pre_dac_swing_on;
+	u32		pre_dac_swing_lvl;
+	boolean		cur_dac_swing_on;
+	u32		cur_dac_swing_lvl;
+	boolean		pre_adc_back_off;
+	boolean		cur_adc_back_off;
+	boolean	pre_agc_table_en;
+	boolean		cur_agc_table_en;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	boolean		need_recover0x948;
+	u32		backup0x948;
+
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	boolean		is_switch_to_1dot5_ant;
+	u8		switch_thres_offset;
+	u32					arp_cnt;
+
+	u8		pre_ant_pos_type;
+	u8		cur_ant_pos_type;
+};
+
+struct coex_sta_8723d_2ant {
+	boolean				bt_disabled;
+	boolean				bt_link_exist;
+	boolean				sco_exist;
+	boolean				a2dp_exist;
+	boolean				hid_exist;
+	boolean				pan_exist;
+
+	boolean				under_lps;
+	boolean				under_ips;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	boolean             is_hiPri_rx_overhead;
+	u8					bt_rssi;
+	boolean				bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	u8					bt_info_c2h[BT_INFO_SRC_8723D_2ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8723D_2ANT_MAX];
+	boolean				bt_whck_test;
+	boolean				c2h_bt_inquiry_page;
+	boolean				c2h_bt_remote_name_req;
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u8					bt_info_ext2;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_vht;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_vht;
+
+	boolean				cck_lock;
+	boolean				pre_ccklock;
+	boolean				cck_ever_lock;
+	u8					coex_table_type;
+	boolean				force_lps_on;
+
+	u8					dis_ver_info_cnt;
+
+	u8					a2dp_bit_pool;
+	u8					cut_version;
+
+	boolean				concurrent_rx_mode_on;
+
+	u16					score_board;
+	u8					isolation_btween_wb;   /* 0~ 50 */
+	u8					wifi_coex_thres;
+	u8					bt_coex_thres;
+	u8					wifi_coex_thres2;
+	u8					bt_coex_thres2;
+
+	u8					num_of_profile;
+	boolean				acl_busy;
+	boolean				bt_create_connection;
+	boolean				wifi_is_high_pri_task;
+	u32					specific_pkt_period_cnt;
+	u32					bt_coex_supported_feature;
+	u32					bt_coex_supported_version;
+
+	u8					bt_ble_scan_type;
+	u32					bt_ble_scan_para[3];
+
+	boolean				run_time_state;
+	boolean				freeze_coexrun_by_btinfo;
+
+	boolean				is_A2DP_3M;
+	boolean				voice_over_HOGP;
+	u8                  bt_info;
+	boolean				is_autoslot;
+	u8					forbidden_slot;
+	u8					hid_busy_num;
+	u8					hid_pair_cnt;
+
+	u32					cnt_RemoteNameReq;
+	u32					cnt_setupLink;
+	u32					cnt_ReInit;
+	u32					cnt_IgnWlanAct;
+	u32					cnt_Page;
+	u32					cnt_RoleSwitch;
+
+	u16					bt_reg_vendor_ac;
+	u16					bt_reg_vendor_ae;
+
+	boolean				is_setupLink;
+	boolean				wl_noisy_level;
+	u32                 gnt_error_cnt;
+
+	u8					bt_afh_map[10];
+	u8					bt_relink_downcount;
+	boolean				is_tdma_btautoslot;
+	boolean				is_tdma_btautoslot_hang;
+};
+
+#define BT_8723D_2ANT_ANTDET_PSD_POINTS			256	/* MAX:1024 */
+#define BT_8723D_2ANT_ANTDET_PSD_AVGNUM		1	/* MAX:3 */
+#define BT_8723D_2ANT_ANTDET_BUF_LEN			16
+
+struct psdscan_sta_8723d_2ant {
+
+	u32			ant_det_bt_le_channel;  /* BT LE Channel ex:2412 */
+	u32			ant_det_bt_tx_time;
+	u32			ant_det_pre_psdscan_peak_val;
+	boolean			ant_det_is_ant_det_available;
+	u32			ant_det_psd_scan_peak_val;
+	boolean			ant_det_is_btreply_available;
+	u32			ant_det_psd_scan_peak_freq;
+
+	u8			ant_det_result;
+	u8			ant_det_peak_val[BT_8723D_2ANT_ANTDET_BUF_LEN];
+	u8			ant_det_peak_freq[BT_8723D_2ANT_ANTDET_BUF_LEN];
+	u32			ant_det_try_count;
+	u32			ant_det_fail_count;
+	u32			ant_det_inteval_count;
+	u32			ant_det_thres_offset;
+
+	u32			real_cent_freq;
+	s32			real_offset;
+	u32			real_span;
+
+	u32			psd_band_width;  /* unit: Hz */
+	u32			psd_point;		/* 128/256/512/1024 */
+	u32			psd_report[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_report_max_hold[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_start_point;
+	u32			psd_stop_point;
+	u32			psd_max_value_point;
+	u32			psd_max_value;
+	u32			psd_max_value2;
+	u32			psd_avg_value;   /* filter loop_max_value that below BT_8723D_1ANT_ANTDET_PSDTHRES_1ANT, and average the rest*/
+	u32			psd_loop_max_value[BT_8723D_2ANT_ANTDET_PSD_SWWEEPCOUNT];  /*max value in each loop */
+	u32			psd_start_base;
+	u32			psd_avg_num;	/* 1/8/16/32 */
+	u32			psd_gen_count;
+	boolean			is_AntDet_running;
+	boolean			is_psd_show_max_only;
+};
+
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8723d2ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723d2ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723d2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8723d2ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723d2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8723d2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8723d2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8723d2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8723d2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723d2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723d2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8723d2ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723d2ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723d2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8723d2ant_set_antenna_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723d2ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723d2ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723d2ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+void ex_halbtc8723d2ant_display_ant_detection(IN struct btc_coexist *btcoexist);
+
+
+#else
+#define	ex_halbtc8723d2ant_power_on_setting(btcoexist)
+#define	ex_halbtc8723d2ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8723d2ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8723d2ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8723d2ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8723d2ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8723d2ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8723d2ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8723d2ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8723d2ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8723d2ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8723d2ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8723d2ant_halt_notify(btcoexist)
+#define	ex_halbtc8723d2ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8723d2ant_periodical(btcoexist)
+#define	ex_halbtc8723d2ant_display_coex_info(btcoexist)
+#define	ex_halbtc8723d2ant_set_antenna_notify(btcoexist, type)
+#define	ex_halbtc8723d2ant_display_ant_detection(btcoexist)
+#define	ex_halbtc8723d2ant_antenna_detection(btcoexist, cent_freq, offset, span, seconds)
+#endif
+
+#endif
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8812a1ant.c
@@ -0,0 +1,3461 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8812A Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8812A_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8812a_1ant		glcoex_dm_8812a_1ant;
+static struct  coex_dm_8812a_1ant	*coex_dm = &glcoex_dm_8812a_1ant;
+static struct  coex_sta_8812a_1ant		glcoex_sta_8812a_1ant;
+static struct  coex_sta_8812a_1ant	*coex_sta = &glcoex_sta_8812a_1ant;
+
+const char *const glbt_info_src_8812a_1ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8812a_1ant = 20140708;
+u32	glcoex_ver_8812a_1ant = 0x52;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8812a1ant_
+ * ************************************************************ */
+u8 halbtc8812a1ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8812a1ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8812a1ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+/* to check 0x430/0x434 is correct?? */
+void halbtc8812a1ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+/* to check 0x42a ?? */
+void halbtc8812a1ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+/* to check 0x456?? */
+void halbtc8812a1ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8812a1ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8812a1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8812a1ant_update_ra_mask(btcoexist, force_exec,
+					       0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8812a1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8812a1ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8812a1ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8812a1ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8812a1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8812a1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8	data_len = 3;
+	u8	buf[5] = {0};
+
+	if (!coex_sta->bt_disabled) {
+		if (!coex_sta->bt_info_query_cnt ||
+		    (coex_sta->bt_info_c2h_cnt[BT_INFO_SRC_8812A_1ANT_BT_RSP]
+		     - coex_sta->bt_info_query_cnt) > 2) {
+			buf[0] = data_len;
+			buf[1] = 0x1;	/* polling enable, 1=enable, 0=disable */
+			buf[2] = 0x2;	/* polling time in seconds */
+			buf[3] = 0x1;	/* auto report enable, 1=enable, 0=disable */
+
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_INFO,
+					   (void *)&buf[0]);
+		}
+	}
+	coex_sta->bt_info_query_cnt++;
+}
+
+void halbtc8812a1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u8		num_of_bt_counter_chk = 0;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if ((coex_sta->low_priority_tx > 1150)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Hi-Pri Rx/Tx: %d/%d, Lo-Pri Rx/Tx: %d/%d\n",
+		    reg_hp_rx, reg_hp_tx, reg_lp_rx, reg_lp_tx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	if ((reg_hp_tx == 0) && (reg_hp_rx == 0) && (reg_lp_tx == 0) &&
+	    (reg_lp_rx == 0)) {
+		num_of_bt_counter_chk++;
+		if (num_of_bt_counter_chk >= 3) {
+			halbtc8812a1ant_query_bt_info(btcoexist);
+			num_of_bt_counter_chk = 0;
+		}
+	}
+}
+
+/* to check registers */
+void halbtc8812a1ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+	s32	wifi_rssi = 0;
+	boolean wifi_busy = false, wifi_under_b_mode = false;
+	static u8 cck_lock_counter = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+			   &wifi_under_b_mode);
+
+	if (coex_sta->under_ips) {
+		coex_sta->crc_ok_cck = 0;
+		coex_sta->crc_ok_11g = 0;
+		coex_sta->crc_ok_11n = 0;
+		coex_sta->crc_ok_11n_agg = 0;
+
+		coex_sta->crc_err_cck = 0;
+		coex_sta->crc_err_11g = 0;
+		coex_sta->crc_err_11n = 0;
+		coex_sta->crc_err_11n_agg = 0;
+	} else {
+		coex_sta->crc_ok_cck	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf04);
+		coex_sta->crc_ok_11g	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf14);
+		coex_sta->crc_ok_11n	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf10);
+		coex_sta->crc_ok_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					   0xf40);
+
+		coex_sta->crc_err_cck	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf06);
+		coex_sta->crc_err_11g	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf16);
+		coex_sta->crc_err_11n	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf12);
+		coex_sta->crc_err_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					    0xf42);
+	}
+
+
+	/* reset counter */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xb58, 0x1, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xb58, 0x1, 0x0);
+
+	if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+		if ((coex_dm->bt_status == BT_8812A_1ANT_BT_STATUS_ACL_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8812A_1ANT_BT_STATUS_SCO_BUSY)) {
+			if (coex_sta->crc_ok_cck > (coex_sta->crc_ok_11g +
+						    coex_sta->crc_ok_11n +
+						    coex_sta->crc_ok_11n_agg)) {
+				if (cck_lock_counter < 5)
+					cck_lock_counter++;
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+	} else {
+		if (cck_lock_counter > 0)
+			cck_lock_counter--;
+	}
+
+	if (!coex_sta->pre_ccklock) {
+
+		if (cck_lock_counter >= 5)
+			coex_sta->cck_lock = true;
+		else
+			coex_sta->cck_lock = false;
+	} else {
+		if (cck_lock_counter == 0)
+			coex_sta->cck_lock = false;
+		else
+			coex_sta->cck_lock = true;
+	}
+
+	coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+
+}
+
+boolean halbtc8812a1ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void halbtc8812a1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8812a1ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8812A_1ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Profile = SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8812A_1ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_1ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_1ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8812A_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_1ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8812A_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! BT Profile = SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8812a1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8812a1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8812a1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+/* to check */
+void halbtc8812a1ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8	tmp_u1;
+
+	tmp_u1 = btcoexist->btc_read_1byte(btcoexist, 0x4fd);
+	tmp_u1 |= BIT(0);
+	if (low_penalty_ra) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Tx rate adaptive, set low penalty!!\n");
+		BTC_TRACE(trace_buf);
+		tmp_u1 &= ~BIT(2);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Tx rate adaptive, set normal!!\n");
+		BTC_TRACE(trace_buf);
+		tmp_u1 |= BIT(2);
+	}
+
+	btcoexist->btc_write_1byte(btcoexist, 0x4fd, tmp_u1);
+}
+
+void halbtc8812a1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8812a1ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8812a1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8812a1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8812a1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8812a1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** CoexTable(%d) **********\n", type);
+	BTC_TRACE(trace_buf);
+
+	coex_sta->coex_table_type = type;
+
+	switch (type) {
+	case 0:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaa5a5a, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0xaa5a5a5a, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8812a1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8	data_len = 3;
+	u8	buf[5] = {0};
+
+	buf[0] = data_len;
+	buf[1] = 0x1;			/* OP_Code */
+	buf[2] = 0x1;			/* OP_Code_Length */
+	if (enable)
+		buf[3] = 0x1;		/* OP_Code_Content */
+	else
+		buf[3] = 0x0;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_COEX,
+			   (void *)&buf[0]);
+}
+
+void halbtc8812a1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8812a1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8812a1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8812a1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8812a1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8812a1ant_sw_mechanism(IN struct btc_coexist *btcoexist,
+				  IN boolean low_penalty_ra)
+{
+	halbtc8812a1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+
+/* to check force_exec */
+void halbtc8812a1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean force_exec, IN boolean init_hwcfg,
+				  IN boolean wifi_off)
+{
+	u8			u8tmp = 0;
+
+	coex_dm->cur_ant_pos_type = ant_pos_type;
+
+	if (init_hwcfg) {
+		btcoexist->btc_write_1byte(btcoexist, 0xcb3, 0x77);
+		btcoexist->btc_write_4byte(btcoexist, 0x900, 0x00000400);
+		btcoexist->btc_write_1byte(btcoexist, 0x76d, 0x1);
+	} else if (wifi_off) {
+		btcoexist->btc_write_1byte(btcoexist, 0xcb3, 0x77);
+		u8tmp = btcoexist->btc_read_1byte(btcoexist, 0xcb7);
+		u8tmp &= ~BIT(3);
+		u8tmp |= BIT(2);
+		btcoexist->btc_write_1byte(btcoexist, 0xcb7, u8tmp);
+	}
+
+	if (force_exec ||
+	    (coex_dm->cur_ant_pos_type != coex_dm->pre_ant_pos_type)) {
+		/* ext switch setting */
+		switch (ant_pos_type) {
+		case BTC_ANT_PATH_WIFI:
+			u8tmp = btcoexist->btc_read_1byte(btcoexist,
+							  0xcb7);
+			u8tmp |= BIT(3);
+			u8tmp &= ~BIT(2);
+			btcoexist->btc_write_1byte(btcoexist, 0xcb7,
+						   u8tmp);
+			break;
+		case BTC_ANT_PATH_BT:
+			u8tmp = btcoexist->btc_read_1byte(btcoexist,
+							  0xcb7);
+			u8tmp &= ~BIT(3);
+			u8tmp |= BIT(2);
+			btcoexist->btc_write_1byte(btcoexist, 0xcb7,
+						   u8tmp);
+			break;
+		default:
+		case BTC_ANT_PATH_PTA:
+			u8tmp = btcoexist->btc_read_1byte(btcoexist,
+							  0xcb7);
+			u8tmp |= BIT(3);
+			u8tmp &= ~BIT(2);
+			btcoexist->btc_write_1byte(btcoexist, 0xcb7,
+						   u8tmp);
+			break;
+		}
+	}
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+}
+
+void halbtc8812a1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for 1Ant AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+		}
+	}
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+
+void halbtc8812a1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_busy = false;
+	u8			rssi_adjust_val = 0;
+	u8			ps_tdma_byte4_val = 0x50, ps_tdma_byte0_val = 0x51,
+				ps_tdma_byte3_val =  0x10;
+	s8			wifi_duration_adjust = 0x0;
+	static boolean	 pre_wifi_busy = false;
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (wifi_busy != pre_wifi_busy) {
+		force_exec = true;
+		pre_wifi_busy = wifi_busy;
+	}
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (coex_sta->scan_ap_num <= 5)
+		wifi_duration_adjust = 2;
+	else if (coex_sta->scan_ap_num >= 40)
+		wifi_duration_adjust = -15;
+	else if (coex_sta->scan_ap_num >= 20)
+		wifi_duration_adjust = -10;
+
+	if (!coex_sta->force_lps_on) { /* only for A2DP-only case 1/2/9/11 while wifi noisy threshold > 30 */
+		ps_tdma_byte0_val = 0x61;  /* no null-pkt */
+		ps_tdma_byte3_val = 0x11; /* no tx-pause at BT-slot */
+		ps_tdma_byte4_val = 0x10; /* 0x778 = d/1 toggle */
+	}
+
+	if ((type == 3) || (type == 13) || (type == 14)) {
+		ps_tdma_byte4_val = ps_tdma_byte4_val &
+			    0xbf;  /* no dynamic slot for multi-profile */
+
+		if (!wifi_busy)
+			ps_tdma_byte4_val = ps_tdma_byte4_val |
+				0x1;  /* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+	}
+
+	if (bt_link_info->slave_role == true)
+		ps_tdma_byte4_val = ps_tdma_byte4_val |
+			0x1;  /* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+
+	if (turn_on) {
+		switch (type) {
+		default:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x1a, 0x1a, 0x0, ps_tdma_byte4_val);
+			break;
+		case 1:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x3a +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 2:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x2d +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 3:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x1d, 0x1d, 0x0, ps_tdma_byte4_val);
+			break;
+		case 4:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x14, 0x0);
+			break;
+		case 5:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x15, 0x3, 0x11, 0x11);
+			break;
+		case 6:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x20, 0x3, 0x11, 0x11);
+			break;
+		case 7:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xc, 0x5, 0x0, 0x0);
+			break;
+		case 8:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 9:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 10:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0xa, 0x0, 0x40);
+			break;
+		case 11:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 12:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x0a, 0x0a, 0x0, 0x50);
+			break;
+		case 13:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x12, 0x12, 0x0, ps_tdma_byte4_val);
+			break;
+		case 14:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x21, 0x3, 0x10, ps_tdma_byte4_val);
+			break;
+		case 15:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0x3, 0x8, 0x0);
+			break;
+		case 16:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x10, 0x0);
+			break;
+		case 18:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 20:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x3f, 0x03, 0x11, 0x10);
+			break;
+		case 21:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x11);
+			break;
+		case 22:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x10);
+			break;
+		case 23:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x18);
+			break;
+		case 24:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x3, 0x31, 0x18);
+			break;
+		case 25:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 26:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 27:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x98);
+			break;
+		case 28:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x69,
+						      0x25, 0x3, 0x31, 0x0);
+			break;
+		case 29:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xab,
+						      0x1a, 0x1a, 0x1, 0x10);
+			break;
+		case 30:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x10);
+			break;
+		case 31:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1a, 0x1a, 0, 0x58);
+			break;
+		case 32:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x3, 0x11, 0x11);
+			break;
+		case 33:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x25, 0x3, 0x30, 0x90);
+			break;
+		case 34:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 35:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x63,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 36:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x12, 0x3, 0x14, 0x50);
+			break;
+		case 40: /* SoftAP only with no sta associated,BT disable ,TDMA mode for power saving */
+			/* here softap mode screen off will cost 70-80mA for phone */
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x23,
+						      0x18, 0x00, 0x10, 0x24);
+			break;
+		}
+	} else {
+
+		/* disable PS tdma */
+		switch (type) {
+		case 8: /* PTA Control */
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 0:
+		default:  /* Software control, Antenna at BT side */
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		}
+	}
+	rssi_adjust_val = 0;
+	btcoexist->btc_set(btcoexist,
+		BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE, &rssi_adjust_val);
+
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+boolean halbtc8812a1ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected &&
+	    BT_8812A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8812a1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8812A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8812a1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (!wifi_connected &&
+		(BT_8812A_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8812a1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (wifi_connected &&
+		(BT_8812A_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8812a1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (!wifi_connected &&
+		(BT_8812A_1ANT_BT_STATUS_CONNECTED_IDLE != coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non connected-idle + BT Busy!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8812a1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else {
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		common = false;
+	}
+
+	return common;
+}
+
+
+void halbtc8812a1ant_tdma_duration_adjust_for_acl(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0, bt_info_ext;
+	boolean			wifi_busy = false;
+
+	if (BT_8812A_1ANT_WIFI_STATUS_CONNECTED_BUSY == wifi_status)
+		wifi_busy = true;
+	else
+		wifi_busy = false;
+
+	if ((BT_8812A_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN ==
+	     wifi_status) ||
+	    (BT_8812A_1ANT_WIFI_STATUS_CONNECTED_SCAN == wifi_status) ||
+	    (BT_8812A_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT ==
+	     wifi_status)) {
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 3 &&
+		    coex_dm->cur_ps_tdma != 9) {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						9);
+			coex_dm->ps_tdma_du_adj_type = 9;
+
+			up = 0;
+			dn = 0;
+			m = 1;
+			n = 3;
+			result = 0;
+			wait_count = 0;
+		}
+		return;
+	}
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 2);
+		coex_dm->ps_tdma_du_adj_type = 2;
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* acquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		bt_info_ext = coex_sta->bt_info_ext;
+
+		if ((coex_sta->low_priority_tx) > 1150 ||
+		    (coex_sta->low_priority_rx) > 1250)
+			retry_count++;
+
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if retry count during continuous n*2 seconds is 0, enlarge WiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if continuous 2 retry count(every 2 seconds) >0 and < 3, reduce WiFi duration */
+				if (wait_count <= 2)
+					m++; /* to avoid loop between the two levels */
+				else
+					m = 1;
+
+				if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, once retry count > 3, to reduce WiFi duration */
+			if (wait_count == 1)
+				m++; /* to avoid loop between the two levels */
+			else
+				m = 1;
+
+			if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (result == -1) {
+			if ((BT_INFO_8812A_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+			    ((coex_dm->cur_ps_tdma == 1) ||
+			     (coex_dm->cur_ps_tdma == 2))) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 1) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 11);
+				coex_dm->ps_tdma_du_adj_type = 11;
+			}
+		} else if (result == 1) {
+			if ((BT_INFO_8812A_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+			    ((coex_dm->cur_ps_tdma == 1) ||
+			     (coex_dm->cur_ps_tdma == 2))) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 11) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 1);
+				coex_dm->ps_tdma_du_adj_type = 1;
+			}
+		} else { /* no change */
+			/* Bryant Modify
+			if(wifi_busy != pre_wifi_busy)
+			{
+				pre_wifi_busy = wifi_busy;
+				halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, true, coex_dm->cur_ps_tdma);
+			}
+			*/
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** TDMA(on, %d) **********\n",
+				    coex_dm->cur_ps_tdma);
+			BTC_TRACE(trace_buf);
+		}
+
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 9 &&
+		    coex_dm->cur_ps_tdma != 11) {
+			/* recover to previous adjust type */
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		}
+	}
+}
+
+void halbtc8812a1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8812a1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8812a1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8812a1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8812a1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8812a1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	halbtc8812a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+	halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, FORCE_EXEC,
+				     false, false);
+}
+
+void halbtc8812a1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a1ant_action_wifi_only(btcoexist);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		if (!bt_disabled) {
+		} else {
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+					   NULL);
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+					   NULL);
+		}
+	}
+}
+
+/* *********************************************
+ *
+ *	Software Coex Mechanism start
+ *
+ * ********************************************* */
+
+/* SCO only or SCO+PAN(HS) */
+
+/*
+void halbtc8812a1ant_action_sco(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8812a1ant_action_hid(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8812a1ant_action_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8812a1ant_action_a2dp_pan_hs(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8812a1ant_action_pan_edr(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, false);
+}
+
+
+void halbtc8812a1ant_action_pan_hs(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, false);
+}
+
+
+void halbtc8812a1ant_action_pan_edr_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8812a1ant_action_pan_edr_hid(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8812a1ant_action_hid_a2dp_pan_edr(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, true);
+}
+
+void halbtc8812a1ant_action_hid_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, true);
+}
+
+*/
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+void halbtc8812a1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC,
+				     false, false);
+	halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8812a1ant_action_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8812a1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_connected = false, ap_enable = false, wifi_busy = false,
+				bt_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	if ((!wifi_connected) && (!coex_sta->wifi_is_high_pri_task)) {
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+		   (bt_link_info->a2dp_exist)) {
+		/* SCO/HID/A2DP  busy */
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if ((bt_link_info->pan_exist) || (wifi_busy)) {
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	}
+}
+
+void halbtc8812a1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	/* tdma and coex table */
+
+	if (bt_link_info->sco_exist) {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	} else { /* HID */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 6);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	}
+}
+
+void halbtc8812a1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	u8		bt_rssi_state;
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	bt_rssi_state = halbtc8812a1ant_bt_rssi_state(2, 28, 0);
+
+	if ((coex_sta->low_priority_rx >= 950)  && (!coex_sta->under_ips))
+		bt_link_info->slave_role = true;
+	else
+		bt_link_info->slave_role = false;
+
+	if (bt_link_info->hid_only) { /* HID */
+		halbtc8812a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				wifi_status);
+		coex_dm->auto_tdma_adjust = false;
+		return;
+	} else if (bt_link_info->a2dp_only) { /* A2DP		 */
+		if (BT_8812A_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifi_status) {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = false;
+		} else {
+			halbtc8812a1ant_tdma_duration_adjust_for_acl(btcoexist,
+					wifi_status);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = true;
+		}
+	} else if (((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	} else if (bt_link_info->hid_exist &&
+		   bt_link_info->a2dp_exist) { /* HID+A2DP */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+		coex_dm->auto_tdma_adjust = false;
+
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	} else if ((bt_link_info->pan_only) || (bt_link_info->hid_exist &&
+		bt_link_info->pan_exist)) { /* PAN(OPP,FTP), HID+PAN(OPP,FTP)			 */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		/* BT no-profile busy (0x9) */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	}
+}
+
+void halbtc8812a1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	/* power save state */
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC,
+				     false, false);
+	halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8812a1ant_action_wifi_not_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if (BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8812A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8812a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8812A_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8812a1ant_action_wifi_not_connected_asso_auth(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist)  || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 4);
+	} else {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 2);
+	}
+}
+
+void halbtc8812a1ant_action_wifi_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if (BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8812A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8812a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8812A_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8812a1ant_action_wifi_connected_specific_packet(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8812a1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	boolean	wifi_busy = false;
+	boolean		scan = false, link = false, roam = false;
+	boolean		under_4way = false, ap_enable = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+	if (under_4way) {
+		halbtc8812a1ant_action_wifi_connected_specific_packet(btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under 4way<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	if (scan || link || roam) {
+		if (scan)
+			halbtc8812a1ant_action_wifi_connected_scan(btcoexist);
+		else
+			halbtc8812a1ant_action_wifi_connected_specific_packet(
+				btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under scan<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	/* power save state */
+	if (!ap_enable &&
+	    BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status &&
+	    !btcoexist->bt_link_info.hid_only) {
+		if (btcoexist->bt_link_info.a2dp_only) {	/* A2DP */
+			if (!wifi_busy)
+				halbtc8812a1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			else { /* busy */
+				if (coex_sta->scan_ap_num >=
+				    BT_8812A_1ANT_WIFI_NOISY_THRESH)  /* no force LPS, no PS-TDMA, use pure TDMA */
+					halbtc8812a1ant_power_save_state(
+						btcoexist, BTC_PS_WIFI_NATIVE,
+						0x0, 0x0);
+				else
+					halbtc8812a1ant_power_save_state(
+						btcoexist, BTC_PS_LPS_ON, 0x50,
+						0x4);
+			}
+		} else if ((coex_sta->pan_exist == false) &&
+			   (coex_sta->a2dp_exist == false) &&
+			   (coex_sta->hid_exist == false))
+			halbtc8812a1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		else
+			halbtc8812a1ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+	} else
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+
+	/* tdma and coex table */
+	if (!wifi_busy) {
+		if (BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8812a1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8812A_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else if ((BT_8812A_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8812a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8812A_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+			halbtc8812a1ant_set_ant_path(btcoexist,
+				BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false);
+			if ((coex_sta->high_priority_tx) +
+			    (coex_sta->high_priority_rx) <= 60)
+				halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+			else
+				halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		}
+	} else {
+		if (BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8812a1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8812A_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else if ((BT_8812A_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8812a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8812A_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+			halbtc8812a1ant_set_ant_path(btcoexist,
+				BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false);
+			if ((coex_sta->high_priority_tx) +
+			    (coex_sta->high_priority_rx) <= 60)
+				halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+			else
+				halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		}
+	}
+}
+
+void halbtc8812a1ant_run_sw_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8				algorithm = 0;
+
+	algorithm = halbtc8812a1ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+
+	if (halbtc8812a1ant_is_common_action(btcoexist)) {
+
+	} else {
+		switch (coex_dm->cur_algorithm) {
+		case BT_8812A_1ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_sco(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_hid(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_a2dp(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_a2dp_pan_hs(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_pan_edr(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_pan_hs(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_pan_edr_a2dp(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_pan_edr_hid(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_hid_a2dp_pan_edr(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_hid_a2dp(btcoexist); */
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_coex_all_off(btcoexist); */
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8812a1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, bt_hs_on = false;
+	boolean	increase_scan_dev_num = false;
+	boolean	bt_ctrl_agg_buf_size = false;
+	boolean	miracast_plus_bt = false;
+	u8	agg_buf_size = 5;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0, wifi_bw;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if ((BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8812A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+			   &increase_scan_dev_num);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist) {
+			halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1,
+						   0, 1);
+			miracast_plus_bt = true;
+		} else {
+			halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0,
+						   0, 0);
+			miracast_plus_bt = false;
+		}
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+		halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+
+		if ((bt_link_info->a2dp_exist) &&
+		    (coex_sta->c2h_bt_inquiry_page)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is Inquirying\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a1ant_action_bt_inquiry(btcoexist);
+		} else
+			halbtc8812a1ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	}
+
+	miracast_plus_bt = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+			   &miracast_plus_bt);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_link_info->bt_link_exist) && (wifi_connected)) {
+		halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1, 0, 1);
+
+		if (bt_link_info->sco_exist)
+			halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC, true,
+						   false, 0x5);
+		else {
+			if (BTC_WIFI_BW_HT40 == wifi_bw)
+				halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC,
+							   false, true, 0x10);
+			else
+				halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC,
+							   false, true, 0x8);
+		}
+
+		halbtc8812a1ant_sw_mechanism(btcoexist, true);
+		halbtc8812a1ant_run_sw_coexist_mechanism(
+			btcoexist);  /* just print debug message */
+	} else {
+		halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+		halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x5);
+
+		halbtc8812a1ant_sw_mechanism(btcoexist, false);
+		halbtc8812a1ant_run_sw_coexist_mechanism(
+			btcoexist); /* //just print debug message */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "############# [BTCoex],  BT Is Inquirying\n");
+		BTC_TRACE(trace_buf);
+		halbtc8812a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8812a1ant_action_hs(btcoexist);
+		return;
+	}
+
+
+	if (!wifi_connected) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is non connected-idle !!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (scan || link || roam) {
+			if (scan)
+				halbtc8812a1ant_action_wifi_not_connected_scan(
+					btcoexist);
+			else
+				halbtc8812a1ant_action_wifi_not_connected_asso_auth(
+					btcoexist);
+		} else
+			halbtc8812a1ant_action_wifi_not_connected(btcoexist);
+	} else	/* wifi LPS/Busy */
+		halbtc8812a1ant_action_wifi_connected(btcoexist);
+}
+
+void halbtc8812a1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+
+	/* sw all off */
+	halbtc8812a1ant_sw_mechanism(btcoexist, false);
+
+	/* halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8); */
+	/* halbtc8812a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0); */
+
+	coex_sta->pop_event_cnt = 0;
+}
+
+void halbtc8812a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up, IN boolean wifi_only)
+{
+	u8	u8tmp = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	/* ant sw control to BT */
+	halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, FORCE_EXEC,
+				     true, false);
+
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* PTA parameter */
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, 0x0);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, 0xffff);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, 0x55555555);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, 0x55555555);
+
+	/* coex parameters */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+
+	/* enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	/* enable PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x40, 0x20);
+
+	/* bt clock related */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x4);
+	u8tmp |= BIT(7);
+	btcoexist->btc_write_1byte(btcoexist, 0x4, u8tmp);
+
+	/* bt clock related */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x7);
+	u8tmp |= BIT(1);
+	btcoexist->btc_write_1byte(btcoexist, 0x7, u8tmp);
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8812a1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8812a1ant_
+ * ************************************************************ */
+void ex_halbtc8812a1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8812a1ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8812a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8812a1ant_init_hw_config(btcoexist, true, wifi_only);
+	btcoexist->stop_coex_dm = false;
+}
+
+void ex_halbtc8812a1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = false;
+
+	halbtc8812a1ant_init_coex_dm(btcoexist);
+
+	halbtc8812a1ant_query_bt_info(btcoexist);
+}
+
+void ex_halbtc8812a1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8			*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u32				u32tmp[4];
+	u32				fw_ver = 0, bt_patch_ver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%d/ 0x%x/ 0x%x(%d)",
+		   "CoexVer/ FwVer/ PatchVer",
+		   glcoex_ver_date_8812a_1ant, glcoex_ver_8812a_1ant, fw_ver,
+		   bt_patch_ver, bt_patch_ver);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8812A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8812A_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_BT_LINK_INFO);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8812A_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8812a_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	if (!btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[mechanisms]============");
+		CL_PRINTF(cli_buf);
+
+		ps_tdma_case = coex_dm->cur_ps_tdma;
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d",
+			   "PS TDMA",
+			   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+			   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+			   coex_dm->ps_tdma_para[4], ps_tdma_case);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ",
+			   "Latest error condition(should be 0)",
+			   coex_dm->error_condition);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ",
+			   "IgnWlanAct",
+			   coex_dm->cur_ignore_wlan_act);
+		CL_PRINTF(cli_buf);
+	}
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x778",
+		   u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xcb3);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xcb7);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x900);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0xcb3/0xcb7/0x900",
+		   u8tmp[0], u8tmp[1], u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x40",
+		   u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)",
+		   u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(hp rx[31:16]/tx[15:0])",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(lp rx[31:16]/tx[15:0])",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+
+void ex_halbtc8812a1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8812a1ant_init_hw_config(btcoexist, false, false);
+		halbtc8812a1ant_init_coex_dm(btcoexist);
+		halbtc8812a1ant_query_bt_info(btcoexist);
+
+		coex_sta->under_ips = false;
+	}
+}
+
+void ex_halbtc8812a1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8812a1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_SCAN_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+	}
+
+	if (coex_sta->bt_disabled)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	halbtc8812a1ant_query_bt_info(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8812a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8812a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8812a1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_SCAN_START == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8812a1ant_action_wifi_not_connected_scan(
+				btcoexist);
+		else	/* wifi is connected */
+			halbtc8812a1ant_action_wifi_connected_scan(btcoexist);
+	} else if (BTC_SCAN_FINISH == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8812a1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8812a1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8812a1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	boolean	wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_ASSOCIATE_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		/* coex_dm->arp_cnt = 0; */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8812a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8812a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8812a1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_ASSOCIATE_START == type)
+		halbtc8812a1ant_action_wifi_not_connected_asso_auth(btcoexist);
+	else if (BTC_ASSOCIATE_FINISH == type) {
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+				   &wifi_connected);
+		if (!wifi_connected) /* non-connected scan */
+			halbtc8812a1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8812a1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+/* to check registers... */
+void ex_halbtc8812a1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			data_len = 5;
+	u8			buf[6] = {0};
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	boolean			wifi_under_b_mode = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+		halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+#if 0
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x10); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+#endif
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		/* h2c_parameter[0] = 0x1; */
+		h2c_parameter[0] = 0x0;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	buf[0] = data_len;
+	buf[1] = 0x5;				/* OP_Code */
+	buf[2] = 0x3;				/* OP_Code_Length */
+	buf[3] = h2c_parameter[0];	/* OP_Code_Content */
+	buf[4] = h2c_parameter[1];
+	buf[5] = h2c_parameter[2];
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_COEX,
+			   (void *)&buf[0]);
+}
+
+void ex_halbtc8812a1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    BTC_PACKET_ARP == type) {
+		if (BTC_PACKET_ARP == type) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], specific Packet ARP notify\n");
+			BTC_TRACE(trace_buf);
+
+			coex_dm->arp_cnt++;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], ARP Packet Count = %d\n",
+				    coex_dm->arp_cnt);
+			BTC_TRACE(trace_buf);
+
+			if (coex_dm->arp_cnt >=
+			    10) /* if APR PKT > 10 after connect, do not go to ActionWifiConnectedSpecificPacket(btcoexist) */
+				coex_sta->wifi_is_high_pri_task = false;
+			else
+				coex_sta->wifi_is_high_pri_task = true;
+		} else {
+			coex_sta->wifi_is_high_pri_task = true;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], specific Packet DHCP or EAPOL notify\n");
+			BTC_TRACE(trace_buf);
+		}
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet [Type = %d] notify\n", type);
+		BTC_TRACE(trace_buf);
+	}
+
+	coex_sta->specific_pkt_period_cnt = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8812a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8812a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8812a1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    ((BTC_PACKET_ARP == type) && (coex_sta->wifi_is_high_pri_task)))
+		halbtc8812a1ant_action_wifi_connected_specific_packet(btcoexist);
+}
+
+void ex_halbtc8812a1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8				bt_info = 0;
+	u8				i, rsp_source = 0;
+	boolean				wifi_connected = false;
+	boolean				bt_busy = false;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8812A_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8812A_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	if (BT_INFO_SRC_8812A_1ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->bt_info_c2h[rsp_source][2] & 0x20)
+			coex_sta->c2h_bt_page = true;
+		else
+			coex_sta->c2h_bt_page = false;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 - 90;
+		/* coex_sta->bt_info_c2h[rsp_source][3]*2+10; */
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+		if (!coex_sta->bt_tx_rx_mask) {
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x15\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+						  0x3c, 0x15);
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if (coex_sta->bt_info_ext & BIT(1)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8812a1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8812a1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if (coex_sta->bt_info_ext & BIT(3)) {
+			if (!btcoexist->manual_control &&
+			    !btcoexist->stop_coex_dm) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8812a1ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			}
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+		}
+#if (BT_AUTO_REPORT_ONLY_8812A_1ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8812a1ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8812A_1ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8812A_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8812A_1ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8812A_1ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8812A_1ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8812A_1ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+	}
+
+	halbtc8812a1ant_update_bt_link_info(btcoexist);
+
+	bt_info = bt_info &
+		0x1f;  /* mask profile bit for connect-ilde identification ( for CSR case: A2DP idle --> 0x41) */
+
+	if (!(bt_info & BT_INFO_8812A_1ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8812A_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8812A_1ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8812A_1ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8812A_1ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8812A_1ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8812A_1ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8812A_1ANT_B_ACL_BUSY) {
+		if (BT_8812A_1ANT_BT_STATUS_ACL_BUSY != coex_dm->bt_status)
+			coex_dm->auto_tdma_adjust = false;
+		coex_dm->bt_status = BT_8812A_1ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8812A_1ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8812A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	halbtc8812a1ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8812a1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+	} else if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+
+		halbtc8812a1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		btcoexist->stop_coex_dm = true;
+	}
+}
+
+void ex_halbtc8812a1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+	halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, FORCE_EXEC,
+				     false, true);
+
+	halbtc8812a1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8812a1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	btcoexist->stop_coex_dm = true;
+}
+
+void ex_halbtc8812a1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+		btcoexist->stop_coex_dm = true;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+		halbtc8812a1ant_init_hw_config(btcoexist, false, false);
+		halbtc8812a1ant_init_coex_dm(btcoexist);
+		halbtc8812a1ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8812a1ant_coex_dm_reset(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], *****************Coex DM Reset*****************\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8812a1ant_init_hw_config(btcoexist, false, false);
+	halbtc8812a1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8812a1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+#if (BT_AUTO_REPORT_ONLY_8812A_1ANT == 0)
+	halbtc8812a1ant_query_bt_info(btcoexist);
+	halbtc8812a1ant_monitor_bt_enable_disable(btcoexist);
+#else
+	halbtc8812a1ant_monitor_bt_ctr(btcoexist);
+	halbtc8812a1ant_monitor_wifi_ctr(btcoexist);
+
+	if (halbtc8812a1ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust)
+		halbtc8812a1ant_run_coexist_mechanism(btcoexist);
+
+	coex_sta->specific_pkt_period_cnt++;
+#endif
+}
+
+void ex_halbtc8812a1ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata)
+{
+	switch (op_code) {
+	case BTC_DBG_SET_COEX_NORMAL:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set CoexMode to Normal\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->manual_control = false;
+		halbtc8812a1ant_init_coex_dm(btcoexist);
+		break;
+	case BTC_DBG_SET_COEX_WIFI_ONLY:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set CoexMode to Wifi Only\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->manual_control = true;
+		halbtc8812a1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+					9);
+		break;
+	case BTC_DBG_SET_COEX_BT_ONLY:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set CoexMode to BT only\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->manual_control = true;
+		halbtc8812a1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+					0);
+		break;
+	case BTC_DBG_SET_COEX_DEC_BT_PWR:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set Dec BT power\n");
+		BTC_TRACE(trace_buf);
+		{
+			u8	data_len = 4;
+			u8	buf[6] = {0};
+			u8	dec_bt_pwr = 0, pwr_level = 0;
+
+			if (op_len == 2) {
+				dec_bt_pwr = pdata[0];
+				pwr_level = pdata[1];
+
+				buf[0] = data_len;
+				buf[1] = 0x3;		/* OP_Code */
+				buf[2] = 0x2;		/* OP_Code_Length */
+
+				buf[3] = dec_bt_pwr;	/* OP_Code_Content */
+				buf[4] = pwr_level;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Set Dec BT power=%d, pwr_level=%d\n",
+					    dec_bt_pwr, pwr_level);
+				BTC_TRACE(trace_buf);
+				btcoexist->btc_set(btcoexist,
+						   BTC_SET_ACT_CTRL_BT_COEX,
+						   (void *)&buf[0]);
+			}
+		}
+		break;
+
+	case BTC_DBG_SET_COEX_BT_AFH_MAP:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set BT AFH Map\n");
+		BTC_TRACE(trace_buf);
+		{
+			u8	data_len = 5;
+			u8	buf[6] = {0};
+
+			if (op_len == 3) {
+				buf[0] = data_len;
+				buf[1] = 0x5;				/* OP_Code */
+				buf[2] = 0x3;				/* OP_Code_Length */
+
+				buf[3] = pdata[0];			/* OP_Code_Content */
+				buf[4] = pdata[1];
+				buf[5] = pdata[2];
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Set BT AFH Map = %02x %02x %02x\n",
+					    pdata[0], pdata[1], pdata[2]);
+				BTC_TRACE(trace_buf);
+				btcoexist->btc_set(btcoexist,
+						   BTC_SET_ACT_CTRL_BT_COEX,
+						   (void *)&buf[0]);
+			}
+		}
+		break;
+
+	case BTC_DBG_SET_COEX_BT_IGNORE_WLAN_ACT:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set BT Ignore Wlan Active\n");
+		BTC_TRACE(trace_buf);
+		{
+			u8	data_len = 3;
+			u8	buf[6] = {0};
+
+			if (op_len == 1) {
+				buf[0] = data_len;
+				buf[1] = 0x1;			/* OP_Code */
+				buf[2] = 0x1;			/* OP_Code_Length */
+
+				buf[3] = pdata[0];		/* OP_Code_Content */
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Set BT Ignore Wlan Active = 0x%x\n",
+					    pdata[0]);
+				BTC_TRACE(trace_buf);
+
+				btcoexist->btc_set(btcoexist,
+						   BTC_SET_ACT_CTRL_BT_COEX,
+						   (void *)&buf[0]);
+			}
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8812a1ant.h
@@ -0,0 +1,230 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8812A_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8812A 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8812A_1ANT				1
+
+#define	BT_INFO_8812A_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8812A_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8812A_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8812A_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8812A_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8812A_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8812A_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8812A_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8812A_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+		(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT		2
+
+#define  BT_8812A_1ANT_WIFI_NOISY_THRESH								30   /* max: 255 */
+
+enum bt_info_src_8812a_1ant {
+	BT_INFO_SRC_8812A_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8812A_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8812A_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8812A_1ANT_MAX
+};
+
+enum bt_8812a_1ant_bt_status {
+	BT_8812A_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8812A_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8812A_1ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8812A_1ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8812A_1ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8812A_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8812a_1ant_wifi_status {
+	BT_8812A_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8812A_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8812A_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8812A_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT				= 0x3,
+	BT_8812A_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8812A_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8812A_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8812a_1ant_coex_algo {
+	BT_8812A_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8812A_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8812A_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8812A_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8812A_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8812A_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8812A_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8812A_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8812A_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8812A_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8812A_1ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8812A_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8812a_1ant {
+	/* hw setting */
+	u8		pre_ant_pos_type;
+	u8		cur_ant_pos_type;
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8812a_1ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	s8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8812A_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8812A_1ANT_MAX];
+	u32					bt_info_query_cnt;
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_page;				/* Add for win8.1 page out issue */
+	boolean					wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_agg;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_agg;
+
+	boolean					cck_lock;
+	boolean					pre_ccklock;
+	u8					coex_table_type;
+
+	boolean					force_lps_on;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8812a1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a1ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8812a1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8812a1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8812a1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8812a1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8812a1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8812a1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8812a1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8812a1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8812a1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8812a1ant_coex_dm_reset(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a1ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata);
+void ex_halbtc8812a1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8812a1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8812a1ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8812a1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8812a1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8812a1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8812a1ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_halt_notify(btcoexist)
+#define	ex_halbtc8812a1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8812a1ant_coex_dm_reset(btcoexist)
+#define	ex_halbtc8812a1ant_periodical(btcoexist)
+#define	ex_halbtc8812a1ant_dbg_control(btcoexist, op_code, op_len, pdata)
+#define	ex_halbtc8812a1ant_display_coex_info(btcoexist)
+
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8812a2ant.c
@@ -0,0 +1,5624 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8812A Co-exist mechanism
+ *
+ * History
+ * 2012/08/22 Cosa first check in.
+ * 2012/11/14 Cosa Revise for 8812A 2Ant out sourcing.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+
+#if (RTL8812A_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8812a_2ant	glcoex_dm_8812a_2ant;
+static struct  coex_dm_8812a_2ant	*coex_dm = &glcoex_dm_8812a_2ant;
+static struct  coex_sta_8812a_2ant	glcoex_sta_8812a_2ant;
+static struct  coex_sta_8812a_2ant	*coex_sta = &glcoex_sta_8812a_2ant;
+
+const char *const glbt_info_src_8812a_2ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+/* ************************************************************
+ * BtCoex Version Format:
+ * 1. date :			glcoex_ver_date_XXXXX_1ant
+ * 2. WifiCoexVersion : glcoex_ver_XXXX_1ant
+ * 3. BtCoexVersion :	glcoex_ver_btdesired_XXXXX_1ant
+ * 4. others :			glcoex_ver_XXXXXX_XXXXX_1ant
+ *
+ * Variable should be indicated IC and Antenna numbers !!!
+ * Please strictly follow this order and naming style !!!
+ *
+ * ************************************************************ */
+u32	glcoex_ver_date_8812a_2ant = 20160818;
+u32	glcoex_ver_8812a_2ant = 0x3c;
+u32	glcoex_ver_btdesired_8812a_2ant = 0x3c;
+/*1. add coex. log for wifi/BT coex. version*/
+
+/* ************************************************************
+* local function proto type if needed
+* ************************************************************
+* ************************************************************
+* local function start with halbtc8812a2ant_
+* ************************************************************ */
+u8 halbtc8812a2ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+
+u8 halbtc8812a2ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+
+void halbtc8812a2ant_set_enable_pta(IN struct btc_coexist *btcoexist,
+				    IN boolean enablePTA)
+{
+	if (enablePTA) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], PTA is enable!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte(btcoexist, 0x40, 0x20);
+
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], PTA is disable!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte(btcoexist, 0x40, 0x00);
+
+	}
+}
+
+void halbtc8812a2ant_enable_pta(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN boolean enable)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], %s turn Enable PTA %s\n",
+		    (force_exec ? "force to" : ""), (enable ? "ON" : "OFF"));
+	BTC_TRACE(trace_buf);
+	coex_dm->cur_enable_pta = enable;
+
+	if (!force_exec) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], pre_enable_pta = %d, cur_enable_pta = %d!!\n",
+			    coex_dm->pre_enable_pta, coex_dm->cur_enable_pta);
+		BTC_TRACE(trace_buf);
+
+		if (coex_dm->pre_enable_pta == coex_dm->cur_enable_pta)
+			return;
+	}
+	halbtc8812a2ant_set_enable_pta(btcoexist, enable);
+
+
+	coex_dm->pre_enable_pta = coex_dm->cur_enable_pta;
+}
+
+u32 halbtc8812a2ant_decide_ra_mask(IN struct btc_coexist *btcoexist,
+				   IN u32 ra_mask_type)
+{
+	u32	dis_ra_mask = 0x0;
+
+	switch (ra_mask_type) {
+	case 0: /* normal mode */
+		dis_ra_mask = 0x0;
+		break;
+	case 1: /* disable cck 1/2 */
+		dis_ra_mask = 0x00000003;
+		break;
+	case 2: /* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4			 */
+		dis_ra_mask = 0x0001f1f7;
+		break;
+	default:
+		break;
+	}
+
+	return dis_ra_mask;
+}
+
+void halbtc8812a2ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8812a2ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8812a2ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8812a2ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8812a2ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	u32	dis_ra_mask = 0x0;
+
+	coex_dm->cur_ra_mask_type = ra_mask_type;
+	dis_ra_mask = halbtc8812a2ant_decide_ra_mask(btcoexist, ra_mask_type);
+	halbtc8812a2ant_update_ra_mask(btcoexist, force_exec, dis_ra_mask);
+
+	halbtc8812a2ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8812a2ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8812a2ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8812a2ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8812a2ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_hp_txrx, reg_hp_tx, reg_hp_tx, reg_hp_rx, reg_hp_rx);
+	BTC_TRACE(trace_buf);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_lp_txrx, reg_lp_tx, reg_lp_tx, reg_lp_rx, reg_lp_rx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+}
+
+
+void halbtc8812a2ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+#if 1
+
+	coex_sta->crc_ok_cck =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_OK_CCK);
+	coex_sta->crc_ok_11g =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_OK_LEGACY);
+	coex_sta->crc_ok_11n =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_OK_HT);
+	coex_sta->crc_ok_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_OK_VHT);
+
+	coex_sta->crc_err_cck =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_ERROR_CCK);
+	coex_sta->crc_err_11g =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_ERROR_LEGACY);
+	coex_sta->crc_err_11n =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_ERROR_HT);
+	coex_sta->crc_err_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_ERROR_VHT);
+#endif
+}
+
+
+void halbtc8812a2ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8	data_len = 3;
+	u8	buf[5] = {0};
+	/* 8812a watch btifo to check BT enable/disable
+	 *	if(!btcoexist->bt_info.bt_disabled) */
+	{
+		if (!coex_sta->bt_info_query_cnt ||
+		    (coex_sta->bt_info_c2h_cnt[BT_INFO_SRC_8812A_2ANT_BT_RSP]
+		     - coex_sta->bt_info_query_cnt) > 2) {
+			buf[0] = data_len;
+			buf[1] = 0x1;	/* polling enable, 1=enable, 0=disable */
+			buf[2] = 0x2;	/* polling time in seconds */
+			buf[3] = 0x1;	/* auto report enable, 1=enable, 0=disable */
+
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_INFO,
+					   (void *)&buf[0]);
+		}
+	}
+	coex_sta->bt_info_query_cnt++;
+}
+
+boolean halbtc8812a2ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean	wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean	wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void halbtc8812a2ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+#if 1/* (BT_AUTO_REPORT_ONLY_8812A_2ANT == 1)	/ profile from bt patch */
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+	bt_link_info->acl_busy = coex_sta->acl_busy;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+#else	/* profile from bt stack */
+	bt_link_info->bt_link_exist = stack_info->bt_link_exist;
+	bt_link_info->sco_exist = stack_info->sco_exist;
+	bt_link_info->a2dp_exist = stack_info->a2dp_exist;
+	bt_link_info->pan_exist = stack_info->pan_exist;
+	bt_link_info->hid_exist = stack_info->hid_exist;
+
+	/* for win-8 stack HID report error */
+	if (!stack_info->hid_exist)
+		stack_info->hid_exist =
+			coex_sta->hid_exist;  /* sync  BTInfo with BT firmware and stack */
+	/* when stack HID report error, here we use the info from bt fw. */
+	if (!stack_info->bt_link_exist)
+		stack_info->bt_link_exist = coex_sta->bt_link_exist;
+#endif
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8812a2ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	struct  btc_stack_info	*stack_info = &btcoexist->stack_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8812A_2ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 0) {
+		if (bt_link_info->acl_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], ACL Busy only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8812A_2ANT_COEX_ALGO_PANEDR;
+		}
+	} else if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8812A_2ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_2ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_2ANT_COEX_ALGO_SCO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8812A_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8812A_2ANT_COEX_ALGO_SCO;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (stack_info->num_of_hid >= 2) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID*2 + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_SCO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_SCO_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8812A_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8812a2ant_set_fw_dac_swing_level(IN struct btc_coexist *btcoexist,
+		IN u8 dac_swing_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	/* There are several type of dacswing */
+	/* 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6 */
+	h2c_parameter[0] = dac_swing_lvl;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Set Dac Swing Level=0x%x\n",
+		    dac_swing_lvl);
+	BTC_TRACE(trace_buf);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], FW write 0x64=0x%x\n",
+		    h2c_parameter[0]);
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
+}
+
+void halbtc8812a2ant_set_fw_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				       IN u8 dec_bt_pwr_lvl)
+{
+	u8	data_len = 4;
+	u8	buf[6] = {0};
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], decrease Bt Power level = %d\n",
+		    dec_bt_pwr_lvl);
+	BTC_TRACE(trace_buf);
+
+	buf[0] = data_len;
+	buf[1] = 0x3;		/* OP_Code */
+	buf[2] = 0x2;		/* OP_Code_Length */
+	if (dec_bt_pwr_lvl)
+		buf[3] = 0x1;	/* OP_Code_Content */
+	else
+		buf[3] = 0x0;
+	buf[4] = dec_bt_pwr_lvl;/* pwr_level */
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_COEX,
+			   (void *)&buf[0]);
+}
+
+void halbtc8812a2ant_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN u8 dec_bt_pwr_lvl)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], %s Dec BT power level = %d\n",
+		    (force_exec ? "force to" : ""), dec_bt_pwr_lvl);
+	BTC_TRACE(trace_buf);
+
+	coex_dm->cur_bt_dec_pwr_lvl = dec_bt_pwr_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_dec_pwr_lvl == coex_dm->cur_bt_dec_pwr_lvl)
+			return;
+	}
+	halbtc8812a2ant_set_fw_dec_bt_pwr(btcoexist,
+					  coex_dm->cur_bt_dec_pwr_lvl);
+
+	coex_dm->pre_bt_dec_pwr_lvl = coex_dm->cur_bt_dec_pwr_lvl;
+}
+
+void halbtc8812a2ant_fw_dac_swing_lvl(IN struct btc_coexist *btcoexist,
+			      IN boolean force_exec, IN u8 fw_dac_swing_lvl)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], %s set FW Dac Swing level = %d\n",
+		    (force_exec ? "force to" : ""), fw_dac_swing_lvl);
+	BTC_TRACE(trace_buf);
+	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swing_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_fw_dac_swing_lvl ==
+		    coex_dm->cur_fw_dac_swing_lvl)
+			return;
+	}
+
+	halbtc8812a2ant_set_fw_dac_swing_level(btcoexist,
+					       coex_dm->cur_fw_dac_swing_lvl);
+
+	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
+}
+
+void halbtc8812a2ant_set_sw_rf_rx_lpf_corner(IN struct btc_coexist *btcoexist,
+		IN boolean rx_rf_shrink_on)
+{
+	if (rx_rf_shrink_on) {
+		/* Shrink RF Rx LPF corner */
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Shrink RF Rx LPF corner!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e, 0xfffff,
+					  0xffffc);
+	} else {
+		/* Resume RF Rx LPF corner */
+		/* After initialized, we can use coex_dm->bt_rf_0x1e_backup */
+		if (btcoexist->initilized) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Resume RF Rx LPF corner!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+					  0xfffff, coex_dm->bt_rf_0x1e_backup);
+		}
+	}
+}
+
+void halbtc8812a2ant_rf_shrink(IN struct btc_coexist *btcoexist,
+		       IN boolean force_exec, IN boolean rx_rf_shrink_on)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], %s turn Rx RF Shrink = %s\n",
+		    (force_exec ? "force to" : ""),
+		    ((rx_rf_shrink_on) ? "ON" : "OFF"));
+	BTC_TRACE(trace_buf);
+	coex_dm->cur_rf_rx_lpf_shrink = rx_rf_shrink_on;
+
+	if (!force_exec) {
+		if (coex_dm->pre_rf_rx_lpf_shrink ==
+		    coex_dm->cur_rf_rx_lpf_shrink)
+			return;
+	}
+	halbtc8812a2ant_set_sw_rf_rx_lpf_corner(btcoexist,
+						coex_dm->cur_rf_rx_lpf_shrink);
+
+	coex_dm->pre_rf_rx_lpf_shrink = coex_dm->cur_rf_rx_lpf_shrink;
+}
+
+void halbtc8812a2ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8	tmp_u1;
+
+	tmp_u1 = btcoexist->btc_read_1byte(btcoexist, 0x4fd);
+	tmp_u1 |= BIT(0);
+	if (low_penalty_ra) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Tx rate adaptive, set low penalty!!\n");
+		BTC_TRACE(trace_buf);
+		tmp_u1 &= ~BIT(2);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Tx rate adaptive, set normal!!\n");
+		BTC_TRACE(trace_buf);
+		tmp_u1 |= BIT(2);
+	}
+
+	btcoexist->btc_write_1byte(btcoexist, 0x4fd, tmp_u1);
+}
+
+void halbtc8812a2ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	return;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], %s turn LowPenaltyRA = %s\n",
+		    (force_exec ? "force to" : ""),
+		    ((low_penalty_ra) ? "ON" : "OFF"));
+	BTC_TRACE(trace_buf);
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8812a2ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8812a2ant_set_dac_swing_reg(IN struct btc_coexist *btcoexist,
+				       IN u32 level)
+{
+	u8	val = (u8)level;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Write SwDacSwing = 0x%x\n",
+		    level);
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc5b, 0x3e, val);
+}
+
+void halbtc8812a2ant_set_sw_full_time_dac_swing(IN struct btc_coexist
+		*btcoexist, IN boolean sw_dac_swing_on, IN u32 sw_dac_swing_lvl)
+{
+	if (sw_dac_swing_on)
+		halbtc8812a2ant_set_dac_swing_reg(btcoexist, sw_dac_swing_lvl);
+	else
+		halbtc8812a2ant_set_dac_swing_reg(btcoexist, 0x18);
+}
+
+
+void halbtc8812a2ant_dac_swing(IN struct btc_coexist *btcoexist,
+	IN boolean force_exec, IN boolean dac_swing_on, IN u32 dac_swing_lvl)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], %s turn DacSwing=%s, dac_swing_lvl=0x%x\n",
+		(force_exec ? "force to" : ""), ((dac_swing_on) ? "ON" : "OFF"),
+		    dac_swing_lvl);
+	BTC_TRACE(trace_buf);
+	coex_dm->cur_dac_swing_on = dac_swing_on;
+	coex_dm->cur_dac_swing_lvl = dac_swing_lvl;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_dac_swing_on == coex_dm->cur_dac_swing_on) &&
+		    (coex_dm->pre_dac_swing_lvl ==
+		     coex_dm->cur_dac_swing_lvl))
+			return;
+	}
+	delay_ms(30);
+	halbtc8812a2ant_set_sw_full_time_dac_swing(btcoexist, dac_swing_on,
+			dac_swing_lvl);
+
+	coex_dm->pre_dac_swing_on = coex_dm->cur_dac_swing_on;
+	coex_dm->pre_dac_swing_lvl = coex_dm->cur_dac_swing_lvl;
+}
+
+void halbtc8812a2ant_set_adc_back_off(IN struct btc_coexist *btcoexist,
+				      IN boolean adc_back_off)
+{
+	if (adc_back_off) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x8db, 0x60, 0x3);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x8db, 0x60, 0x1);
+	}
+}
+
+void halbtc8812a2ant_adc_back_off(IN struct btc_coexist *btcoexist,
+			  IN boolean force_exec, IN boolean adc_back_off)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], %s turn AdcBackOff = %s\n",
+		    (force_exec ? "force to" : ""),
+		    ((adc_back_off) ? "ON" : "OFF"));
+	BTC_TRACE(trace_buf);
+
+	coex_dm->cur_adc_back_off = adc_back_off;
+
+	if (!force_exec) {
+		if (coex_dm->pre_adc_back_off == coex_dm->cur_adc_back_off)
+			return;
+	}
+	halbtc8812a2ant_set_adc_back_off(btcoexist, coex_dm->cur_adc_back_off);
+
+	coex_dm->pre_adc_back_off = coex_dm->cur_adc_back_off;
+}
+
+void halbtc8812a2ant_set_agc_table(IN struct btc_coexist *btcoexist,
+				   IN boolean agc_table_en)
+{
+	u8		rssi_adjust_val = 0;
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x02000);
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x28F4B);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x10AB2);
+		rssi_adjust_val = 8;
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x2884B);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x104B2);
+	}
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x0);
+
+	/* set rssi_adjust_val for wifi module. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON,
+			   &rssi_adjust_val);
+}
+
+void halbtc8812a2ant_agc_table(IN struct btc_coexist *btcoexist,
+			       IN boolean force_exec, IN boolean agc_table_en)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], %s %s Agc Table\n",
+		    (force_exec ? "force to" : ""),
+		    ((agc_table_en) ? "Enable" : "Disable"));
+	BTC_TRACE(trace_buf);
+	coex_dm->cur_agc_table_en = agc_table_en;
+
+	if (!force_exec) {
+		if (coex_dm->pre_agc_table_en == coex_dm->cur_agc_table_en)
+			return;
+	}
+	halbtc8812a2ant_set_agc_table(btcoexist, agc_table_en);
+
+	coex_dm->pre_agc_table_en = coex_dm->cur_agc_table_en;
+}
+
+void halbtc8812a2ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], set coex table, set 0x6c0=0x%x\n", val0x6c0);
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], set coex table, set 0x6c4=0x%x\n", val0x6c4);
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], set coex table, set 0x6c8=0x%x\n", val0x6c8);
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], set coex table, set 0x6cc=0x%x\n", val0x6cc);
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8812a2ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], %s write Coex Table 0x6c0=0x%x, 0x6c4=0x%x, 0x6c8=0x%x, 0x6cc=0x%x\n",
+		(force_exec ? "force to" : ""), val0x6c0, val0x6c4, val0x6c8,
+		    val0x6cc);
+	BTC_TRACE(trace_buf);
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8812a2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8812a2ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	switch (type) {
+	case 0:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5ffb5ffb, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0x5fdf5fdf, 0x5fdb5fdb, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0xdfffdfff, 0x5fdb5fdb, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0x5ddd5ddd, 0x5fdb5fdb, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 7:
+		if (coex_sta->scan_ap_num <= 5)
+			halbtc8812a2ant_coex_table(btcoexist,
+					   force_exec, 0xffffffff, 0xfafafafa,
+						   0xffffff, 0x3);
+		else
+			halbtc8812a2ant_coex_table(btcoexist,
+					   force_exec, 0xffffffff, 0x5a5a5a5a,
+						   0xffffff, 0x3);
+		break;
+	case 8:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0x5f5f5f5f, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+
+	default:
+		break;
+	}
+}
+
+void halbtc8812a2ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8	data_len = 3;
+	u8	buf[5] = {0};
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], %s BT Ignore Wlan_Act\n",
+		    (enable ? "Enable" : "Disable"));
+	BTC_TRACE(trace_buf);
+
+	buf[0] = data_len;
+	buf[1] = 0x1;			/* OP_Code */
+	buf[2] = 0x1;			/* OP_Code_Length */
+	if (enable)
+		buf[3] = 0x1;		/* OP_Code_Content */
+	else
+		buf[3] = 0x0;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_COEX,
+			   (void *)&buf[0]);
+}
+
+void halbtc8812a2ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], %s turn Ignore WlanAct %s\n",
+		    (force_exec ? "force to" : ""), (enable ? "ON" : "OFF"));
+	BTC_TRACE(trace_buf);
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8812a2ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8812a2ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for 1Ant AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+		}
+	}
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], PS-TDMA H2C cmd =0x%x%08x\n",
+		    h2c_parameter[0],
+		    h2c_parameter[1] << 24 | h2c_parameter[2] << 16 |
+		    h2c_parameter[3] << 8 | h2c_parameter[4]);
+
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8812a2ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8812a2ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8812a2ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8812a2ant_sw_mechanism1(IN struct btc_coexist *btcoexist,
+			   IN boolean shrink_rx_lpf, IN boolean low_penalty_ra,
+			   IN boolean limited_dig, IN boolean bt_lna_constrain)
+{
+	/*
+	u32	wifi_bw;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if(BTC_WIFI_BW_HT40 != wifi_bw)
+	{
+		if (shrink_rx_lpf)
+			shrink_rx_lpf = false;
+	}
+	*/
+
+	halbtc8812a2ant_rf_shrink(btcoexist, NORMAL_EXEC, shrink_rx_lpf);
+	/* halbtc8812a2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra); */
+}
+
+void halbtc8812a2ant_sw_mechanism2(IN struct btc_coexist *btcoexist,
+			   IN boolean agc_table_shift, IN boolean adc_back_off,
+			   IN boolean sw_dac_swing, IN u32 dac_swing_lvl)
+{
+	/* halbtc8812a2ant_agc_table(btcoexist, NORMAL_EXEC, agc_table_shift); */
+	halbtc8812a2ant_adc_back_off(btcoexist, NORMAL_EXEC, adc_back_off);
+	halbtc8812a2ant_dac_swing(btcoexist, NORMAL_EXEC, sw_dac_swing,
+				  dac_swing_lvl);
+}
+
+void halbtc8812a2ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean init_hwcfg, IN boolean wifi_off)
+{
+	u8			u8tmp = 0;
+
+	if (init_hwcfg) {
+		btcoexist->btc_write_4byte(btcoexist, 0x900, 0x00000400);
+		btcoexist->btc_write_1byte(btcoexist, 0x76d, 0x1);
+	} else if (wifi_off) {
+
+		}
+
+	/* ext switch setting */
+	switch (ant_pos_type) {
+	case BTC_ANT_WIFI_AT_CPL_MAIN:
+		u8tmp = btcoexist->btc_read_1byte(btcoexist, 0xcb7);
+		u8tmp &= ~BIT(2);
+		u8tmp |= BIT(3);
+		btcoexist->btc_write_1byte(btcoexist, 0xcb7, u8tmp);
+		break;
+	case BTC_ANT_WIFI_AT_CPL_AUX:
+		u8tmp = btcoexist->btc_read_1byte(btcoexist, 0xcb7);
+		u8tmp &= ~BIT(3);
+		u8tmp |= BIT(2);
+		btcoexist->btc_write_1byte(btcoexist, 0xcb7, u8tmp);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8812a2ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	s8			wifi_duration_adjust = 0x0;
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	if (!force_exec) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], pre_ps_tdma_on = %d, cur_ps_tdma_on = %d!!\n",
+			    coex_dm->pre_ps_tdma_on, coex_dm->cur_ps_tdma_on);
+		BTC_TRACE(trace_buf);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], pre_ps_tdma = %d, cur_ps_tdma = %d!!\n",
+			    coex_dm->pre_ps_tdma, coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (coex_sta->scan_ap_num >= 40)
+		wifi_duration_adjust = -15;
+	else if (coex_sta->scan_ap_num >= 20)
+		wifi_duration_adjust = -10;
+
+	/*
+		if (!coex_sta->force_lps_on)
+		{
+			ps_tdma_byte0_val = 0x61;
+			ps_tdma_byte3_val = 0x11;
+			ps_tdma_byte4_val = 0x10;
+		}
+
+
+		if (  (type == 3) || (type == 13) || (type == 14) )
+		{
+			ps_tdma_byte4_val = ps_tdma_byte4_val & 0xbf;
+
+			if (!wifi_busy)
+			 ps_tdma_byte4_val = ps_tdma_byte4_val | 0x1;
+		}
+
+		if (bt_link_info->slave_role == true)
+			ps_tdma_byte4_val = ps_tdma_byte4_val | 0x1;
+
+	*/
+	if (turn_on) {
+		switch (type) {
+		case 1:
+		default:	/* d1,wb */
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0x11, 0x10);
+			break;
+		case 2:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x32, 0x03, 0x11, 0x10);
+			break;
+		case 3:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x28, 0x03, 0x11, 0x10);
+			break;
+		case 4:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1e, 0x03, 0x11, 0x10);
+			break;
+		case 5:		/* d1,pb,TXpause */
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x63,
+						      0x3c, 0x03, 0x90, 0x10);
+			break;
+		case 6:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x63,
+						      0x32, 0x03, 0x90, 0x10);
+			break;
+		case 7:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x63,
+						      0x28, 0x03, 0x90, 0x10);
+			break;
+		case 8:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x63,
+						      0x1e, 0x03, 0x90, 0x10);
+			break;
+		case 9:		/* d1,bb */
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0x31, 0x10);
+			break;
+		case 10:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x32, 0x03, 0x31, 0x10);
+			break;
+		case 11:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x28, 0x03, 0x31, 0x10);
+			break;
+		case 12:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1e, 0x03, 0x31, 0x10);
+			break;
+		case 13:	/* d1,bb,TXpause */
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0x30, 0x10);
+			break;
+		case 14:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x32, 0x03, 0x30, 0x10);
+			break;
+		case 15:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x28, 0x03, 0x30, 0x10);
+			break;
+		case 16:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1e, 0x03, 0x30, 0x10);
+			break;
+		case 17:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x3, 0x11, 0x11);
+			break;
+		case 18:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x5, 0x5, 0xe1, 0x90);
+			break;
+		case 19:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0xe1, 0x90);
+			break;
+		case 20:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0x60, 0x90);
+			break;
+		case 21:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x3, 0x70, 0x90);
+			break;
+		case 22:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x1a, 0x1a, 0x21, 0x10);
+			break;
+		case 23:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x03, 0x31, 0x10);
+			break;
+
+		case 71:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1a, 0x1a, 0xe1, 0x90);
+			break;
+
+		/* following cases is for wifi rssi low, started from 81 */
+		case 80:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x3c, 0x3, 0x90, 0x50);
+			break;
+		case 81:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x53,
+				      0x3a + wifi_duration_adjust, 0x3, 0x90,
+						      0x50);
+			break;
+		case 82:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x53,
+				      0x30 + wifi_duration_adjust, 0x03, 0x90,
+						      0x50);
+			break;
+		case 83:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x21, 0x03, 0x90, 0x50);
+			break;
+		case 84:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x15, 0x3, 0x90, 0x50);
+			break;
+		case 85:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x1d, 0x1d, 0x80, 0x50);
+			break;
+		case 86:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x15, 0x15, 0x80, 0x50);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 0: /* ANT2PTA, 0x778=0x1 */
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 1: /* ANT2BT, 0x778=3 */
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x8, 0x0);
+			delay_ms(5);
+			halbtc8812a2ant_set_ant_path(btcoexist,
+				     BTC_ANT_WIFI_AT_CPL_AUX, false, false);
+			break;
+		case 2: /* ANT2BT, 0x778=3 */
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x8, 0x0);
+			delay_ms(5);
+			halbtc8812a2ant_set_ant_path(btcoexist,
+				     BTC_ANT_WIFI_AT_CPL_MAIN, false, false);
+			break;
+		default:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+
+void halbtc8812a2ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+
+void halbtc8812a2ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+	boolean	ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		ps_type = BTC_PS_WIFI_NATIVE;
+		lps_val = 0x0;
+		rpwm_val = 0x0;
+	}
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8812a2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8812a2ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma. */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8812a2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8812a2ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* fw all off */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8812a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8812a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	/* hw all off */
+	halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8812a2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 1);
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 6);
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8812a2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8812a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8812a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+void halbtc8812a2ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_stack_info	*stack_info = &btcoexist->stack_info;
+	static u32	bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	/* only 8812a need to consider if core stack is installed. */
+	/*if (!stack_info->hci_version)*/
+	/*bt_active = false;*/
+
+	bt_disabled = btcoexist->bt_info.bt_disabled;
+
+	if (coex_sta->pre_bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			(coex_sta->pre_bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->pre_bt_disabled = bt_disabled;
+
+		if (bt_disabled) {
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						2);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+		}
+	}
+}
+
+
+void halbtc8812a2ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8812a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8812a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+
+boolean halbtc8812a2ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				common = false, wifi_connected = false, wifi_busy = false;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8812a2ant_action_bt_inquiry(btcoexist);
+		return true;
+	}
+
+	if (bt_link_info->sco_exist || bt_link_info->hid_exist)
+		halbtc8812a2ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 0, 0, 0);
+	else
+		halbtc8812a2ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+	if (!wifi_connected) {
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non-connected idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		if ((BT_8812A_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		     coex_dm->bt_status) ||
+		    (BT_8812A_2ANT_BT_STATUS_CONNECTED_IDLE ==
+		     coex_dm->bt_status)) {
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+		} else {
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+		}
+
+		halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8812a2ant_sw_mechanism1(btcoexist, false, false, false,
+					      false);
+		halbtc8812a2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+
+		common = true;
+	} else {
+		if (BT_8812A_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, false, 0x8);
+
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+			halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 6);
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else if (BT_8812A_2ANT_BT_STATUS_CONNECTED_IDLE ==
+			   coex_dm->bt_status) {
+			if (bt_hs_on)
+				return false;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, false, 0x8);
+
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+			halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 6);
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else {
+			if (wifi_busy) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+				common = false;
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+
+				halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+
+				halbtc8812a2ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, false, false, 0x8);
+
+				halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 17);
+
+				halbtc8812a2ant_fw_dac_swing_lvl(btcoexist,
+							 NORMAL_EXEC, 6);
+				halbtc8812a2ant_dec_bt_pwr(btcoexist,
+							   NORMAL_EXEC, 0);
+				halbtc8812a2ant_sw_mechanism1(btcoexist, false,
+						      false, false, false);
+				halbtc8812a2ant_sw_mechanism2(btcoexist, false,
+						      false, false, 0x18);
+				common = true;
+			}
+		}
+	}
+
+	return common;
+}
+
+void halbtc8812a2ant_tdma_duration_adjust(IN struct btc_coexist *btcoexist,
+		IN boolean sco_hid, IN boolean tx_pause, IN u8 max_interval)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], TdmaDurationAdjust()\n");
+	BTC_TRACE(trace_buf);
+
+	coex_dm->auto_tdma_adjust_low_rssi = false;
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], first run TdmaDurationAdjust()!!\n");
+		BTC_TRACE(trace_buf);
+		{
+			if (sco_hid) {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					} else if (max_interval == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (max_interval == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					} else if (max_interval == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (max_interval == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			} else {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (max_interval == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (max_interval == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (max_interval == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (max_interval == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					}
+				}
+			}
+		}
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* acquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], retry_count = %d\n",
+			    retry_count);
+		BTC_TRACE(trace_buf);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], up=%d, dn=%d, m=%d, n=%d, wait_count=%d\n",
+			    up, dn, m, n, wait_count);
+		BTC_TRACE(trace_buf);
+
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if s n 2 retry count0, heWiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Increase wifi duration!!\n");
+				BTC_TRACE(trace_buf);
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if s 2 2 retry count< 3, hWiFi duration */
+				if (wait_count <= 2)
+					m++; /* K@blevel^ */
+				else
+					m = 1;
+
+				if (m >= 20)  /* m j = 20 ' j120 recheckO_ WiFi duration. */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Decrease wifi duration for retry_counter<3!!\n");
+				BTC_TRACE(trace_buf);
+			}
+		} else { /* retry count > 3, un1 retry count > 3, hWiFi duration */
+			if (wait_count == 1)
+				m++; /* K@blevel^ */
+			else
+				m = 1;
+
+			if (m >= 20)  /* m j = 20 ' j120 recheckO_ WiFi duration. */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Decrease wifi duration for retry_counter>3!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], max Interval = %d\n",
+			    max_interval);
+		BTC_TRACE(trace_buf);
+
+		if (max_interval == 1) {
+			if (tx_pause) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], TxPause = 1\n");
+				BTC_TRACE(trace_buf);
+
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 13);
+					coex_dm->ps_tdma_du_adj_type = 13;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					}
+				}
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], TxPause = 0\n");
+				BTC_TRACE(trace_buf);
+
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 1);
+					coex_dm->ps_tdma_du_adj_type = 1;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 9);
+					coex_dm->ps_tdma_du_adj_type = 9;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					}
+				}
+			}
+		} else if (max_interval == 2) {
+			if (tx_pause) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], TxPause = 1\n");
+				BTC_TRACE(trace_buf);
+
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					}
+				}
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], TxPause = 0\n");
+				BTC_TRACE(trace_buf);
+
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					}
+				}
+			}
+		} else if (max_interval == 3) {
+			if (tx_pause) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], TxPause = 1\n");
+				BTC_TRACE(trace_buf);
+
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				}
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], TxPause = 0\n");
+				BTC_TRACE(trace_buf);
+
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			}
+		}
+	}
+
+	/* if current PsTdma not match with the recorded one (when scan, dhcp...), */
+	/* then we have to adjust it back to the previous record one. */
+	if (coex_dm->cur_ps_tdma != coex_dm->ps_tdma_du_adj_type) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], PsTdma type dismatch!!!, cur_ps_tdma=%d, recordPsTdma=%d\n",
+			    coex_dm->cur_ps_tdma, coex_dm->ps_tdma_du_adj_type);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (!scan && !link && !roam)
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+}
+
+/* ******************
+ * pstdma for wifi rssi low
+ * ****************** */
+void halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+	IN struct btc_coexist *btcoexist/* , */ /* IN u8 wifi_status */)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0, bt_info_ext;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low()\n");
+	BTC_TRACE(trace_buf);
+#if 0
+	if ((BT_8812A_2ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN ==
+	     wifi_status) ||
+	    (BT_8812A_2ANT_WIFI_STATUS_CONNECTED_SCAN == wifi_status) ||
+	    (BT_8812A_2ANT_WIFI_STATUS_CONNECTED_SPECIAL_PKT ==
+	     wifi_status)) {
+		if (coex_dm->cur_ps_tdma != 81 &&
+		    coex_dm->cur_ps_tdma != 82 &&
+		    coex_dm->cur_ps_tdma != 83 &&
+		    coex_dm->cur_ps_tdma != 84) {
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						82);
+			coex_dm->ps_tdma_du_adj_type = 82;
+
+			up = 0;
+			dn = 0;
+			m = 1;
+			n = 3;
+			result = 0;
+			wait_count = 0;
+		}
+		return;
+	}
+#endif
+	coex_dm->auto_tdma_adjust = false;
+
+	retry_count = coex_sta->bt_retry_cnt;
+	bt_info_ext = coex_sta->bt_info_ext;
+
+	if (!coex_dm->auto_tdma_adjust_low_rssi) {
+		coex_dm->auto_tdma_adjust_low_rssi = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], first run TdmaDurationAdjustForWifiRssiLow()!!\n");
+		BTC_TRACE(trace_buf);
+
+		if (BT_INFO_8812A_2ANT_A2DP_BASIC_RATE(bt_info_ext)) {
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						83);
+			coex_dm->ps_tdma_du_adj_type = 83;
+		} else {
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						82);
+			coex_dm->ps_tdma_du_adj_type = 82;
+		}
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* acquire the BT TRx retry count from BT_Info byte2
+		*		retry_count = coex_sta->bt_retry_cnt;
+		*		bt_info_ext = coex_sta->bt_info_ext; */
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], retry_count = %d\n",
+			    retry_count);
+		BTC_TRACE(trace_buf);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], up=%d, dn=%d, m=%d, n=%d, wait_count=%d\n",
+			    up, dn, m, n, wait_count);
+		BTC_TRACE(trace_buf);
+		result = 0;
+		wait_count++;
+
+		if ((coex_sta->low_priority_tx) > 1050 ||
+		    (coex_sta->low_priority_rx) > 1250)
+			retry_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if s n 2 retry count0, heWiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Increase wifi duration!!\n");
+				BTC_TRACE(trace_buf);
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if s 2 2 retry count< 3, hWiFi duration */
+				if (wait_count <= 2)
+					m++; /* K@blevel^ */
+				else
+					m = 1;
+
+				if (m >= 20)  /* m j = 20 ' j120 recheckO_ WiFi duration. */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Decrease wifi duration for retry_counter<3!!\n");
+				BTC_TRACE(trace_buf);
+			}
+		} else { /* retry count > 3, un1 retry count > 3, hWiFi duration */
+			if (wait_count == 1)
+				m++; /* K@blevel^ */
+			else
+				m = 1;
+
+			if (m >= 20)  /* m j = 20 ' j120 recheckO_ WiFi duration. */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Decrease wifi duration for retry_counter>3!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		if (result == -1) {
+			/*
+						if( (BT_INFO_8812A_2ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+							((coex_dm->cur_ps_tdma == 81) ||(coex_dm->cur_ps_tdma == 82)) )
+						{
+							halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 84);
+							coex_dm->ps_tdma_du_adj_type = 84;
+						}
+			*/
+			if (coex_dm->cur_ps_tdma == 80) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 82);
+				coex_dm->ps_tdma_du_adj_type = 82;
+			} else if (coex_dm->cur_ps_tdma == 81) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 82);
+				coex_dm->ps_tdma_du_adj_type = 82;
+			} else if (coex_dm->cur_ps_tdma == 82) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 83);
+				coex_dm->ps_tdma_du_adj_type = 83;
+			} else if (coex_dm->cur_ps_tdma == 83) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 84);
+				coex_dm->ps_tdma_du_adj_type = 84;
+			}
+		} else if (result == 1) {
+			/*
+						if( (BT_INFO_8812A_2ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+							((coex_dm->cur_ps_tdma == 81) ||(coex_dm->cur_ps_tdma == 82)) )
+						{
+							halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 83);
+							coex_dm->ps_tdma_du_adj_type = 83;
+						}
+			*/
+			if (coex_dm->cur_ps_tdma == 84) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 83);
+				coex_dm->ps_tdma_du_adj_type = 83;
+			} else if (coex_dm->cur_ps_tdma == 83) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 82);
+				coex_dm->ps_tdma_du_adj_type = 82;
+			} else if (coex_dm->cur_ps_tdma == 82) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 81);
+				coex_dm->ps_tdma_du_adj_type = 81;
+			} else if ((coex_dm->cur_ps_tdma == 81) &&
+				   ((coex_sta->scan_ap_num <= 5))) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 81);
+				coex_dm->ps_tdma_du_adj_type = 81;
+			}
+		}
+
+		if (coex_dm->cur_ps_tdma != 80 &&
+		    coex_dm->cur_ps_tdma != 81 &&
+		    coex_dm->cur_ps_tdma != 82 &&
+		    coex_dm->cur_ps_tdma != 83 &&
+		    coex_dm->cur_ps_tdma != 84) {
+			/* recover to previous adjust type */
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		}
+	}
+}
+
+void halbtc8812a2ant_get_bt_rssi_threshold(IN struct btc_coexist *btcoexist,
+		IN u8 *pThres0, IN u8 *pThres1)
+{
+	u8 ant_type;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_ANT_TYPE, &ant_type);
+
+
+	switch (ant_type) {
+	case BTC_ANT_TYPE_0:
+		*pThres0 = 100;
+		*pThres1 = 100;
+		break;
+	case BTC_ANT_TYPE_1:
+		*pThres0 = 34;
+		*pThres1 = 42;
+		break;
+	case BTC_ANT_TYPE_2:
+		*pThres0 = 34;
+		*pThres1 = 42;
+		break;
+	case BTC_ANT_TYPE_3:
+		*pThres0 = 34;
+		*pThres1 = 42;
+		break;
+	case BTC_ANT_TYPE_4:
+		*pThres0 = 34;
+		*pThres1 = 42;
+		break;
+	default:
+		break;
+	}
+}
+
+
+
+void halbtc8812a2ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+
+	/*	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0, &bt_thresh1); */
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42);
+
+	/* power save state */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* coex table */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	/* pstdma */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+	else
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+
+	/* decrease BT power */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x6);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x6);
+		}
+	}
+}
+
+void halbtc8812a2ant_action_sco_hid(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+	/*	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0, &bt_thresh1); */
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42);
+
+	/* power save state */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* coex table */
+	halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	/* pstdma */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+	else
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+
+	/* decrease BT power	 */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x6);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x6);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x6);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x6);
+		}
+	}
+}
+
+void halbtc8812a2ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		anttype = 0;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_ANT_TYPE, &anttype);
+
+
+	/*	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0, &bt_thresh1);
+	 *	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0, bt_thresh1); */
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42);
+
+
+	if (anttype == 0) { /* ANTTYPE = 0   92E 2ant with SPDT */
+		/* power save state & pstdma & coex table */
+		coex_dm->auto_tdma_adjust = false;
+		coex_dm->auto_tdma_adjust_low_rssi = false;
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (anttype ==
+		1) { /* 92E 2ant with coupler and bad ant. isolation, 92E 3ant with bad ant. isolation */
+		/* power save state & pstdma & coex table */
+		coex_dm->auto_tdma_adjust = false;
+		coex_dm->auto_tdma_adjust_low_rssi = false;
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (anttype ==
+		2) { /* ANTTYPE = 2, 92E 2ant with coupler and normal/good ant. isolation, 92E 3ant with normal ant. isolation */
+		/* power save state & pstdma & coex table */
+		if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		    (!BTC_RSSI_LOW(bt_rssi_state)) &&
+		    (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & shielding room */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, true, 9);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 3);
+		} else if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+			   (!BTC_RSSI_LOW(bt_rssi_state)) &&
+			(coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & noisy environment */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, true, 9);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 3);
+		} else {	/* WIFI RSSI || BT RSSI == low */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, true, 9);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 3);
+		}
+	} else if (anttype ==
+		   3) {	/* ANTTYPE = 3,  92E 3ant with good ant. isolation */
+		/* power save state & pstdma & coex table */
+		if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		    (!BTC_RSSI_LOW(bt_rssi_state)) &&
+		    (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & shielding room */
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						1);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+		} else if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+			   (!BTC_RSSI_LOW(bt_rssi_state)) &&
+			(coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & noisy environment */
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						1);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+		} else {	/* WIFI RSSI || BT RSSI == low */
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						1);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+		}
+	} else {	/* ANTTYPE = 4 for test */
+		/* power save state & pstdma & coex table */
+		if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		    (!BTC_RSSI_LOW(bt_rssi_state)) &&
+		    (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & shielding room */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+				btcoexist);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		} else if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+			   (!BTC_RSSI_LOW(bt_rssi_state)) &&
+			(coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & noisy environment */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+				btcoexist);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		} else {	/* WIFI RSSI || BT RSSI == low */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+				btcoexist);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		}
+	}
+
+
+	/* power save state */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* coex table */
+	halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+	/* decrease BT power */
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8812a2ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		anttype = 0;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_ANT_TYPE, &anttype);
+
+	/*	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0, &bt_thresh1);
+	 *	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0, bt_thresh1); */
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42);
+
+	/*	anttype = 4; */
+
+	if (anttype == 0) { /* ANTTYPE = 0   92E 2ant with SPDT */
+
+		if (coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A) {
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						0);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+		} else {
+			if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+			    (!BTC_RSSI_LOW(bt_rssi_state))) {
+				/* WIFI RSSI = high & BT RSSI = high & shielding room */
+				halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+				halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+					btcoexist);
+				halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+			} else {	/* WIFI RSSI || BT RSSI == low */
+				halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+				halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+					btcoexist);
+				halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+			}
+		}
+
+		/* power save state & pstdma & coex table
+		*
+		if(BTC_RSSI_HIGH(wifi_rssi_state) &&	(!BTC_RSSI_LOW(bt_rssi_state)) && (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A))
+		{
+			halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(btcoexist);
+			halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		}
+		else if (BTC_RSSI_HIGH(wifi_rssi_state)&&(!BTC_RSSI_LOW(bt_rssi_state)) && (coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A))
+		{
+		coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+			halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		}
+		else
+		{
+			halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(btcoexist);
+			halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		}
+		*/
+	} else if (anttype ==
+		1) { /* 92E 2ant with coupler and bad ant. isolation, 92E 3ant with bad ant. isolation */
+		/* power save state & pstdma & coex table */
+		if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		    (!BTC_RSSI_LOW(bt_rssi_state)) &&
+		    (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & shielding room */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_tdma_duration_adjust(btcoexist, false,
+					     false, 1);	/* shielding room */
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+		} else if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+			   (!BTC_RSSI_LOW(bt_rssi_state)) &&
+			(coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & noisy environment */
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						1);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+		} else {	/* WIFI RSSI || BT RSSI == low */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+				btcoexist);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		}
+
+	} else if (anttype ==
+		2) { /* ANTTYPE = 2, 92E 2ant with coupler and normal/good ant. isolation, 92E 3ant with normal ant. isolation */
+		/* power save state & pstdma & coex table */
+		if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		    (!BTC_RSSI_LOW(bt_rssi_state)) &&
+		    (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & shielding room */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_tdma_duration_adjust(btcoexist, false,
+							     false, 1);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 5);
+		} else if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+			   (!BTC_RSSI_LOW(bt_rssi_state)) &&
+			(coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & noisy environment */
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						1);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+		} else {	/* WIFI RSSI || BT RSSI == low */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+				btcoexist);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		}
+	} else if (anttype ==
+		   3) {	/* ANTTYPE = 3,  92E 3ant with good ant. isolation */
+		/* power save state & pstdma & coex table */
+		if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		    (!BTC_RSSI_LOW(bt_rssi_state)) &&
+		    (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & shielding room */
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						1);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+		} else if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+			   (!BTC_RSSI_LOW(bt_rssi_state)) &&
+			(coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & noisy environment */
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						1);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+		} else {	/* WIFI RSSI || BT RSSI == low */
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						1);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+		}
+	} else {	/* ANTTYPE = 4 for test */
+		/* power save state & pstdma & coex table */
+		if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		    (!BTC_RSSI_LOW(bt_rssi_state)) &&
+		    (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & shielding room */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+				btcoexist);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		} else if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+			   (!BTC_RSSI_LOW(bt_rssi_state)) &&
+			(coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & noisy environment */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+				btcoexist);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		} else {	/* WIFI RSSI || BT RSSI == low */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+				btcoexist);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		}
+	}
+
+	/* decrease BT power */
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* decrease BT power
+	*
+	if(BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if(BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else if (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+	*/
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8812a2ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+	/*	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0, &bt_thresh1); */
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42);
+
+	/* power save state */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* coex table	 */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+
+	/* pstdma	 */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, false, false,
+						     2);
+	else
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, false, true, 2);
+
+	/* decrease BT power */
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	/*
+
+		if(BTC_RSSI_LOW(bt_rssi_state))
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		else if(BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+	*/
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x6);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x6);
+		}
+	}
+}
+
+void halbtc8812a2ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	else
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+
+	/* coex table */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 1);
+	else
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 85);
+
+	/* decrease BT power */
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* PAN(HS) only */
+void halbtc8812a2ant_action_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42);
+
+	/* power save state */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* coex table */
+	halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+	/* pstdma */
+	halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+	/* decrease BT power */
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/*
+
+		if(BTC_RSSI_LOW(bt_rssi_state))
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		else if(BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+	*/
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* PAN(EDR)+A2DP */
+void halbtc8812a2ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&	(!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	else
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+
+	/* coex table */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&	(!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&	(!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, false, false,
+						     3);
+	else {
+		coex_dm->auto_tdma_adjust = false;
+		coex_dm->auto_tdma_adjust_low_rssi = false;
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 86);
+	}
+
+	/* decrease BT power */
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+
+void halbtc8812a2ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	else
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+
+	/* coex table */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 10);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+	else
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 85);
+
+	/* decrease BT power */
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/*
+
+		if(BTC_RSSI_LOW(bt_rssi_state))
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		else if(BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+	*/
+	/* limited Rx */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true,
+					   0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8812a2ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	else
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+
+	/* coex table */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, true, false, 3);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, true, true, 3);
+	else {
+		coex_dm->auto_tdma_adjust = false;
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 86);
+	}
+
+	/* decrease BT power */
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	/*
+
+		if(BTC_RSSI_LOW(bt_rssi_state))
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		else if(BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+	*/
+	/* limited Rx */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true,
+					   0x8);
+
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8812a2ant_action_hid_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* coex table */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, true, false, 2);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, true, true, 2);
+	else
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, true, true, 2);
+
+	/* decrease BT power */
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/*
+
+		if(BTC_RSSI_LOW(bt_rssi_state))
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		else if(BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+	*/
+	/* limited Rx */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true,
+					   0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8812a2ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		anttype = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_ANT_TYPE, &anttype);
+
+
+	/*	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0, &bt_thresh1);
+	 *	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0, bt_thresh1); */
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42);
+
+	if (anttype == 0) { /* ANTTYPE = 0	92E 2ant with SPDT */
+		/* power save state & pstdma & coex table */
+		if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		    (!BTC_RSSI_LOW(bt_rssi_state)) &&
+		    (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)) {
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, true,
+						83);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+
+		} else if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+			   (!BTC_RSSI_LOW(bt_rssi_state)) &&
+			(coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A)) {
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						0);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+		} else {
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, true,
+						83);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+		}
+	} else if (anttype ==
+		1) { /* 92E 2ant with coupler and bad ant. isolation, 92E 3ant with bad ant. isolation */
+		/* power save state & pstdma & coex table */
+		if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		    (!BTC_RSSI_LOW(bt_rssi_state)) &&
+		    (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)) {
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_tdma_duration_adjust(btcoexist, true,
+							     true, 2);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+		} else if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+			   (!BTC_RSSI_LOW(bt_rssi_state)) &&
+			(coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A)) {
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						0);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+		} else {
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, true,
+						83);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+		}
+	} else if (anttype ==
+		2) { /* ANTTYPE = 2, 92E 2ant with coupler and normal/good ant. isolation, 92E 3ant with normal ant. isolation */
+		/* power save state & pstdma & coex table */
+		if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		    (!BTC_RSSI_LOW(bt_rssi_state)) &&
+		    (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & shielding room */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_tdma_duration_adjust(btcoexist, true,
+							     true, 2);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+		} else if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+			   (!BTC_RSSI_LOW(bt_rssi_state)) &&
+			(coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & noisy environment */
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						0);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+		} else {	/* WIFI RSSI || BT RSSI == low */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, true,
+						83);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+		}
+	} else if (anttype ==
+		   3) {	/* ANTTYPE = 3,  92E 3ant with good ant. isolation */
+		/* power save state & pstdma & coex table */
+		if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		    (!BTC_RSSI_LOW(bt_rssi_state)) &&
+		    (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & shielding room */
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						1);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+		} else if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+			   (!BTC_RSSI_LOW(bt_rssi_state)) &&
+			(coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & noisy environment */
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						1);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+		} else {	/* WIFI RSSI || BT RSSI == low */
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+						1);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+		}
+	} else {	/* ANTTYPE = 4 for test */
+		/* power save state & pstdma & coex table */
+		if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+		    (!BTC_RSSI_LOW(bt_rssi_state)) &&
+		    (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & shielding room */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+				btcoexist);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		} else if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+			   (!BTC_RSSI_LOW(bt_rssi_state)) &&
+			(coex_sta->scan_ap_num > NOISY_AP_NUM_THRESH_8812A)) {
+			/* WIFI RSSI = high & BT RSSI = high & noisy environment */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+				btcoexist);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		} else {	/* WIFI RSSI || BT RSSI == low */
+			halbtc8812a2ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+			halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+				btcoexist);
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		}
+	}
+
+	/* decrease BT power */
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/*
+
+		if(BTC_RSSI_LOW(bt_rssi_state))
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		else if(BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else if (coex_sta->scan_ap_num < NOISY_AP_NUM_THRESH_8812A)
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+	*/
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8812a2ant_coex_under_5g(IN struct btc_coexist *btcoexist)
+{
+	halbtc8812a2ant_coex_all_off(btcoexist);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Under 5G, force set BT to ignore Wlan active!!\n");
+	BTC_TRACE(trace_buf);
+	halbtc8812a2ant_ignore_wlan_act(btcoexist, NORMAL_EXEC, true);
+}
+/* **************************************************** */
+void halbtc8812a2ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	boolean				wifi_under_5g = false;
+	u8				algorithm = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), run 5G coex setting!!<===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8812a2ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+
+	algorithm = halbtc8812a2ant_action_algorithm(btcoexist);
+	if (coex_sta->c2h_bt_inquiry_page &&
+	    (BT_8812A_2ANT_COEX_ALGO_PANHS != algorithm)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8812a2ant_action_bt_inquiry(btcoexist);
+		return;
+	}
+
+	coex_dm->cur_algorithm = algorithm;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Algorithm = %d\n",
+		    coex_dm->cur_algorithm);
+	BTC_TRACE(trace_buf);
+
+	if (halbtc8812a2ant_is_common_action(btcoexist)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant common.\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->auto_tdma_adjust = false;
+		coex_dm->auto_tdma_adjust_low_rssi = false;
+	} else {
+		if (coex_dm->cur_algorithm != coex_dm->pre_algorithm) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], pre_algorithm=%d, cur_algorithm=%d\n",
+				coex_dm->pre_algorithm, coex_dm->cur_algorithm);
+			BTC_TRACE(trace_buf);
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+		}
+		switch (coex_dm->cur_algorithm) {
+		case BT_8812A_2ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_sco(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_SCO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = SCO+HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_sco_hid(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_hid(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_a2dp(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_a2dp_pan_hs(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_pan_edr(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_pan_hs(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_pan_edr_a2dp(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_pan_edr_hid(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_hid_a2dp_pan_edr(
+				btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_hid_a2dp_pan_hs(
+				btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_hid_a2dp(btcoexist);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_coex_all_off(btcoexist);
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+
+}
+
+void halbtc8812a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up)
+{
+	u8	u8tmp = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 2Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	if (back_up) {
+		/* backup rf 0x1e value */
+		coex_dm->bt_rf_0x1e_backup =
+			btcoexist->btc_get_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+						  0xfffff);
+
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	}
+
+	/* ant sw control to BT */
+	halbtc8812a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_CPL_AUX, true,
+				     false);
+
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* PTA parameter */
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, 0x0);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, 0xffff);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, 0x55555555);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, 0x55555555);
+
+	/* coex parameters */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+
+	/* enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	/* disable PTA to avoid BT insn't on */
+	btcoexist->btc_write_1byte(btcoexist, 0x40, 0x00);
+
+	/* bt clock related */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x4);
+	u8tmp |= BIT(7);
+	btcoexist->btc_write_1byte(btcoexist, 0x4, u8tmp);
+
+	/* bt clock related */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x7);
+	u8tmp |= BIT(1);
+	btcoexist->btc_write_1byte(btcoexist, 0x7, u8tmp);
+
+	/* Give bt_coex_supported_version the default value */
+	coex_sta->bt_coex_supported_version = 0;
+
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8812a2ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8812a2ant_
+ * ************************************************************ */
+void ex_halbtc8812a2ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8812a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8812a2ant_init_hw_config(btcoexist, true);
+}
+
+void ex_halbtc8812a2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8812a2ant_init_coex_dm(btcoexist);
+}
+
+
+void ex_halbtc8812a2ant_pta_off_on_notify(IN struct btc_coexist *btcoexist,
+		IN u8 bt_status)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], BToff/on notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_BT_OFF == bt_status) {
+		/* PTA off */
+		btcoexist->bt_info.bt_disabled = true;
+		halbtc8812a2ant_enable_pta(btcoexist, FORCE_EXEC, false);
+
+	} else {
+		/* PTA on */
+		btcoexist->bt_info.bt_disabled = false;
+		halbtc8812a2ant_enable_pta(btcoexist, FORCE_EXEC, true);
+	}
+
+}
+
+
+void ex_halbtc8812a2ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_stack_info		*stack_info = &btcoexist->stack_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+	u32				fw_ver = 0, bt_patch_ver = 0, bt_coex_ver = 0;
+	u32				phyver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+#if 0
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "Antenna type:",
+		   board_info->ant_type);
+	CL_PRINTF(cli_buf);
+#endif
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %d",
+		   "BT stack/ hci ext ver",
+		   ((stack_info->profile_notified) ? "Yes" : "No"),
+		   stack_info->hci_version);
+	CL_PRINTF(cli_buf);
+
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+	bt_coex_ver = coex_sta->bt_coex_supported_version & 0xff;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+		   "CoexVer WL/  BT_Desired/ BT_Report",
+		   glcoex_ver_date_8812a_2ant, glcoex_ver_8812a_2ant,
+		   glcoex_ver_btdesired_8812a_2ant, bt_coex_ver,
+		   (bt_coex_ver == 0xff ? "Unknown" : (bt_coex_ver >=
+				   glcoex_ver_btdesired_8812a_2ant ? "Match" :
+				   "Mis-Match")));
+	CL_PRINTF(cli_buf);
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d",
+		   "W_FW/ B_FW/ Phy",
+		   fw_ver, bt_patch_ver, phyver);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((btcoexist->bt_info.bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8812A_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8812A_2ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_BT_LINK_INFO);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8812A_2ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8812a_2ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	/* Sw mechanism	 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Sw mechanism]============");
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ",
+		   "SM1[ShRf/ LpRA/ LimDig]",
+		   coex_dm->cur_rf_rx_lpf_shrink, coex_dm->cur_low_penalty_ra,
+		   coex_dm->limited_dig);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ",
+		   "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]",
+		   coex_dm->cur_agc_table_en, coex_dm->cur_adc_back_off,
+		   coex_dm->cur_dac_swing_on, coex_dm->cur_dac_swing_lvl);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ", "Rate Mask",
+		   btcoexist->bt_info.ra_mask);
+	CL_PRINTF(cli_buf);
+
+	/* Fw mechanism		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Fw mechanism]============");
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (auto:%d/%d)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   coex_dm->auto_tdma_adjust,
+		   coex_dm->auto_tdma_adjust_low_rssi);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "DecBtPwr/ IgnWlanAct",
+		   coex_dm->cur_bt_dec_pwr_lvl, coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x",
+		   "RF-A, 0x1e initVal",
+		   coex_dm->bt_rf_0x1e_backup);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "backup ARFR1/ARFR2/RL/AMaxTime",
+		   coex_dm->backup_arfr_cnt1, coex_dm->backup_arfr_cnt2,
+		   coex_dm->backup_retry_limit,
+		   coex_dm->backup_ampdu_max_time);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "0x430/0x434/0x42a/0x456",
+		   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x ",
+		   "0x778 (W_Act)/ 0x6cc (CoTab Sel)",
+		   u8tmp[0], u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x8db);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xc5b);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x8db(ADC)/0xc5b[29:25](DAC)",
+		   ((u8tmp[0] & 0x60) >> 5), ((u8tmp[1] & 0x3e) >> 1));
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xcb3);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xcb7);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xcb3/ 0xcb7",
+		   u8tmp[0], u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x974);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x40/ 0x4c[24:23]/ 0x974",
+		   u8tmp[0], ((u32tmp[0] & 0x01800000) >> 23), u32tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xa0a);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xc50(DIG)/0xa0a(CCK-TH)",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8812A_2ANT == 1)
+	halbtc8812a2ant_monitor_bt_ctr(btcoexist);
+#endif
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8812a2ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	boolean	wifi_under_5g = false;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->under_ips = true;
+		halbtc8812a2ant_coex_all_off(btcoexist);
+		halbtc8812a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_CPL_AUX,
+					     false, true);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], IPS notify, force set BT to ignore Wlan active!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8812a2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		ex_halbtc8812a2ant_media_status_notify(btcoexist,
+						       BTC_MEDIA_DISCONNECT);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->under_ips = false;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G,
+				   &wifi_under_5g);
+		if (!wifi_under_5g) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], IPS notify, force set BT NOT to ignore Wlan active!!\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8812a2ant_ignore_wlan_act(btcoexist, FORCE_EXEC,
+							false);
+		}
+	}
+}
+
+void ex_halbtc8812a2ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8812a2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	if (BTC_SCAN_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_SCAN_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+	}
+}
+
+void ex_halbtc8812a2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	if (BTC_ASSOCIATE_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_ASSOCIATE_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8812a2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			data_len = 5;
+	u8			buf[6] = {0};
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    btcoexist->bt_info.bt_disabled)
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] = 0x1;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	buf[0] = data_len;
+	buf[1] = 0x5;				/* OP_Code */
+	buf[2] = 0x3;				/* OP_Code_Length */
+	buf[3] = h2c_parameter[0];	/* OP_Code_Content */
+	buf[4] = h2c_parameter[1];
+	buf[5] = h2c_parameter[2];
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_COEX,
+			   (void *)&buf[0]);
+}
+
+void ex_halbtc8812a2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	if (type == BTC_PACKET_DHCP) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], DHCP Packet notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8812a2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8			bt_info = 0;
+	u8			i, rsp_source = 0;
+	boolean			bt_busy = false, limited_dig = false;
+	boolean			wifi_connected = false, wifi_under_5g = false;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8812A_2ANT_MAX)
+		rsp_source = BT_INFO_SRC_8812A_2ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	if (BT_INFO_SRC_8812A_2ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if ((coex_sta->bt_info_ext & BIT(1))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8812a2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8812a2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if ((coex_sta->bt_info_ext & BIT(3)) && !wifi_under_5g) {
+			/* BT already ignored WlanAct */
+			if (!btcoexist->manual_control &&
+			    !btcoexist->stop_coex_dm) {
+				if (!coex_sta->under_ips) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+					BTC_TRACE(trace_buf);
+					halbtc8812a2ant_ignore_wlan_act(
+						btcoexist, FORCE_EXEC, false);
+				}
+			}
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+
+			if (coex_sta->under_ips) {
+				/* work around for 8812a combo hw bug => when IPS, wlanAct is always high. */
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], wifi is under IPS, set BT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8812a2ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, true);
+			}
+		}
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8812A_2ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8812A_2ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+		coex_sta->acl_busy = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8812A_2ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8812A_2ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8812A_2ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8812A_2ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+		if (bt_info & BT_INFO_8812A_2ANT_B_ACL_BUSY)
+			coex_sta->acl_busy = true;
+		else
+			coex_sta->acl_busy = false;
+
+	}
+
+	halbtc8812a2ant_update_bt_link_info(btcoexist);
+
+	if (!(bt_info & BT_INFO_8812A_2ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8812A_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8812A_2ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8812A_2ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8812A_2ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8812A_2ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8812A_2ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8812A_2ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8812A_2ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8812A_2ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8812A_2ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8812A_2ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8812A_2ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status)) {
+		bt_busy = true;
+		if (!wifi_under_5g)
+			limited_dig = true;
+	} else {
+		bt_busy = false;
+		limited_dig = false;
+	}
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	coex_dm->limited_dig = limited_dig;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_LIMITED_DIG, &limited_dig);
+
+	halbtc8812a2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8812a2ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8812a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_CPL_AUX, false,
+				     true);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Halt notify, force set BT to ignore Wlan active!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8812a2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+	ex_halbtc8812a2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	/* 0x522=0xff, pause tx */
+	btcoexist->btc_write_1byte(btcoexist, 0x522, 0xff);
+	/* 0x40[7:6]=2'b01, modify BT mode. */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0xc0, 0x2);
+	/* PTA off. */
+#ifndef CONFIG_PCI_HCI
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x0);
+#endif
+}
+
+void ex_halbtc8812a2ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	static u8		dis_ver_info_cnt = 0;
+	u32				fw_ver = 0, bt_patch_ver = 0;
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_stack_info		*stack_info = &btcoexist->stack_info;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ==========================Periodical===========================\n");
+	BTC_TRACE(trace_buf);
+
+	if (dis_ver_info_cnt <= 5) {
+		dis_ver_info_cnt += 1;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ****************************************************************\n");
+		BTC_TRACE(trace_buf);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Ant PG Num/ Ant Mech/ Ant Pos = %d/ %d/ %d\n",
+			    board_info->pg_ant_num, board_info->btdm_ant_num,
+			    board_info->btdm_ant_pos);
+		BTC_TRACE(trace_buf);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT stack/ hci ext ver = %s / %d\n",
+			    ((stack_info->profile_notified) ? "Yes" : "No"),
+			    stack_info->hci_version);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER,
+				   &bt_patch_ver);
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexVer/ FwVer/ PatchVer = %d_%x/ 0x%x/ 0x%x(%d)\n",
+			    glcoex_ver_date_8812a_2ant, glcoex_ver_8812a_2ant,
+			    fw_ver, bt_patch_ver, bt_patch_ver);
+		BTC_TRACE(trace_buf);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ****************************************************************\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((coex_sta->bt_coex_supported_version == 0) ||
+	    (coex_sta->bt_coex_supported_version == 0xffff))
+		coex_sta->bt_coex_supported_version =
+			btcoexist->btc_get_bt_coex_supported_version(btcoexist);
+
+#if (BT_AUTO_REPORT_ONLY_8812A_2ANT == 0)
+	halbtc8812a2ant_query_bt_info(btcoexist);
+	halbtc8812a2ant_monitor_bt_ctr(btcoexist);
+	halbtc8812a2ant_monitor_wifi_ctr(btcoexist);
+	halbtc8812a2ant_monitor_bt_enable_disable(btcoexist);
+#else
+	halbtc8812a2ant_monitor_wifi_ctr(btcoexist);
+
+	if (halbtc8812a2ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust ||
+	    coex_dm->auto_tdma_adjust_low_rssi)
+		halbtc8812a2ant_run_coexist_mechanism(btcoexist);
+#endif
+}
+
+void ex_halbtc8812a2ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata)
+{
+	switch (op_code) {
+	case BTC_DBG_SET_COEX_DEC_BT_PWR:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set Dec BT power\n");
+		BTC_TRACE(trace_buf);
+
+		{
+			u8	data_len = 4;
+			u8	buf[6] = {0};
+			u8	dec_bt_pwr = 0, pwr_level = 0;
+
+			if (op_len == 2) {
+				dec_bt_pwr = pdata[0];
+				pwr_level = pdata[1];
+
+				buf[0] = data_len;
+				buf[1] = 0x3;		/* OP_Code */
+				buf[2] = 0x2;		/* OP_Code_Length */
+
+				buf[3] = dec_bt_pwr;	/* OP_Code_Content */
+				buf[4] = pwr_level;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Set Dec BT power=%d, pwr_level=%d\n",
+					    dec_bt_pwr, pwr_level);
+				BTC_TRACE(trace_buf);
+
+				btcoexist->btc_set(btcoexist,
+						   BTC_SET_ACT_CTRL_BT_COEX,
+						   (void *)&buf[0]);
+			}
+		}
+		break;
+
+	case BTC_DBG_SET_COEX_BT_AFH_MAP:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set BT AFH Map\n");
+		BTC_TRACE(trace_buf);
+		{
+			u8	data_len = 5;
+			u8	buf[6] = {0};
+
+			if (op_len == 3) {
+				buf[0] = data_len;
+				buf[1] = 0x5;				/* OP_Code */
+				buf[2] = 0x3;				/* OP_Code_Length */
+
+				buf[3] = pdata[0];			/* OP_Code_Content */
+				buf[4] = pdata[1];
+				buf[5] = pdata[2];
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Set BT AFH Map = %02x %02x %02x\n",
+					    pdata[0], pdata[1], pdata[2]);
+				BTC_TRACE(trace_buf);
+				btcoexist->btc_set(btcoexist,
+						   BTC_SET_ACT_CTRL_BT_COEX,
+						   (void *)&buf[0]);
+			}
+		}
+		break;
+
+	case BTC_DBG_SET_COEX_BT_IGNORE_WLAN_ACT:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set BT Ignore Wlan Active\n");
+		BTC_TRACE(trace_buf);
+		{
+			u8	data_len = 3;
+			u8	buf[6] = {0};
+
+			if (op_len == 1) {
+				buf[0] = data_len;
+				buf[1] = 0x1;			/* OP_Code */
+				buf[2] = 0x1;			/* OP_Code_Length */
+
+				buf[3] = pdata[0];		/* OP_Code_Content */
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Set BT Ignore Wlan Active = 0x%x\n",
+					    pdata[0]);
+				BTC_TRACE(trace_buf);
+
+				btcoexist->btc_set(btcoexist,
+						   BTC_SET_ACT_CTRL_BT_COEX,
+						   (void *)&buf[0]);
+			}
+		}
+		break;
+
+	default:
+		break;
+	}
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8812a2ant.h
@@ -0,0 +1,227 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8812A_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8812A 2Ant BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8812A_2ANT				0
+
+#define	BT_INFO_8812A_2ANT_B_FTP						BIT(7)
+#define	BT_INFO_8812A_2ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8812A_2ANT_B_HID						BIT(5)
+#define	BT_INFO_8812A_2ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8812A_2ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8812A_2ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8812A_2ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8812A_2ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8812A_2ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+		(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT		2
+#define	NOISY_AP_NUM_THRESH_8812A						50
+
+enum bt_info_src_8812a_2ant {
+	BT_INFO_SRC_8812A_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8812A_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8812A_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8812A_2ANT_MAX
+};
+
+enum bt_8812a_2ant_bt_status {
+	BT_8812A_2ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8812A_2ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8812A_2ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8812A_2ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8812A_2ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8812A_2ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8812A_2ANT_BT_STATUS_MAX
+};
+
+enum bt_8812a_2ant_coex_algo {
+	BT_8812A_2ANT_COEX_ALGO_UNDEFINED		= 0x0,
+	BT_8812A_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8812A_2ANT_COEX_ALGO_SCO_HID		= 0x2,
+	BT_8812A_2ANT_COEX_ALGO_HID				= 0x3,
+	BT_8812A_2ANT_COEX_ALGO_A2DP			= 0x4,
+	BT_8812A_2ANT_COEX_ALGO_A2DP_PANHS		= 0x5,
+	BT_8812A_2ANT_COEX_ALGO_PANEDR			= 0x6,
+	BT_8812A_2ANT_COEX_ALGO_PANHS			= 0x7,
+	BT_8812A_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x8,
+	BT_8812A_2ANT_COEX_ALGO_PANEDR_HID		= 0x9,
+	BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0xa,
+	BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANHS	= 0xb,
+	BT_8812A_2ANT_COEX_ALGO_HID_A2DP		= 0xc,
+	BT_8812A_2ANT_COEX_ALGO_MAX				= 0xd
+};
+
+struct coex_dm_8812a_2ant {
+	/* fw mechanism */
+	u8		pre_bt_dec_pwr_lvl;
+	u8		cur_bt_dec_pwr_lvl;
+	u8		pre_fw_dac_swing_lvl;
+	u8		cur_fw_dac_swing_lvl;
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		auto_tdma_adjust_low_rssi;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean		pre_rf_rx_lpf_shrink;
+	boolean		cur_rf_rx_lpf_shrink;
+	u32		bt_rf_0x1e_backup;
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	boolean		pre_dac_swing_on;
+	u32		pre_dac_swing_lvl;
+	boolean		cur_dac_swing_on;
+	u32		cur_dac_swing_lvl;
+	boolean		pre_adc_back_off;
+	boolean		cur_adc_back_off;
+	boolean	pre_agc_table_en;
+	boolean		cur_agc_table_en;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		cur_ra_mask_type;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+
+	boolean	cur_enable_pta;
+	boolean	pre_enable_pta;
+};
+
+struct coex_sta_8812a_2ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+	boolean					acl_busy;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	u8					bt_rssi;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8812A_2ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8812A_2ANT_MAX];
+	u32					bt_info_query_cnt;
+	boolean					c2h_bt_inquiry_page;
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u8					scan_ap_num;
+	boolean				pre_bt_disabled;
+	u32					pre_bt_info_c2h_cnt_bt_rsp;
+	u32					pre_bt_info_c2h_cnt_bt_send;
+	boolean				force_lps_on;
+	u32				bt_coex_supported_version;
+
+	u32				crc_ok_cck;
+	u32				crc_ok_11g;
+	u32				crc_ok_11n;
+	u32				crc_ok_11n_vht;
+
+	u32				crc_err_cck;
+	u32				crc_err_11g;
+	u32				crc_err_11n;
+	u32				crc_err_11n_vht;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8812a2ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8812a2ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8812a2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8812a2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8812a2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8812a2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8812a2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8812a2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8812a2ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+
+void ex_halbtc8812a2ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a2ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a2ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a2ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata);
+void ex_halbtc8812a2ant_pta_off_on_notify(IN struct btc_coexist *btcoexist,
+		IN u8 bt_status);
+
+#else
+#define	ex_halbtc8812a2ant_power_on_setting(btcoexist)
+#define	ex_halbtc8812a2ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8812a2ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8812a2ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8812a2ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_halt_notify(btcoexist)
+#define	ex_halbtc8812a2ant_periodical(btcoexist)
+#define	ex_halbtc8812a2ant_display_coex_info(btcoexist)
+#define	ex_halbtc8812a2ant_dbg_control(btcoexist, op_code, op_len, pdata)
+#define ex_halbtc8812a2ant_pta_off_on_notify(btcoexist, bt_status)
+
+#endif
+
+#endif
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8821a1ant.c
@@ -0,0 +1,3256 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for 8821A_1ANT Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************
+ * SY modify 2015/04/27
+ * ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8821a_1ant		glcoex_dm_8821a_1ant;
+static struct  coex_dm_8821a_1ant	*coex_dm = &glcoex_dm_8821a_1ant;
+static struct  coex_sta_8821a_1ant		glcoex_sta_8821a_1ant;
+static struct  coex_sta_8821a_1ant	*coex_sta = &glcoex_sta_8821a_1ant;
+
+const char *const glbt_info_src_8821a_1ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8821a_1ant = 20161128;
+u32	glcoex_ver_8821a_1ant = 0x64;
+u32	glcoex_ver_btdesired_8821a_1ant = 0x62;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8821a1ant_
+ * ************************************************************ */
+u8 halbtc8821a1ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8821a1ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8821a1ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8821a1ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8821a1ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8821a1ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8821a1ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8821a1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8821a1ant_update_ra_mask(btcoexist, force_exec,
+					       0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8821a1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8821a1ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8821a1ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8821a1ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+
+/* true/xxxx/x:1
+ * false/false/x: 64
+ * false/true/x:x */
+void halbtc8821a1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8821a1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+#if 0
+	/* to avoid 0x76e[3] = 1 (WLAN_Act control by PTA) during IPS */
+	if (!(btcoexist->btc_read_1byte(btcoexist, 0x76e) & 0x8)) {
+		coex_sta->high_priority_tx = 65535;
+		coex_sta->high_priority_rx = 65535;
+		coex_sta->low_priority_tx = 65535;
+		coex_sta->low_priority_rx = 65535;
+		return;
+	}
+#endif
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+}
+
+void halbtc8821a1ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+#if 1
+
+	coex_sta->crc_ok_cck = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_CCK);
+	coex_sta->crc_ok_11g = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_LEGACY);
+	coex_sta->crc_ok_11n = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_HT);
+	coex_sta->crc_ok_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_OK_VHT);
+
+	coex_sta->crc_err_cck = btcoexist->btc_phydm_query_PHY_counter(
+					btcoexist,
+					PHYDM_INFO_CRC32_ERROR_CCK);
+	coex_sta->crc_err_11g =  btcoexist->btc_phydm_query_PHY_counter(
+					 btcoexist,
+					 PHYDM_INFO_CRC32_ERROR_LEGACY);
+	coex_sta->crc_err_11n = btcoexist->btc_phydm_query_PHY_counter(
+					btcoexist,
+					PHYDM_INFO_CRC32_ERROR_HT);
+	coex_sta->crc_err_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_ERROR_VHT);
+
+#endif
+}
+
+
+void halbtc8821a1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+boolean halbtc8821a1ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void halbtc8821a1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8821a1ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8821A_1ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Profile = SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8821A_1ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! BT Profile = SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8821a1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8821a1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8821a1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8821a1ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf5;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xa0;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xa0; /* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8821a1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8821a1ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8821a1ant_sw_mechanism(IN struct btc_coexist *btcoexist,
+				  IN boolean low_penalty_ra)
+{
+	halbtc8821a1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+
+void halbtc8821a1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8821a1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8821a1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8821a1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** CoexTable(%d) **********\n", type);
+	BTC_TRACE(trace_buf);
+
+	switch (type) {
+	case 0:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0xaaaa5a5a, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaa5a5a, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8821a1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable)
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8821a1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8821a1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8821a1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8821a1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8821a1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8821a1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean init_hwcfg, IN boolean wifi_off)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u32			u32tmp = 0;
+	u8			h2c_parameter[2] = {0};
+
+	if (init_hwcfg) {
+		/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp |= BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		/* 0x765 = 0x18 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x3);
+
+		if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT) {
+			/* tell firmware "antenna inverse"  ==> WRONG firmware antenna control code.==>need fw to fix */
+			h2c_parameter[0] = 1;
+			h2c_parameter[1] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+						h2c_parameter);
+
+			/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x64, 0x1, 0x1); */ /*Main Ant to  BT for IPS case 0x4c[23]=1 */
+		} else {
+			/* tell firmware "no antenna inverse" ==> WRONG firmware antenna control code.==>need fw to fix */
+			h2c_parameter[0] = 0;
+			h2c_parameter[1] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+						h2c_parameter);
+
+			/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x64, 0x1, 0x0); */ /*Aux Ant to  BT for IPS case 0x4c[23]=1 */
+		}
+	} else if (wifi_off) {
+		/* 0x4c[24:23]=00, Set Antenna control by BT_RFE_CTRL	BT Vendor 0xac=0xf002 */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp &= ~BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		/* 0x765 = 0x18 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x3);
+	} else {
+		/* 0x765 = 0x0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x0);
+	}
+
+	/* ext switch setting */
+	switch (ant_pos_type) {
+	case BTC_ANT_PATH_WIFI:
+		btcoexist->btc_write_1byte(btcoexist, 0xcb4, 0x77);
+		if (board_info->btdm_ant_pos ==
+		    BTC_ANTENNA_AT_MAIN_PORT)
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x1);
+		else
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x2);
+		break;
+	case BTC_ANT_PATH_BT:
+		btcoexist->btc_write_1byte(btcoexist, 0xcb4, 0x77);
+		if (board_info->btdm_ant_pos ==
+		    BTC_ANTENNA_AT_MAIN_PORT)
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x2);
+		else
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x1);
+		break;
+	default:
+	case BTC_ANT_PATH_PTA:
+		btcoexist->btc_write_1byte(btcoexist, 0xcb4, 0x66);
+		if (board_info->btdm_ant_pos ==
+		    BTC_ANTENNA_AT_MAIN_PORT)
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x1);
+		else
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x2);
+		break;
+	}
+}
+
+
+void halbtc8821a1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0x8, 0, 0, 0, 0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+/* halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,8); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+				h2c_parameter);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+/* halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,8); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+				h2c_parameter);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8821a1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8821a1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8821a1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma. */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8821a1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8821a1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8821a1ant_power_save_state(btcoexist,
+				BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		}
+} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50, 0x4);
+
+	} else  {
+			halbtc8821a1ant_power_save_state(btcoexist,
+				BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+	}
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8821a1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	u8			rssi_adjust_val = 0;
+	/* u32			fw_ver=0; */
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+	if (turn_on) {
+		switch (type) {
+		default:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x1a, 0x1a, 0x0, 0x50);
+			break;
+		case 1:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x3a, 0x03, 0x10, 0x50);
+			rssi_adjust_val = 11;
+			break;
+		case 2:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x2b, 0x03, 0x10, 0x50);
+			rssi_adjust_val = 14;
+			break;
+		case 3:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x1d, 0x1d, 0x0, 0x52);
+			break;
+		case 4:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x14, 0x0);
+			rssi_adjust_val = 17;
+			break;
+		case 5:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x15, 0x3, 0x11, 0x10);
+			break;
+		case 6:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x20, 0x3, 0x11, 0x13);
+			break;
+		case 7:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xc, 0x5, 0x0, 0x0);
+			break;
+		case 8:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 9:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x21, 0x3, 0x10, 0x50);
+			rssi_adjust_val = 18;
+			break;
+		case 10:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0xa, 0x0, 0x40);
+			break;
+		case 11:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x15, 0x03, 0x10, 0x50);
+			rssi_adjust_val = 20;
+			break;
+		case 12:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x0a, 0x0a, 0x0, 0x50);
+			break;
+		case 13:
+			if (coex_sta->scan_ap_num <= 5)
+				halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x40, 0x3, 0x10, 0x50);
+			else
+				halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x12, 0x12, 0x0, 0x50);
+			break;
+		case 14:
+			if (coex_sta->scan_ap_num <= 5)
+				halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x50);
+			else
+				halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x1e, 0x3, 0x10, 0x14);
+			break;
+		case 15:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0x3, 0x8, 0x0);
+			break;
+		case 16:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x10, 0x0);
+			rssi_adjust_val = 18;
+			break;
+		case 18:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			rssi_adjust_val = 14;
+			break;
+		case 20:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x03, 0x11, 0x10);
+			break;
+		case 21:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x11);
+			break;
+		case 22:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x10);
+			break;
+		case 23:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x18);
+			rssi_adjust_val = 22;
+			break;
+		case 24:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x3, 0x31, 0x18);
+			rssi_adjust_val = 22;
+			break;
+		case 25:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			rssi_adjust_val = 22;
+			break;
+		case 26:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			rssi_adjust_val = 22;
+			break;
+		case 27:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x98);
+			rssi_adjust_val = 22;
+			break;
+		case 28:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x69,
+						      0x25, 0x3, 0x31, 0x0);
+			break;
+		case 29:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xab,
+						      0x1a, 0x1a, 0x1, 0x10);
+			break;
+		case 30:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x10);
+			break;
+		case 31:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1a, 0x1a, 0, 0x58);
+			break;
+		case 32:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x3, 0x11, 0x11);
+			break;
+		case 33:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x25, 0x3, 0x30, 0x90);
+			break;
+		case 34:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 35:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x63,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 36:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x12, 0x3, 0x14, 0x50);
+			break;
+		case 40: /* SoftAP only with no sta associated,BT disable ,TDMA mode for power saving */
+			/* here softap mode screen off will cost 70-80mA for phone */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x23,
+						      0x18, 0x00, 0x10, 0x24);
+			break;
+		case 41:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x15, 0x3, 0x11, 0x11);
+			break;
+		case 42:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x20, 0x3, 0x11, 0x11);
+			break;
+		case 43:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x11);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 8: /* PTA Control */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			halbtc8821a1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_PTA, false, false);
+			break;
+		case 0:
+		default:  /* Software control, Antenna at BT side */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			halbtc8821a1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_BT, false, false);
+			break;
+		case 9:   /* Software control, Antenna at WiFi side */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			halbtc8821a1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_WIFI, false, false);
+			break;
+		case 10:	/* under 5G */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x8, 0x0);
+			halbtc8821a1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_BT, false, false);
+			break;
+		}
+	}
+	rssi_adjust_val = 0;
+	btcoexist->btc_set(btcoexist,
+		BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE, &rssi_adjust_val);
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8821a1ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* sw all off */
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+	/* hw all off */
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+boolean halbtc8821a1ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected &&
+	    BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+		common = true;
+	} else if (!wifi_connected &&
+		   (BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+		common = true;
+	} else if (!wifi_connected &&
+		   (BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE !=
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non connected-idle + BT Busy!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+		common = true;
+	} else {
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		common = false;
+	}
+
+	return common;
+}
+
+/* *********************************************
+ *
+ *	Software Coex Mechanism start
+ *
+ * ********************************************* */
+
+void halbtc8821a1ant_action_bt_whck_test(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	/* halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false); */
+	halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, false, false);
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+/* SCO only or SCO+PAN(HS) */
+void halbtc8821a1ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, true);
+}
+
+void halbtc8821a1ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, true);
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8821a1ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8821a1ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8821a1ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+}
+
+/* PAN(HS) only */
+void halbtc8821a1ant_action_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+}
+
+/* PAN(EDR)+A2DP */
+void halbtc8821a1ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8821a1ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, true);
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8821a1ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, true);
+}
+
+void halbtc8821a1ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, true);
+}
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+void halbtc8821a1ant_action_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8821a1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_connected = false, ap_enable = false, wifi_busy = false,
+				bt_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	if ((!wifi_connected) && (!coex_sta->wifi_is_high_pri_task)) {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	}
+
+	/* sy modify	 */
+	else if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+		 (bt_link_info->a2dp_exist)) {
+		/* SCO/HID/A2DP  busy */
+
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	}
+
+	/* sy modify */
+
+	else if ((bt_link_info->a2dp_exist) &&
+		 (bt_link_info->hid_exist)) {
+		/* A2DP+HID	busy */
+
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+					14);
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist,
+						     NORMAL_EXEC, 1);
+	}
+
+
+	else if ((bt_link_info->pan_exist) || (wifi_busy)) {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	}
+}
+
+void halbtc8821a1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	/* tdma and coex table */
+
+	if (bt_link_info->sco_exist) {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 41);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	} else { /* HID */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 42);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8821a1ant_coex_under_5g(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8821a1ant_ignore_wlan_act(btcoexist, NORMAL_EXEC, true);
+
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 10);
+
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+	halbtc8821a1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 5);
+}
+
+void halbtc8821a1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 9);
+}
+
+void halbtc8821a1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 10) {
+			bt_disabled = true;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_wifi_only(btcoexist);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		if (!bt_disabled) {
+		} else {
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+					   NULL);
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+					   NULL);
+		}
+	}
+}
+
+void halbtc8821a1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+
+void halbtc8821a1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	u8		bt_rssi_state;
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	bt_rssi_state = halbtc8821a1ant_bt_rssi_state(2, 28, 0);
+
+	if (bt_link_info->hid_only) { /* HID */
+		halbtc8821a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				wifi_status);
+		coex_dm->auto_tdma_adjust = false;
+		return;
+	} else if (bt_link_info->a2dp_only) { /* A2DP		 */
+		if (BT_8821A_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifi_status) {
+			/* halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8); */
+			/* halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2); */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+			coex_dm->auto_tdma_adjust = false;
+		} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+			   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			/* halbtc8821a1ant_tdma_duration_adjust_for_acl(btcoexist, wifi_status); */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		} else { /* for low BT RSSI */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+			coex_dm->auto_tdma_adjust = false;
+		}
+	} else if (bt_link_info->hid_exist &&
+		   bt_link_info->a2dp_exist) { /* HID+A2DP */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+			coex_dm->auto_tdma_adjust = false;
+		} else { /* for low BT RSSI */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+			coex_dm->auto_tdma_adjust = false;
+		}
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+	} else if ((bt_link_info->pan_only) || (bt_link_info->hid_exist &&
+		bt_link_info->pan_exist)) { /* PAN(OPP,FTP), HID+PAN(OPP,FTP)			 */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 6);
+		coex_dm->auto_tdma_adjust = false;
+	} else if (((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 43);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 11);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+		coex_dm->auto_tdma_adjust = false;
+	}
+}
+
+void halbtc8821a1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+
+	/* tdma and coex table	 */
+	halbtc8821a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8821a1ant_action_wifi_not_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+
+	/* tdma and coex table */
+	if (BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			/* sy modify */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8821A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8821a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8821A_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20); */
+		/* halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1); */
+
+		/* Bryant Add */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8821a1ant_action_wifi_not_connected_asso_auth(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist)  || (bt_link_info->hid_exist)) {
+		/* sy modify */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+	} else if ((bt_link_info->a2dp_exist)  || (bt_link_info->pan_exist)) {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8821a1ant_action_wifi_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* tdma and coex table */
+	if (BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			/* sy modify */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8821A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8821a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8821A_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20); */
+		/* halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1); */
+
+		/* Bryant Add */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8821a1ant_action_wifi_connected_specific_packet(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* tdma and coex table */
+	/* sy modify */
+	if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	}
+
+	if ((bt_link_info->hid_exist) && (bt_link_info->a2dp_exist)) {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+					14);
+		halbtc8821a1ant_coex_table_with_type(btcoexist,
+						     NORMAL_EXEC, 1);
+	}
+
+
+	else if (bt_link_info->pan_exist) {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8821a1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	boolean	wifi_busy = false;
+	boolean	scan = false, link = false, roam = false;
+	boolean		under_4way = false, ap_enable = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+	if (under_4way) {
+		halbtc8821a1ant_action_wifi_connected_specific_packet(
+			btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under 4way<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	if (scan || link || roam) {
+		if (scan)
+			halbtc8821a1ant_action_wifi_connected_scan(btcoexist);
+		else
+			halbtc8821a1ant_action_wifi_connected_specific_packet(
+				btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under scan<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	/* tdma and coex table */
+	if (!wifi_busy) {
+		if (BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8821a1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8821A_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else if ((BT_8821A_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8821a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8821A_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+		}
+	} else {
+		if (BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8821a1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8821A_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else if ((BT_8821A_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8821a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8821A_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+		}
+	}
+}
+
+void halbtc8821a1ant_run_sw_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8	algorithm = 0;
+
+	algorithm = halbtc8821a1ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+
+	if (halbtc8821a1ant_is_common_action(btcoexist)) {
+
+	} else {
+		switch (coex_dm->cur_algorithm) {
+		case BT_8821A_1ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_sco(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_hid(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_a2dp(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_a2dp_pan_hs(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_pan_edr(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_pan_hs(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_pan_edr_a2dp(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_pan_edr_hid(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_hid_a2dp_pan_edr(
+				btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_hid_a2dp(btcoexist);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8821a1ant_coex_all_off(btcoexist); */
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8821a1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, bt_hs_on = false;
+	boolean	increase_scan_dev_num = false;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+	u8	wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	wifi_under_5g = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_action_bt_whck_test(btcoexist);
+		return;
+	}
+
+	if ((BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+			   &increase_scan_dev_num);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8821a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8821a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (!bt_link_info->sco_exist && !bt_link_info->hid_exist)
+		halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+	else {
+		if (wifi_connected) {
+			wifi_rssi_state = halbtc8821a1ant_wifi_rssi_state(
+						  btcoexist, 1, 2, 30, 0);
+			if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+			    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+				/* halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1, 1, 1); */
+				halbtc8821a1ant_limited_tx(btcoexist,
+						   NORMAL_EXEC, 1, 1, 0, 1);
+			} else {
+				/* halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1, 1, 1); */
+				halbtc8821a1ant_limited_tx(btcoexist,
+						   NORMAL_EXEC, 1, 1, 0, 1);
+			}
+		} else
+			halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0,
+						   0, 0);
+
+	}
+
+	if (bt_link_info->sco_exist) {
+		bt_ctrl_agg_buf_size = true;
+		agg_buf_size = 0x3;
+	} else if (bt_link_info->hid_exist) {
+		bt_ctrl_agg_buf_size = true;
+		agg_buf_size = 0x5;
+	} else if (bt_link_info->a2dp_exist || bt_link_info->pan_exist) {
+		bt_ctrl_agg_buf_size = true;
+		agg_buf_size = 0x8;
+	}
+	halbtc8821a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+				   bt_ctrl_agg_buf_size, agg_buf_size);
+
+	halbtc8821a1ant_run_sw_coexist_mechanism(btcoexist);
+
+	/* low pelnaty ra in pcr ra */
+	btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 25);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8821a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8821a1ant_action_hs(btcoexist);
+		return;
+	}
+
+
+	if (!wifi_connected) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is non connected-idle !!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (scan || link || roam) {
+			if (scan)
+				halbtc8821a1ant_action_wifi_not_connected_scan(
+					btcoexist);
+			else
+				halbtc8821a1ant_action_wifi_not_connected_asso_auth(
+					btcoexist);
+		} else
+			halbtc8821a1ant_action_wifi_not_connected(btcoexist);
+	} else	/* wifi LPS/Busy */
+		halbtc8821a1ant_action_wifi_connected(btcoexist);
+}
+
+void halbtc8821a1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+	/* sw all off */
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+	/* halbtc8821a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8); */
+	halbtc8821a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+}
+
+void halbtc8821a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up, IN boolean wifi_only)
+{
+	u8	u8tmp = 0;
+	boolean			wifi_under_5g = false;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	if (wifi_only)
+		return;
+
+	if (back_up) {
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	}
+
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	/* Give bt_coex_supported_version the default value */
+	coex_sta->bt_coex_supported_version = 0;
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	/* Antenna config */
+	if (wifi_under_5g)
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, true,
+					     false);
+	else
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, true,
+					     false);
+
+	/* PTA parameter */
+	halbtc8821a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	/* Enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e,
+			   0xc); /* 0x76e[3] =1, WLAN_Act control by PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x3);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8821a1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8821a1ant_
+ * ************************************************************ */
+void ex_halbtc8821a1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8821a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8821a1ant_init_hw_config(btcoexist, true, wifi_only);
+}
+
+void ex_halbtc8821a1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = false;
+
+	halbtc8821a1ant_init_coex_dm(btcoexist);
+
+	halbtc8821a1ant_query_bt_info(btcoexist);
+}
+
+void ex_halbtc8821a1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fw_ver = 0, bt_patch_ver = 0;
+	u32				bt_coex_ver = 0;
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+	u32				phyver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d",
+		   "Ant PG Num/ Ant Mech/ Ant Pos:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num,
+		   board_info->btdm_ant_pos);
+	CL_PRINTF(cli_buf);
+
+	/* btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver); */
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+	bt_coex_ver = ((coex_sta->bt_coex_supported_version & 0xff00) >> 8);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+		   "CoexVer WL/  BT_Desired/ BT_Report",
+		   glcoex_ver_date_8821a_1ant, glcoex_ver_8821a_1ant,
+		   glcoex_ver_btdesired_8821a_1ant,
+		   bt_coex_ver,
+		   (bt_coex_ver == 0xff ? "Unknown" :
+		    (bt_coex_ver >= glcoex_ver_btdesired_8821a_1ant ?
+		     "Match" : "Mis-Match")));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d/ %c",
+		   "W_FW/ B_FW/ Phy/ Kt",
+		   fw_ver, bt_patch_ver, phyver,
+		   coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_BT_LINK_INFO);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8821A_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8821a_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	if (!btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+			   "SM[LowPenaltyRA]",
+			   coex_dm->cur_low_penalty_ra);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[mechanisms]============");
+		CL_PRINTF(cli_buf);
+
+		ps_tdma_case = coex_dm->cur_ps_tdma;
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n %-35s = %02x %02x %02x %02x %02x case-%d (auto:%d)",
+			   "PS TDMA",
+			   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+			   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+			   coex_dm->ps_tdma_para[4], ps_tdma_case,
+			   coex_dm->auto_tdma_adjust);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ",
+			   "IgnWlanAct",
+			   coex_dm->cur_ignore_wlan_act);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ",
+			   "Latest error condition(should be 0)",
+			   coex_dm->error_condition);
+		CL_PRINTF(cli_buf);
+	}
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "backup ARFR1/ARFR2/RL/AMaxTime",
+		   coex_dm->backup_arfr_cnt1, coex_dm->backup_arfr_cnt2,
+		   coex_dm->backup_retry_limit,
+		   coex_dm->backup_ampdu_max_time);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "0x430/0x434/0x42a/0x456",
+		   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc58);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x778/ 0xc58[29:25]",
+		   u8tmp[0], (u32tmp[0] & 0x3e000000) >> 25);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x8db);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8db[6:5]",
+		   ((u8tmp[0] & 0x60) >> 5));
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x975);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0xcb4[29:28]/0xcb4[7:0]/0x974[9:8]",
+		   (u32tmp[0] & 0x30000000) >> 28, u32tmp[0] & 0xff,
+		   u8tmp[0] & 0x3);
+	CL_PRINTF(cli_buf);
+
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x64);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x40/0x4c[24:23]/0x64[0]",
+		   u8tmp[0], ((u32tmp[0] & 0x01800000) >> 23), u8tmp[1] & 0x1);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)",
+		   u32tmp[0] & 0xff);
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8821A_1ANT == 1)
+	halbtc8821a1ant_monitor_bt_ctr(btcoexist);
+#endif
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8821a1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	boolean	wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G,
+			   &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false,
+					     true);
+		/* halbtc8821a1ant_set_ant_path_d_cut(btcoexist, false, false, false, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL_OFF); */
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+
+		halbtc8821a1ant_init_hw_config(btcoexist, false, false);
+		halbtc8821a1ant_init_coex_dm(btcoexist);
+		halbtc8821a1ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8821a1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8821a1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+	boolean	wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	if (BTC_SCAN_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if (coex_sta->bt_disabled)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	halbtc8821a1ant_query_bt_info(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8821a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8821a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8821a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8821a1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_SCAN_START == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8821a1ant_action_wifi_not_connected_scan(
+				btcoexist);
+		else	/* wifi is connected */
+			halbtc8821a1ant_action_wifi_connected_scan(btcoexist);
+	} else if (BTC_SCAN_FINISH == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8821a1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8821a1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+/* copy scan notify content to switch band notify */
+void ex_halbtc8821a1ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+	boolean	wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	if (BTC_SCAN_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if (coex_sta->bt_disabled)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	halbtc8821a1ant_query_bt_info(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8821a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8821a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8821a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8821a1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_SCAN_START == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8821a1ant_action_wifi_not_connected_scan(
+				btcoexist);
+		else	/* wifi is connected */
+			halbtc8821a1ant_action_wifi_connected_scan(btcoexist);
+	} else if (BTC_SCAN_FINISH == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8821a1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8821a1ant_action_wifi_connected(btcoexist);
+	}
+}
+void ex_halbtc8821a1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	boolean	wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+	boolean	wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	if (BTC_ASSOCIATE_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8821a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8821a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8821a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8821a1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_ASSOCIATE_START == type)
+		halbtc8821a1ant_action_wifi_not_connected_asso_auth(btcoexist);
+	else if (BTC_ASSOCIATE_FINISH == type) {
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+				   &wifi_connected);
+		if (!wifi_connected) /* non-connected scan */
+			halbtc8821a1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8821a1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8821a1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	boolean	wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		/* h2c_parameter[0] = 0x1; */
+		h2c_parameter[0] = 0x0;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+}
+
+void ex_halbtc8821a1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+	boolean	wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    BTC_PACKET_ARP == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+
+		if (BTC_PACKET_ARP == type) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], specific Packet ARP notify\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], specific Packet DHCP or EAPOL notify\n");
+			BTC_TRACE(trace_buf);
+		}
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet [Type = %d] notify\n", type);
+		BTC_TRACE(trace_buf);
+	}
+
+	coex_sta->specific_pkt_period_cnt = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8821a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8821a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8821a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8821a1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    BTC_PACKET_ARP == type) {
+		if (BTC_PACKET_ARP == type) {
+			coex_dm->arp_cnt++;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], ARP Packet Count = %d\n",
+				    coex_dm->arp_cnt);
+			BTC_TRACE(trace_buf);
+			if (coex_dm->arp_cnt >=
+			    10) /* if APR PKT > 10 after connect, do not go to ActionWifiConnectedSpecificPacket(btcoexist) */
+				return;
+		}
+
+		halbtc8821a1ant_action_wifi_connected_specific_packet(
+			btcoexist);
+	}
+}
+
+void ex_halbtc8821a1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8				bt_info = 0;
+	u8				i, rsp_source = 0;
+	boolean				wifi_connected = false;
+	boolean				bt_busy = false;
+	boolean				wifi_under_5g = false;
+
+
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8821A_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8821A_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+	/* if 0xff, it means BT is under WHCK test */
+	if (bt_info == 0xff)
+		coex_sta->bt_whck_test = true;
+	else
+		coex_sta->bt_whck_test = false;
+
+	if (BT_INFO_SRC_8821A_1ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		if (coex_sta->bt_info_c2h[rsp_source][2] & 0x20)
+			coex_sta->c2h_bt_page = true;
+		else
+			coex_sta->c2h_bt_page = false;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+		if (!coex_sta->bt_tx_rx_mask) {
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x15\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+						  0x3c, 0x15);
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if (coex_sta->bt_info_ext & BIT(1)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8821a1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8821a1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if ((coex_sta->bt_info_ext & BIT(3)) && !wifi_under_5g) {
+			if (!btcoexist->manual_control &&
+			    !btcoexist->stop_coex_dm) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821a1ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			}
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+		}
+#if (BT_AUTO_REPORT_ONLY_8821A_1ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8821a1ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8821A_1ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8821A_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8821A_1ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8821A_1ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8821A_1ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8821A_1ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+	}
+
+	halbtc8821a1ant_update_bt_link_info(btcoexist);
+
+	bt_info = bt_info &
+		0x1f;  /* mask profile bit for connect-ilde identification ( for CSR case: A2DP idle --> 0x41) */
+
+	if (!(bt_info & BT_INFO_8821A_1ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8821A_1ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8821A_1ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8821A_1ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8821A_1ANT_B_ACL_BUSY) {
+		if (BT_8821A_1ANT_BT_STATUS_ACL_BUSY != coex_dm->bt_status)
+			coex_dm->auto_tdma_adjust = false;
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	halbtc8821a1ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8821a1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	boolean	wifi_under_5g = false;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+	halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false, true);
+	/* halbtc8821a1ant_set_ant_path_d_cut(btcoexist, false, false, false, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL_OFF); */
+
+	halbtc8821a1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8821a1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	btcoexist->stop_coex_dm = true;
+}
+
+void ex_halbtc8821a1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	boolean wifi_under_5g = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false,
+					     true);
+		/* halbtc8821a1ant_set_ant_path_d_cut(btcoexist, false, false, false, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL_OFF); */
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+		btcoexist->stop_coex_dm = true;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+		halbtc8821a1ant_init_hw_config(btcoexist, false, false);
+		halbtc8821a1ant_init_coex_dm(btcoexist);
+		halbtc8821a1ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8821a1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	u32 bt_patch_ver;
+
+	if (((coex_sta->bt_coex_supported_version == 0) ||
+	     (coex_sta->bt_coex_supported_version == 0xffff)) && (!coex_sta->bt_disabled))
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION, &coex_sta->bt_coex_supported_version);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+
+#if (BT_AUTO_REPORT_ONLY_8821A_1ANT == 0)
+	halbtc8821a1ant_query_bt_info(btcoexist);
+	halbtc8821a1ant_monitor_bt_enable_disable(btcoexist);
+#else
+	halbtc8821a1ant_monitor_bt_ctr(btcoexist);
+	halbtc8821a1ant_monitor_wifi_ctr(btcoexist);
+	halbtc8821a1ant_monitor_bt_enable_disable(btcoexist);
+	if (halbtc8821a1ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust) {
+		/* if(coex_sta->specific_pkt_period_cnt > 2) */
+		/* { */
+		halbtc8821a1ant_run_coexist_mechanism(btcoexist);
+		/* } */
+	}
+
+	coex_sta->specific_pkt_period_cnt++;
+#endif
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
+
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8821a1ant.h
@@ -0,0 +1,214 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8821A 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8821A_1ANT				1
+
+#define	BT_INFO_8821A_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8821A_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8821A_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8821A_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8821A_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8821A_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8821A_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8821A_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8821A_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+		(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT		2
+
+enum bt_info_src_8821a_1ant {
+	BT_INFO_SRC_8821A_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8821A_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8821A_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8821A_1ANT_MAX
+};
+
+enum bt_8821a_1ant_bt_status {
+	BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8821A_1ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8821A_1ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8821A_1ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8821A_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8821a_1ant_wifi_status {
+	BT_8821A_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8821A_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8821A_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8821A_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT				= 0x3,
+	BT_8821A_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8821A_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8821A_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8821a_1ant_coex_algo {
+	BT_8821A_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8821A_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8821A_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8821A_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8821A_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8821A_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8821A_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8821A_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8821A_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8821A_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8821A_1ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8821A_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8821a_1ant {
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8821a_1ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_vht;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_vht;
+
+	u32					bt_coex_supported_version;
+	u8					cut_version;
+	u8					bt_rssi;
+	u8					scan_ap_num;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8821A_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8821A_1ANT_MAX];
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_page;				/* Add for win8.1 page out issue */
+	boolean					wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	boolean				bt_whck_test;	/* Add for ASUS WHQL TEST that enable wifi test bt */
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8821a1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8821a1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821a1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821a1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8821a1ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8821a1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8821a1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8821a1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8821a1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8821a1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8821a1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8821a1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_switchband_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8821a1ant_halt_notify(btcoexist)
+#define	ex_halbtc8821a1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8821a1ant_periodical(btcoexist)
+#define	ex_halbtc8821a1ant_display_coex_info(btcoexist)
+
+#endif
+
+#endif
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8821a2ant.c
@@ -0,0 +1,4584 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8821A Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8821a_2ant		glcoex_dm_8821a_2ant;
+static struct  coex_dm_8821a_2ant	*coex_dm = &glcoex_dm_8821a_2ant;
+static struct  coex_sta_8821a_2ant		glcoex_sta_8821a_2ant;
+static struct  coex_sta_8821a_2ant	*coex_sta = &glcoex_sta_8821a_2ant;
+
+const char *const glbt_info_src_8821a_2ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8821a_2ant = 20161128;
+u32	glcoex_ver_8821a_2ant = 0x60;
+u32	glcoex_ver_btdesired_8821a_2ant = 0x5c;
+
+/* modify 20140903v43 a2dpandhid tdmaonoff a2dp glitch _ tdma off 778=3(case1)->778=1(case0)
+ * and to improve tp while a2dphid case23->case25 , case123->case125 for asus spec
+ * and modify for asus bt WHQL test _ tdma off_ 778=3->1_
+ * ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8821a2ant_
+ * ************************************************************ */
+u8 halbtc8821a2ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8821a2ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+
+void halbtc8821a2ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+}
+
+void halbtc8821a2ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if ((coex_sta->low_priority_rx >= 950)  &&
+	    (coex_sta->low_priority_rx >= coex_sta->low_priority_tx) &&
+	    (!coex_sta->under_ips))
+		bt_link_info->slave_role = true;
+	else
+		bt_link_info->slave_role = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_hp_txrx, reg_hp_tx, reg_hp_tx, reg_hp_rx, reg_hp_rx);
+	BTC_TRACE(trace_buf);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_lp_txrx, reg_lp_tx, reg_lp_tx, reg_lp_rx, reg_lp_rx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+}
+
+void halbtc8821a2ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+#if 1
+
+	coex_sta->crc_ok_cck = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_CCK);
+	coex_sta->crc_ok_11g = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_LEGACY);
+	coex_sta->crc_ok_11n = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_HT);
+	coex_sta->crc_ok_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_OK_VHT);
+
+	coex_sta->crc_err_cck = btcoexist->btc_phydm_query_PHY_counter(
+					btcoexist,
+					PHYDM_INFO_CRC32_ERROR_CCK);
+	coex_sta->crc_err_11g =  btcoexist->btc_phydm_query_PHY_counter(
+					 btcoexist,
+					 PHYDM_INFO_CRC32_ERROR_LEGACY);
+	coex_sta->crc_err_11n = btcoexist->btc_phydm_query_PHY_counter(
+					btcoexist,
+					PHYDM_INFO_CRC32_ERROR_HT);
+	coex_sta->crc_err_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_ERROR_VHT);
+
+#endif
+}
+
+void halbtc8821a2ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+boolean halbtc8821a2ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean			wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean			wifi_connected = false;
+	u8			wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+
+
+		wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 3,
+			  2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+
+		if ((BTC_RSSI_STATE_HIGH == wifi_rssi_state) ||
+		    (BTC_RSSI_STATE_LOW == wifi_rssi_state))
+			return true;
+
+	}
+
+	return false;
+}
+
+void halbtc8821a2ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32	bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 10) {
+			bt_disabled = true;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		/* if (!bt_disabled) {} else {} */
+	}
+}
+
+void halbtc8821a2ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8821a2ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8821A_2ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				{
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], SCO + HID + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(HS) ==> SCO\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(EDR) ==> SCO\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8821a2ant_set_fw_dac_swing_level(IN struct btc_coexist *btcoexist,
+		IN u8 dac_swing_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	/* There are several type of dacswing */
+	/* 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6 */
+	h2c_parameter[0] = dac_swing_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
+}
+
+void halbtc8821a2ant_set_fw_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				       IN u8 dec_bt_pwr_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = dec_bt_pwr_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x62, 1, h2c_parameter);
+}
+
+void halbtc8821a2ant_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN u8 dec_bt_pwr_lvl)
+{
+	coex_dm->cur_bt_dec_pwr_lvl = dec_bt_pwr_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_dec_pwr_lvl == coex_dm->cur_bt_dec_pwr_lvl)
+			return;
+	}
+	halbtc8821a2ant_set_fw_dec_bt_pwr(btcoexist,
+					  coex_dm->cur_bt_dec_pwr_lvl);
+
+	coex_dm->pre_bt_dec_pwr_lvl = coex_dm->cur_bt_dec_pwr_lvl;
+}
+
+void halbtc8821a2ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8821a2ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8821a2ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8821a2ant_fw_dac_swing_lvl(IN struct btc_coexist *btcoexist,
+			      IN boolean force_exec, IN u8 fw_dac_swing_lvl)
+{
+	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swing_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_fw_dac_swing_lvl ==
+		    coex_dm->cur_fw_dac_swing_lvl)
+			return;
+	}
+
+	halbtc8821a2ant_set_fw_dac_swing_level(btcoexist,
+					       coex_dm->cur_fw_dac_swing_lvl);
+
+	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
+}
+
+void halbtc8821a2ant_set_sw_rf_rx_lpf_corner(IN struct btc_coexist *btcoexist,
+		IN boolean rx_rf_shrink_on)
+{
+	if (rx_rf_shrink_on) {
+		/* Shrink RF Rx LPF corner */
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Shrink RF Rx LPF corner!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e, 0xfffff,
+					  0xffffc);
+	} else {
+		/* Resume RF Rx LPF corner */
+		/* After initialized, we can use coex_dm->bt_rf_0x1e_backup */
+		if (btcoexist->initilized) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Resume RF Rx LPF corner!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+					  0xfffff, coex_dm->bt_rf_0x1e_backup);
+		}
+	}
+}
+
+void halbtc8821a2ant_rf_shrink(IN struct btc_coexist *btcoexist,
+		       IN boolean force_exec, IN boolean rx_rf_shrink_on)
+{
+	coex_dm->cur_rf_rx_lpf_shrink = rx_rf_shrink_on;
+
+	if (!force_exec) {
+		if (coex_dm->pre_rf_rx_lpf_shrink ==
+		    coex_dm->cur_rf_rx_lpf_shrink)
+			return;
+	}
+	halbtc8821a2ant_set_sw_rf_rx_lpf_corner(btcoexist,
+						coex_dm->cur_rf_rx_lpf_shrink);
+
+	coex_dm->pre_rf_rx_lpf_shrink = coex_dm->cur_rf_rx_lpf_shrink;
+}
+
+void halbtc8821a2ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf3;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xa0;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xa0;	/* MCS5 or OFDM36 */
+		/* h2c_parameter[3] = 0xf7; */ /*MCS7 or OFDM54 */
+		/* h2c_parameter[4] = 0xf8; */ /*MCS6 or OFDM48 */
+		/* h2c_parameter[5] = 0xf9;	/MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8821a2ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8821a2ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8821a2ant_set_dac_swing_reg(IN struct btc_coexist *btcoexist,
+				       IN u32 level)
+{
+	u8	val = (u8)level;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Write SwDacSwing = 0x%x\n", level);
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc5b, 0x3e, val);
+}
+
+void halbtc8821a2ant_set_sw_full_time_dac_swing(IN struct btc_coexist
+		*btcoexist, IN boolean sw_dac_swing_on, IN u32 sw_dac_swing_lvl)
+{
+	if (sw_dac_swing_on)
+		halbtc8821a2ant_set_dac_swing_reg(btcoexist, sw_dac_swing_lvl);
+	else
+		halbtc8821a2ant_set_dac_swing_reg(btcoexist, 0x18);
+}
+
+
+void halbtc8821a2ant_dac_swing(IN struct btc_coexist *btcoexist,
+	IN boolean force_exec, IN boolean dac_swing_on, IN u32 dac_swing_lvl)
+{
+	coex_dm->cur_dac_swing_on = dac_swing_on;
+	coex_dm->cur_dac_swing_lvl = dac_swing_lvl;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_dac_swing_on == coex_dm->cur_dac_swing_on) &&
+		    (coex_dm->pre_dac_swing_lvl ==
+		     coex_dm->cur_dac_swing_lvl))
+			return;
+	}
+	delay_ms(30);
+	halbtc8821a2ant_set_sw_full_time_dac_swing(btcoexist, dac_swing_on,
+			dac_swing_lvl);
+
+	coex_dm->pre_dac_swing_on = coex_dm->cur_dac_swing_on;
+	coex_dm->pre_dac_swing_lvl = coex_dm->cur_dac_swing_lvl;
+}
+
+void halbtc8821a2ant_set_adc_back_off(IN struct btc_coexist *btcoexist,
+				      IN boolean adc_back_off)
+{
+	if (adc_back_off) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x8db, 0x60, 0x3);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x8db, 0x60, 0x1);
+	}
+}
+
+void halbtc8821a2ant_adc_back_off(IN struct btc_coexist *btcoexist,
+			  IN boolean force_exec, IN boolean adc_back_off)
+{
+	coex_dm->cur_adc_back_off = adc_back_off;
+
+	if (!force_exec) {
+		if (coex_dm->pre_adc_back_off == coex_dm->cur_adc_back_off)
+			return;
+	}
+	halbtc8821a2ant_set_adc_back_off(btcoexist, coex_dm->cur_adc_back_off);
+
+	coex_dm->pre_adc_back_off = coex_dm->cur_adc_back_off;
+}
+
+void halbtc8821a2ant_set_agc_table(IN struct btc_coexist *btcoexist,
+				   IN boolean agc_table_en)
+{
+	u8		rssi_adjust_val = 0;
+
+	/* =================BB AGC Gain Table */
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6e1A0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6d1B0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6c1C0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6b1D0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6a1E0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x691F0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x68200001);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xaa1A0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa91B0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa81C0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa71D0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa61E0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa51F0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa4200001);
+	}
+
+
+	/* =================RF Gain */
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x02000);
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x38fff);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x38ffe);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x380c3);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x28ce6);
+	}
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xed, 0xfffff, 0x1);
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x38fff);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x38ffe);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x380c3);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x28ce6);
+	}
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xed, 0xfffff, 0x0);
+
+	/* set rssi_adjust_val for wifi module. */
+	if (agc_table_en)
+		rssi_adjust_val = 8;
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON,
+			   &rssi_adjust_val);
+}
+
+void halbtc8821a2ant_agc_table(IN struct btc_coexist *btcoexist,
+			       IN boolean force_exec, IN boolean agc_table_en)
+{
+	coex_dm->cur_agc_table_en = agc_table_en;
+
+	if (!force_exec) {
+		if (coex_dm->pre_agc_table_en == coex_dm->cur_agc_table_en)
+			return;
+	}
+	halbtc8821a2ant_set_agc_table(btcoexist, agc_table_en);
+
+	coex_dm->pre_agc_table_en = coex_dm->cur_agc_table_en;
+}
+
+void halbtc8821a2ant_sw_mechanism1(IN struct btc_coexist *btcoexist,
+			   IN boolean shrink_rx_lpf, IN boolean low_penalty_ra,
+			   IN boolean limited_dig, IN boolean bt_lna_constrain)
+{
+
+
+	/* halbtc8821a2ant_rf_shrink(btcoexist, NORMAL_EXEC, shrink_rx_lpf); */
+	halbtc8821a2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+
+void halbtc8821a2ant_sw_mechanism2(IN struct btc_coexist *btcoexist,
+			   IN boolean agc_table_shift, IN boolean adc_back_off,
+			   IN boolean sw_dac_swing, IN u32 dac_swing_lvl)
+{
+
+	halbtc8821a2ant_dac_swing(btcoexist, NORMAL_EXEC, sw_dac_swing,
+				  dac_swing_lvl);
+}
+
+void halbtc8821a2ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8821a2ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8821a2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8821a2ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	coex_sta->coex_table_type = type;
+
+	switch (type) {
+	case 0:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5afa5afa, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5ada5ada, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0xffffffff, 0xffffffff, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0x5fff5fff, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55ff55ff, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 8:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 9:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 10:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 11:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 12:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 13:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 14:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 15:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 16:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5fdf5fdf, 0x5fdb5fdb, 0xffffff, 0x3);
+		break;
+	case 17:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0xfafafafa, 0xfafafafa, 0xffffff, 0x3);
+		break;
+	case 18:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5555555f, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8821a2ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable)
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8821a2ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8821a2ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+
+void halbtc8821a2ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8821a2ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8821a2ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8821a2ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0x0, 0, 0, 48, 0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+				h2c_parameter);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+				h2c_parameter);
+		} else {
+		}
+	}
+}
+
+void halbtc8821a2ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8821a2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8821a2ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/*power save must executed before psTdma*/
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8821a2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+
+void halbtc8821a2ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean		ap_enable = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8821a2ant_power_save_state(btcoexist,
+				BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		}
+} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50, 0x4);
+
+	} else {
+			halbtc8821a2ant_power_save_state(btcoexist,
+				BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+	}
+
+	h2c_parameter[0] = byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = byte5;
+
+	coex_dm->ps_tdma_para[0] = byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8821a2ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	u8			wifi_rssi_state1, bt_rssi_state;
+
+
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	if (!(BTC_RSSI_HIGH(wifi_rssi_state1) &&
+	      BTC_RSSI_HIGH(bt_rssi_state)) && turn_on) {
+		type = type + 100; /* for WiFi RSSI low or BT RSSI low */
+	}
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+	if (turn_on) {
+		switch (type) {
+		case 1:
+		default:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0xf1, 0x90);
+			break;
+		case 2:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x12, 0x12, 0xe1, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x2d, 0x03, 0xf1, 0x90);
+			break;
+		case 3:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf1, 0x90);
+			break;
+		case 4:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x03, 0xf1, 0x90);
+			break;
+		case 5:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x3, 0x70, 0x90);
+			break;
+		case 6:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x12, 0x12, 0x60, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x2d, 0x3, 0x70, 0x90);
+			break;
+		case 7:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0x70, 0x90);
+			break;
+		case 8:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x10, 0x3, 0x70, 0x90);
+			break;
+		case 9:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0xf1, 0x90);
+			break;
+		case 10:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x12, 0x12, 0xe1, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x2d, 0x03, 0xf1, 0x90);
+			break;
+		case 11:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0xa, 0xa, 0xe1, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf1, 0x90);
+			break;
+		case 12:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x5, 0x5, 0xe1, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0xf1, 0x90);
+			break;
+		case 13:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x3, 0x70, 0x90);
+			break;
+		case 14:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x12, 0x12, 0x60, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x2d, 0x3, 0x70, 0x90);
+			break;
+		case 15:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0xa, 0xa, 0x60, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0x70, 0x90);
+			break;
+		case 16:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x5, 0x5, 0x60, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0x70, 0x90);
+			break;
+		case 17:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x2f, 0x2f, 0x60, 0x90);
+			break;
+		case 18:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x5, 0x5, 0xe1, 0x90);
+			break;
+		case 19:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0xe1, 0x90);
+			break;
+		case 20:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0x60, 0x90);
+			break;
+		case 21:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x03, 0x70, 0x90);
+			break;
+		case 23:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1e, 0x03, 0xf1, 0x94);
+			break;
+		case 24:
+		case 124:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x3c, 0x03, 0x70, 0x50);
+			break;
+		/* case25/case125 : for lenovo bt pan tp degrade<30% while wifi downlink */
+		case 25:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x14, 0x03, 0xf1, 0x90);
+			break;
+		case 26:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x30, 0x03, 0xf1, 0x90);
+			break;
+		case 27:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x23, 0x03, 0x70, 0x50);
+			break;
+		case 28:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1e, 0x03, 0xf1, 0x94);
+			break;
+		case 71:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90); */
+
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0xf1, 0x90);
+			break;
+		case 101:
+		case 105:
+		case 171:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x3a, 0x03, 0x70, 0x50);
+			break;
+		case 102:
+		case 106:
+		case 110:
+		case 114:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x2d, 0x03, 0x70, 0x50);
+			break;
+		case 103:
+		case 107:
+		case 111:
+		case 115:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1c, 0x03, 0x70, 0x50);
+			break;
+		case 104:
+		case 108:
+		case 112:
+		case 116:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x10, 0x03, 0x70, 0x50);
+			break;
+		case 109:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0xf1, 0x90);
+			break;
+		case 113:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0x70, 0x90);
+			break;
+		case 121:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x03, 0x70, 0x90);
+			break;
+		case 22:
+		case 122:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x35, 0x03, 0x71, 0x11);
+			break;
+		case 123:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1e, 0x03, 0x70, 0x54);
+			break;
+		/* case25/case125 : for lenovo bt pan tp degrade<30% while wifi downlink */
+		case 125:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x14, 0x03, 0x70, 0x50);
+			break;
+		case 126:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x30, 0x03, 0x70, 0x50);
+			break;
+		case 127:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x28, 0x03, 0x70, 0x50);
+			break;
+		case 128:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1e, 0x03, 0x70, 0x54);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 0:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		case 1:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x48, 0x0);
+			break;
+		default:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+
+void halbtc8821a2ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean init_hwcfg, IN boolean wifi_off)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u32				u32tmp = 0;
+	u8				h2c_parameter[2] = {0};
+
+	if (init_hwcfg) {
+		/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp |= BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		btcoexist->btc_write_4byte(btcoexist, 0x974, 0x3ff);
+		/* btcoexist->btc_write_1byte(btcoexist, 0xcb4, 0x77); */
+
+		if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT) {
+
+			h2c_parameter[0] = 1;
+			h2c_parameter[1] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+						h2c_parameter);
+		} else {
+
+			h2c_parameter[0] = 0;
+			h2c_parameter[1] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+						h2c_parameter);
+		}
+	}
+
+	/* ext switch setting */
+	switch (ant_pos_type) {
+	case BTC_ANT_WIFI_AT_MAIN:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb7,
+						   0x30, 0x1);
+		break;
+	case BTC_ANT_WIFI_AT_AUX:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb7,
+						   0x30, 0x2);
+		break;
+	}
+}
+
+void halbtc8821a2ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* fw all off */
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	/* hw all off */
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); */
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8821a2ant_coex_under_5g(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a2ant_coex_all_off(btcoexist);
+
+	halbtc8821a2ant_ignore_wlan_act(btcoexist, NORMAL_EXEC, true);
+}
+
+void halbtc8821a2ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	boolean	wifi_connected = false;
+	boolean	low_pwr_disable = true;
+	boolean		scan = false, link = false, roam = false;
+
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+			   &low_pwr_disable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+	if (scan || link || roam) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi link process + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     7);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+	} else if (wifi_connected) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     7);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi no-link + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	}
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 6);
+	halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+}
+
+
+void halbtc8821a2ant_action_wifi_link_process(IN struct btc_coexist *btcoexist)
+{
+	u8	u8tmpa, u8tmpb;
+
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+	halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+
+
+	u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+	u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "############# [BTCoex], 0x765=0x%x, 0x76e=0x%x\n", u8tmpa,
+		    u8tmpb);
+	BTC_TRACE(trace_buf);
+}
+
+boolean halbtc8821a2ant_action_wifi_idle_process(IN struct btc_coexist
+		*btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u8		ap_num = 0;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	/* wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0); */
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES - 20, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM, &ap_num);
+
+	/* define the office environment */
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) &&
+	    (coex_sta->hid_exist == true) &&
+	    (coex_sta->a2dp_exist == true)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi  idle process for BT HID+A2DP exist!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_dac_swing(btcoexist, NORMAL_EXEC, true, 0x6);
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		/* sw all off */
+		halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false,
+					      false);
+		halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+		return true;
+	}
+
+	/* */
+	else if (coex_sta->pan_exist == true) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi  idle process for BT PAN exist!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_dac_swing(btcoexist, NORMAL_EXEC, true, 0x6);
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		/* sw all off */
+		halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false,
+					      false);
+		halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+		return true;
+	}
+
+	else {
+		halbtc8821a2ant_dac_swing(btcoexist, NORMAL_EXEC, true, 0x18);
+		return false;
+	}
+
+
+}
+
+
+
+boolean halbtc8821a2ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+	boolean			bt_hs_on = false, low_pwr_disable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected) {
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non-connected idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+		halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false,
+					      false);
+		halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+
+		common = true;
+	} else {
+		if (BT_8821A_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status) {
+			low_pwr_disable = false;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+			halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, false, 0x8);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+			halbtc8821a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+			halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+			halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 0xb);
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false,
+						      false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else if (BT_8821A_2ANT_BT_STATUS_CONNECTED_IDLE ==
+			   coex_dm->bt_status) {
+			low_pwr_disable = true;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+
+			if (bt_hs_on)
+				return false;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, false, 0x8);
+
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+			halbtc8821a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+			halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+			halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 0xb);
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else {
+			low_pwr_disable = true;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+
+			if (wifi_busy) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+				common = false;
+				/* common = halbtc8821a2ant_action_wifi_idle_process(btcoexist);	 */
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+				/* common = false;	 */
+				common = halbtc8821a2ant_action_wifi_idle_process(
+						 btcoexist);
+			}
+		}
+	}
+
+	return common;
+}
+void halbtc8821a2ant_tdma_duration_adjust(IN struct btc_coexist *btcoexist,
+		IN boolean sco_hid, IN boolean tx_pause, IN u8 max_interval)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0;
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+		{
+			if (sco_hid) {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					} else if (max_interval == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (max_interval == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					} else if (max_interval == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (max_interval == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			} else {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (max_interval == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (max_interval == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (max_interval == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (max_interval == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					}
+				}
+			}
+		}
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* acquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if s n 2 retry count0, heWiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if s 2 2 retry count< 3, hWiFi duration */
+				if (wait_count <= 2)
+					m++; /* K@blevel^ */
+				else
+					m = 1;
+
+				if (m >= 20)  /* m j = 20 ' j120 recheckO_ WiFi duration. */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, un1 retry count > 3, hWiFi duration */
+			if (wait_count == 1)
+				m++; /* K@blevel^ */
+			else
+				m = 1;
+
+			if (m >= 20)  /* m j = 20 ' j120 recheckO_ WiFi duration. */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (max_interval == 1) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 71) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 13);
+					coex_dm->ps_tdma_du_adj_type = 13;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 71);
+					coex_dm->ps_tdma_du_adj_type = 71;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 9);
+					coex_dm->ps_tdma_du_adj_type = 9;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 71) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 71);
+						coex_dm->ps_tdma_du_adj_type =
+							71;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					}
+				}
+			}
+		} else if (max_interval == 2) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					}
+				}
+			}
+		} else if (max_interval == 3) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			}
+		}
+	}
+
+	/* if current PsTdma not match with the recorded one (when scan, dhcp...), */
+	/* then we have to adjust it back to the previous record one. */
+	if (coex_dm->cur_ps_tdma != coex_dm->ps_tdma_du_adj_type) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], PsTdma type dismatch!!!, cur_ps_tdma=%d, recordPsTdma=%d\n",
+			    coex_dm->cur_ps_tdma, coex_dm->ps_tdma_du_adj_type);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (!scan && !link && !roam)
+			halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+}
+
+/* SCO only or SCO+PAN(HS) */
+void halbtc8821a2ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8	wifi_rssi_state, bt_rssi_state;
+	u32	wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 4);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for SCO quality at 11b/g mode */
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else { /* for SCO quality & wifi performance balance at 11n mode */
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			halbtc8821a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+		else {
+			if (bt_link_info->sco_only)
+				halbtc8821a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 17);
+			else
+				halbtc8821a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 12);
+		}
+	}
+
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+				0); /* for voice quality */
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x18);
+		}
+	}
+}
+
+
+void halbtc8821a2ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	u8	wifi_rssi_state, bt_rssi_state;
+	u32	wifi_bw;
+
+	btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 25);
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for HID at 11b/g mode */
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	else  /* for HID quality & wifi performance balance at 11n mode */
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 24);
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8821a2ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+	u8		ap_num = 0;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM, &ap_num);
+
+	/* define the office environment */
+	if ((ap_num >= 10) && BTC_RSSI_HIGH(wifi_rssi_state1) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+		/* dbg_print(" AP#>10(%d)\n", ap_num); */
+
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+		halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+		halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		/* halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1); */
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 23);
+
+		/* sw mechanism */
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		}
+		return;
+
+	}
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		/* halbtc8821a2ant_tdma_duration_adjust(btcoexist, false, false, 1); */
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 23);
+	} else {
+		/* halbtc8821a2ant_tdma_duration_adjust(btcoexist, false, true, 1); */
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 23);
+	}
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8821a2ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	} else {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+	}
+
+	halbtc8821a2ant_tdma_duration_adjust(btcoexist, false, true, 2);
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8821a2ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     10);
+	} else {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+	}
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 26);
+	else
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 26);
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+
+/* PAN(HS) only */
+void halbtc8821a2ant_action_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* PAN(EDR)+A2DP */
+void halbtc8821a2ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     12);
+
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			halbtc8821a2ant_tdma_duration_adjust(btcoexist, false,
+							     true, 3);
+		else
+			halbtc8821a2ant_tdma_duration_adjust(btcoexist, false,
+							     false, 3);
+	} else {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+		halbtc8821a2ant_tdma_duration_adjust(btcoexist, false, true, 3);
+	}
+
+	/* sw mechanism	 */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8821a2ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 25);
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	} else {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     14);
+	}
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		if (BTC_WIFI_BW_HT40 == wifi_bw) {
+			halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 3);
+			/* halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 11); */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x780);
+		} else {
+			halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 6);
+			/* halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7); */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+		}
+		halbtc8821a2ant_tdma_duration_adjust(btcoexist, true, false, 2);
+	} else {
+		halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		/* halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 14); */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+		halbtc8821a2ant_tdma_duration_adjust(btcoexist, true, true, 2);
+	}
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8821a2ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1,  bt_rssi_state;
+	u32		wifi_bw;
+
+	btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 25);
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	} else {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     14);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			halbtc8821a2ant_tdma_duration_adjust(btcoexist, true,
+							     true, 3);
+		else
+			halbtc8821a2ant_tdma_duration_adjust(btcoexist, true,
+							     false, 3);
+	} else
+		halbtc8821a2ant_tdma_duration_adjust(btcoexist, true, true, 3);
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8821a2ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+	u8		ap_num = 0;
+
+	btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 25);
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	/* bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2, 29, 0); */
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(3,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 37);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true, 0x6);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) {
+		if (BTC_RSSI_HIGH(bt_rssi_state))
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	} else {
+		/* only 802.11N mode we have to dec bt power to 4 degree */
+		if (BTC_RSSI_HIGH(bt_rssi_state)) {
+			btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+					   &ap_num);
+			/* need to check ap Number of Not */
+			if (ap_num < 10)
+				halbtc8821a2ant_dec_bt_pwr(btcoexist,
+							   NORMAL_EXEC, 4);
+			else
+				halbtc8821a2ant_dec_bt_pwr(btcoexist,
+							   NORMAL_EXEC, 2);
+		} else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	}
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     18);
+	} else {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     18);
+	}
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		/* halbtc8821a2ant_tdma_duration_adjust(btcoexist, true, false, 3); */
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 28);
+	} else {
+		/* halbtc8821a2ant_tdma_duration_adjust(btcoexist, true, true, 3); */
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 28);
+	}
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8821a2ant_action_bt_whck_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8821a2ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	/* hw all off */
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); */
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+}
+
+void halbtc8821a2ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	boolean				wifi_under_5g = false;
+	u8				algorithm = 0;
+	u32				num_of_wifi_link = 0;
+	u32				wifi_link_status = 0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean				miracast_plus_bt = false;
+	boolean				scan = false, link = false, roam = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), run 5G coex setting!!<===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_bt_whck_test(btcoexist);
+		return;
+	}
+
+	algorithm = halbtc8821a2ant_action_algorithm(btcoexist);
+	if (coex_sta->c2h_bt_inquiry_page &&
+	    (BT_8821A_2ANT_COEX_ALGO_PANHS != algorithm)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_bt_inquiry(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+	if (scan || link || roam) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under Link Process !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_wifi_link_process(btcoexist);
+		return;
+	}
+
+	/* for P2P */
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist)
+			miracast_plus_bt = true;
+		else
+			miracast_plus_bt = false;
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+		halbtc8821a2ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	}
+	miracast_plus_bt = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+			   &miracast_plus_bt);
+
+	coex_dm->cur_algorithm = algorithm;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Algorithm = %d\n",
+		    coex_dm->cur_algorithm);
+	BTC_TRACE(trace_buf);
+
+	if (halbtc8821a2ant_is_common_action(btcoexist)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant common.\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		if (coex_dm->cur_algorithm != coex_dm->pre_algorithm) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], pre_algorithm=%d, cur_algorithm=%d\n",
+				coex_dm->pre_algorithm, coex_dm->cur_algorithm);
+			BTC_TRACE(trace_buf);
+			coex_dm->auto_tdma_adjust = false;
+		}
+		switch (coex_dm->cur_algorithm) {
+		case BT_8821A_2ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_sco(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_hid(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_a2dp(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_a2dp_pan_hs(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_pan_edr(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_pan_hs(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_pan_edr_a2dp(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_pan_edr_hid(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_hid_a2dp_pan_edr(
+				btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_hid_a2dp(btcoexist);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_coex_all_off(btcoexist);
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8821a2ant_wifi_off_hw_cfg(IN struct btc_coexist *btcoexist)
+{
+	u8 h2c_parameter[2] = {0};
+	u32 fw_ver = 0;
+
+	/* set wlan_act to low */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+			  0x780); /* WiFi goto standby while GNT_BT 0-->1 */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	if (fw_ver >= 0x180000) {
+		/* Use H2C to set GNT_BT to HIGH */
+		h2c_parameter[0] = 1;
+		btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1, h2c_parameter);
+	} else
+		btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+}
+
+void halbtc8821a2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821a2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 1);
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 6);
+	halbtc8821a2ant_dec_bt_pwr(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+void halbtc8821a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up)
+{
+	u8	u8tmp = 0;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 2Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	/* Give bt_coex_supported_version the default value */
+	coex_sta->bt_coex_supported_version = 0;
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	/* backup rf 0x1e value */
+	coex_dm->bt_rf_0x1e_backup =
+		btcoexist->btc_get_rf_reg(btcoexist, BTC_RF_A, 0x1e, 0xfffff);
+
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* Antenna config	 */
+	halbtc8821a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN, true,
+				     false);
+	coex_sta->dis_ver_info_cnt = 0;
+
+	/* PTA parameter */
+	halbtc8821a2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	/* Enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e,
+			   0x4); /* 0x76e[3] =1, WLAN_Act control by PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x3);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8821a2ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8821a2ant_
+ * ************************************************************ */
+void ex_halbtc8821a2ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+
+}
+
+void ex_halbtc8821a2ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x4; /* Set BIT2 by default since it's 2ant case */
+
+	/* */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+	if (btcoexist->chip_interface == BTC_INTF_USB) {
+		/* fixed at S0 for USB interface */
+		u8tmp |= 0x1;	/* antenna inverse */
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	} else {
+		/* for PCIE and SDIO interface, we check efuse 0xc3[6] */
+		if (board_info->single_ant_path == 0) {
+		} else if (board_info->single_ant_path == 1) {
+			/* set to S0 */
+			u8tmp |= 0x1;	/* antenna inverse */
+		}
+
+		if (btcoexist->chip_interface == BTC_INTF_PCI)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x384,
+							     u8tmp);
+		else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60,
+							     u8tmp);
+	}
+}
+
+void ex_halbtc8821a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8821a2ant_init_hw_config(btcoexist, true);
+}
+
+void ex_halbtc8821a2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821a2ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8821a2ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u32				u32tmp[4];
+	u32				fw_ver = 0, bt_patch_ver = 0;
+	u32				bt_coex_ver = 0;
+	u32				phyver = 0;
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+	/* btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver); */
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+	bt_coex_ver = coex_sta->bt_coex_supported_version & 0xff;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+		   "CoexVer WL/  BT_Desired/ BT_Report",
+		   glcoex_ver_date_8821a_2ant, glcoex_ver_8821a_2ant,
+		   glcoex_ver_btdesired_8821a_2ant,
+		   bt_coex_ver,
+		   (bt_coex_ver == 0xff ? "Unknown" :
+		    (bt_coex_ver >= glcoex_ver_btdesired_8821a_2ant ?
+		     "Match" : "Mis-Match")));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d/ %c",
+		   "W_FW/ B_FW/ Phy/ Kt",
+		   fw_ver, bt_patch_ver, phyver,
+		   coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %ddBm/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8821A_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8821A_2ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi - 100, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+
+	{
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+			   "BT Role",
+			   (bt_link_info->slave_role) ? "Slave" : "Master");
+		CL_PRINTF(cli_buf);
+	}
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8821A_2ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8821a_2ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	/* Sw mechanism	 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Sw mechanism]============");
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ",
+		   "SM1[ShRf/ LpRA/ LimDig]",
+		   coex_dm->cur_rf_rx_lpf_shrink, coex_dm->cur_low_penalty_ra,
+		   coex_dm->limited_dig);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ",
+		   "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]",
+		   coex_dm->cur_agc_table_en, coex_dm->cur_adc_back_off,
+		   coex_dm->cur_dac_swing_on, coex_dm->cur_dac_swing_lvl);
+	CL_PRINTF(cli_buf);
+
+	/* Fw mechanism		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Fw mechanism]============");
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (auto:%d)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   coex_dm->auto_tdma_adjust);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Coex Table Type",
+		   coex_sta->coex_table_type);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "DecBtPwr/ IgnWlanAct",
+		   coex_dm->cur_bt_dec_pwr_lvl, coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x",
+		   "RF-A, 0x1e initVal",
+		   coex_dm->bt_rf_0x1e_backup);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xc5b);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x880);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x778/0x880[29:25]/0xc58[29:25]",
+		   u8tmp[0], (u32tmp[0] & 0x3e000000) >> 25,
+		   ((u8tmp[1] & 0x3e) >> 1));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x764);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x764/ 0x765/ 0x76e",
+		   (u32tmp[0] & 0xff), (u32tmp[0] & 0xff00) >> 8, u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xcb4[7:0](ctrl)/ 0xcb4[29:28](val)",
+		   u32tmp[0] & 0xff, ((u32tmp[0] & 0x30000000) >> 28));
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x974);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x40/ 0x4c[24:23]/ 0x974",
+		   u8tmp[0], ((u32tmp[0] & 0x01800000) >> 23), u32tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x49c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xc50(dig)/0x49c(null-drop)",
+		   u32tmp[0] & 0xff, u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8821A_2ANT == 1)
+	/* halbtc8821a2ant_monitor_bt_ctr(btcoexist); */
+#endif
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8821a2ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+		halbtc8821a2ant_wifi_off_hw_cfg(btcoexist);
+		halbtc8821a2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		halbtc8821a2ant_coex_all_off(btcoexist);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+		halbtc8821a2ant_init_hw_config(btcoexist, false);
+		halbtc8821a2ant_init_coex_dm(btcoexist);
+		halbtc8821a2ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8821a2ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8821a2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	u8	u8tmpa, u8tmpb;
+
+	u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+	u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+
+	if (BTC_SCAN_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_SCAN_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "############# [BTCoex], 0x765=0x%x, 0x76e=0x%x\n", u8tmpa,
+		    u8tmpb);
+	BTC_TRACE(trace_buf);
+}
+
+/* copy scan notify content to switch band notify */
+void ex_halbtc8821a2ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8	u8tmpa, u8tmpb;
+
+	u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+	u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+
+	if (BTC_SCAN_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_SCAN_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "############# [BTCoex], 0x765=0x%x, 0x76e=0x%x\n", u8tmpa,
+		    u8tmpb);
+	BTC_TRACE(trace_buf);
+}
+
+void ex_halbtc8821a2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	if (BTC_ASSOCIATE_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_ASSOCIATE_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8821a2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	u8			ap_num = 0;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] = 0x1;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else {
+			btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+					   &ap_num);
+			if (ap_num < 10)
+				h2c_parameter[2] = 0x30;
+			else
+				h2c_parameter[2] = 0x20;
+		}
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+}
+
+void ex_halbtc8821a2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	if (type == BTC_PACKET_DHCP) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], DHCP Packet notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8821a2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8			bt_info = 0;
+	u8			i, rsp_source = 0;
+	boolean			bt_busy = false, limited_dig = false;
+	boolean			wifi_connected = false, wifi_under_5g = false;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8821A_2ANT_MAX)
+		rsp_source = BT_INFO_SRC_8821A_2ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), return for Manual CTRL<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	/* if 0xff, it means BT is under WHCK test */
+	if (bt_info == 0xff)
+		coex_sta->bt_whck_test = true;
+	else
+		coex_sta->bt_whck_test = false;
+
+	if (BT_INFO_SRC_8821A_2ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+		if (coex_sta->bt_tx_rx_mask) {
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x01 => Need to switch BT TRx Mask */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x01\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+						  0x3c, 0x01);
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if ((coex_sta->bt_info_ext & BIT(1))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			if (wifi_connected)
+				ex_halbtc8821a2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8821a2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+
+		if (!btcoexist->manual_control && !wifi_under_5g) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT ext info = 0x%x!!\n",
+				    coex_sta->bt_info_ext);
+			BTC_TRACE(trace_buf);
+			if ((coex_sta->bt_info_ext & BIT(3))) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3=1, wifi_connected=%d\n",
+					    wifi_connected);
+				BTC_TRACE(trace_buf);
+				if (wifi_connected) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+					BTC_TRACE(trace_buf);
+					halbtc8821a2ant_ignore_wlan_act(
+						btcoexist, FORCE_EXEC, false);
+				}
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3=0, wifi_connected=%d\n",
+					    wifi_connected);
+				BTC_TRACE(trace_buf);
+				/* BT already NOT ignore Wlan active, do nothing here. */
+				if (!wifi_connected) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT ext info bit3 check, set BT to ignore Wlan active!!\n");
+					BTC_TRACE(trace_buf);
+					halbtc8821a2ant_ignore_wlan_act(
+						btcoexist, FORCE_EXEC, true);
+				}
+			}
+		}
+
+#if (BT_AUTO_REPORT_ONLY_8821A_2ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8821a2ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8821A_2ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8821A_2ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8821A_2ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8821A_2ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8821A_2ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8821A_2ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+
+		if ((coex_sta->hid_exist == false) &&
+		    (coex_sta->c2h_bt_inquiry_page == false) &&
+		    (coex_sta->sco_exist == false)) {
+			if (coex_sta->high_priority_tx  +
+			    coex_sta->high_priority_rx >= 160)
+				coex_sta->hid_exist = true;
+		}
+	}
+
+	halbtc8821a2ant_update_bt_link_info(btcoexist);
+
+	if (!(bt_info & BT_INFO_8821A_2ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8821A_2ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8821A_2ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8821A_2ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8821A_2ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8821A_2ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_2ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_2ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status)) {
+		bt_busy = true;
+		limited_dig = true;
+	} else {
+		bt_busy = false;
+		limited_dig = false;
+	}
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	coex_dm->limited_dig = limited_dig;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_LIMITED_DIG, &limited_dig);
+
+	halbtc8821a2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8821a2ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821a2ant_wifi_off_hw_cfg(btcoexist);
+	/* remove due to interrupt is disabled that polling c2h will fail and delay 100ms. */
+	/* btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x3c, 0x15); */ /*BT goto standby while GNT_BT 1-->0 */
+	halbtc8821a2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8821a2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+}
+
+void ex_halbtc8821a2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_init_hw_config(btcoexist, false);
+		halbtc8821a2ant_init_coex_dm(btcoexist);
+		halbtc8821a2ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8821a2ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	u32 bt_patch_ver;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ==========================Periodical===========================\n");
+	BTC_TRACE(trace_buf);
+
+	if (coex_sta->dis_ver_info_cnt <= 5) {
+		coex_sta->dis_ver_info_cnt += 1;
+		if (coex_sta->dis_ver_info_cnt == 3) {
+			/* Antenna config to set 0x765 = 0x0 (GNT_BT control by PTA) after initial */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Set GNT_BT control by PTA\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_set_ant_path(btcoexist,
+				     BTC_ANT_WIFI_AT_MAIN, false, false);
+		}
+	}
+
+	if (((coex_sta->bt_coex_supported_version == 0) ||
+	     (coex_sta->bt_coex_supported_version == 0xffff)) && (!coex_sta->bt_disabled))
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION, &coex_sta->bt_coex_supported_version);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+
+#if (BT_AUTO_REPORT_ONLY_8821A_2ANT == 0)
+	halbtc8821a2ant_query_bt_info(btcoexist);
+	halbtc8821a2ant_monitor_bt_enable_disable(btcoexist);
+#else
+	halbtc8821a2ant_monitor_bt_ctr(btcoexist);
+	halbtc8821a2ant_monitor_wifi_ctr(btcoexist);
+	halbtc8821a2ant_monitor_bt_enable_disable(btcoexist);
+
+	if (halbtc8821a2ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust)
+		halbtc8821a2ant_run_coexist_mechanism(btcoexist);
+#endif
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8821a2ant.h
@@ -0,0 +1,211 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8821A 2Ant BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8821A_2ANT				1
+
+
+#define	BT_INFO_8821A_2ANT_B_FTP						BIT(7)
+#define	BT_INFO_8821A_2ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8821A_2ANT_B_HID						BIT(5)
+#define	BT_INFO_8821A_2ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8821A_2ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8821A_2ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8821A_2ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8821A_2ANT_B_CONNECTION				BIT(0)
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT		2
+
+
+#define	BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES				42  /* WiFi RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation */
+#define	BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES				46 /* BT RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation */
+
+enum bt_info_src_8821a_2ant {
+	BT_INFO_SRC_8821A_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8821A_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8821A_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8821A_2ANT_MAX
+};
+
+enum bt_8821a_2ant_bt_status {
+	BT_8821A_2ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8821A_2ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8821A_2ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8821A_2ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8821A_2ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8821A_2ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8821A_2ANT_BT_STATUS_MAX
+};
+
+enum bt_8821a_2ant_coex_algo {
+	BT_8821A_2ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8821A_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8821A_2ANT_COEX_ALGO_HID				= 0x2,
+	BT_8821A_2ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8821A_2ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8821A_2ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8821A_2ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8821A_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8821A_2ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8821A_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8821A_2ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8821A_2ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8821a_2ant {
+	/* fw mechanism */
+	u8		pre_bt_dec_pwr_lvl;
+	u8		cur_bt_dec_pwr_lvl;
+	u8		pre_fw_dac_swing_lvl;
+	u8		cur_fw_dac_swing_lvl;
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		reset_tdma_adjust;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+
+	/* sw mechanism */
+	boolean		pre_rf_rx_lpf_shrink;
+	boolean		cur_rf_rx_lpf_shrink;
+	u32		bt_rf_0x1e_backup;
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	boolean		pre_dac_swing_on;
+	u32		pre_dac_swing_lvl;
+	boolean		cur_dac_swing_on;
+	u32		cur_dac_swing_lvl;
+	boolean		pre_adc_back_off;
+	boolean		cur_adc_back_off;
+	boolean	pre_agc_table_en;
+	boolean		cur_agc_table_en;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	boolean		need_recover0x948;
+	u32		backup0x948;
+
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+};
+
+struct coex_sta_8821a_2ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	u8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8821A_2ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8821A_2ANT_MAX];
+	boolean				bt_whck_test;
+	boolean					c2h_bt_inquiry_page;
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u8					scan_ap_num;
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_vht;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_vht;
+
+	u32					bt_coex_supported_version;
+	u8					cut_version;
+	u8					coex_table_type;
+	boolean					force_lps_on;
+
+	u8					dis_ver_info_cnt;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8821a2ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8821a2ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821a2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821a2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8821a2ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8821a2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8821a2ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8821a2ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_display_coex_info(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8821a2ant_power_on_setting(btcoexist)
+#define	ex_halbtc8821a2ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8821a2ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8821a2ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8821a2ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_switchband_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8821a2ant_halt_notify(btcoexist)
+#define	ex_halbtc8821a2ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8821a2ant_periodical(btcoexist)
+#define	ex_halbtc8821a2ant_display_coex_info(btcoexist)
+#endif
+
+#endif
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8821c1ant.c
@@ -0,0 +1,5343 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8821C Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821C_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	*trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8821c_1ant		glcoex_dm_8821c_1ant;
+static struct  coex_dm_8821c_1ant	*coex_dm = &glcoex_dm_8821c_1ant;
+static struct  coex_sta_8821c_1ant		glcoex_sta_8821c_1ant;
+static struct  coex_sta_8821c_1ant	*coex_sta = &glcoex_sta_8821c_1ant;
+static struct  psdscan_sta_8821c_1ant		gl_psd_scan_8821c_1ant;
+static struct  psdscan_sta_8821c_1ant	*psd_scan = &gl_psd_scan_8821c_1ant;
+static struct	rfe_type_8821c_1ant		gl_rfe_type_8821c_1ant;
+static struct	rfe_type_8821c_1ant		*rfe_type = &gl_rfe_type_8821c_1ant;
+
+
+const char *const glbt_info_src_8821c_1ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8821c_1ant = 20161107;
+u32	glcoex_ver_8821c_1ant = 0x0a;
+u32	glcoex_ver_btdesired_8821c_1ant = 0x0a;
+
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8821c1ant_
+ * ************************************************************ */
+u8 halbtc8821c1ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821C_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821C_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8821C_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8821c1ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821C_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821C_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8821C_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8821c1ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8821c1ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8821c1ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8821c1ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8821c1ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8821c1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8821c1ant_update_ra_mask(btcoexist, force_exec,
+					       0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8821c1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8821c1ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8821c1ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8821c1ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8821c1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8821c1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (coex_sta->bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], No query BT info because BT is disabled!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], WL query BT info!!\n");
+	BTC_TRACE(trace_buf);
+}
+
+void halbtc8821c1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u8		num_of_bt_counter_chk = 0, cnt_slave = 0, cnt_overhead = 0,
+				cnt_autoslot_hang = 0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* to avoid 0x76e[3] = 1 (WLAN_Act control by PTA) during IPS */
+	/* if (! (btcoexist->btc_read_1byte(btcoexist, 0x76e) & 0x8) ) */
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Hi-Pri Rx/Tx: %d/%d, Lo-Pri Rx/Tx: %d/%d\n",
+		    reg_hp_rx, reg_hp_tx, reg_lp_rx, reg_lp_tx);
+
+	BTC_TRACE(trace_buf);
+
+	if (BT_8821C_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+
+		if (coex_sta->high_priority_rx >= 15) {
+			if (cnt_overhead < 3)
+				cnt_overhead++;
+
+			if (cnt_overhead == 3)
+				coex_sta->is_hiPri_rx_overhead = true;
+
+		} else {
+			if (cnt_overhead > 0)
+				cnt_overhead--;
+
+			if (cnt_overhead == 0)
+				coex_sta->is_hiPri_rx_overhead = false;
+		}
+	}
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	if ((coex_sta->low_priority_tx > 1150)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	if ((coex_sta->low_priority_rx >= 1150) &&
+	    (coex_sta->low_priority_rx >= coex_sta->low_priority_tx)
+	    && (!coex_sta->under_ips)
+	    && (!coex_sta->c2h_bt_inquiry_page)
+	    && ((bt_link_info->a2dp_exist) || (bt_link_info->pan_exist))) {
+		if (cnt_slave >= 2) {
+			bt_link_info->slave_role = true;
+			cnt_slave = 2;
+		} else
+			cnt_slave++;
+	} else {
+		if (cnt_slave == 0)	{
+			bt_link_info->slave_role = false;
+			cnt_slave = 0;
+		} else
+			cnt_slave--;
+	}
+
+	if (coex_sta->is_tdma_btautoslot) {
+		if ((coex_sta->low_priority_tx >= 1300) &&
+		(coex_sta->low_priority_rx <= 150)) {
+			if (cnt_autoslot_hang >= 2) {
+				coex_sta->is_tdma_btautoslot_hang = true;
+				cnt_autoslot_hang = 2;
+			} else
+				cnt_autoslot_hang++;
+		} else {
+			if (cnt_autoslot_hang == 0)	{
+				coex_sta->is_tdma_btautoslot_hang = false;
+				cnt_autoslot_hang = 0;
+			} else
+				cnt_autoslot_hang--;
+		}
+	}
+
+	if (!coex_sta->bt_disabled) {
+
+		if ((coex_sta->high_priority_tx == 0) &&
+		    (coex_sta->high_priority_rx == 0) &&
+		    (coex_sta->low_priority_tx == 0) &&
+		    (coex_sta->low_priority_rx == 0)) {
+			num_of_bt_counter_chk++;
+			if (num_of_bt_counter_chk >= 3) {
+				halbtc8821c1ant_query_bt_info(btcoexist);
+				num_of_bt_counter_chk = 0;
+			}
+		}
+	}
+
+}
+
+
+
+void halbtc8821c1ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+#if 1
+	s32	wifi_rssi = 0;
+	boolean wifi_busy = false, wifi_under_b_mode = false,
+		wifi_scan = false;
+	boolean	bt_idle = false, wl_idle = false;
+	static u8 cck_lock_counter = 0, wl_noisy_count0 = 0,
+		  wl_noisy_count1 = 3, wl_noisy_count2 = 0;
+	u32	total_cnt, reg_val1, reg_val2, cck_cnt;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+			   &wifi_under_b_mode);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+
+	coex_sta->crc_ok_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			       PHYDM_INFO_CRC32_OK_CCK);
+	coex_sta->crc_ok_11g = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			       PHYDM_INFO_CRC32_OK_LEGACY);
+	coex_sta->crc_ok_11n = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			       PHYDM_INFO_CRC32_OK_HT);
+	coex_sta->crc_ok_11n_vht = btcoexist->btc_phydm_query_PHY_counter(
+					   btcoexist, PHYDM_INFO_CRC32_OK_VHT);
+
+	coex_sta->crc_err_cck = btcoexist->btc_phydm_query_PHY_counter(
+					btcoexist, PHYDM_INFO_CRC32_ERROR_CCK);
+	coex_sta->crc_err_11g =  btcoexist->btc_phydm_query_PHY_counter(
+				 btcoexist, PHYDM_INFO_CRC32_ERROR_LEGACY);
+	coex_sta->crc_err_11n = btcoexist->btc_phydm_query_PHY_counter(
+					btcoexist, PHYDM_INFO_CRC32_ERROR_HT);
+	coex_sta->crc_err_11n_vht = btcoexist->btc_phydm_query_PHY_counter(
+				    btcoexist, PHYDM_INFO_CRC32_ERROR_VHT);
+
+	cck_cnt = coex_sta->crc_ok_cck + coex_sta->crc_err_cck;
+
+		if (cck_cnt > 250) {
+			if (wl_noisy_count2 < 3)
+				wl_noisy_count2++;
+
+			if (wl_noisy_count2 == 3) {
+				wl_noisy_count0 = 0;
+				wl_noisy_count1 = 0;
+			}
+
+		} else if (cck_cnt < 50) {
+			if (wl_noisy_count0 < 3)
+				wl_noisy_count0++;
+
+			if (wl_noisy_count0 == 3) {
+				wl_noisy_count1 = 0;
+				wl_noisy_count2 = 0;
+			}
+
+		} else {
+			if (wl_noisy_count1 < 3)
+				wl_noisy_count1++;
+
+			if (wl_noisy_count1 == 3) {
+				wl_noisy_count0 = 0;
+				wl_noisy_count2 = 0;
+			}
+	}
+
+		if (wl_noisy_count2 == 3)
+			coex_sta->wl_noisy_level = 2;
+		else if (wl_noisy_count1 == 3)
+			coex_sta->wl_noisy_level = 1;
+		else
+			coex_sta->wl_noisy_level = 0;
+
+	if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+		total_cnt = coex_sta->crc_ok_cck + coex_sta->crc_ok_11g +
+			    coex_sta->crc_ok_11n + coex_sta->crc_ok_11n_vht;
+
+		if ((coex_dm->bt_status == BT_8821C_1ANT_BT_STATUS_ACL_BUSY) ||
+		    (coex_dm->bt_status == BT_8821C_1ANT_BT_STATUS_ACL_SCO_BUSY)
+		    ||
+		    (coex_dm->bt_status == BT_8821C_1ANT_BT_STATUS_SCO_BUSY)) {
+			if (coex_sta->crc_ok_cck > (total_cnt -
+						    coex_sta->crc_ok_cck)) {
+				if (cck_lock_counter < 3)
+					cck_lock_counter++;
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+	} else {
+		if (cck_lock_counter > 0)
+			cck_lock_counter--;
+	}
+
+	if (!coex_sta->pre_ccklock) {
+
+		if (cck_lock_counter >= 3)
+			coex_sta->cck_lock = true;
+		else
+			coex_sta->cck_lock = false;
+	} else {
+		if (cck_lock_counter == 0)
+			coex_sta->cck_lock = false;
+		else
+			coex_sta->cck_lock = true;
+	}
+
+	if (coex_sta->cck_lock)
+		coex_sta->cck_ever_lock = true;
+
+	coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+#endif
+}
+
+void halbtc8821c1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	boolean		bt_busy = false;
+
+
+	coex_sta->num_of_profile = 0;
+
+	/* set link exist status */
+	if (!(coex_sta->bt_info & BT_INFO_8821C_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (coex_sta->bt_info & BT_INFO_8821C_1ANT_B_FTP) {
+			coex_sta->pan_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->pan_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8821C_1ANT_B_A2DP) {
+			coex_sta->a2dp_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->a2dp_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8821C_1ANT_B_HID) {
+			coex_sta->hid_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->hid_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8821C_1ANT_B_SCO_ESCO) {
+			coex_sta->sco_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->sco_exist = false;
+
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+	bt_link_info->acl_busy = coex_sta->acl_busy;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+
+	if (coex_sta->bt_info & BT_INFO_8821C_1ANT_B_INQ_PAGE) {
+		coex_dm->bt_status = BT_8821C_1ANT_BT_STATUS_INQ_PAGE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Inq/page!!!\n");
+	} else if (!(coex_sta->bt_info & BT_INFO_8821C_1ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8821C_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+	} else if (coex_sta->bt_info == BT_INFO_8821C_1ANT_B_CONNECTION) {
+		/* connection exists but no busy */
+		coex_dm->bt_status = BT_8821C_1ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+	} else if (((coex_sta->bt_info & BT_INFO_8821C_1ANT_B_SCO_ESCO) ||
+		    (coex_sta->bt_info & BT_INFO_8821C_1ANT_B_SCO_BUSY)) &&
+		   (coex_sta->bt_info & BT_INFO_8821C_1ANT_B_ACL_BUSY)) {
+		coex_dm->bt_status = BT_8821C_1ANT_BT_STATUS_ACL_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL SCO busy!!!\n");
+	} else if ((coex_sta->bt_info & BT_INFO_8821C_1ANT_B_SCO_ESCO) ||
+		   (coex_sta->bt_info & BT_INFO_8821C_1ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8821C_1ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+	} else if (coex_sta->bt_info & BT_INFO_8821C_1ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8821C_1ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+	} else {
+		coex_dm->bt_status = BT_8821C_1ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+	}
+
+	BTC_TRACE(trace_buf);
+
+	if ((BT_8821C_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8821C_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8821C_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+}
+
+void halbtc8821c1ant_update_wifi_channel_info(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] =
+			0x1;  /* enable BT AFH skip WL channel for 8821c because BT Rx LO interference */
+		/* h2c_parameter[0] = 0x0; */
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+
+}
+
+u8 halbtc8821c1ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8821C_1ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Profile = SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8821C_1ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821C_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821C_1ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_1ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_1ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821C_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821C_1ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821C_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821C_1ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_1ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_1ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821C_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821C_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_1ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! BT Profile = SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8821c1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8821c1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8821c1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+
+void halbtc8821c1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+
+#if 1
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra ==
+		    coex_dm->cur_low_penalty_ra)
+			return;
+	}
+
+	if (low_penalty_ra)
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 15);
+	else
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 0);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+
+#endif
+
+}
+
+void halbtc8821c1ant_write_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16				bitpos,
+	IN	boolean		state
+)
+{
+
+	static u16 originalval = 0x8002, preval = 0x0;
+
+	if (state)
+		originalval = originalval | bitpos;
+	else
+		originalval = originalval & (~bitpos);
+
+	if (originalval != preval) {
+
+		preval = originalval;
+		btcoexist->btc_write_2byte(btcoexist, 0xaa, originalval);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], halbtc8821c1ant_write_score_board: return for nochange\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void halbtc8821c1ant_read_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN   u16				*score_board_val
+)
+{
+
+	*score_board_val = (btcoexist->btc_read_2byte(btcoexist,
+			    0xaa)) & 0x7fff;
+}
+
+void halbtc8821c1ant_post_state_to_bt(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16						type,
+	IN  boolean                 state
+)
+{
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], halbtc8821c1ant_post_state_to_bt: type = %d, state =%d\n",
+		type, state);
+	BTC_TRACE(trace_buf);
+
+	halbtc8821c1ant_write_score_board(btcoexist, (u16) type, state);
+}
+
+boolean halbtc8821c1ant_is_wifibt_status_changed(IN struct btc_coexist
+		*btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false, pre_bt_off = false,
+			pre_bt_slave = false;
+	static u8 pre_hid_busy_num = 0, pre_wl_noisy_level = 0;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (coex_sta->bt_disabled != pre_bt_off) {
+		pre_bt_off = coex_sta->bt_disabled;
+
+		if (coex_sta->bt_disabled)
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+		else
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is enabled !!\n");
+
+		BTC_TRACE(trace_buf);
+
+		coex_sta->bt_coex_supported_feature = 0;
+		coex_sta->bt_coex_supported_version = 0;
+		coex_sta->bt_ble_scan_type = 0;
+		coex_sta->bt_ble_scan_para[0] = 0;
+		coex_sta->bt_ble_scan_para[1] = 0;
+		coex_sta->bt_ble_scan_para[2] = 0;
+		coex_sta->bt_reg_vendor_ac = 0xffff;
+		coex_sta->bt_reg_vendor_ae = 0xffff;
+		return true;
+	}
+
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+
+			if (wifi_busy)
+				halbtc8821c1ant_post_state_to_bt(btcoexist,
+						BT_8821C_1ANT_SCOREBOARD_UNDERTEST, true);
+			else
+				halbtc8821c1ant_post_state_to_bt(btcoexist,
+						BT_8821C_1ANT_SCOREBOARD_UNDERTEST, false);
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+		if (coex_sta->wl_noisy_level != pre_wl_noisy_level) {
+			pre_wl_noisy_level = coex_sta->wl_noisy_level;
+			return true;
+		}
+	}
+
+	if (!coex_sta->bt_disabled) {
+		if (coex_sta->hid_busy_num != pre_hid_busy_num) {
+			pre_hid_busy_num = coex_sta->hid_busy_num;
+			return true;
+		}
+	}
+
+	if (bt_link_info->slave_role != pre_bt_slave) {
+		pre_bt_slave = bt_link_info->slave_role;
+		return true;
+	}
+
+	return false;
+}
+
+
+void halbtc8821c1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean		bt_active = true, bt_disabled = false, wifi_under_5g = false;
+	u16			u16tmp;
+
+	/* This function check if bt is disabled */
+#if 0
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+
+
+#else
+
+	/* Read BT on/off status from scoreboard[1], enable this only if BT patch support this feature */
+	halbtc8821c1ant_read_score_board(btcoexist,	&u16tmp);
+
+	bt_active = u16tmp & BIT(1);
+
+
+#endif
+
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	} else {
+
+		bt_disable_cnt++;
+		if (bt_disable_cnt >= 10) {
+			bt_disabled = true;
+			bt_disable_cnt = 10;
+		}
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if ((wifi_under_5g) || (bt_disabled))
+		halbtc8821c1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, false);
+	else
+		halbtc8821c1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, true);
+
+
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+	}
+
+}
+
+void halbtc8821c1ant_enable_gnt_to_gpio(IN struct btc_coexist *btcoexist,
+					boolean isenable)
+{
+#if BT_8821C_1ANT_COEX_DBG
+	static u8			bitVal[5] = {0, 0, 0, 0, 0};
+	static boolean		state = false;
+	/*
+		if (state ==isenable)
+			return;
+		else
+			state = isenable;
+	*/
+	if (isenable) {
+
+		/* enable GNT_WL, GNT_BT to GPIO for debug */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x1);
+
+		/* store original value */
+		bitVal[0] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x66) & BIT(4)) >> 4;	/*0x66[4] */
+		bitVal[1] = (btcoexist->btc_read_1byte(btcoexist,
+					       0x67) & BIT(0));		/*0x66[8] */
+		bitVal[2] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x42) & BIT(3)) >> 3;  /*0x40[19] */
+		bitVal[3] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x65) & BIT(7)) >> 7;  /*0x64[15] */
+		bitVal[4] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x72) & BIT(2)) >> 2;  /*0x70[18] */
+
+		/*  switch GPIO Mux */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x66, BIT(4),
+						   0x0);  /*0x66[4] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, BIT(0),
+						   0x0);  /*0x66[8] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x42, BIT(3),
+						   0x0);  /*0x40[19] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x65, BIT(7),
+						   0x0);  /*0x64[15] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x72, BIT(2),
+						   0x0);  /*0x70[18] = 0 */
+
+
+	} else {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x0);
+
+		/*  Restore original value */
+		/*  switch GPIO Mux */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x66, BIT(4),
+						   bitVal[0]);  /*0x66[4] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, BIT(0),
+						   bitVal[1]);  /*0x66[8] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x42, BIT(3),
+					   bitVal[2]);  /*0x40[19] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x65, BIT(7),
+					   bitVal[3]);  /*0x64[15] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x72, BIT(2),
+					   bitVal[4]);  /*0x70[18] = 0 */
+	}
+
+#endif
+}
+
+u32 halbtc8821c1ant_ltecoex_indirect_read_reg(IN struct btc_coexist *btcoexist,
+		IN u16 reg_addr)
+{
+	u32 j = 0;
+
+
+	/* wait for ready bit before access 0x1700		 */
+	btcoexist->btc_write_4byte(btcoexist, 0x1700, 0x800F0000 | reg_addr);
+
+	do {
+		j++;
+	} while (((btcoexist->btc_read_1byte(btcoexist,
+					     0x1703)&BIT(5)) == 0) &&
+		 (j < BT_8821C_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+
+	return btcoexist->btc_read_4byte(btcoexist,
+					 0x1708);  /* get read data */
+
+}
+
+void halbtc8821c1ant_ltecoex_indirect_write_reg(IN struct btc_coexist
+		*btcoexist,
+		IN u16 reg_addr, IN u32 bit_mask, IN u32 reg_value)
+{
+	u32 val, i = 0, j = 0, bitpos = 0;
+
+
+	if (bit_mask == 0x0)
+		return;
+	if (bit_mask == 0xffffffff) {
+		btcoexist->btc_write_4byte(btcoexist, 0x1704,
+					   reg_value); /* put write data */
+
+		/* wait for ready bit before access 0x1700 */
+		do {
+			j++;
+		} while (((btcoexist->btc_read_1byte(btcoexist,
+						     0x1703)&BIT(5)) == 0) &&
+			(j < BT_8821C_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+
+
+		btcoexist->btc_write_4byte(btcoexist, 0x1700,
+					   0xc00F0000 | reg_addr);
+	} else {
+		for (i = 0; i <= 31; i++) {
+			if (((bit_mask >> i) & 0x1) == 0x1) {
+				bitpos = i;
+				break;
+			}
+		}
+
+		/* read back register value before write */
+		val = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist,
+				reg_addr);
+		val = (val & (~bit_mask)) | (reg_value << bitpos);
+
+		btcoexist->btc_write_4byte(btcoexist, 0x1704,
+					   val); /* put write data */
+
+		/* wait for ready bit before access 0x1700		 */
+		do {
+			j++;
+		} while (((btcoexist->btc_read_1byte(btcoexist,
+						     0x1703)&BIT(5)) == 0) &&
+			(j < BT_8821C_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+
+
+		btcoexist->btc_write_4byte(btcoexist, 0x1700,
+					   0xc00F0000 | reg_addr);
+
+	}
+
+}
+
+void halbtc8821c1ant_ltecoex_enable(IN struct btc_coexist *btcoexist,
+				    IN boolean enable)
+{
+	u8 val;
+
+	val = (enable) ? 1 : 0;
+	halbtc8821c1ant_ltecoex_indirect_write_reg(btcoexist, 0x38, 0x80,
+			val);  /* 0x38[7] */
+
+}
+
+void halbtc8821c1ant_ltecoex_pathcontrol_owner(IN struct btc_coexist *btcoexist,
+		IN boolean wifi_control)
+{
+	u8 val;
+
+	val = (wifi_control) ? 1 : 0;
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x4,
+					   val); /* 0x70[26] */
+
+}
+
+void halbtc8821c1ant_ltecoex_set_gnt_bt(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, val_orig = 0;
+
+	if (!sw_control)
+		val = 0x0;
+	else if (state & 0x1)
+		val = 0x3;
+	else
+		val = 0x1;
+
+	val_orig = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist,
+			0x38);
+
+	switch (control_block) {
+	case BT_8821C_1ANT_GNT_BLOCK_RFC_BB:
+	default:
+		val = ((val << 14) | (val << 10)) | (val_orig & 0xffff33ff);
+		break;
+	case BT_8821C_1ANT_GNT_BLOCK_RFC:
+		val = (val << 14) | (val_orig & 0xffff3fff);
+		break;
+	case BT_8821C_1ANT_GNT_BLOCK_BB:
+		val = (val << 10) | (val_orig & 0xfffff3ff);
+		break;
+	}
+
+	halbtc8821c1ant_ltecoex_indirect_write_reg(btcoexist,
+			0x38, 0xffffffff, val);
+}
+
+void halbtc8821c1ant_ltecoex_set_gnt_wl(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, val_orig = 0;
+
+	if (!sw_control)
+		val = 0x0;
+	else if (state & 0x1)
+		val = 0x3;
+	else
+		val = 0x1;
+
+	val_orig = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist,
+			0x38);
+
+	switch (control_block) {
+	case BT_8821C_1ANT_GNT_BLOCK_RFC_BB:
+	default:
+		val = ((val << 12) | (val << 8)) | (val_orig & 0xffffccff);
+		break;
+	case BT_8821C_1ANT_GNT_BLOCK_RFC:
+		val = (val << 12) | (val_orig & 0xffffcfff);
+		break;
+	case BT_8821C_1ANT_GNT_BLOCK_BB:
+		val = (val << 8) | (val_orig & 0xfffffcff);
+		break;
+	}
+
+	halbtc8821c1ant_ltecoex_indirect_write_reg(btcoexist,
+			0x38, 0xffffffff, val);
+}
+
+void halbtc8821c1ant_ltecoex_set_coex_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u16 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8821C_1ANT_CTT_WL_VS_LTE:
+		reg_addr = 0xa0;
+		break;
+	case BT_8821C_1ANT_CTT_BT_VS_LTE:
+		reg_addr = 0xa4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8821c1ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xffff, table_content); /* 0xa0[15:0] or 0xa4[15:0] */
+
+
+}
+
+
+void halbtc8821c1ant_ltecoex_set_break_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u8 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8821C_1ANT_LBTT_WL_BREAK_LTE:
+		reg_addr = 0xa8;
+		break;
+	case BT_8821C_1ANT_LBTT_BT_BREAK_LTE:
+		reg_addr = 0xac;
+		break;
+	case BT_8821C_1ANT_LBTT_LTE_BREAK_WL:
+		reg_addr = 0xb0;
+		break;
+	case BT_8821C_1ANT_LBTT_LTE_BREAK_BT:
+		reg_addr = 0xb4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8821c1ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xff, table_content); /* 0xa8[15:0] or 0xb4[15:0] */
+
+
+}
+
+void halbtc8821c1ant_set_wltoggle_coex_table(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec,  IN u8 interval,
+		IN u8 val0x6c4_b0, IN u8 val0x6c4_b1, IN u8 val0x6c4_b2,
+		IN u8 val0x6c4_b3)
+{
+	static u8 pre_h2c_parameter[6] = {0};
+	u8	cur_h2c_parameter[6] = {0};
+	u8 i, match_cnt = 0;
+
+	cur_h2c_parameter[0] = 0x7;	/* op_code, 0x7= wlan toggle slot*/
+
+	cur_h2c_parameter[1] = interval;
+	cur_h2c_parameter[2] = val0x6c4_b0;
+	cur_h2c_parameter[3] = val0x6c4_b1;
+	cur_h2c_parameter[4] = val0x6c4_b2;
+	cur_h2c_parameter[5] = val0x6c4_b3;
+
+	if (!force_exec) {
+		for (i = 1; i <= 5; i++) {
+			if (cur_h2c_parameter[i] != pre_h2c_parameter[i])
+				break;
+
+			match_cnt++;
+		}
+
+		if (match_cnt == 5)
+			return;
+	}
+
+	for (i = 1; i <= 5; i++)
+		pre_h2c_parameter[i] = cur_h2c_parameter[i];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, cur_h2c_parameter);
+}
+
+
+void halbtc8821c1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8821c1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+
+	halbtc8821c1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8821c1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	u32	break_table;
+	u8	select_table;
+
+	coex_sta->coex_table_type = type;
+
+	if (coex_sta->concurrent_rx_mode_on == true) {
+		break_table = 0xf0ffffff;  /* set WL hi-pri can break BT */
+		select_table =
+			0xb;		/* set Tx response = Hi-Pri (ex: Transmitting ACK,BA,CTS) */
+	} else {
+		break_table = 0xffffff;
+		select_table = 0x3;
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** Table-%d **********\n",
+		    coex_sta->coex_table_type);
+	BTC_TRACE(trace_buf);
+
+	switch (type) {
+	case 0:
+		halbtc8821c1ant_coex_table(btcoexist, force_exec,
+					   0x55555555, 0x55555555, break_table,
+					   select_table);
+		break;
+	case 1:
+		halbtc8821c1ant_coex_table(btcoexist, force_exec,
+					   0x55555555, 0x5a5a5a5a, break_table,
+					   select_table);
+		break;
+	case 2:
+		halbtc8821c1ant_coex_table(btcoexist, force_exec,
+					   0xaa5a5a5a, 0xaa5a5a5a, break_table,
+					   select_table);
+		break;
+	case 3:
+		halbtc8821c1ant_coex_table(btcoexist, force_exec,
+					   0x55555555, 0x5a5a5a5a, break_table,
+					   select_table);
+		break;
+	case 4:
+		halbtc8821c1ant_coex_table(btcoexist, force_exec,
+					   0xa5555555, 0x5a5a5a5a, break_table,
+					   select_table);
+		break;
+	case 5:
+		halbtc8821c1ant_coex_table(btcoexist, force_exec,
+					   0x5a5a5a5a, 0x5a5a5a5a, break_table,
+					   select_table);
+		break;
+	case 6:
+		halbtc8821c1ant_coex_table(btcoexist, force_exec,
+					   0xa5555555, 0x5a5a5a5a, break_table,
+					   select_table);
+		break;
+	case 7:
+		halbtc8821c1ant_coex_table(btcoexist, force_exec,
+					   0xaaaaaaaa, 0xaaaaaaaa, break_table,
+					   select_table);
+		break;
+	case 8:
+		halbtc8821c1ant_coex_table(btcoexist, force_exec,
+					   0xa5555555, 0xaaaa5aaa, break_table,
+					   select_table);
+		break;
+	case 9:
+		halbtc8821c1ant_coex_table(btcoexist, force_exec,
+					   0x5a5a5a5a, 0xaaaa5aaa, break_table,
+					   select_table);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8821c1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable)
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8821c1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8821c1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8821c1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8821c1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8821c1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8821c1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0x8, 0, 0, 0, 0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			/*halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			/*halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);*/
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8821c1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		coex_sta->force_lps_on = false;
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+
+		break;
+	case BTC_PS_LPS_ON:
+		coex_sta->force_lps_on = true;
+		halbtc8821c1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8821c1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+
+		break;
+	case BTC_PS_LPS_OFF:
+		coex_sta->force_lps_on = false;
+		halbtc8821c1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+
+		break;
+	default:
+		break;
+	}
+}
+
+
+void halbtc8821c1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	if (byte5 & BIT(2))
+		coex_sta->is_tdma_btautoslot = true;
+	else
+		coex_sta->is_tdma_btautoslot = false;
+
+	/* release bt-auto slot for auto-slot hang is detected!! */
+	if (coex_sta->is_tdma_btautoslot)
+		if ((coex_sta->is_tdma_btautoslot_hang) ||
+			(bt_link_info->slave_role))
+			byte5 = byte5 & 0xfb;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for 1Ant AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8821c1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0,
+							 0x0);
+		}
+	} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+
+		halbtc8821c1ant_power_save_state(
+			btcoexist, BTC_PS_LPS_ON, 0x50,
+			0x4);
+	} else {
+		halbtc8821c1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0,
+						 0x0);
+	}
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+
+void halbtc8821c1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	boolean			wifi_busy = false;
+	static u8			psTdmaByte4Modify = 0x0, pre_psTdmaByte4Modify = 0x0;
+	static boolean	 pre_wifi_busy = false;
+
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (wifi_busy != pre_wifi_busy) {
+		force_exec = true;
+		pre_wifi_busy = wifi_busy;
+	}
+
+	/* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+	if (bt_link_info->slave_role)
+		psTdmaByte4Modify = 0x1;
+	else
+		psTdmaByte4Modify = 0x0;
+
+	if (pre_psTdmaByte4Modify != psTdmaByte4Modify) {
+		force_exec = true;
+		pre_psTdmaByte4Modify = psTdmaByte4Modify;
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Skip TDMA because no change TDMA(%s, %d)\n",
+				    (coex_dm->cur_ps_tdma_on ? "on" : "off"),
+				    coex_dm->cur_ps_tdma);
+			BTC_TRACE(trace_buf);
+			return;
+		}
+	}
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+
+	if (turn_on) {
+		switch (type) {
+		default:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x35, 0x03, 0x11, 0x11);
+			break;
+
+		case 3:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x3a, 0x03, 0x10, 0x50);
+			break;
+		case 4:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x21, 0x03, 0x10, 0x50);
+			break;
+		case 5:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x15, 0x03, 0x11, 0x11);
+			break;
+		case 6:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x20, 0x03, 0x11, 0x11);
+			break;
+		case 7:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x10, 0x03, 0x10,  0x54 |
+						      psTdmaByte4Modify);
+			break;
+		case 8:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x10, 0x03, 0x10,  0x54 |
+						      psTdmaByte4Modify);
+			break;
+		case 9:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x55, 0x10, 0x03, 0x10,  0x54 |
+						      psTdmaByte4Modify);
+			break;
+		case 10:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x30, 0x03, 0x11, 0x10);
+			break;
+		case 11:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x65, 0x25, 0x03, 0x11,  0x11 |
+						      psTdmaByte4Modify);
+			break;
+		case 12:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x55, 0x30, 0x03, 0x10,  0x50 |
+						      psTdmaByte4Modify);
+			break;
+		case 13:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x25, 0x03, 0x10,  0x50 |
+						      psTdmaByte4Modify);
+			break;
+		case 14:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x15, 0x03, 0x10,  0x50 |
+						      psTdmaByte4Modify);
+			break;
+		case 15:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x20, 0x03, 0x10,  0x50 |
+						      psTdmaByte4Modify);
+			break;
+		case 16:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x10, 0x03, 0x11,  0x15 |
+						      psTdmaByte4Modify);
+			break;
+		case 17:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x10, 0x03, 0x11, 0x14 |
+							psTdmaByte4Modify);
+			break;
+		case 18:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x30, 0x03, 0x10,  0x50 |
+						      psTdmaByte4Modify);
+			break;
+		case 19:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x15, 0x03, 0x11, 0x10);
+			break;
+		case 20:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x30, 0x03, 0x11, 0x10);
+			break;
+		case 21:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x30, 0x03, 0x11, 0x10);
+			break;
+		case 22:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x25, 0x03, 0x11, 0x10);
+			break;
+		case 23:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x10, 0x03, 0x11, 0x10);
+			break;
+		case 27:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x10, 0x03, 0x11, 0x15);
+			break;
+		case 32:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x35, 0x03, 0x11, 0x11);
+			break;
+		case 33:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x35, 0x03, 0x11, 0x10);
+			break;
+		case 57:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x10, 0x03, 0x10,  0x50 |
+						      psTdmaByte4Modify);
+			break;
+		case 58:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x10, 0x03, 0x10,  0x50 |
+						      psTdmaByte4Modify);
+			break;
+		case 67:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x10, 0x03, 0x11,  0x10 |
+						      psTdmaByte4Modify);
+			break;
+
+		/*     1-Ant to 2-Ant      TDMA case */
+		case 103:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xd3, 0x3a, 0x03, 0x70, 0x10);
+			break;
+		case 104:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xd3, 0x21, 0x03, 0x70, 0x10);
+			break;
+		case 105:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xe3, 0x15, 0x03, 0x71, 0x11);
+			break;
+		case 106:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xe3, 0x20, 0x03, 0x71, 0x11);
+			break;
+		case 107:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xd3, 0x10, 0x03, 0x70,  0x14 |
+						      psTdmaByte4Modify);
+			break;
+		case 108:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xd3, 0x10, 0x03, 0x70,  0x14 |
+						      psTdmaByte4Modify);
+			break;
+		case 113:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xd3, 0x25, 0x03, 0x70,  0x10 |
+						      psTdmaByte4Modify);
+			break;
+		case 114:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xd3, 0x15, 0x03, 0x70,  0x10 |
+						      psTdmaByte4Modify);
+			break;
+		case 115:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xd3, 0x20, 0x03, 0x70,  0x10 |
+						      psTdmaByte4Modify);
+			break;
+		case 117:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xe3, 0x10, 0x03, 0x71,  0x14 |
+						      psTdmaByte4Modify);
+			break;
+		case 119:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xe3, 0x15, 0x03, 0x71, 0x10);
+			break;
+		case 120:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xe3, 0x30, 0x03, 0x71, 0x10);
+			break;
+		case 121:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xe3, 0x30, 0x03, 0x71, 0x10);
+			break;
+		case 122:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xe3, 0x25, 0x03, 0x71, 0x10);
+			break;
+		case 132:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xe3, 0x35, 0x03, 0x71, 0x11);
+			break;
+		case 133:
+			halbtc8821c1ant_set_fw_pstdma(btcoexist,
+					      0xe3, 0x35, 0x03, 0x71, 0x10);
+			break;
+
+		}
+	} else {
+
+		/* disable PS tdma */
+		switch (type) {
+		case 8: /* PTA Control */
+			halbtc8821c1ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 0:
+		default:  /* Software control, Antenna at BT side */
+			halbtc8821c1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 1: /* 2-Ant, 0x778=3, antenna control by antenna diversity */
+			halbtc8821c1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x48, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8821c1ant_set_int_block(IN struct btc_coexist *btcoexist,
+				   IN boolean force_exec,  IN u8 pos_type)
+{
+#if 0
+	u8		regval_0xcba;
+	u32		u32tmp1 = 0;
+
+	coex_dm->cur_int_block_status = pos_type;
+
+	if (!force_exec) {
+		if (coex_dm->pre_int_block_status ==
+		    coex_dm->cur_int_block_status)
+			return;
+	}
+
+	coex_dm->pre_int_block_status = coex_dm->cur_int_block_status;
+
+	regval_0xcba =  btcoexist->btc_read_1byte(btcoexist, 0xcba);
+
+	switch (pos_type) {
+
+	case BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLG_OF_BTG:
+		regval_0xcba = (regval_0xcba | BIT(0)) & (~(BIT(
+			2)));				/* 0xcb8[16] = 1, 0xcb8[18] = 0, WL_G select BTG */
+		regval_0xcba =   regval_0xcba & 0x0f;
+
+		/*btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc1d, 0x0f, 0x5); */ /* Gain Table */
+		/*btcoexist->btc_write_1byte_bitmask(btcoexist, 0xa9e, 0x0f, 0x2); */ /* CCK Gain Table */
+
+		break;
+	case BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLG_OF_WLAG:
+		regval_0xcba =   regval_0xcba & (~(BIT(2) | BIT(
+			0)));			/* 0xcb8[16] = 0, 0xcb8[18] = 0, WL_G select WLAG */
+
+		/* regval_0xcba =   regval_0xcba | BIT(4) | BIT(5) ; */			/* 0xcb8[21:20] = 2b'11, WL_G @ WLAG on */
+		/* regval_0xcba =    (regval_0xcba | BIT(6)) & (~(BIT(7)) ) ; */		/* 0xcb8[23:22] = 2b'01, WL_A @ WLAG off */
+		/*btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc1d, 0x0f, 0x0); */ /* Gain Table */
+		/*btcoexist->btc_write_1byte_bitmask(btcoexist, 0xa9e, 0x0f, 0x6); */ /* CCK Gain Table */
+
+		break;
+	case BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLA_OF_WLAG:
+		regval_0xcba =   regval_0xcba & (~(BIT(2) | BIT(
+			0)));			/* 0xcb8[16] = 0, 0xcb8[18] = 0, WL_G select WLAG */
+		/*regval_0xcba = (regval_0xcba | BIT(4)) & (~(BIT(5))); */			/* 0xcb8[21:20] = 2b'01, WL_G @ WLAG off */
+		/*regval_0xcba = regval_0xcba | BIT(6) | BIT(7); */				/* 0xcb8[23:22] = 2b'11, WL_A @ WLAG on */
+
+		break;
+	}
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcba, 0xff,
+					   regval_0xcba);
+
+	u32tmp1 = btcoexist->btc_read_4byte(btcoexist, 0xcb8);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (After Int Block setup) 0xcb8 = 0x%08x **********\n",
+		    u32tmp1);
+	BTC_TRACE(trace_buf);
+
+#endif
+}
+
+void halbtc8821c1ant_set_ext_band_switch(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 pos_type)
+{
+
+#if 0
+	boolean	switch_polatiry_inverse = false;
+	u8		regval_0xcb6;
+	u32		u32tmp1 = 0, u32tmp2 = 0;
+
+	if (!rfe_type->ext_band_switch_exist)
+		return;
+
+	coex_dm->cur_ext_band_switch_status = pos_type;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ext_band_switch_status ==
+		    coex_dm->cur_ext_band_switch_status)
+			return;
+	}
+
+	coex_dm->pre_ext_band_switch_status =
+		coex_dm->cur_ext_band_switch_status;
+
+	/* swap control polarity if use different switch control polarity*/
+	switch_polatiry_inverse = (rfe_type->ext_band_switch_ctrl_polarity == 1
+		   ? ~switch_polatiry_inverse : switch_polatiry_inverse);
+
+	/*swap control polarity for WL_A, default polarity 0xcb4[21] = 0 && 0xcb4[23] = 1 is for WL_G */
+	switch_polatiry_inverse = (pos_type ==
+		BT_8821C_1ANT_EXT_BAND_SWITCH_TO_WLA ? ~switch_polatiry_inverse
+				   : switch_polatiry_inverse);
+
+	regval_0xcb6 =  btcoexist->btc_read_1byte(btcoexist, 0xcb6);
+
+	/* for normal switch polrity, 0xcb4[21] =1 && 0xcb4[23] = 0 for WL_A, vice versa */
+	regval_0xcb6 = (switch_polatiry_inverse == 1 ? ((regval_0xcb6 & (~(BIT(
+		7)))) | BIT(5)) : ((regval_0xcb6 & (~(BIT(5)))) | BIT(7)));
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb6, 0xff,
+					   regval_0xcb6);
+
+	u32tmp1 = btcoexist->btc_read_4byte(btcoexist, 0xcb0);
+	u32tmp2 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (After Ext Band switch setup) 0xcb0 = 0x%08x, 0xcb4 = 0x%08x**********\n",
+		    u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+#endif
+
+}
+
+void halbtc8821c1ant_set_ext_ant_switch(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u8 ctrl_type, IN u8 pos_type)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	boolean	switch_polatiry_inverse = false;
+	u8		regval_0xcb7 = 0, regval_0x64;
+	u32		u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+
+	if (!rfe_type->ext_ant_switch_exist)
+		return;
+
+	coex_dm->cur_ext_ant_switch_status = (ctrl_type << 8)  + pos_type;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ext_ant_switch_status ==
+		    coex_dm->cur_ext_ant_switch_status)
+			return;
+	}
+
+	coex_dm->pre_ext_ant_switch_status = coex_dm->cur_ext_ant_switch_status;
+
+	/* swap control polarity if use different switch control polarity*/
+	/*  Normal switch polarity for DPDT, 0xcb4[29:28] = 2b'01 => BTG to Main, WLG to Aux,  0xcb4[29:28] = 2b'10 => BTG to Aux, WLG to Main */
+	/*  Normal switch polarity for SPDT, 0xcb4[29:28] = 2b'01 => Ant to BTG,  0xcb4[29:28] = 2b'10 => Ant to WLG */
+	if (rfe_type->ext_ant_switch_ctrl_polarity)
+		switch_polatiry_inverse =  ~switch_polatiry_inverse;
+
+	/* swap control polarity if 1-Ant at Aux */
+	if (rfe_type->ant_at_main_port == false)
+		switch_polatiry_inverse =  ~switch_polatiry_inverse;
+
+	switch (pos_type) {
+	default:
+	case BT_8821C_1ANT_EXT_ANT_SWITCH_TO_BT:
+	case BT_8821C_1ANT_EXT_ANT_SWITCH_TO_NOCARE:
+	case BT_8821C_1ANT_EXT_ANT_SWITCH_TO_WLA:
+
+		break;
+	case BT_8821C_1ANT_EXT_ANT_SWITCH_TO_WLG:
+		if (!rfe_type->wlg_Locate_at_btg)
+			switch_polatiry_inverse =  ~switch_polatiry_inverse;
+		break;
+	}
+
+	if (board_info->ant_div_cfg)
+		ctrl_type = BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_ANTDIV;
+
+
+	switch (ctrl_type) {
+	default:
+	case BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /*  0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x1);  /* 0x4c[24] = 1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb4,
+			0xff, 0x77);	/* BB SW, DPDT use RFE_ctrl8 and RFE_ctrl9 as control pin */
+
+		regval_0xcb7 = (switch_polatiry_inverse == false ?
+			0x1 : 0x2);     /* 0xcb4[29:28] = 2b'01 for no switch_polatiry_inverse, DPDT_SEL_N =1, DPDT_SEL_P =0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb7,
+						   0x30, regval_0xcb7);
+
+		break;
+	case BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_PTA:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /* 0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x1);  /* 0x4c[24] = 1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb4,
+			0xff, 0x66);	/* PTA,  DPDT use RFE_ctrl8 and RFE_ctrl9 as control pin */
+
+		regval_0xcb7 = (switch_polatiry_inverse == false ?
+			0x2 : 0x1);     /* 0xcb4[29:28] = 2b'10 for no switch_polatiry_inverse, DPDT_SEL_N =1, DPDT_SEL_P =0  @ GNT_BT=1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb7,
+						   0x30, regval_0xcb7);
+
+		break;
+	case BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_ANTDIV:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /* 0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x1);  /* 0x4c[24] = 1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb4,
+						   0xff, 0x88);  /* */
+
+		/* no regval_0xcb7 setup required, because  antenna switch control value by antenna diversity */
+
+		break;
+	case BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_MAC:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x1);  /*  0x4c[23] = 1 */
+
+		regval_0x64 = (switch_polatiry_inverse == false ?  0x0 :
+			0x1);     /* 0x64[0] = 1b'0 for no switch_polatiry_inverse, DPDT_SEL_N =1, DPDT_SEL_P =0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x64, 0x1,
+						   regval_0x64);
+		break;
+	case BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_BT:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /* 0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x0);  /* 0x4c[24] = 0 */
+
+		/* no  setup required, because  antenna switch control value by BT vendor 0xac[1:0] */
+		break;
+	}
+
+	/* PAPE, LNA_ON control by BT  while WLAN off for current leakage issue */
+	if (ctrl_type == BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_BT) {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+					   0x0);  /* PAPE   0x64[29] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x10,
+					   0x0);  /* LNA_ON 0x64[28] = 0 */
+	} else {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+					   0x1);  /* PAPE   0x64[29] = 1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x10,
+					   0x1);  /* LNA_ON 0x64[28] = 1 */
+	}
+
+#if BT_8821C_1ANT_COEX_DBG
+	u32tmp1 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u32tmp2 = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0x64) & 0xff;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], (After Ext Ant switch setup) 0xcb4 = 0x%08x, 0x4c = 0x%08x, 0x64= 0x%02x\n",
+		    u32tmp1, u32tmp2, u32tmp3);
+	BTC_TRACE(trace_buf);
+#endif
+
+}
+
+void halbtc8821c1ant_set_rfe_type(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+
+
+	/* the following setup should be got from Efuse in the future */
+	rfe_type->rfe_module_type = board_info->rfe_type & 0x1f;
+
+	rfe_type->ext_ant_switch_ctrl_polarity = 0;
+
+	switch (rfe_type->rfe_module_type) {
+	case 0:
+	default:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_1ANT_EXT_ANT_SWITCH_USE_DPDT;          /*2-Ant, DPDT, WLG*/
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 1:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_1ANT_EXT_ANT_SWITCH_USE_SPDT;          /*1-Ant, Main, DPDT or SPDT, WLG */
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 2:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_1ANT_EXT_ANT_SWITCH_USE_SPDT;            /*1-Ant, Main, DPDT or SPDT, BTG */
+		rfe_type->wlg_Locate_at_btg = true;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 3:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_1ANT_EXT_ANT_SWITCH_USE_DPDT;          /*1-Ant, Aux, DPDT, WLG */
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = false;
+		break;
+	case 4:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_1ANT_EXT_ANT_SWITCH_USE_DPDT;          /*1-Ant, Aux, DPDT, BTG */
+		rfe_type->wlg_Locate_at_btg = true;
+		rfe_type->ant_at_main_port = false;
+		break;
+	case 5:
+		rfe_type->ext_ant_switch_exist = false;			    /*2-Ant, no antenna switch, WLG*/
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_1ANT_EXT_ANT_SWITCH_NONE;
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 6:
+		rfe_type->ext_ant_switch_exist = false;			   /*2-Ant, no antenna switch, WLG*/
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_1ANT_EXT_ANT_SWITCH_NONE;
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 7:
+		rfe_type->ext_ant_switch_exist = true;			 /*2-Ant, DPDT, BTG*/
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_1ANT_EXT_ANT_SWITCH_USE_DPDT;
+		rfe_type->wlg_Locate_at_btg = true;
+		rfe_type->ant_at_main_port = true;
+		break;
+	}
+
+#if 0
+	if (rfe_type->wlg_Locate_at_btg)
+		halbtc8821c1ant_set_int_block(btcoexist, FORCE_EXEC,
+			      BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLG_OF_BTG);
+	else
+		halbtc8821c1ant_set_int_block(btcoexist, FORCE_EXEC,
+			      BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLG_OF_WLAG);
+#endif
+
+}
+
+
+void halbtc8821c1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+				  IN u8 ant_pos_type, IN boolean force_exec,
+				  IN u8 phase)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u32			cnt_bt_cal_chk = 0;
+	boolean			is_in_mp_mode = false;
+	u8			u8tmp = 0;
+	u32			u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+	u16			u16tmp1 = 0;
+
+
+	u32tmp1 = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist,
+			0x38);
+
+	/* To avoid indirect access fail  */
+	if (((u32tmp1 & 0xf000) >> 12) != ((u32tmp1 & 0x0f00) >> 8)) {
+		force_exec = true;
+		coex_sta->gnt_error_cnt++;
+	}
+
+
+#if BT_8821C_1ANT_COEX_DBG
+
+	u32tmp2 = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist,
+			0x54);
+	u8tmp  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex],(Before Ant Setup) 0xcb4 = 0x%x, 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x\n",
+		    u32tmp3, u8tmp, u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+#endif
+
+	coex_dm->cur_ant_pos_type = (ant_pos_type << 8)  + phase;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex],(Before Ant Setup) pre_ant_pos_type = 0x%x, cur_ant_pos_type = 0x%x\n",
+		    coex_dm->pre_ant_pos_type,
+		    coex_dm->cur_ant_pos_type);
+	BTC_TRACE(trace_buf);
+
+
+	if (!force_exec) {
+		if (coex_dm->cur_ant_pos_type == coex_dm->pre_ant_pos_type)
+			return;
+	}
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+
+
+	switch (phase) {
+	case BT_8821C_1ANT_PHASE_COEX_POWERON:
+
+		/* set Path control owner to WL at initial step */
+		halbtc8821c1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8821C_1ANT_PCO_BTSIDE);
+
+		/* set GNT_BT to SW high */
+		halbtc8821c1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_1ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW high */
+		halbtc8821c1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_1ANT_SIG_STA_SET_TO_HIGH);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		coex_sta->run_time_state = false;
+
+		break;
+	case BT_8821C_1ANT_PHASE_COEX_INIT:
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8821c1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8821c1ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8821C_1ANT_CTT_WL_VS_LTE,
+			0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8821c1ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8821C_1ANT_CTT_BT_VS_LTE,
+			0xffff);
+
+		/* Wait If BT IQK running, because Path control owner is at BT during BT IQK (setup by WiFi firmware) */
+		while (cnt_bt_cal_chk <= 20) {
+			u8tmp = btcoexist->btc_read_1byte(
+					btcoexist,
+					0x49c);
+			cnt_bt_cal_chk++;
+			if (u8tmp & BIT(1)) {
+				BTC_SPRINTF(
+					trace_buf,
+					BT_TMP_BUF_SIZE,
+					"[BTCoex], ########### BT is calibrating (wait cnt=%d) ###########\n",
+					cnt_bt_cal_chk);
+				BTC_TRACE(
+					trace_buf);
+				delay_ms(50);
+			} else {
+				BTC_SPRINTF(
+					trace_buf,
+					BT_TMP_BUF_SIZE,
+					"[BTCoex], ********** BT is NOT calibrating (wait cnt=%d)**********\n",
+					cnt_bt_cal_chk);
+				BTC_TRACE(
+					trace_buf);
+				break;
+			}
+		}
+
+		/* set Path control owner to WL at initial step */
+		halbtc8821c1ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8821C_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW high */
+		halbtc8821c1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_1ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW low */
+		halbtc8821c1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_1ANT_SIG_STA_SET_TO_LOW);
+
+		coex_sta->run_time_state = false;
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		break;
+	case BT_8821C_1ANT_PHASE_WLANONLY_INIT:
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8821c1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8821c1ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8821C_1ANT_CTT_WL_VS_LTE,
+			0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8821c1ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8821C_1ANT_CTT_BT_VS_LTE,
+			0xffff);
+
+		/* set Path control owner to WL at initial step */
+		halbtc8821c1ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8821C_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW Low */
+		halbtc8821c1ant_ltecoex_set_gnt_bt(btcoexist,
+						BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+						BT_8821C_1ANT_GNT_TYPE_CTRL_BY_SW,
+						BT_8821C_1ANT_SIG_STA_SET_TO_LOW);
+		/* Set GNT_WL to SW high */
+		halbtc8821c1ant_ltecoex_set_gnt_wl(btcoexist,
+						BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+						BT_8821C_1ANT_GNT_TYPE_CTRL_BY_SW,
+						BT_8821C_1ANT_SIG_STA_SET_TO_HIGH);
+
+		coex_sta->run_time_state = false;
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_WIFI;
+
+		break;
+	case BT_8821C_1ANT_PHASE_WLAN_OFF:
+		/* Disable LTE Coex Function in WiFi side */
+		halbtc8821c1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* set Path control owner to BT */
+		halbtc8821c1ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8821C_1ANT_PCO_BTSIDE);
+
+		/* Set Ext Ant Switch to BT control at wifi off step */
+		halbtc8821c1ant_set_ext_ant_switch(btcoexist,
+						FORCE_EXEC,
+						BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_BT,
+						BT_8821C_1ANT_EXT_ANT_SWITCH_TO_NOCARE);
+
+		coex_sta->run_time_state = false;
+		break;
+	case BT_8821C_1ANT_PHASE_2G_RUNTIME:
+
+		while (cnt_bt_cal_chk <= 20) {
+			/* 0x49c[0]=1 WL IQK, 0x49c[1]=1 BT IQK*/
+			u8tmp = btcoexist->btc_read_1byte(
+					btcoexist,
+					0x49c);
+
+			cnt_bt_cal_chk++;
+			if (u8tmp & BIT(0)) {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ########### WL is IQK (wait cnt=%d)\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				delay_ms(50);
+			} else if (u8tmp & BIT(1)) {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ########### BT is IQK (wait cnt=%d)\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				delay_ms(50);
+			} else {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ********** WL and BT is NOT IQK (wait cnt=%d)\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				break;
+			}
+		}
+
+		/* set Path control owner to WL at runtime step */
+		halbtc8821c1ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8821C_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to PTA */
+		halbtc8821c1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_1ANT_GNT_TYPE_CTRL_BY_PTA,
+					   BT_8821C_1ANT_SIG_STA_SET_BY_HW);
+
+		halbtc8821c1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_1ANT_GNT_TYPE_CTRL_BY_PTA,
+					   BT_8821C_1ANT_SIG_STA_SET_BY_HW);
+
+		coex_sta->run_time_state = true;
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type) {
+			if (rfe_type->wlg_Locate_at_btg)
+				ant_pos_type =
+					BTC_ANT_PATH_WIFI;
+			else
+				ant_pos_type = BTC_ANT_PATH_PTA;
+		}
+
+		if (rfe_type->wlg_Locate_at_btg)
+			halbtc8821c1ant_set_int_block(btcoexist,
+						      NORMAL_EXEC,
+				BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLG_OF_BTG);
+		else
+			halbtc8821c1ant_set_int_block(btcoexist,
+						      NORMAL_EXEC,
+				BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLG_OF_WLAG);
+
+		break;
+	case BT_8821C_1ANT_PHASE_5G_RUNTIME:
+
+		/* set Path control owner to WL at runtime step */
+		halbtc8821c1ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8821C_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW Hi */
+		halbtc8821c1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_1ANT_GNT_TYPE_CTRL_BY_PTA,
+					   BT_8821C_1ANT_SIG_STA_SET_BY_HW);
+
+		/* Set GNT_WL to SW Hi */
+		halbtc8821c1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_1ANT_SIG_STA_SET_TO_HIGH);
+
+		coex_sta->run_time_state = true;
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type) {
+			/*	if (rfe_type->ext_band_switch_exist)
+					ant_pos_type =   BTC_ANT_PATH_PTA;
+				else */
+			ant_pos_type =
+				BTC_ANT_PATH_WIFI5G;
+		}
+
+		halbtc8821c1ant_set_int_block(btcoexist,
+					      NORMAL_EXEC,
+			      BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLA_OF_WLAG);
+
+		break;
+	case BT_8821C_1ANT_PHASE_BTMPMODE:
+		/* Disable LTE Coex Function in WiFi side */
+		halbtc8821c1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* set Path control owner to WL */
+		halbtc8821c1ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8821C_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW Hi */
+		halbtc8821c1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_1ANT_SIG_STA_SET_TO_HIGH);
+
+		/* Set GNT_WL to SW Lo */
+		halbtc8821c1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_1ANT_SIG_STA_SET_TO_LOW);
+
+		coex_sta->run_time_state = false;
+
+		/* Set Ext Ant Switch to BT side at BT MP mode */
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		break;
+	case BT_8821C_1ANT_PHASE_ANTENNA_DET:
+		halbtc8821c1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8821C_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to high */
+		halbtc8821c1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_1ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to high */
+		halbtc8821c1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8821C_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_1ANT_SIG_STA_SET_TO_HIGH);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		coex_sta->run_time_state = false;
+
+		break;
+	}
+
+	if (phase != BT_8821C_1ANT_PHASE_WLAN_OFF) {
+		switch (ant_pos_type) {
+		case BTC_ANT_PATH_WIFI:
+			halbtc8821c1ant_set_ext_ant_switch(
+				btcoexist,
+				force_exec,
+				BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW,
+				BT_8821C_1ANT_EXT_ANT_SWITCH_TO_WLG);
+			break;
+		case BTC_ANT_PATH_WIFI5G
+				:
+			halbtc8821c1ant_set_ext_ant_switch(
+				btcoexist,
+				force_exec,
+				BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW,
+				BT_8821C_1ANT_EXT_ANT_SWITCH_TO_WLA);
+			break;
+		case BTC_ANT_PATH_BT:
+			halbtc8821c1ant_set_ext_ant_switch(
+				btcoexist,
+				force_exec,
+				BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW,
+				BT_8821C_1ANT_EXT_ANT_SWITCH_TO_BT);
+			break;
+		default:
+		case BTC_ANT_PATH_PTA:
+			halbtc8821c1ant_set_ext_ant_switch(
+				btcoexist,
+				force_exec,
+				BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_PTA,
+				BT_8821C_1ANT_EXT_ANT_SWITCH_TO_NOCARE);
+			break;
+		}
+
+	}
+
+#if BT_8821C_1ANT_COEX_DBG
+	u32tmp1 = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u8tmp  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex],(After Ant-Setup phase---%d) 0xcb4 = 0x%x, 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x\n",
+		    phase, u32tmp3, u8tmp, u32tmp1, u32tmp2);
+
+	BTC_TRACE(trace_buf);
+#endif
+}
+
+
+boolean halbtc8821c1ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected &&
+	    BT_8821C_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8821C_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		common = true;
+	} else if (!wifi_connected &&
+		   (BT_8821C_1ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8821C_1ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		common = true;
+	} else if (!wifi_connected &&
+		   (BT_8821C_1ANT_BT_STATUS_CONNECTED_IDLE !=
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non connected-idle + BT Busy!!\n");
+		BTC_TRACE(trace_buf);
+
+		common = true;
+	} else {
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		common = false;
+	}
+
+	return common;
+}
+
+
+/* *********************************************
+ *
+ *	Software Coex Mechanism start
+ *
+ * ********************************************* */
+
+
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+void halbtc8821c1ant_action_bt_whql_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8821C_1ANT_PHASE_2G_RUNTIME);
+	halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8821c1ant_action_bt_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8821c1ant_action_bt_relink(IN struct btc_coexist *btcoexist)
+{
+	/*halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5); */
+	halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	coex_sta->bt_relink_downcount = 2;
+}
+
+void halbtc8821c1ant_action_bt_idle(IN struct btc_coexist *btcoexist)
+{
+	boolean wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_busy) {
+		halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+					6);
+		halbtc8821c1ant_coex_table_with_type(btcoexist,
+						     NORMAL_EXEC, 3);
+
+	} else {  /* if wl busy */
+
+		if (BT_8821C_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status) {
+
+			halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+
+			halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						33);
+		} else {
+
+			halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+			halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+
+		}
+
+	}
+
+}
+
+void halbtc8821c1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_connected = false, wifi_busy = false,
+				bt_busy = false;
+	boolean	wifi_scan = false, wifi_link = false, wifi_roam = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &wifi_link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &wifi_roam);
+
+
+	if ((coex_sta->bt_create_connection) && ((wifi_link) || (wifi_roam)
+		|| (wifi_scan) || (wifi_busy) || (coex_sta->wifi_is_high_pri_task))) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi link/roam/Scan/busy/hi-pri-task + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+
+		if ((bt_link_info->a2dp_exist) && (!bt_link_info->pan_exist))
+			halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 17);
+		else
+			halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+	} else if ((!wifi_connected) && (!wifi_scan)) {
+
+		halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (bt_link_info->pan_exist) {
+
+		halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+		halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	} else if (bt_link_info->a2dp_exist) {
+
+		halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 16);
+
+		halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+
+		if ((wifi_link) || (wifi_roam) || (wifi_scan) || (wifi_busy)
+			|| (coex_sta->wifi_is_high_pri_task))
+			halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+		else
+			halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 23);
+
+		halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	}
+}
+
+void halbtc8821c1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, wifi_busy = false;
+	u32  wifi_bw = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,
+			   &wifi_bw);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+
+	if (bt_link_info->sco_exist) {
+		halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+					true, 5);
+		halbtc8821c1ant_coex_table_with_type(btcoexist,
+						     NORMAL_EXEC, 5);
+	} else if (coex_sta->hid_busy_num >= 2) {  /*for 4/18 hid */
+
+		/* if 11bg mode */
+		if (wifi_bw == 0) {
+
+			halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+			halbtc8821c1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x1, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+			halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						11);
+		} else {
+
+			if (wifi_busy) {
+
+				halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+				halbtc8821c1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+									0xaa);
+				halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							11);
+			} else {
+
+				halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 6);
+				halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 3);
+
+			}
+		}
+	} else {
+		halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+					true, 6);
+		halbtc8821c1ant_coex_table_with_type(btcoexist,
+						     NORMAL_EXEC, 3);
+	}
+}
+
+void halbtc8821c1ant_action_wifi_under5g(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8821C_1ANT_PHASE_5G_RUNTIME);
+}
+
+
+void halbtc8821c1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821c1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+				     BT_8821C_1ANT_PHASE_2G_RUNTIME);
+	halbtc8821c1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 7);
+}
+
+void halbtc8821c1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8821C_1ANT_PHASE_2G_RUNTIME);
+
+	if (!bt_link_info->pan_exist)
+		halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	else
+		halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+
+void halbtc8821c1ant_action_wifi_linkscan_process(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	if (bt_link_info->pan_exist) {
+
+		halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+		halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	} else if (bt_link_info->a2dp_exist) {
+
+		halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 27);
+
+		halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+
+		halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+
+		halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	}
+
+}
+
+void halbtc8821c1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_busy = false, wifi_turbo = false;
+	u32  wifi_bw = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,
+			   &wifi_bw);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex],  scan_ap_num = %d, wl_noisy_level = %d\n",
+		    coex_sta->scan_ap_num, coex_sta->wl_noisy_level);
+	BTC_TRACE(trace_buf);
+
+#if 1
+
+	if ((wifi_busy) && (coex_sta->wl_noisy_level == 0))
+		wifi_turbo = true;
+#endif
+
+	if ((coex_sta->bt_relink_downcount != 0)
+			&& (!bt_link_info->pan_exist) && (wifi_busy)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  BT Re-Link + A2DP + WL busy\n");
+		BTC_TRACE(trace_buf);
+
+		/*halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);*/
+		halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	} else if (bt_link_info->a2dp_only) { /* A2DP		 */
+		if (!wifi_busy) {
+
+			/* halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32); */
+
+			halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						27);
+			halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+
+			if (coex_sta->wl_noisy_level == 2)
+				halbtc8821c1ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 17);
+			else
+				halbtc8821c1ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+
+			if (wifi_turbo)
+				halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+			else
+				halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if (((bt_link_info->a2dp_exist) &&
+		    (bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+
+		if ((bt_link_info->hid_exist) &&
+		    (coex_sta->hid_busy_num >= 2)) {
+			halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+			halbtc8821c1ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+			halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						12);
+		} else if (wifi_busy)	{
+			if (((coex_sta->a2dp_bit_pool > 40) &&
+			     (coex_sta->a2dp_bit_pool < 255)) ||
+			    (!coex_sta->is_A2DP_3M))
+				halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 15);
+			else if (wifi_turbo)
+				halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 18);
+			else
+				halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 13);
+		} else
+			halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+
+		if (bt_link_info->hid_exist)
+			halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		else if (wifi_turbo)
+			halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+		else
+			halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+	} else if (bt_link_info->hid_exist &&
+		   bt_link_info->a2dp_exist) { /* HID+A2DP */
+
+		if ((wifi_busy) && (coex_sta->hid_busy_num >= 2)) {/*for 4/18 hid */
+			halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+
+			if (wifi_bw == 0)  /* 11bg mode */
+			  halbtc8821c1ant_set_wltoggle_coex_table(
+				btcoexist,
+				NORMAL_EXEC,
+				0x1, 0xaa,
+				0x5a, 0xaa,
+				0xaa);
+			else
+			  halbtc8821c1ant_set_wltoggle_coex_table(
+				btcoexist,
+				NORMAL_EXEC,
+				0x2, 0xaa,
+				0x5a, 0xaa,
+				0xaa);
+			halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						true,
+						9);
+		} else {
+			halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						true,
+						8);
+			halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		}
+
+	} else if ((bt_link_info->pan_only)
+		   || (bt_link_info->hid_exist && bt_link_info->pan_exist)) {
+		/* PAN(OPP,FTP), HID+PAN(OPP,FTP) */
+
+		if ((bt_link_info->hid_exist) && (bt_link_info->pan_exist) &&
+			(coex_sta->hid_busy_num >= 2)) {
+
+			halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+			if (wifi_bw == 0)  /* 11bg mode */
+				halbtc8821c1ant_set_wltoggle_coex_table(
+				btcoexist,
+				NORMAL_EXEC,
+				0x1, 0xaa,
+				0x5a, 0xaa,
+				0xaa);
+			else
+				halbtc8821c1ant_set_wltoggle_coex_table(
+				btcoexist,
+				NORMAL_EXEC,
+				0x2, 0xaa,
+				0x5a, 0xaa,
+				0xaa);
+
+			halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						true, 12);
+		} else {
+
+			if (!wifi_busy)
+				halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							4);
+			else
+				halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							3);
+
+			if (bt_link_info->hid_exist)
+				halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+			else if (wifi_turbo)
+				halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+			else
+				halbtc8821c1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else {
+		/* BT no-profile busy (0x9) */
+		halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+		halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	}
+
+}
+
+void halbtc8821c1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	/* tdma and coex table */
+	halbtc8821c1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+
+	halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8821c1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_busy = false;
+	boolean	wifi_under_5g = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (wifi_under_5g) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under 5G!!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_action_wifi_under5g(btcoexist);
+		return;
+	}
+
+	halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+				     NORMAL_EXEC,
+				     BT_8821C_1ANT_PHASE_2G_RUNTIME);
+
+	if (BT_8821C_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+
+		if (bt_link_info->hid_only)  /* HID only */
+			halbtc8821c1ant_action_bt_sco_hid_only_busy(btcoexist);
+		else
+			halbtc8821c1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist);
+
+	} else if ((BT_8821C_1ANT_BT_STATUS_SCO_BUSY ==
+		    coex_dm->bt_status) ||
+		   (BT_8821C_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status))
+		halbtc8821c1ant_action_bt_sco_hid_only_busy(btcoexist);
+	else
+		halbtc8821c1ant_action_bt_idle(btcoexist);
+
+}
+
+void halbtc8821c1ant_run_sw_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8				algorithm = 0;
+
+	algorithm = halbtc8821c1ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+
+	if (!halbtc8821c1ant_is_common_action(btcoexist)) {
+		switch (coex_dm->cur_algorithm) {
+		case BT_8821C_1ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8821c1ant_action_sco(btcoexist); */
+			break;
+		case BT_8821C_1ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8821c1ant_action_hid(btcoexist); */
+			break;
+		case BT_8821C_1ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8821c1ant_action_a2dp(btcoexist); */
+			break;
+		case BT_8821C_1ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8821c1ant_action_a2dp_pan_hs(btcoexist); */
+			break;
+		case BT_8821C_1ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8821c1ant_action_pan_edr(btcoexist); */
+			break;
+		case BT_8821C_1ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8821c1ant_action_pan_hs(btcoexist); */
+			break;
+		case BT_8821C_1ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8821c1ant_action_pan_edr_a2dp(btcoexist); */
+			break;
+		case BT_8821C_1ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8821c1ant_action_pan_edr_hid(btcoexist); */
+			break;
+		case BT_8821C_1ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8821c1ant_action_hid_a2dp_pan_edr(btcoexist); */
+			break;
+		case BT_8821C_1ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8821c1ant_action_hid_a2dp(btcoexist); */
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8821c1ant_coex_all_off(btcoexist); */
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+
+void halbtc8821c1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, bt_hs_on = false;
+	boolean	increase_scan_dev_num = false;
+	boolean	bt_ctrl_agg_buf_size = false;
+	boolean	miracast_plus_bt = false, wifi_under_5g = false;
+	u8	agg_buf_size = 5;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0, wifi_bw;
+	u8	iot_peer = BTC_IOT_PEER_UNKNOWN;
+	boolean	scan = false, link = false, roam = false, under_4way = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (!coex_sta->run_time_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], return for run_time_state = false !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->freeze_coexrun_by_btinfo) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), return for freeze_coexrun_by_btinfo\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (wifi_under_5g) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under 5G!!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_action_wifi_under5g(btcoexist);
+		return;
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under 2G!!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+					     BT_8821C_1ANT_PHASE_2G_RUNTIME);
+	}
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c1ant_action_bt_whql_test(btcoexist);
+		return;
+	}
+
+	if (coex_sta->bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is disabled !!!\n");
+		halbtc8821c1ant_action_wifi_only(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c1ant_action_bt_inquiry(btcoexist);
+		return;
+	}
+
+	if (coex_sta->is_setupLink) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is re-link !!!\n");
+		halbtc8821c1ant_action_bt_relink(btcoexist);
+		return;
+	}
+
+	if ((BT_8821C_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8821C_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8821C_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+			   &increase_scan_dev_num);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist)
+			miracast_plus_bt = true;
+		else
+			miracast_plus_bt = false;
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+
+		halbtc8821c1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   false, 0x5);
+
+		if (scan || link || roam || under_4way) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], scan = %d, link = %d, roam = %d 4way = %d!!!\n",
+				    scan, link, roam, under_4way);
+			BTC_TRACE(trace_buf);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], wifi is under linkscan process + Multi-Port !!\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8821c1ant_action_wifi_linkscan_process(btcoexist);
+		} else
+			halbtc8821c1ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	} else {
+
+		miracast_plus_bt = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	if ((bt_link_info->bt_link_exist) && (wifi_connected)) {
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_IOT_PEER, &iot_peer);
+
+		if (BTC_IOT_PEER_CISCO == iot_peer) {
+
+			if (BTC_WIFI_BW_HT40 == wifi_bw)
+				halbtc8821c1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, false, true, 0x10);
+			else
+				halbtc8821c1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, false, true, 0x8);
+		}  else
+			halbtc8821c1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+						   0x5);
+	}
+
+	halbtc8821c1ant_run_sw_coexist_mechanism(
+		btcoexist); /* just print debug message */
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (bt_hs_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "############# [BTCoex],  BT Is hs\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c1ant_action_bt_hs(btcoexist);
+		return;
+	}
+
+	if ((BT_8821C_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	     coex_dm->bt_status) ||
+	    (BT_8821C_1ANT_BT_STATUS_CONNECTED_IDLE ==
+	     coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "############# [BTCoex],  BT Is idle\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c1ant_action_bt_idle(btcoexist);
+		return;
+	}
+
+	if (scan || link || roam || under_4way) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], scan = %d, link = %d, roam = %d 4way = %d!!!\n",
+			    scan, link, roam, under_4way);
+		BTC_TRACE(trace_buf);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under linkscan process!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_action_wifi_linkscan_process(btcoexist);
+	} else if (wifi_connected) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under connected!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_action_wifi_connected(btcoexist);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under not-connected!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_action_wifi_not_connected(btcoexist);
+	}
+}
+
+void halbtc8821c1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+	halbtc8821c1ant_low_penalty_ra(btcoexist, FORCE_EXEC, false);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	coex_sta->pop_event_cnt = 0;
+	coex_sta->cnt_RemoteNameReq = 0;
+	coex_sta->cnt_ReInit = 0;
+	coex_sta->cnt_setupLink = 0;
+	coex_sta->cnt_IgnWlanAct = 0;
+	coex_sta->cnt_Page = 0;
+	coex_sta->cnt_RoleSwitch = 0;
+
+	halbtc8821c1ant_query_bt_info(btcoexist);
+}
+
+void halbtc8821c1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up, IN boolean wifi_only)
+{
+	u32			u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+	u16			u16tmp1 = 0;
+	u8			i;
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u32tmp1 = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex],(Before Init HW config) 0xcb4 = 0x%x, 0x38= 0x%x, 0x54= 0x%x\n",
+		    u32tmp3, u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+
+
+	coex_sta->bt_coex_supported_feature = 0;
+	coex_sta->bt_coex_supported_version = 0;
+	coex_sta->bt_ble_scan_type = 0;
+	coex_sta->bt_ble_scan_para[0] = 0;
+	coex_sta->bt_ble_scan_para[1] = 0;
+	coex_sta->bt_ble_scan_para[2] = 0;
+	coex_sta->bt_reg_vendor_ac = 0xffff;
+	coex_sta->bt_reg_vendor_ae = 0xffff;
+	coex_sta->isolation_btween_wb = BT_8821C_1ANT_DEFAULT_ISOLATION;
+	coex_sta->gnt_error_cnt = 0;
+	coex_sta->bt_relink_downcount = 0;
+
+	for (i = 0; i <= 9; i++)
+		coex_sta->bt_afh_map[i] = 0;
+
+	/* Setup RF front end type */
+	halbtc8821c1ant_set_rfe_type(btcoexist);
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+
+	/* BT report packet sample rate	 */
+	btcoexist->btc_write_1byte(btcoexist, 0x790, 0x5);
+
+	/* Init 0x778 = 0x1 for 1-Ant */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+
+	/* Enable PTA (3-wire function form BT side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x41, 0x02, 0x1);
+
+	/* Enable PTA (tx/rx signal form WiFi side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4c6, 0x10, 0x1);
+
+	/* set GNT_BT=1 for coex table select both */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x763, 0x10, 0x1);
+
+	halbtc8821c1ant_enable_gnt_to_gpio(btcoexist, true);
+
+#if 0
+	/* check if WL firmware download ok */
+	/*if (btcoexist->btc_read_1byte(btcoexist, 0x80) == 0xc6)*/
+	 halbtc8821c1ant_post_state_to_bt(btcoexist,
+					BT_8821C_1ANT_SCOREBOARD_ONOFF, true);
+#endif
+
+	/* PTA parameter */
+	halbtc8821c1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+
+	halbtc8821c1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	psd_scan->ant_det_is_ant_det_available = true;
+
+	/* Antenna config */
+	if (wifi_only) {
+		coex_sta->concurrent_rx_mode_on = false;
+		halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_WIFI,
+					     FORCE_EXEC,
+					     BT_8821C_1ANT_PHASE_WLANONLY_INIT);
+
+		btcoexist->stop_coex_dm = true;
+	} else {
+		/*Set BT polluted packet on for Tx rate adaptive not including Tx retry break by PTA, 0x45c[19] =1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x45e, 0x8, 0x1);
+
+		coex_sta->concurrent_rx_mode_on = true;
+		/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x953, 0x2, 0x1); */
+
+		/* RF 0x1[1] = 0->Set GNT_WL_RF_Rx always = 1 for con-current Rx, mask Tx only */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0x2, 0x0);
+
+		halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_1ANT_PHASE_COEX_INIT);
+
+		btcoexist->stop_coex_dm = false;
+	}
+
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u32tmp1 = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], (After Init HW config) 0xcb4 = 0x%x, 0x38= 0x%x, 0x54= 0x%x\n",
+		    u32tmp3, u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+
+}
+
+
+/* ************************************************************
+ * work around function start with wa_halbtc8821c1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8821c1ant_
+ * ************************************************************ */
+void ex_halbtc8821c1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x0;
+	u16 u16tmp = 0x0;
+	u32	value = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"xxxxxxxxxxxxxxxx Execute 8821c 1-Ant PowerOn Setting xxxxxxxxxxxxxxxx!!\n");
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "Ant Det Finish = %s, Ant Det Number  = %d\n",
+		    (board_info->btdm_ant_det_finish ? "Yes" : "No"),
+		    board_info->btdm_ant_num_by_ant_det);
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = true;
+	psd_scan->ant_det_is_ant_det_available = false;
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write BB Register correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+
+	/* Set Antenna Path to BT side */
+	/* Check efuse 0xc3[6] for Single Antenna Path */
+	if (board_info->single_ant_path == 0) {
+
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+		u8tmp = 1;
+	} else if (board_info->single_ant_path == 1) {
+
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+		u8tmp = 0;
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (Power On) single_ant_path  = %d, btdm_ant_pos = %d\n",
+		    board_info->single_ant_path , board_info->btdm_ant_pos);
+	BTC_TRACE(trace_buf);
+
+	/* Setup RF front end type */
+	halbtc8821c1ant_set_rfe_type(btcoexist);
+
+	/* Set Antenna Path to BT side */
+	halbtc8821c1ant_set_ant_path(btcoexist,
+				     BTC_ANT_PATH_AUTO,
+				     FORCE_EXEC,
+				     BT_8821C_1ANT_PHASE_COEX_POWERON);
+
+	/* Save"single antenna position" info in Local register setting for FW reading, because FW may not ready at  power on */
+	if (btcoexist->chip_interface == BTC_INTF_PCI)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x3e0, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_USB)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60, u8tmp);
+
+	/* enable GNT_WL/GNT_BT debug signal to GPIO14/15 */
+	halbtc8821c1ant_enable_gnt_to_gpio(btcoexist, true);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********  LTE coex Reg 0x38 (Power-On) = 0x%x\n",
+		    halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist, 0x38));
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********  MAC Reg 0x70/ BB Reg 0xcb4 (Power-On) = 0x%x / 0x%x\n",
+		    btcoexist->btc_read_4byte(btcoexist, 0x70),
+		    btcoexist->btc_read_4byte(btcoexist, 0xcb4));
+	BTC_TRACE(trace_buf);
+
+}
+
+void ex_halbtc8821c1ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8821c1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8821c1ant_init_hw_config(btcoexist, true, wifi_only);
+}
+
+void ex_halbtc8821c1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821c1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8821c1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_stack_info		*stack_info = &btcoexist->stack_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+	u32				fw_ver = 0, bt_patch_ver = 0, bt_coex_ver = 0;
+	static u8			pop_report_in_10s = 0;
+	u32			phyver = 0;
+	boolean			lte_coex_on = false;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	if (psd_scan->ant_det_try_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %s / %d",
+			   "Ant PG Num/ Mech/ Pos/ RFE",
+			   board_info->pg_ant_num, board_info->btdm_ant_num,
+			   (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT
+			    ? "Main" : "Aux"),
+			   rfe_type->rfe_module_type);
+		CL_PRINTF(cli_buf);
+	} else {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %s/ %d  (%d/%d/%d)",
+			   "Ant PG Num/ Mech(Ant_Det)/ Pos/ RFE",
+			   board_info->pg_ant_num,
+			   board_info->btdm_ant_num_by_ant_det,
+			   (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT
+			    ? "Main" : "Aux"),
+			   rfe_type->rfe_module_type,
+			   psd_scan->ant_det_try_count,
+			   psd_scan->ant_det_fail_count,
+			   psd_scan->ant_det_result);
+		CL_PRINTF(cli_buf);
+
+		if (board_info->btdm_ant_det_finish) {
+
+			if (psd_scan->ant_det_result != 12)
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					   "\r\n %-35s = %s",
+					   "Ant Det PSD Value",
+					   psd_scan->ant_det_peak_val);
+			else
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					   "\r\n %-35s = %d",
+					   "Ant Det PSD Value",
+					   psd_scan->ant_det_psd_scan_peak_val
+					   / 100);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+
+	bt_coex_ver = ((coex_sta->bt_coex_supported_version & 0xff00) >> 8);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+		   "CoexVer WL/  BT_Desired/ BT_Report",
+		   glcoex_ver_date_8821c_1ant, glcoex_ver_8821c_1ant,
+		   glcoex_ver_btdesired_8821c_1ant,
+		   bt_coex_ver,
+		   (bt_coex_ver == 0xff ? "Unknown" :
+		    (coex_sta->bt_disabled ? "BT-disable" :
+		     (bt_coex_ver >= glcoex_ver_btdesired_8821c_1ant ?
+		      "Match" : "Mis-Match"))));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d/ %c",
+		   "W_FW/ B_FW/ Phy/ Kt",
+		   fw_ver, bt_patch_ver, phyver,
+		   coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "AFH Map to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	pop_report_in_10s++;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = [%s/ %d dBm/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt/ popCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+			   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page")
+			   : ((BT_8821C_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8821C_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi - 100, coex_sta->bt_retry_cnt,
+		   coex_sta->pop_event_cnt);
+	CL_PRINTF(cli_buf);
+
+	if (pop_report_in_10s >= 5) {
+		coex_sta->pop_event_cnt = 0;
+		pop_report_in_10s = 0;
+	}
+
+	if (coex_sta->num_of_profile != 0)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %s%s%s%s%s",
+			   "Profiles",
+			   ((bt_link_info->a2dp_exist) ? "A2DP," : ""),
+			   ((bt_link_info->sco_exist) ?  "HFP," : ""),
+			   ((bt_link_info->hid_exist) ?
+			    ((coex_sta->hid_busy_num >= 2) ? "HID(4/18)," :
+			     "HID(2/18),") : ""),
+			   ((bt_link_info->pan_exist) ?  "PAN," : ""),
+			   ((coex_sta->voice_over_HOGP) ? "Voice" : ""));
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = None", "Profiles");
+
+	CL_PRINTF(cli_buf);
+
+	if (bt_link_info->a2dp_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %d/ %s",
+			   "A2DP Rate/Bitpool/Auto_Slot",
+			   ((coex_sta->is_A2DP_3M) ? "3M" : "No_3M"),
+			   coex_sta->a2dp_bit_pool,
+			   ((coex_sta->is_autoslot) ? "On" : "Off")
+			  );
+		CL_PRINTF(cli_buf);
+	}
+
+	if (bt_link_info->hid_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+			   "HID PairNum/Forbid_Slot",
+			   coex_sta->hid_pair_cnt,
+			   coex_sta->forbidden_slot
+			  );
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %d/ %s/ 0x%x",
+				"Role/RoleSwCnt/IgnWlact/Feature",
+				((bt_link_info->slave_role) ? "Slave" : "Master"),
+				coex_sta->cnt_RoleSwitch,
+				((coex_dm->cur_ignore_wlan_act) ? "Yes" : "No"),
+				coex_sta->bt_coex_supported_feature);
+	CL_PRINTF(cli_buf);
+
+	if ((coex_sta->bt_ble_scan_type & 0x7) != 0x0) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+				"BLEScan Type/TV/Init/Ble",
+				coex_sta->bt_ble_scan_type,
+				(coex_sta->bt_ble_scan_type & 0x1 ?
+				coex_sta->bt_ble_scan_para[0] : 0x0),
+				(coex_sta->bt_ble_scan_type & 0x2 ?
+				coex_sta->bt_ble_scan_para[1] : 0x0),
+				(coex_sta->bt_ble_scan_type & 0x4 ?
+				coex_sta->bt_ble_scan_para[2] : 0x0));
+			CL_PRINTF(cli_buf);
+	}
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d",
+		   "ReInit/ReLink/IgnWlact/Page/NameReq",
+		   coex_sta->cnt_ReInit,
+		   coex_sta->cnt_setupLink,
+		   coex_sta->cnt_IgnWlanAct,
+		   coex_sta->cnt_Page,
+		   coex_sta->cnt_RemoteNameReq
+		  );
+	CL_PRINTF(cli_buf);
+
+	halbtc8821c1ant_read_score_board(btcoexist,	&u16tmp[0]);
+
+	if ((coex_sta->bt_reg_vendor_ae == 0xffff) ||
+	    (coex_sta->bt_reg_vendor_ac == 0xffff))
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = x/ x/ %04x",
+			   "0xae[4]/0xac[1:0]/Scoreboard", u16tmp[0]);
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = 0x%x/ 0x%x/ %04x",
+			   "0xae[4]/0xac[1:0]/Scoreboard",
+			   ((coex_sta->bt_reg_vendor_ae & BIT(4)) >> 4),
+			   coex_sta->bt_reg_vendor_ac & 0x3, u16tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	if (coex_sta->num_of_profile > 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
+			"AFH MAP",
+			coex_sta->bt_afh_map[0],
+			coex_sta->bt_afh_map[1],
+			coex_sta->bt_afh_map[2],
+			coex_sta->bt_afh_map[3],
+			coex_sta->bt_afh_map[4],
+			coex_sta->bt_afh_map[5],
+			coex_sta->bt_afh_map[6],
+			coex_sta->bt_afh_map[7],
+			coex_sta->bt_afh_map[8],
+			coex_sta->bt_afh_map[9]
+			   );
+		CL_PRINTF(cli_buf);
+	}
+
+	for (i = 0; i < BT_INFO_SRC_8821C_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8821c_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[mechanisms] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[Mechanisms]============");
+
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x (case-%d, %s)",
+		   "TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   (coex_dm->cur_ps_tdma_on ? "TDMA On" : "TDMA Off"));
+
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d/ 0x%x/ 0x%x/ 0x%x",
+		   "Table/0x6c0/0x6c4/0x6c8",
+		   coex_sta->coex_table_type, u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x778/0x6cc",
+		   u8tmp[0], u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s",
+		   "AntDiv/ForceLPS/LPRA",
+		   ((board_info->ant_div_cfg) ? "On" : "Off"),
+		   ((coex_sta->force_lps_on) ? "On" : "Off"),
+		   ((coex_dm->cur_low_penalty_ra) ? "On" : "Off"));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	lte_coex_on = ((u32tmp[0] & BIT(7)) >> 7) ?  true : false;
+
+	if (lte_coex_on) {
+
+		u32tmp[0] = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa0);
+		u32tmp[1] = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa4);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+			   "LTE Coex Table W_L/B_L",
+			   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff);
+		CL_PRINTF(cli_buf);
+
+		u32tmp[0] = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa8);
+		u32tmp[1] = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xac);
+		u32tmp[2] = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xb0);
+		u32tmp[3] = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist,
+				0xb4);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+			   "LTE Break Table W_L/B_L/L_W/L_B",
+			   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff,
+			   u32tmp[2] & 0xffff, u32tmp[3] & 0xffff);
+		CL_PRINTF(cli_buf);
+	}
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp[1] = halbtc8821c1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s",
+		   "LTE Coex/Path Owner",
+		   ((lte_coex_on) ? "On" : "Off") ,
+		   ((u8tmp[0] & BIT(2)) ? "WL" : "BT"));
+	CL_PRINTF(cli_buf);
+
+	if (lte_coex_on) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %d/ %d",
+			   "LTE 3Wire/OPMode/UART/UARTMode",
+			   (int)((u32tmp[0] & BIT(6)) >> 6),
+			   (int)((u32tmp[0] & (BIT(5) | BIT(4))) >> 4),
+			   (int)((u32tmp[0] & BIT(3)) >> 3),
+			   (int)(u32tmp[0] & (BIT(2) | BIT(1) | BIT(0))));
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+			   "LTE_Busy/UART_Busy",
+			   (int)((u32tmp[1] & BIT(1)) >> 1),
+			   (int)(u32tmp[1] & BIT(0)));
+		CL_PRINTF(cli_buf);
+	}
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %s (BB:%s)/ %s (BB:%s)/ %s %d",
+		   "GNT_WL_Ctrl/GNT_BT_Ctrl/Dbg",
+		   ((u32tmp[0] & BIT(12)) ? "SW" : "HW"),
+		   ((u32tmp[0] & BIT(8)) ?  "SW" : "HW"),
+		   ((u32tmp[0] & BIT(14)) ? "SW" : "HW"),
+		   ((u32tmp[0] & BIT(10)) ?  "SW" : "HW"),
+		   ((u8tmp[0] & BIT(3)) ? "On" : "Off"),
+		   coex_sta->gnt_error_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "GNT_WL/GNT_BT",
+		   (int)((u32tmp[1] & BIT(2)) >> 2),
+		   (int)((u32tmp[1] & BIT(3)) >> 3));
+	CL_PRINTF(cli_buf);
+
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xcb0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xcba);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%04x/ 0x%04x/ 0x%02x %s",
+		   "0xcb0/0xcb4/0xcb8[23:16]",
+		   u32tmp[0], u32tmp[1], u8tmp[0],
+		   ((u8tmp[0] & 0x1) == 0x1 ?  "(BTG)" :   "(WL_A+G)"));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0x64);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x4c6);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "4c[24:23]/64[0]/4c6[4]/40[5]",
+		   (u32tmp[0] & (BIT(24) | BIT(23))) >> 23 , u8tmp[2] & 0x1 ,
+		   (int)((u8tmp[0] & BIT(4)) >> 4),
+		   (int)((u8tmp[1] & BIT(5)) >> 5));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x953);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0xc50);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ %s/ 0x%x",
+		   "0x550/0x522/4-RxAGC/0xc50",
+		u32tmp[0], u8tmp[0], (u8tmp[1] & 0x2) ? "On" : "Off", u8tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+
+#if 1
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11ac",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11ac",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+#endif
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s/ %d",
+		   "WlHiPri/ Locking/ Locked/ Noisy",
+		   (coex_sta->wifi_is_high_pri_task ? "Yes" : "No"),
+		   (coex_sta->cck_lock ? "Yes" : "No"),
+		   (coex_sta->cck_ever_lock ? "Yes" : "No"),
+		   coex_sta->wl_noisy_level);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d %s",
+		   "0x770(Hi-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx,
+		   (coex_sta->is_hiPri_rx_overhead ? "(scan overhead!!)" : ""));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d %s",
+		   "0x774(Lo-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx,
+		   (bt_link_info->slave_role ? "(Slave!!)" : (
+		   coex_sta->is_tdma_btautoslot_hang ? "(auto-slot hang!!)" : "")));
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8821c1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+
+		/* Write WL "Active" in Score-board for LPS off */
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+				BT_8821C_1ANT_SCOREBOARD_ACTIVE |
+				BT_8821C_1ANT_SCOREBOARD_ONOFF |
+				BT_8821C_1ANT_SCOREBOARD_SCAN |
+				BT_8821C_1ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		halbtc8821c1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+		halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_1ANT_PHASE_WLAN_OFF);
+
+		halbtc8821c1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+#if 0
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+				BT_8821C_1ANT_SCOREBOARD_ACTIVE, true);
+
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+				BT_8821C_1ANT_SCOREBOARD_ONOFF, true);
+#endif
+		halbtc8821c1ant_init_hw_config(btcoexist, false, false);
+		halbtc8821c1ant_init_coex_dm(btcoexist);
+
+		coex_sta->under_ips = false;
+	}
+}
+
+void ex_halbtc8821c1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+
+		if (coex_sta->force_lps_on == true) { /* LPS No-32K */
+			/* Write WL "Active" in Score-board for PS-TDMA */
+			halbtc8821c1ant_post_state_to_bt(btcoexist,
+					 BT_8821C_1ANT_SCOREBOARD_ACTIVE, true);
+
+		} else { /* LPS-32K, need check if this h2c 0x71 can work?? (2015/08/28) */
+			/* Write WL "Non-Active" in Score-board for Native-PS */
+			halbtc8821c1ant_post_state_to_bt(btcoexist,
+				 BT_8821C_1ANT_SCOREBOARD_ACTIVE, false);
+
+		}
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+
+		/* Write WL "Active" in Score-board for LPS off */
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+					 BT_8821C_1ANT_SCOREBOARD_ACTIVE, true);
+
+	}
+}
+
+void ex_halbtc8821c1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected = false;
+	boolean wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	coex_sta->freeze_coexrun_by_btinfo = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	if (wifi_connected)
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** WL connected before SCAN\n");
+	else
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], **********  WL is not connected before SCAN\n");
+
+	BTC_TRACE(trace_buf);
+
+	halbtc8821c1ant_query_bt_info(btcoexist);
+
+	if (BTC_SCAN_START == type) {
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G,
+				   &wifi_under_5g);
+
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+					BT_8821C_1ANT_SCOREBOARD_ACTIVE |
+					BT_8821C_1ANT_SCOREBOARD_SCAN |
+					BT_8821C_1ANT_SCOREBOARD_ONOFF,
+					true);
+
+		if (wifi_under_5g) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** SCAN START notify (5g)\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8821c1ant_action_wifi_under5g(btcoexist);
+			return;
+		}
+
+		coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** SCAN START notify (2g)\n");
+		BTC_TRACE(trace_buf);
+
+		/* Force antenna setup for no scan result issue */
+		halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_1ANT_PHASE_2G_RUNTIME);
+
+		halbtc8821c1ant_run_coexist_mechanism(btcoexist);
+
+		return;
+	}
+
+	if (BTC_SCAN_START_2G == type) {
+
+		if (!wifi_connected)
+			coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify  (2G)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+					 BT_8821C_1ANT_SCOREBOARD_ACTIVE |
+					 BT_8821C_1ANT_SCOREBOARD_SCAN |
+					 BT_8821C_1ANT_SCOREBOARD_ONOFF,
+					 true);
+
+		/* Force antenna setup for no scan result issue */
+		halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_1ANT_PHASE_2G_RUNTIME);
+
+		halbtc8821c1ant_run_coexist_mechanism(btcoexist);
+
+	} else {
+
+		coex_sta->wifi_is_high_pri_task = false;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify  (Scan-AP = %d)\n",
+			    coex_sta->scan_ap_num);
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_run_coexist_mechanism(btcoexist);
+	}
+
+
+}
+
+void ex_halbtc8821c1ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+
+	if (type == BTC_SWITCH_TO_5G) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], switchband_notify ---  switch to 5G\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_action_wifi_under5g(btcoexist);
+
+	} else if (type == BTC_SWITCH_TO_24G_NOFORSCAN) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** switchband_notify BTC_SWITCH_TO_2G (no for scan)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_run_coexist_mechanism(btcoexist);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], switchband_notify ---  switch to 2G\n");
+		BTC_TRACE(trace_buf);
+
+		ex_halbtc8821c1ant_scan_notify(btcoexist,
+					       BTC_SCAN_START_2G);
+	}
+}
+
+
+void ex_halbtc8821c1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+
+	halbtc8821c1ant_post_state_to_bt(btcoexist,
+					 BT_8821C_1ANT_SCOREBOARD_ACTIVE |
+					 BT_8821C_1ANT_SCOREBOARD_SCAN |
+					 BT_8821C_1ANT_SCOREBOARD_ONOFF,
+					 true);
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if ((BTC_ASSOCIATE_5G_START == type) ||
+	    (BTC_ASSOCIATE_5G_FINISH == type)) {
+
+		if (BTC_ASSOCIATE_5G_START == type)
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], connect_notify ---  5G start\n");
+		else
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], connect_notify ---  5G finish\n");
+
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_action_wifi_under5g(btcoexist);
+		return;
+	}
+
+	if (BTC_ASSOCIATE_START == type) {
+
+		coex_sta->wifi_is_high_pri_task = true;
+
+		/* Force antenna setup for no scan result issue */
+		halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_1ANT_PHASE_2G_RUNTIME);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify (2G)\n");
+		BTC_TRACE(trace_buf);
+
+		coex_dm->arp_cnt = 0;
+
+		halbtc8821c1ant_run_coexist_mechanism(btcoexist);
+
+		/* To keep TDMA case during connect process,
+		to avoid changed by Btinfo and runcoexmechanism */
+		coex_sta->freeze_coexrun_by_btinfo = true;
+	} else {
+
+		coex_sta->wifi_is_high_pri_task = false;
+		coex_sta->freeze_coexrun_by_btinfo = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify (2G)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_run_coexist_mechanism(btcoexist);
+	}
+
+}
+
+void ex_halbtc8821c1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean			wifi_under_b_mode = false, wifi_under_5g = false;
+
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (BTC_MEDIA_CONNECT == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+					 BT_8821C_1ANT_SCOREBOARD_ACTIVE |
+					 BT_8821C_1ANT_SCOREBOARD_ONOFF,
+					 true);
+
+		if (wifi_under_5g) {
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], WiFi is under 5G!!!\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8821c1ant_action_wifi_under5g(btcoexist);
+			return;
+		}
+
+		/* Force antenna setup for no scan result issue */
+		halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_1ANT_PHASE_2G_RUNTIME);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+			/* btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x10); */ /*CCK Tx */
+			/* btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x10); */ /*CCK Rx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+				 BT_8821C_1ANT_SCOREBOARD_ACTIVE, false);
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+
+		coex_sta->cck_ever_lock = false;
+	}
+
+	halbtc8821c1ant_update_wifi_channel_info(btcoexist, type);
+
+}
+
+void ex_halbtc8821c1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	under_4way = false, wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (wifi_under_5g) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under 5G!!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_action_wifi_under5g(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (under_4way) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ---- under_4way!!\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+	} else if (BTC_PACKET_ARP == type) {
+
+		coex_dm->arp_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ARP notify -cnt = %d\n",
+			    coex_dm->arp_cnt);
+		BTC_TRACE(trace_buf);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet DHCP or EAPOL notify [Type = %d]\n",
+			    type);
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+	}
+
+	if (coex_sta->wifi_is_high_pri_task) {
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+					 BT_8821C_1ANT_SCOREBOARD_SCAN, true);
+		halbtc8821c1ant_run_coexist_mechanism(btcoexist);
+	}
+
+}
+
+void ex_halbtc8821c1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8				i, rsp_source = 0;
+	boolean				wifi_connected = false;
+	boolean	wifi_scan = false, wifi_link = false, wifi_roam = false,
+			wifi_busy = false;
+	static boolean is_scoreboard_scan = false;
+
+	if (psd_scan->is_AntDet_running == true) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], bt_info_notify return for AntDet is running\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8821C_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8821C_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt_info[%d], len=%d, data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	coex_sta->bt_info = coex_sta->bt_info_c2h[rsp_source][1];
+	coex_sta->bt_info_ext = coex_sta->bt_info_c2h[rsp_source][4];
+	coex_sta->bt_info_ext2 = coex_sta->bt_info_c2h[rsp_source][5];
+
+	if (BT_INFO_SRC_8821C_1ANT_WIFI_FW != rsp_source) {
+
+		/* if 0xff, it means BT is under WHCK test */
+		coex_sta->bt_whck_test = ((coex_sta->bt_info == 0xff) ? true :
+					  false);
+
+		coex_sta->bt_create_connection = ((
+			coex_sta->bt_info_c2h[rsp_source][2] & 0x80) ? true :
+						  false);
+
+		/* unit: %, value-100 to translate to unit: dBm */
+		coex_sta->bt_rssi = coex_sta->bt_info_c2h[rsp_source][3] * 2 +
+				    10;
+
+		coex_sta->c2h_bt_remote_name_req = ((
+			coex_sta->bt_info_c2h[rsp_source][2] & 0x20) ? true :
+						    false);
+
+		coex_sta->is_A2DP_3M = ((coex_sta->bt_info_c2h[rsp_source][2] &
+					 0x10) ? true : false);
+
+		coex_sta->acl_busy = ((coex_sta->bt_info_c2h[rsp_source][1] &
+				       0x9) ? true : false);
+
+		coex_sta->voice_over_HOGP = ((coex_sta->bt_info_ext & 0x10) ?
+					     true : false);
+
+		coex_sta->c2h_bt_inquiry_page = ((coex_sta->bt_info &
+			  BT_INFO_8821C_1ANT_B_INQ_PAGE) ? true : false);
+
+		coex_sta->a2dp_bit_pool = (((
+			coex_sta->bt_info_c2h[rsp_source][1] & 0x49) == 0x49) ?
+				   coex_sta->bt_info_c2h[rsp_source][6] : 0);
+
+		coex_sta->bt_retry_cnt = coex_sta->bt_info_c2h[rsp_source][2] &
+					 0xf;
+
+		coex_sta->is_autoslot = coex_sta->bt_info_ext2 & 0x8;
+
+		coex_sta->forbidden_slot = coex_sta->bt_info_ext2 & 0x7;
+
+		coex_sta->hid_busy_num = (coex_sta->bt_info_ext2 & 0x30) >> 4;
+
+		coex_sta->hid_pair_cnt = (coex_sta->bt_info_ext2 & 0xc0) >> 6;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->c2h_bt_remote_name_req)
+			coex_sta->cnt_RemoteNameReq++;
+
+		if (coex_sta->bt_info_ext & BIT(1))
+			coex_sta->cnt_ReInit++;
+
+		if (coex_sta->bt_info_ext & BIT(2)) {
+			coex_sta->cnt_setupLink++;
+			coex_sta->is_setupLink = true;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Re-Link start in BT info!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			coex_sta->is_setupLink = false;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Re-Link stop in BT info!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		if (coex_sta->bt_info_ext & BIT(3))
+			coex_sta->cnt_IgnWlanAct++;
+
+		if (coex_sta->bt_info_ext & BIT(6))
+			coex_sta->cnt_RoleSwitch++;
+
+		if (coex_sta->bt_create_connection) {
+			coex_sta->cnt_Page++;
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY,
+					   &wifi_busy);
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &wifi_link);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &wifi_roam);
+
+			if ((wifi_link) || (wifi_roam) || (wifi_scan) ||
+			    (coex_sta->wifi_is_high_pri_task) || (wifi_busy)) {
+
+				is_scoreboard_scan = true;
+				halbtc8821c1ant_post_state_to_bt(btcoexist,
+					 BT_8821C_1ANT_SCOREBOARD_SCAN, true);
+
+			} else
+				halbtc8821c1ant_post_state_to_bt(btcoexist,
+					 BT_8821C_1ANT_SCOREBOARD_SCAN, false);
+
+		} else {
+				if (is_scoreboard_scan) {
+					halbtc8821c1ant_post_state_to_bt(btcoexist,
+						 BT_8821C_1ANT_SCOREBOARD_SCAN, false);
+					is_scoreboard_scan = false;
+				}
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+
+		if ((!btcoexist->manual_control) &&
+		    (!btcoexist->stop_coex_dm)) {
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+
+			/*  Re-Init */
+			if ((coex_sta->bt_info_ext & BIT(1))) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+				BTC_TRACE(trace_buf);
+				if (wifi_connected)
+					halbtc8821c1ant_update_wifi_channel_info(
+						btcoexist, BTC_MEDIA_CONNECT);
+				else
+					halbtc8821c1ant_update_wifi_channel_info(
+						btcoexist,
+						BTC_MEDIA_DISCONNECT);
+			}
+
+			/*  If Ignore_WLanAct && not SetUp_Link */
+			if ((coex_sta->bt_info_ext & BIT(3)) &&
+			    (!(coex_sta->bt_info_ext & BIT(2)))) {
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821c1ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			}
+		}
+
+	}
+
+	if ((coex_sta->bt_info_ext & BIT(5))) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BT ext info bit4 check, query BLE Scan type!!\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_ble_scan_type = btcoexist->btc_get_ble_scan_type_from_bt(
+						     btcoexist);
+
+		if ((coex_sta->bt_ble_scan_type & 0x1) == 0x1)
+			coex_sta->bt_ble_scan_para[0]  =
+				btcoexist->btc_get_ble_scan_para_from_bt(btcoexist,
+						0x1);
+		if ((coex_sta->bt_ble_scan_type & 0x2) == 0x2)
+			coex_sta->bt_ble_scan_para[1]  =
+				btcoexist->btc_get_ble_scan_para_from_bt(btcoexist,
+						0x2);
+		if ((coex_sta->bt_ble_scan_type & 0x4) == 0x4)
+			coex_sta->bt_ble_scan_para[2]  =
+				btcoexist->btc_get_ble_scan_para_from_bt(btcoexist,
+						0x4);
+
+	}
+
+	halbtc8821c1ant_update_bt_link_info(btcoexist);
+
+	halbtc8821c1ant_run_coexist_mechanism(btcoexist);
+}
+
+
+
+void ex_halbtc8821c1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->stop_coex_dm = false;
+#if 0
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+					 BT_8821C_1ANT_SCOREBOARD_ACTIVE |
+					 BT_8821C_1ANT_SCOREBOARD_ONOFF,
+					 true);
+#endif
+	} else if (BTC_RF_OFF == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+				BT_8821C_1ANT_SCOREBOARD_ACTIVE |
+				BT_8821C_1ANT_SCOREBOARD_ONOFF |
+				BT_8821C_1ANT_SCOREBOARD_SCAN |
+				BT_8821C_1ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		halbtc8821c1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+
+		halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_1ANT_PHASE_WLAN_OFF);
+
+		btcoexist->stop_coex_dm = true;
+	}
+}
+
+void ex_halbtc8821c1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821c1ant_post_state_to_bt(btcoexist,
+				BT_8821C_1ANT_SCOREBOARD_ACTIVE |
+				BT_8821C_1ANT_SCOREBOARD_ONOFF |
+				BT_8821C_1ANT_SCOREBOARD_SCAN |
+				BT_8821C_1ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+	halbtc8821c1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+
+	halbtc8821c1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+				     BT_8821C_1ANT_PHASE_WLAN_OFF);
+
+	halbtc8821c1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8821c1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	btcoexist->stop_coex_dm = true;
+}
+
+void ex_halbtc8821c1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	boolean wifi_under_5g = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if ((BTC_WIFI_PNP_SLEEP == pnp_state) ||
+	    (BTC_WIFI_PNP_SLEEP_KEEP_ANT == pnp_state)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+				BT_8821C_1ANT_SCOREBOARD_ACTIVE |
+				BT_8821C_1ANT_SCOREBOARD_ONOFF |
+				BT_8821C_1ANT_SCOREBOARD_SCAN |
+				BT_8821C_1ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		if (BTC_WIFI_PNP_SLEEP_KEEP_ANT == pnp_state) {
+
+			if (wifi_under_5g)
+				halbtc8821c1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO, FORCE_EXEC,
+					     BT_8821C_1ANT_PHASE_5G_RUNTIME);
+			else
+				halbtc8821c1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO, FORCE_EXEC,
+					     BT_8821C_1ANT_PHASE_2G_RUNTIME);
+		} else {
+
+			halbtc8821c1ant_set_ant_path(btcoexist,
+						     BTC_ANT_PATH_AUTO,
+						     FORCE_EXEC,
+					     BT_8821C_1ANT_PHASE_WLAN_OFF);
+		}
+
+		btcoexist->stop_coex_dm = true;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+#if 0
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+					 BT_8821C_1ANT_SCOREBOARD_ACTIVE |
+					 BT_8821C_1ANT_SCOREBOARD_ONOFF,
+					 true);
+#endif
+		btcoexist->stop_coex_dm = false;
+	}
+}
+
+
+void ex_halbtc8821c1ant_coex_dm_reset(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], *****************Coex DM Reset*****************\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821c1ant_init_hw_config(btcoexist, false, false);
+	halbtc8821c1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8821c1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	boolean wifi_busy = false;
+	u16 bt_scoreboard_val = 0;
+	u32 bt_patch_ver;
+	static u8 cnt = 0;
+	boolean bt_relink_finish = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ************* Periodical *************\n");
+	BTC_TRACE(trace_buf);
+
+#if (BT_AUTO_REPORT_ONLY_8821C_1ANT == 0)
+	halbtc8821c1ant_query_bt_info(btcoexist);
+
+#endif
+
+	halbtc8821c1ant_monitor_bt_ctr(btcoexist);
+	halbtc8821c1ant_monitor_wifi_ctr(btcoexist);
+
+	halbtc8821c1ant_monitor_bt_enable_disable(btcoexist);
+
+#if 0
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	/* halbtc8821c1ant_read_score_board(btcoexist, &bt_scoreboard_val); */
+
+	if (wifi_busy) {
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+				BT_8821C_1ANT_SCOREBOARD_UNDERTEST, true);
+		/*
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+					 BT_8821C_1ANT_SCOREBOARD_WLBUSY, true);
+
+		if (bt_scoreboard_val & BIT(6))
+			halbtc8821c1ant_query_bt_info(btcoexist); */
+	} else {
+		halbtc8821c1ant_post_state_to_bt(btcoexist,
+					BT_8821C_1ANT_SCOREBOARD_UNDERTEST, false);
+	}
+#endif
+
+	if (coex_sta->bt_relink_downcount != 0) {
+		coex_sta->bt_relink_downcount--;
+
+		if (coex_sta->bt_relink_downcount == 0)
+			bt_relink_finish = true;
+	}
+
+	/* for 4-way, DHCP, EAPOL packet */
+	if (coex_sta->specific_pkt_period_cnt > 0) {
+
+		coex_sta->specific_pkt_period_cnt--;
+
+		if ((coex_sta->specific_pkt_period_cnt == 0) &&
+		    (coex_sta->wifi_is_high_pri_task))
+			coex_sta->wifi_is_high_pri_task = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ***************** Hi-Pri Task = %s\n",
+			    (coex_sta->wifi_is_high_pri_task ? "Yes" :
+			     "No"));
+		BTC_TRACE(trace_buf);
+
+	}
+
+	if (!coex_sta->bt_disabled) {
+		if (coex_sta->bt_coex_supported_feature == 0)
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_FEATURE,
+						&coex_sta->bt_coex_supported_feature);
+
+		if ((coex_sta->bt_coex_supported_version == 0) ||
+		    (coex_sta->bt_coex_supported_version == 0xffff))
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION,
+						&coex_sta->bt_coex_supported_version);
+
+		if (coex_sta->bt_reg_vendor_ac == 0xffff)
+			coex_sta->bt_reg_vendor_ac = (u16)(
+					btcoexist->btc_get_bt_reg(btcoexist, 3,
+					0xac) & 0xffff);
+
+		if (coex_sta->bt_reg_vendor_ae == 0xffff)
+			coex_sta->bt_reg_vendor_ae = (u16)(
+					btcoexist->btc_get_bt_reg(btcoexist, 3,
+					0xae) & 0xffff);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER,
+						&bt_patch_ver);
+		btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+
+		if (coex_sta->num_of_profile > 0) {
+			cnt++;
+
+			if (cnt >= 3) {
+				btcoexist->btc_get_bt_afh_map_from_bt(btcoexist, 0,
+					&coex_sta->bt_afh_map[0]);
+				cnt = 0;
+			}
+		}
+	}
+
+	if (halbtc8821c1ant_is_wifibt_status_changed(btcoexist) || (bt_relink_finish))
+		halbtc8821c1ant_run_coexist_mechanism(btcoexist);
+
+}
+
+/*#pragma optimize( "", off )*/
+void ex_halbtc8821c1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+}
+
+
+void ex_halbtc8821c1ant_display_ant_detection(IN struct btc_coexist *btcoexist)
+{
+
+}
+
+void ex_halbtc8821c1ant_antenna_isolation(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+
+}
+
+void ex_halbtc8821c1ant_psd_scan(IN struct btc_coexist *btcoexist,
+		 IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+
+}
+
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
+
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8821c1ant.h
@@ -0,0 +1,483 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821C_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8821C 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_8821C_1ANT_COEX_DBG					0
+#define	BT_AUTO_REPORT_ONLY_8821C_1ANT				1
+
+#define	BT_INFO_8821C_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8821C_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8821C_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8821C_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8821C_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8821C_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8821C_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8821C_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8821C_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+	(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8821C_1ANT		2
+
+#define  BT_8821C_1ANT_WIFI_NOISY_THRESH							30   /* max: 255 */
+#define  BT_8821C_1ANT_DEFAULT_ISOLATION						15	 /*  unit: dB */
+
+
+/* for Antenna detection */
+#define	BT_8821C_1ANT_ANTDET_PSDTHRES_BACKGROUND					50
+#define	BT_8821C_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION				70
+#define	BT_8821C_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION			55
+#define	BT_8821C_1ANT_ANTDET_PSDTHRES_1ANT							35
+#define	BT_8821C_1ANT_ANTDET_RETRY_INTERVAL							10	/* retry timer if ant det is fail, unit: second */
+#define	BT_8821C_1ANT_ANTDET_SWEEPPOINT_DELAY							60000
+#define	BT_8821C_1ANT_ANTDET_ENABLE									0
+#define	BT_8821C_1ANT_ANTDET_BTTXTIME									100
+#define	BT_8821C_1ANT_ANTDET_BTTXCHANNEL								39
+#define	BT_8821C_1ANT_ANTDET_PSD_SWWEEPCOUNT						50
+
+#define	BT_8821C_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT		30000
+
+enum bt_8821c_1ant_signal_state {
+	BT_8821C_1ANT_SIG_STA_SET_TO_LOW		= 0x0,
+	BT_8821C_1ANT_SIG_STA_SET_BY_HW		= 0x0,
+	BT_8821C_1ANT_SIG_STA_SET_TO_HIGH		= 0x1,
+	BT_8821C_1ANT_SIG_STA_MAX
+};
+
+enum bt_8821c_1ant_path_ctrl_owner {
+	BT_8821C_1ANT_PCO_BTSIDE		= 0x0,
+	BT_8821C_1ANT_PCO_WLSIDE	= 0x1,
+	BT_8821C_1ANT_PCO_MAX
+};
+
+enum bt_8821c_1ant_gnt_ctrl_type {
+	BT_8821C_1ANT_GNT_TYPE_CTRL_BY_PTA		= 0x0,
+	BT_8821C_1ANT_GNT_TYPE_CTRL_BY_SW		= 0x1,
+	BT_8821C_1ANT_GNT_TYPE_MAX
+};
+
+enum bt_8821c_1ant_gnt_ctrl_block {
+	BT_8821C_1ANT_GNT_BLOCK_RFC_BB		= 0x0,
+	BT_8821C_1ANT_GNT_BLOCK_RFC			= 0x1,
+	BT_8821C_1ANT_GNT_BLOCK_BB			= 0x2,
+	BT_8821C_1ANT_GNT_BLOCK_MAX
+};
+
+enum bt_8821c_1ant_lte_coex_table_type {
+	BT_8821C_1ANT_CTT_WL_VS_LTE			= 0x0,
+	BT_8821C_1ANT_CTT_BT_VS_LTE			= 0x1,
+	BT_8821C_1ANT_CTT_MAX
+};
+
+enum bt_8821c_1ant_lte_break_table_type {
+	BT_8821C_1ANT_LBTT_WL_BREAK_LTE			= 0x0,
+	BT_8821C_1ANT_LBTT_BT_BREAK_LTE				= 0x1,
+	BT_8821C_1ANT_LBTT_LTE_BREAK_WL			= 0x2,
+	BT_8821C_1ANT_LBTT_LTE_BREAK_BT				= 0x3,
+	BT_8821C_1ANT_LBTT_MAX
+};
+
+enum bt_info_src_8821c_1ant {
+	BT_INFO_SRC_8821C_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8821C_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8821C_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8821C_1ANT_MAX
+};
+
+enum bt_8821c_1ant_bt_status {
+	BT_8821C_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8821C_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8821C_1ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8821C_1ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8821C_1ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8821C_1ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8821C_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8821c_1ant_wifi_status {
+	BT_8821C_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8821C_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8821C_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8821C_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT				= 0x3,
+	BT_8821C_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8821C_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8821C_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8821c_1ant_coex_algo {
+	BT_8821C_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8821C_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8821C_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8821C_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8821C_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8821C_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8821C_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8821C_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8821C_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8821C_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8821C_1ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8821C_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+enum bt_8821c_1ant_ext_ant_switch_type {
+	BT_8821C_1ANT_EXT_ANT_SWITCH_USE_DPDT		= 0x0,
+	BT_8821C_1ANT_EXT_ANT_SWITCH_USE_SPDT		= 0x1,
+	BT_8821C_1ANT_EXT_ANT_SWITCH_NONE			= 0x2,
+	BT_8821C_1ANT_EXT_ANT_SWITCH_MAX
+};
+
+
+enum bt_8821c_1ant_ext_ant_switch_ctrl_type {
+	BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW	= 0x0,
+	BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_PTA		= 0x1,
+	BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_ANTDIV	= 0x2,
+	BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_MAC		= 0x3,
+	BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_BY_BT		= 0x4,
+	BT_8821C_1ANT_EXT_ANT_SWITCH_CTRL_MAX
+};
+
+enum bt_8821c_1ant_ext_ant_switch_pos_type {
+	BT_8821C_1ANT_EXT_ANT_SWITCH_TO_BT			= 0x0,
+	BT_8821C_1ANT_EXT_ANT_SWITCH_TO_WLG			= 0x1,
+	BT_8821C_1ANT_EXT_ANT_SWITCH_TO_WLA			= 0x2,
+	BT_8821C_1ANT_EXT_ANT_SWITCH_TO_NOCARE		= 0x3,
+	BT_8821C_1ANT_EXT_ANT_SWITCH_TO_MAX
+};
+
+enum bt_8821c_1ant_ext_band_switch_pos_type {
+	BT_8821C_1ANT_EXT_BAND_SWITCH_TO_WLG			= 0x0,
+	BT_8821C_1ANT_EXT_BAND_SWITCH_TO_WLA			= 0x1,
+	BT_8821C_1ANT_EXT_BAND_SWITCH_TO_MAX
+};
+
+enum bt_8821c_1ant_int_block {
+	BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLG_OF_BTG			= 0x0,
+	BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLG_OF_WLAG		= 0x1,
+	BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLA_OF_WLAG		= 0x2,
+	BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_MAX
+};
+
+enum bt_8821c_1ant_phase {
+	BT_8821C_1ANT_PHASE_COEX_INIT								= 0x0,
+	BT_8821C_1ANT_PHASE_WLANONLY_INIT							= 0x1,
+	BT_8821C_1ANT_PHASE_WLAN_OFF								= 0x2,
+	BT_8821C_1ANT_PHASE_2G_RUNTIME								= 0x3,
+	BT_8821C_1ANT_PHASE_5G_RUNTIME								= 0x4,
+	BT_8821C_1ANT_PHASE_BTMPMODE									= 0x5,
+	BT_8821C_1ANT_PHASE_ANTENNA_DET								= 0x6,
+	BT_8821C_1ANT_PHASE_COEX_POWERON							= 0x7,
+	BT_8821C_1ANT_PHASE_MAX
+};
+
+enum bt_8821c_1ant_Scoreboard {
+	BT_8821C_1ANT_SCOREBOARD_ACTIVE								= BIT(0),
+	BT_8821C_1ANT_SCOREBOARD_ONOFF								= BIT(1),
+	BT_8821C_1ANT_SCOREBOARD_SCAN								= BIT(2),
+	BT_8821C_1ANT_SCOREBOARD_UNDERTEST							= BIT(3),
+	BT_8821C_1ANT_SCOREBOARD_WLBUSY								= BIT(6)
+};
+
+struct coex_dm_8821c_1ant {
+	/* hw setting */
+	u32		pre_ant_pos_type;
+	u32		cur_ant_pos_type;
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u32		pre_ext_ant_switch_status;
+	u32		cur_ext_ant_switch_status;
+
+	u8		pre_ext_band_switch_status;
+	u8		cur_ext_band_switch_status;
+
+	u8		pre_int_block_status;
+	u8		cur_int_block_status;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8821c_1ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+	u8					num_of_profile;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	boolean             is_hiPri_rx_overhead;
+	s8					bt_rssi;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	u8					bt_info_c2h[BT_INFO_SRC_8821C_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8821C_1ANT_MAX];
+	boolean					bt_whck_test;
+	boolean					c2h_bt_inquiry_page;
+	boolean				c2h_bt_remote_name_req;
+	boolean					c2h_bt_page;				/* Add for win8.1 page out issue */
+	boolean					wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+
+	u8					bt_info_ext;
+	u8					bt_info_ext2;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+	u8					bt_retry_cnt;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_vht;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_vht;
+
+	boolean					cck_lock;
+	boolean					pre_ccklock;
+	boolean					cck_ever_lock;
+	u8					coex_table_type;
+
+	boolean					force_lps_on;
+
+	boolean					concurrent_rx_mode_on;
+
+	u16					score_board;
+	u8					isolation_btween_wb;   /* 0~ 50 */
+
+	u8					a2dp_bit_pool;
+	u8					cut_version;
+	boolean				acl_busy;
+	boolean				bt_create_connection;
+
+	u32					bt_coex_supported_feature;
+	u32					bt_coex_supported_version;
+
+	u8					bt_ble_scan_type;
+	u32					bt_ble_scan_para[3];
+
+	boolean				run_time_state;
+	boolean				freeze_coexrun_by_btinfo;
+
+	boolean				is_A2DP_3M;
+	boolean				voice_over_HOGP;
+	u8                  bt_info;
+	boolean				is_autoslot;
+	u8					forbidden_slot;
+	u8					hid_busy_num;
+	u8					hid_pair_cnt;
+
+	u32					cnt_RemoteNameReq;
+	u32					cnt_setupLink;
+	u32					cnt_ReInit;
+	u32					cnt_IgnWlanAct;
+	u32					cnt_Page;
+	u32					cnt_RoleSwitch;
+
+	u16					bt_reg_vendor_ac;
+	u16					bt_reg_vendor_ae;
+
+	boolean				is_setupLink;
+	u8					wl_noisy_level;
+	u32                 gnt_error_cnt;
+
+	u8					bt_afh_map[10];
+	u8					bt_relink_downcount;
+	boolean				is_tdma_btautoslot;
+	boolean				is_tdma_btautoslot_hang;
+};
+
+
+#define  BT_8821C_1ANT_EXT_BAND_SWITCH_USE_DPDT	0
+#define  BT_8821C_1ANT_EXT_BAND_SWITCH_USE_SPDT	1
+
+
+struct rfe_type_8821c_1ant {
+
+	u8			rfe_module_type;
+	boolean		ext_ant_switch_exist;
+	u8			ext_ant_switch_type;			/* 0:DPDT, 1:SPDT */
+	u8			ext_ant_switch_ctrl_polarity;		/*  iF 0: DPDT_P=0, DPDT_N=1 => BTG to Main, WL_A+G to Aux */
+
+	boolean		ext_band_switch_exist;
+	u8			ext_band_switch_type;			/* 0:DPDT, 1:SPDT */
+	u8			ext_band_switch_ctrl_polarity;
+
+	boolean		ant_at_main_port;
+
+	boolean		wlg_Locate_at_btg;				/*  If true:  WLG at BTG, If false: WLG at WLAG */
+
+	boolean		ext_ant_switch_diversity;		/* If diversity on */
+};
+
+#define  BT_8821C_1ANT_ANTDET_PSD_POINTS			256	/* MAX:1024 */
+#define  BT_8821C_1ANT_ANTDET_PSD_AVGNUM			1	/* MAX:3 */
+#define	BT_8821C_1ANT_ANTDET_BUF_LEN				16
+
+struct psdscan_sta_8821c_1ant {
+
+	u32			ant_det_bt_le_channel;  /* BT LE Channel ex:2412 */
+	u32			ant_det_bt_tx_time;
+	u32			ant_det_pre_psdscan_peak_val;
+	boolean			ant_det_is_ant_det_available;
+	u32			ant_det_psd_scan_peak_val;
+	boolean			ant_det_is_btreply_available;
+	u32			ant_det_psd_scan_peak_freq;
+
+	u8			ant_det_result;
+	u8			ant_det_peak_val[BT_8821C_1ANT_ANTDET_BUF_LEN];
+	u8			ant_det_peak_freq[BT_8821C_1ANT_ANTDET_BUF_LEN];
+	u32			ant_det_try_count;
+	u32			ant_det_fail_count;
+	u32			ant_det_inteval_count;
+	u32			ant_det_thres_offset;
+
+	u32			real_cent_freq;
+	s32			real_offset;
+	u32			real_span;
+
+	u32			psd_band_width;  /* unit: Hz */
+	u32			psd_point;		/* 128/256/512/1024 */
+	u32			psd_report[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_report_max_hold[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_start_point;
+	u32			psd_stop_point;
+	u32			psd_max_value_point;
+	u32			psd_max_value;
+	u32			psd_max_value2;
+	u32			psd_avg_value;   /* filter loop_max_value that below BT_8821C_1ANT_ANTDET_PSDTHRES_1ANT, and average the rest*/
+	u32			psd_loop_max_value[BT_8821C_1ANT_ANTDET_PSD_SWWEEPCOUNT];  /*max value in each loop */
+	u32			psd_start_base;
+	u32			psd_avg_num;	/* 1/8/16/32 */
+	u32			psd_gen_count;
+	boolean			is_AntDet_running;
+	boolean			is_psd_show_max_only;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8821c1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821c1ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821c1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8821c1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821c1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821c1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821c1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8821c1ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821c1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8821c1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821c1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821c1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8821c1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821c1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821c1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8821c1ant_coex_dm_reset(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821c1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821c1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821c1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+void ex_halbtc8821c1ant_antenna_isolation(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+
+void ex_halbtc8821c1ant_psd_scan(IN struct btc_coexist *btcoexist,
+		 IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+void ex_halbtc8821c1ant_display_ant_detection(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8821c1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8821c1ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8821c1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8821c1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8821c1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8821c1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8821c1ant_scan_notify(btcoexist, type)
+#define   ex_halbtc8821c1ant_switchband_notify(btcoexist,type)
+#define	ex_halbtc8821c1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8821c1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8821c1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8821c1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8821c1ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8821c1ant_halt_notify(btcoexist)
+#define	ex_halbtc8821c1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8821c1ant_coex_dm_reset(btcoexist)
+#define	ex_halbtc8821c1ant_periodical(btcoexist)
+#define	ex_halbtc8821c1ant_display_coex_info(btcoexist)
+#define	ex_halbtc8821c1ant_antenna_detection(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8821c1ant_antenna_isolation(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8821c1ant_psd_scan(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8821c1ant_display_ant_detection(btcoexist)
+#endif
+
+#endif
+
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8821c2ant.c
@@ -0,0 +1,5951 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8821C Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821C_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	*trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8821c_2ant		glcoex_dm_8821c_2ant;
+static struct  coex_dm_8821c_2ant	*coex_dm = &glcoex_dm_8821c_2ant;
+static struct  coex_sta_8821c_2ant		glcoex_sta_8821c_2ant;
+static struct  coex_sta_8821c_2ant	*coex_sta = &glcoex_sta_8821c_2ant;
+static struct  psdscan_sta_8821c_2ant	gl_psd_scan_8821c_2ant;
+static struct  psdscan_sta_8821c_2ant *psd_scan = &gl_psd_scan_8821c_2ant;
+static struct	rfe_type_8821c_2ant		gl_rfe_type_8821c_2ant;
+static struct	rfe_type_8821c_2ant		*rfe_type = &gl_rfe_type_8821c_2ant;
+
+const char *const glbt_info_src_8821c_2ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8821c_2ant = 20161107;
+u32	glcoex_ver_8821c_2ant = 0x0a;
+u32 glcoex_ver_btdesired_8821c_2ant = 0x0a;
+
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8821c2ant_
+ * ************************************************************ */
+u8 halbtc8821c2ant_bt_rssi_state(u8 *ppre_bt_rssi_state, u8 level_num,
+				 u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = *ppre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821C_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return *ppre_bt_rssi_state;
+		}
+
+		if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821C_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+			(*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8821C_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	*ppre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8821c2ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 *pprewifi_rssi_state, IN u8 level_num, IN u8 rssi_thresh,
+				   IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = *pprewifi_rssi_state;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((*pprewifi_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821C_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return *pprewifi_rssi_state;
+		}
+
+		if ((*pprewifi_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821C_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((*pprewifi_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+			(*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8821C_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	*pprewifi_rssi_state = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8821c2ant_coex_switch_threshold(IN struct btc_coexist *btcoexist,
+		IN u8 isolation_measuared)
+{
+	s8	interference_wl_tx = 0, interference_bt_tx = 0;
+
+
+	interference_wl_tx = BT_8821C_2ANT_WIFI_MAX_TX_POWER -
+			     isolation_measuared;
+	interference_bt_tx = BT_8821C_2ANT_BT_MAX_TX_POWER -
+			     isolation_measuared;
+
+
+
+	coex_sta->wifi_coex_thres		 = BT_8821C_2ANT_WIFI_RSSI_COEXSWITCH_THRES1;
+	coex_sta->wifi_coex_thres2	 = BT_8821C_2ANT_WIFI_RSSI_COEXSWITCH_THRES2;
+
+	coex_sta->bt_coex_thres		 = BT_8821C_2ANT_BT_RSSI_COEXSWITCH_THRES1;
+	coex_sta->bt_coex_thres2		 = BT_8821C_2ANT_BT_RSSI_COEXSWITCH_THRES2;
+
+
+	/*
+		coex_sta->wifi_coex_thres		= interference_wl_tx + BT_8821C_2ANT_WIFI_SIR_THRES1;
+		coex_sta->wifi_coex_thres2		= interference_wl_tx + BT_8821C_2ANT_WIFI_SIR_THRES2;
+
+		coex_sta->bt_coex_thres		= interference_bt_tx + BT_8821C_2ANT_BT_SIR_THRES1;
+		coex_sta->bt_coex_thres2		= interference_bt_tx + BT_8821C_2ANT_BT_SIR_THRES2;
+	*/
+
+
+
+
+
+	/*
+		if  ( BT_8821C_2ANT_WIFI_RSSI_COEXSWITCH_THRES1 < (isolation_measuared -
+					BT_8821C_2ANT_DEFAULT_ISOLATION) )
+			coex_sta->wifi_coex_thres	 = BT_8821C_2ANT_WIFI_RSSI_COEXSWITCH_THRES1;
+		else
+			coex_sta->wifi_coex_thres =  BT_8821C_2ANT_WIFI_RSSI_COEXSWITCH_THRES1 -  (isolation_measuared -
+					BT_8821C_2ANT_DEFAULT_ISOLATION);
+
+		if  ( BT_8821C_2ANT_BT_RSSI_COEXSWITCH_THRES1 < (isolation_measuared -
+					BT_8821C_2ANT_DEFAULT_ISOLATION) )
+			coex_sta->bt_coex_thres	 = BT_8821C_2ANT_BT_RSSI_COEXSWITCH_THRES1;
+		else
+			coex_sta->bt_coex_thres =  BT_8821C_2ANT_BT_RSSI_COEXSWITCH_THRES1 -  (isolation_measuared -
+					BT_8821C_2ANT_DEFAULT_ISOLATION);
+
+	*/
+}
+
+
+void halbtc8821c2ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+}
+
+void halbtc8821c2ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (coex_sta->bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], No query BT info because BT is disabled!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+void halbtc8821c2ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u8		num_of_bt_counter_chk = 0, cnt_slave = 0, cnt_overhead = 0,
+				cnt_autoslot_hang = 0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Hi-Pri Rx/Tx: %d/%d, Lo-Pri Rx/Tx: %d/%d\n",
+		    reg_hp_rx, reg_hp_tx, reg_lp_rx, reg_lp_tx);
+
+	BTC_TRACE(trace_buf);
+
+	if (BT_8821C_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+
+		if (coex_sta->high_priority_rx >= 15) {
+			if (cnt_overhead < 3)
+				cnt_overhead++;
+
+			if (cnt_overhead == 3)
+				coex_sta->is_hiPri_rx_overhead = true;
+
+		} else {
+			if (cnt_overhead > 0)
+				cnt_overhead--;
+
+			if (cnt_overhead == 0)
+				coex_sta->is_hiPri_rx_overhead = false;
+		}
+	}
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	if ((coex_sta->low_priority_tx > 1150)	&&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	if ((coex_sta->low_priority_rx >= 1150) &&
+	    (coex_sta->low_priority_rx >= coex_sta->low_priority_tx)
+	    && (!coex_sta->under_ips)
+	    && (!coex_sta->c2h_bt_inquiry_page)
+	    && ((bt_link_info->a2dp_exist) || (bt_link_info->pan_exist))) {
+		if (cnt_slave >= 2) {
+			bt_link_info->slave_role = true;
+			cnt_slave = 2;
+		} else
+			cnt_slave++;
+	} else {
+		if (cnt_slave == 0)	{
+			bt_link_info->slave_role = false;
+			cnt_slave = 0;
+		} else
+			cnt_slave--;
+	}
+
+	if (coex_sta->is_tdma_btautoslot) {
+		if ((coex_sta->low_priority_tx >= 1300) &&
+		(coex_sta->low_priority_rx <= 150)) {
+			if (cnt_autoslot_hang >= 2) {
+				coex_sta->is_tdma_btautoslot_hang = true;
+				cnt_autoslot_hang = 2;
+			} else
+				cnt_autoslot_hang++;
+		} else {
+			if (cnt_autoslot_hang == 0)	{
+				coex_sta->is_tdma_btautoslot_hang = false;
+				cnt_autoslot_hang = 0;
+			} else
+				cnt_autoslot_hang--;
+		}
+	}
+
+	if (!coex_sta->bt_disabled) {
+
+		if ((coex_sta->high_priority_tx == 0) &&
+		    (coex_sta->high_priority_rx == 0) &&
+		    (coex_sta->low_priority_tx == 0) &&
+		    (coex_sta->low_priority_rx == 0)) {
+			num_of_bt_counter_chk++;
+			if (num_of_bt_counter_chk >= 3) {
+				halbtc8821c2ant_query_bt_info(btcoexist);
+				num_of_bt_counter_chk = 0;
+			}
+		}
+	}
+
+}
+
+
+void halbtc8821c2ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+#if 1
+	s32 wifi_rssi = 0;
+	boolean wifi_busy = false, wifi_under_b_mode = false,
+		wifi_scan = false;
+	boolean bt_idle = false, wl_idle = false;
+	static u8 cck_lock_counter = 0, wl_noisy_count0 = 0,
+		  wl_noisy_count1 = 3, wl_noisy_count2 = 0;
+	u32 total_cnt, reg_val1, reg_val2, cck_cnt;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+			   &wifi_under_b_mode);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+
+	coex_sta->crc_ok_cck = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_CCK);
+	coex_sta->crc_ok_11g = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_LEGACY);
+	coex_sta->crc_ok_11n = btcoexist->btc_phydm_query_PHY_counter(
+				       btcoexist,
+				       PHYDM_INFO_CRC32_OK_HT);
+	coex_sta->crc_ok_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_OK_VHT);
+
+	coex_sta->crc_err_cck = btcoexist->btc_phydm_query_PHY_counter(
+					btcoexist, PHYDM_INFO_CRC32_ERROR_CCK);
+	coex_sta->crc_err_11g =  btcoexist->btc_phydm_query_PHY_counter(
+				 btcoexist, PHYDM_INFO_CRC32_ERROR_LEGACY);
+	coex_sta->crc_err_11n = btcoexist->btc_phydm_query_PHY_counter(
+					btcoexist, PHYDM_INFO_CRC32_ERROR_HT);
+	coex_sta->crc_err_11n_vht =
+		btcoexist->btc_phydm_query_PHY_counter(
+			btcoexist,
+			PHYDM_INFO_CRC32_ERROR_VHT);
+
+	cck_cnt = coex_sta->crc_ok_cck + coex_sta->crc_err_cck;
+
+	if ((coex_dm->bt_status ==
+	     BT_8821C_2ANT_BT_STATUS_NON_CONNECTED_IDLE) ||
+	    (coex_dm->bt_status ==
+	     BT_8821C_2ANT_BT_STATUS_CONNECTED_IDLE) ||
+	    (coex_sta->bt_disabled))
+		bt_idle = true;
+
+		if (cck_cnt > 250) {
+			if (wl_noisy_count2 < 3)
+				wl_noisy_count2++;
+
+			if (wl_noisy_count2 == 3) {
+				wl_noisy_count0 = 0;
+				wl_noisy_count1 = 0;
+			}
+
+		} else if (cck_cnt < 50) {
+			if (wl_noisy_count0 < 3)
+				wl_noisy_count0++;
+
+			if (wl_noisy_count0 == 3) {
+				wl_noisy_count1 = 0;
+				wl_noisy_count2 = 0;
+			}
+
+		} else {
+			if (wl_noisy_count1 < 3)
+				wl_noisy_count1++;
+
+			if (wl_noisy_count1 == 3) {
+				wl_noisy_count0 = 0;
+				wl_noisy_count2 = 0;
+			}
+		}
+
+		if (wl_noisy_count2 == 3)
+			coex_sta->wl_noisy_level = 2;
+		else if (wl_noisy_count1 == 3)
+			coex_sta->wl_noisy_level = 1;
+		else
+			coex_sta->wl_noisy_level = 0;
+
+	if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+		total_cnt = coex_sta->crc_ok_cck + coex_sta->crc_ok_11g
+				+ coex_sta->crc_ok_11n
+				+ coex_sta->crc_ok_11n_vht;
+
+		if ((coex_dm->bt_status ==
+		     BT_8821C_1ANT_BT_STATUS_ACL_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8821C_1ANT_BT_STATUS_ACL_SCO_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8821C_1ANT_BT_STATUS_SCO_BUSY)) {
+			if (coex_sta->crc_ok_cck > (total_cnt -
+						    coex_sta->crc_ok_cck)) {
+				if (cck_lock_counter < 3)
+					cck_lock_counter++;
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+	} else {
+		if (cck_lock_counter > 0)
+			cck_lock_counter--;
+	}
+
+	if (!coex_sta->pre_ccklock) {
+
+		if (cck_lock_counter >= 3)
+			coex_sta->cck_lock = true;
+		else
+			coex_sta->cck_lock = false;
+	} else {
+		if (cck_lock_counter == 0)
+			coex_sta->cck_lock = false;
+		else
+			coex_sta->cck_lock = true;
+	}
+
+	if (coex_sta->cck_lock)
+		coex_sta->cck_ever_lock = true;
+
+	coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+#endif
+}
+
+void halbtc8821c2ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+
+	struct	btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean			bt_hs_on = false;
+	boolean		bt_busy = false;
+
+	coex_sta->num_of_profile = 0;
+
+	/* set link exist status */
+	if (!(coex_sta->bt_info & BT_INFO_8821C_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (coex_sta->bt_info & BT_INFO_8821C_1ANT_B_FTP) {
+			coex_sta->pan_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->pan_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8821C_1ANT_B_A2DP) {
+			coex_sta->a2dp_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->a2dp_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8821C_1ANT_B_HID) {
+			coex_sta->hid_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->hid_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8821C_1ANT_B_SCO_ESCO) {
+			coex_sta->sco_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->sco_exist = false;
+
+	}
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+	bt_link_info->acl_busy = coex_sta->acl_busy;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+
+	if (coex_sta->bt_info & BT_INFO_8821C_2ANT_B_INQ_PAGE) {
+		coex_dm->bt_status = BT_8821C_2ANT_BT_STATUS_INQ_PAGE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Inq/page!!!\n");
+	} else if (!(coex_sta->bt_info & BT_INFO_8821C_2ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8821C_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+	} else if (coex_sta->bt_info == BT_INFO_8821C_2ANT_B_CONNECTION) {
+		/* connection exists but no busy */
+		coex_dm->bt_status = BT_8821C_2ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+	} else if (((coex_sta->bt_info & BT_INFO_8821C_2ANT_B_SCO_ESCO) ||
+		    (coex_sta->bt_info & BT_INFO_8821C_2ANT_B_SCO_BUSY)) &&
+		   (coex_sta->bt_info & BT_INFO_8821C_2ANT_B_ACL_BUSY)) {
+		coex_dm->bt_status = BT_8821C_2ANT_BT_STATUS_ACL_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL SCO busy!!!\n");
+	} else if ((coex_sta->bt_info & BT_INFO_8821C_2ANT_B_SCO_ESCO) ||
+		   (coex_sta->bt_info & BT_INFO_8821C_2ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8821C_2ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+	} else if (coex_sta->bt_info & BT_INFO_8821C_2ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8821C_2ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+	} else {
+		coex_dm->bt_status = BT_8821C_2ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+	}
+
+	BTC_TRACE(trace_buf);
+
+	if ((BT_8821C_2ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8821C_2ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8821C_2ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+}
+
+void halbtc8821c2ant_update_wifi_channel_info(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] =
+			0x1;  /* enable BT AFH skip WL channel for 8821c because BT Rx LO interference */
+		/* h2c_parameter[0] = 0x0; */
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+
+}
+
+void halbtc8821c2ant_set_fw_dac_swing_level(IN struct btc_coexist *btcoexist,
+		IN u8 dac_swing_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	/* There are several type of dacswing */
+	/* 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6 */
+	h2c_parameter[0] = dac_swing_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
+}
+
+void halbtc8821c2ant_fw_dac_swing_lvl(IN struct btc_coexist *btcoexist,
+			      IN boolean force_exec, IN u8 fw_dac_swing_lvl)
+{
+	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swing_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_fw_dac_swing_lvl ==
+		    coex_dm->cur_fw_dac_swing_lvl)
+			return;
+	}
+
+	halbtc8821c2ant_set_fw_dac_swing_level(btcoexist,
+					       coex_dm->cur_fw_dac_swing_lvl);
+
+	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
+}
+
+void halbtc8821c2ant_set_fw_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				       IN u8 dec_bt_pwr_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = dec_bt_pwr_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x62, 1, h2c_parameter);
+}
+
+void halbtc8821c2ant_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN u8 dec_bt_pwr_lvl)
+{
+	coex_dm->cur_bt_dec_pwr_lvl = dec_bt_pwr_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_dec_pwr_lvl == coex_dm->cur_bt_dec_pwr_lvl)
+			return;
+	}
+	halbtc8821c2ant_set_fw_dec_bt_pwr(btcoexist,
+					  coex_dm->cur_bt_dec_pwr_lvl);
+
+	coex_dm->pre_bt_dec_pwr_lvl = coex_dm->cur_bt_dec_pwr_lvl;
+}
+
+
+void halbtc8821c2ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+
+#if 1
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra ==
+		    coex_dm->cur_low_penalty_ra)
+			return;
+	}
+
+	if (low_penalty_ra)
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 15);
+	else
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 0);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+
+#endif
+
+}
+
+
+void halbtc8821c2ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8821c2ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8821c2ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8821c2ant_write_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16				bitpos,
+	IN	boolean		state
+)
+{
+
+	static u16 originalval = 0x8002;
+
+	if (state)
+		originalval = originalval | bitpos;
+	else
+		originalval = originalval & (~bitpos);
+
+
+	btcoexist->btc_write_2byte(btcoexist, 0xaa, originalval);
+
+}
+
+void halbtc8821c2ant_read_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN   u16				*score_board_val
+)
+{
+
+	*score_board_val = (btcoexist->btc_read_2byte(btcoexist,
+			    0xaa)) & 0x7fff;
+}
+
+
+void halbtc8821c2ant_post_state_to_bt(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16						type,
+	IN  boolean                 state
+)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], halbtc8821c2ant_post_state_to_bt: type = %d, state =%d\n",
+		type, state);
+	BTC_TRACE(trace_buf);
+
+	halbtc8821c2ant_write_score_board(btcoexist, (u16) type, state);
+}
+
+
+boolean halbtc8821c2ant_is_wifibt_status_changed(IN struct btc_coexist
+		*btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false, pre_bt_off = false,
+			pre_bt_slave = false;
+	static u8 pre_hid_busy_num = 0, pre_wl_noisy_level = 0;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (coex_sta->bt_disabled != pre_bt_off) {
+		pre_bt_off = coex_sta->bt_disabled;
+
+		if (coex_sta->bt_disabled)
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+		else
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is enabled !!\n");
+
+		BTC_TRACE(trace_buf);
+
+		coex_sta->bt_coex_supported_feature = 0;
+		coex_sta->bt_coex_supported_version = 0;
+		coex_sta->bt_ble_scan_type = 0;
+		coex_sta->bt_ble_scan_para[0] = 0;
+		coex_sta->bt_ble_scan_para[1] = 0;
+		coex_sta->bt_ble_scan_para[2] = 0;
+		coex_sta->bt_reg_vendor_ac = 0xffff;
+		coex_sta->bt_reg_vendor_ae = 0xffff;
+		return true;
+	}
+
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+
+			if (wifi_busy)
+				halbtc8821c2ant_post_state_to_bt(btcoexist,
+						BT_8821C_2ANT_SCOREBOARD_UNDERTEST, true);
+			else
+				halbtc8821c2ant_post_state_to_bt(btcoexist,
+						BT_8821C_2ANT_SCOREBOARD_UNDERTEST, false);
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+		if (coex_sta->wl_noisy_level != pre_wl_noisy_level) {
+			pre_wl_noisy_level = coex_sta->wl_noisy_level;
+			return true;
+		}
+	}
+
+	if (!coex_sta->bt_disabled) {
+		if (coex_sta->hid_busy_num != pre_hid_busy_num) {
+			pre_hid_busy_num = coex_sta->hid_busy_num;
+			return true;
+		}
+	}
+
+	if (bt_link_info->slave_role != pre_bt_slave) {
+		pre_bt_slave = bt_link_info->slave_role;
+		return true;
+	}
+
+	return false;
+}
+
+void halbtc8821c2ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false, wifi_under_5g = false;
+	u16			u16tmp;
+
+	/* This function check if bt is disabled */
+#if 0
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+
+
+#else
+
+	/* Read BT on/off status from scoreboard[1], enable this only if BT patch support this feature */
+	halbtc8821c2ant_read_score_board(btcoexist,	&u16tmp);
+
+	bt_active = u16tmp & BIT(1);
+
+
+#endif
+
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	} else {
+
+		bt_disable_cnt++;
+		if (bt_disable_cnt >= 10) {
+			bt_disabled = true;
+			bt_disable_cnt = 10;
+		}
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if ((wifi_under_5g) || (bt_disabled))
+		halbtc8821c2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, false);
+	else
+		halbtc8821c2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, true);
+
+
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+	}
+
+}
+
+void halbtc8821c2ant_enable_gnt_to_gpio(IN struct btc_coexist *btcoexist,
+					boolean isenable)
+{
+#if BT_8821C_2ANT_COEX_DBG
+	static u8			bitVal[5] = {0, 0, 0, 0, 0};
+	static boolean		state = false;
+	/*
+		if (state ==isenable)
+			return;
+		else
+			state = isenable;
+	*/
+	if (isenable) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], enable_gnt_to_gpio!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* enable GNT_WL, GNT_BT to GPIO for debug */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x1);
+
+		/* store original value */
+		bitVal[0] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x66) & BIT(4)) >> 4;	/*0x66[4] */
+		bitVal[1] = (btcoexist->btc_read_1byte(btcoexist,
+					       0x67) & BIT(0));		/*0x66[8] */
+		bitVal[2] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x42) & BIT(3)) >> 3;  /*0x40[19] */
+		bitVal[3] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x65) & BIT(7)) >> 7;  /*0x64[15] */
+		bitVal[4] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x72) & BIT(2)) >> 2;  /*0x70[18] */
+
+		/*  switch GPIO Mux */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x66, BIT(4),
+						   0x0);  /*0x66[4] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, BIT(0),
+						   0x0);  /*0x66[8] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x42, BIT(3),
+						   0x0);  /*0x40[19] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x65, BIT(7),
+						   0x0);  /*0x64[15] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x72, BIT(2),
+						   0x0);  /*0x70[18] = 0 */
+
+
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], disable_gnt_to_gpio!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x0);
+
+		/*  Restore original value */
+		/*  switch GPIO Mux */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x66, BIT(4),
+						   bitVal[0]);  /*0x66[4] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, BIT(0),
+						   bitVal[1]);  /*0x66[8] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x42, BIT(3),
+					   bitVal[2]);  /*0x40[19] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x65, BIT(7),
+					   bitVal[3]);  /*0x64[15] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x72, BIT(2),
+					   bitVal[4]);  /*0x70[18] = 0 */
+	}
+
+#endif
+}
+
+u32 halbtc8821c2ant_ltecoex_indirect_read_reg(IN struct btc_coexist *btcoexist,
+		IN u16 reg_addr)
+{
+	u32 j = 0;
+
+
+	/* wait for ready bit before access 0x1700		 */
+	btcoexist->btc_write_4byte(btcoexist, 0x1700, 0x800F0000 | reg_addr);
+
+	do {
+		j++;
+	} while (((btcoexist->btc_read_1byte(btcoexist,
+					     0x1703)&BIT(5)) == 0) &&
+		 (j < BT_8821C_2ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+
+
+	return btcoexist->btc_read_4byte(btcoexist,
+					 0x1708);  /* get read data */
+
+}
+
+void halbtc8821c2ant_ltecoex_indirect_write_reg(IN struct btc_coexist
+		*btcoexist,
+		IN u16 reg_addr, IN u32 bit_mask, IN u32 reg_value)
+{
+	u32 val, i = 0, j = 0, bitpos = 0;
+
+
+	if (bit_mask == 0x0)
+		return;
+	if (bit_mask == 0xffffffff) {
+		btcoexist->btc_write_4byte(btcoexist, 0x1704,
+					   reg_value); /* put write data */
+
+		/* wait for ready bit before access 0x1700 */
+		do {
+			j++;
+		} while (((btcoexist->btc_read_1byte(btcoexist,
+						     0x1703)&BIT(5)) == 0) &&
+			(j < BT_8821C_2ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+
+
+		btcoexist->btc_write_4byte(btcoexist, 0x1700,
+					   0xc00F0000 | reg_addr);
+	} else {
+		for (i = 0; i <= 31; i++) {
+			if (((bit_mask >> i) & 0x1) == 0x1) {
+				bitpos = i;
+				break;
+			}
+		}
+
+		/* read back register value before write */
+		val = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist,
+				reg_addr);
+		val = (val & (~bit_mask)) | (reg_value << bitpos);
+
+		btcoexist->btc_write_4byte(btcoexist, 0x1704,
+					   val); /* put write data */
+
+		/* wait for ready bit before access 0x7c0		 */
+		do {
+			j++;
+		} while (((btcoexist->btc_read_1byte(btcoexist,
+						     0x1703)&BIT(5)) == 0) &&
+			(j < BT_8821C_2ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+
+
+		btcoexist->btc_write_4byte(btcoexist, 0x1700,
+					   0xc00F0000 | reg_addr);
+
+	}
+
+}
+
+void halbtc8821c2ant_ltecoex_enable(IN struct btc_coexist *btcoexist,
+				    IN boolean enable)
+{
+	u8 val;
+
+	val = (enable) ? 1 : 0;
+	halbtc8821c2ant_ltecoex_indirect_write_reg(btcoexist, 0x38, 0x80,
+			val);  /* 0x38[7] */
+
+}
+
+void halbtc8821c2ant_ltecoex_pathcontrol_owner(IN struct btc_coexist *btcoexist,
+		IN boolean wifi_control)
+{
+	u8 val;
+
+	val = (wifi_control) ? 1 : 0;
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x4,
+					   val); /* 0x70[26] */
+
+}
+
+void halbtc8821c2ant_ltecoex_set_gnt_bt(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, val_orig = 0;
+
+	if (!sw_control)
+		val = 0x0;
+	else if (state & 0x1)
+		val = 0x3;
+	else
+		val = 0x1;
+
+	val_orig = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist,
+			0x38);
+
+	switch (control_block) {
+	case BT_8821C_2ANT_GNT_BLOCK_RFC_BB:
+	default:
+		val = ((val << 14) | (val << 10)) | (val_orig & 0xffff33ff);
+		break;
+	case BT_8821C_2ANT_GNT_BLOCK_RFC:
+		val = (val << 14) | (val_orig & 0xffff3fff);
+		break;
+	case BT_8821C_2ANT_GNT_BLOCK_BB:
+		val = (val << 10) | (val_orig & 0xfffff3ff);
+		break;
+	}
+
+	halbtc8821c2ant_ltecoex_indirect_write_reg(btcoexist,
+			0x38, 0xffffffff, val);
+}
+
+void halbtc8821c2ant_ltecoex_set_gnt_wl(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, val_orig = 0;
+
+	if (!sw_control)
+		val = 0x0;
+	else if (state & 0x1)
+		val = 0x3;
+	else
+		val = 0x1;
+
+	val_orig = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist,
+			0x38);
+
+	switch (control_block) {
+	case BT_8821C_2ANT_GNT_BLOCK_RFC_BB:
+	default:
+		val = ((val << 12) | (val << 8)) | (val_orig & 0xffffccff);
+		break;
+	case BT_8821C_2ANT_GNT_BLOCK_RFC:
+		val = (val << 12) | (val_orig & 0xffffcfff);
+		break;
+	case BT_8821C_2ANT_GNT_BLOCK_BB:
+		val = (val << 8) | (val_orig & 0xfffffcff);
+		break;
+	}
+
+	halbtc8821c2ant_ltecoex_indirect_write_reg(btcoexist,
+			0x38, 0xffffffff, val);
+}
+
+void halbtc8821c2ant_ltecoex_set_coex_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u16 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8821C_2ANT_CTT_WL_VS_LTE:
+		reg_addr = 0xa0;
+		break;
+	case BT_8821C_2ANT_CTT_BT_VS_LTE:
+		reg_addr = 0xa4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8821c2ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xffff, table_content); /* 0xa0[15:0] or 0xa4[15:0] */
+
+
+}
+
+
+void halbtc8821c2ant_ltecoex_set_break_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u8 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8821C_2ANT_LBTT_WL_BREAK_LTE:
+		reg_addr = 0xa8;
+		break;
+	case BT_8821C_2ANT_LBTT_BT_BREAK_LTE:
+		reg_addr = 0xac;
+		break;
+	case BT_8821C_2ANT_LBTT_LTE_BREAK_WL:
+		reg_addr = 0xb0;
+		break;
+	case BT_8821C_2ANT_LBTT_LTE_BREAK_BT:
+		reg_addr = 0xb4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8821c2ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xff, table_content); /* 0xa8[15:0] or 0xb4[15:0] */
+
+
+}
+
+void halbtc8821c2ant_set_wltoggle_coex_table(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec,  IN u8 interval,
+		IN u8 val0x6c4_b0, IN u8 val0x6c4_b1, IN u8 val0x6c4_b2,
+		IN u8 val0x6c4_b3)
+{
+	static u8 pre_h2c_parameter[6] = {0};
+	u8	cur_h2c_parameter[6] = {0};
+	u8 i, match_cnt = 0;
+
+	cur_h2c_parameter[0] = 0x7;	/* op_code, 0x7= wlan toggle slot*/
+
+	cur_h2c_parameter[1] = interval;
+	cur_h2c_parameter[2] = val0x6c4_b0;
+	cur_h2c_parameter[3] = val0x6c4_b1;
+	cur_h2c_parameter[4] = val0x6c4_b2;
+	cur_h2c_parameter[5] = val0x6c4_b3;
+
+	if (!force_exec) {
+		for (i = 1; i <= 5; i++) {
+			if (cur_h2c_parameter[i] != pre_h2c_parameter[i])
+				break;
+
+			match_cnt++;
+		}
+
+		if (match_cnt == 5)
+			return;
+	}
+
+	for (i = 1; i <= 5; i++)
+		pre_h2c_parameter[i] = cur_h2c_parameter[i];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, cur_h2c_parameter);
+}
+
+
+
+void halbtc8821c2ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8821c2ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8821c2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8821c2ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	u32	break_table;
+	u8	select_table;
+
+	coex_sta->coex_table_type = type;
+
+	if (coex_sta->concurrent_rx_mode_on == true) {
+		break_table = 0xf0ffffff;  /* set WL hi-pri can break BT */
+		select_table =
+			0xb;		/* set Tx response = Hi-Pri (ex: Transmitting ACK,BA,CTS) */
+	} else {
+		break_table = 0xffffff;
+		select_table = 0x3;
+	}
+
+	switch (type) {
+	case 0:
+		halbtc8821c2ant_coex_table(btcoexist, force_exec,
+			   0xffffffff, 0xffffffff, break_table, select_table);
+		break;
+	case 1:
+		halbtc8821c2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0x5a5a5a5a, break_table, select_table);
+		break;
+	case 2:
+		halbtc8821c2ant_coex_table(btcoexist, force_exec,
+			   0x5a5a5a5a, 0x5a5a5a5a, break_table, select_table);
+		break;
+	case 3:
+		halbtc8821c2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0x5a5a5a5a, break_table, select_table);
+		break;
+	case 4:
+		halbtc8821c2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0x5a5a5a5a, break_table, select_table);
+		break;
+	case 5:
+		halbtc8821c2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0x55555555, break_table, select_table);
+		break;
+	case 6:
+		halbtc8821c2ant_coex_table(btcoexist, force_exec,
+			   0xa5555555, 0xfafafafa, break_table, select_table);
+		break;
+	case 7:
+		halbtc8821c2ant_coex_table(btcoexist, force_exec,
+			   0xa5555555, 0xaa5a5a5a, break_table, select_table);
+		break;
+	case 8:
+		halbtc8821c2ant_coex_table(btcoexist, force_exec,
+			   0xa5555555, 0xfafafafa, break_table, select_table);
+		break;
+	case 9:
+		halbtc8821c2ant_coex_table(btcoexist, force_exec,
+			   0x5a5a5a5a, 0xaaaa5aaa, break_table, select_table);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8821c2ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable) {
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8821c2ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8821c2ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8821c2ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8821c2ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8821c2ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8821c2ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0, 0, 0, 0x40, 0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			/*halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			/*halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);*/
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8821c2ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8821c2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8821c2ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8821c2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+
+
+void halbtc8821c2ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	if (byte5 & BIT(2))
+		coex_sta->is_tdma_btautoslot = true;
+	else
+		coex_sta->is_tdma_btautoslot = false;
+
+	/* release bt-auto slot for auto-slot hang is detected!! */
+	if (coex_sta->is_tdma_btautoslot)
+		if ((coex_sta->is_tdma_btautoslot_hang) ||
+			(bt_link_info->slave_role))
+			byte5 = byte5 & 0xfb;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8821c2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0,
+							 0x0);
+		}
+	} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+
+		halbtc8821c2ant_power_save_state(
+			btcoexist, BTC_PS_LPS_ON, 0x50,
+			0x4);
+	} else {
+		halbtc8821c2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0,
+						 0x0);
+	}
+
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8821c2ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	static u8			psTdmaByte4Modify = 0x0, pre_psTdmaByte4Modify = 0x0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	/* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+	if (bt_link_info->slave_role)
+		psTdmaByte4Modify = 0x1;
+	else
+		psTdmaByte4Modify = 0x0;
+
+	if (pre_psTdmaByte4Modify != psTdmaByte4Modify) {
+		force_exec = true;
+		pre_psTdmaByte4Modify = psTdmaByte4Modify;
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Skip TDMA because no change TDMA(%s, %d)\n",
+				    (coex_dm->cur_ps_tdma_on ? "on" : "off"),
+				    coex_dm->cur_ps_tdma);
+			BTC_TRACE(trace_buf);
+			return;
+		}
+	}
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+
+	if (turn_on) {
+		switch (type) {
+		case 1:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x10, 0x03, 0x91,
+						      0x54 | psTdmaByte4Modify);
+			break;
+		case 2:
+		default:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x03, 0x11,
+						      0x11 | psTdmaByte4Modify);
+			break;
+		case 3:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x3a, 0x3, 0x91,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 4:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x21, 0x3, 0x91,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 5:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x3, 0x91,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 6:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x10, 0x3, 0x91,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 7:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x20, 0x3, 0x91,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 8:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x15, 0x03, 0x11,
+						      0x11);
+			break;
+		case 10:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x30, 0x03, 0x11,
+						      0x10);
+			break;
+		case 11:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x03, 0x11,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 12:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x03, 0x11, 0x11);
+			break;
+		case 13:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x1c, 0x03, 0x11,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 14:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x20, 0x03, 0x11,
+						      0x11);
+			break;
+		case 15:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x10, 0x03, 0x11,
+						      0x14);
+			break;
+		case 16:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x10, 0x03, 0x11,
+						      0x15);
+			break;
+		case 21:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x30, 0x03, 0x11,
+						      0x10);
+			break;
+		case 22:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11,
+						      0x10);
+			break;
+		case 23:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+							0x10, 0x03, 0x11,
+							0x10);
+			break;
+		case 51:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x10, 0x03, 0x91,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 101:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x10, 0x03, 0x10,
+						      0x54 | psTdmaByte4Modify);
+			break;
+		case 102:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x03, 0x11,
+						      0x11 | psTdmaByte4Modify);
+			break;
+		case 103:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x3a, 0x3, 0x10,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 104:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x21, 0x3, 0x10,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 105:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x25, 0x3, 0x10,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 106:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x10, 0x3, 0x10,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 107:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x20, 0x3, 0x10,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 108:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 109:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x55,
+						      0x10, 0x03, 0x10,
+						      0x54 | psTdmaByte4Modify);
+			break;
+		case 110:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x55,
+						      0x30, 0x03, 0x10,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 111:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x65,
+						      0x25, 0x03, 0x11,
+						      0x11 | psTdmaByte4Modify);
+			break;
+		case 151:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x10, 0x03, 0x10,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 0:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		case 1:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x48, 0x0);
+			break;
+		default:
+			halbtc8821c2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8821c2ant_set_int_block(IN struct btc_coexist *btcoexist,
+				   IN boolean force_exec,  IN u8 pos_type)
+{
+#if 0
+	u8		regval_0xcba;
+	u32		u32tmp1 = 0;
+
+	coex_dm->cur_int_block_status = pos_type;
+
+	if (!force_exec) {
+		if (coex_dm->pre_int_block_status ==
+		    coex_dm->cur_int_block_status)
+			return;
+	}
+
+	coex_dm->pre_int_block_status = coex_dm->cur_int_block_status;
+
+	regval_0xcba =  btcoexist->btc_read_1byte(btcoexist, 0xcba);
+
+	switch (pos_type) {
+
+	case BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLG_OF_BTG:
+		regval_0xcba = (regval_0xcba | BIT(0)) & (~(BIT(
+			2)));			/* 0xcb8[16] = 1, 0xcb8[18] = 0, WL_G select BTG */
+		regval_0xcba =   regval_0xcba & 0x0f;
+
+		/*btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc1d, 0x0f, 0x5); */ /* Gain Table */
+		/*btcoexist->btc_write_1byte_bitmask(btcoexist, 0xa9e, 0x0f, 0x2); */ /* CCK Gain Table */
+
+		break;
+	case BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLG_OF_WLAG:
+		regval_0xcba =   regval_0xcba & (~(BIT(2) | BIT(
+			0)));			/* 0xcb8[16] = 0, 0xcb8[18] = 0, WL_G select WLAG */
+
+		/* regval_0xcba = regval_0xcba | BIT(4) | BIT(5) ; */				/* 0xcb8[21:20] = 2b'11, WL_G @ WLAG on */
+		/* regval_0xcba =    (regval_0xcba | BIT(6)) & (~(BIT(7)) ) ; */		/* 0xcb8[23:22] = 2b'01, WL_A @ WLAG off */
+		/*btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc1d, 0x0f, 0x0); */ /* Gain Table */
+		/*btcoexist->btc_write_1byte_bitmask(btcoexist, 0xa9e, 0x0f, 0x6); */ /* CCK Gain Table */
+
+		break;
+	case BT_8821C_1ANT_INT_BLOCK_SWITCH_TO_WLA_OF_WLAG:
+		regval_0xcba =   regval_0xcba & (~(BIT(2) | BIT(
+			0)));			/* 0xcb8[16] = 0, 0xcb8[18] = 0, WL_G select WLAG */
+		/*regval_0xcba =   (regval_0xcba | BIT(4)) & (~(BIT(5))); */			/* 0xcb8[21:20] = 2b'01, WL_G @ WLAG off */
+		/*regval_0xcba = regval_0xcba | BIT(6) | BIT(7); */					/* 0xcb8[23:22] = 2b'11, WL_A @ WLAG on */
+
+		break;
+	}
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcba, 0xff,
+					   regval_0xcba);
+
+	u32tmp1 = btcoexist->btc_read_4byte(btcoexist, 0xcb8);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (After Int Block setup) 0xcb8 = 0x%08x **********\n",
+		    u32tmp1);
+	BTC_TRACE(trace_buf);
+
+#endif
+}
+
+void halbtc8821c2ant_set_ext_band_switch(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 pos_type)
+{
+
+#if 0
+	boolean	switch_polatiry_inverse = false;
+	u8		regval_0xcb6;
+	u32		u32tmp1 = 0, u32tmp2 = 0;
+
+	if (!rfe_type->ext_band_switch_exist)
+		return;
+
+	coex_dm->cur_ext_band_switch_status = pos_type;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ext_band_switch_status ==
+		    coex_dm->cur_ext_band_switch_status)
+			return;
+	}
+
+	coex_dm->pre_ext_band_switch_status =
+		coex_dm->cur_ext_band_switch_status;
+
+	/* swap control polarity if use different switch control polarity*/
+	switch_polatiry_inverse = (rfe_type->ext_band_switch_ctrl_polarity == 1
+		   ? ~switch_polatiry_inverse : switch_polatiry_inverse);
+
+	/*swap control polarity for WL_A, default polarity 0xcb4[21] = 0 && 0xcb4[23] = 1 is for WL_G */
+	switch_polatiry_inverse = (pos_type ==
+		BT_8821C_2ANT_EXT_BAND_SWITCH_TO_WLA ? ~switch_polatiry_inverse
+				   : switch_polatiry_inverse);
+
+	regval_0xcb6 =  btcoexist->btc_read_1byte(btcoexist, 0xcb6);
+
+	/* for normal switch polrity, 0xcb4[21] =1 && 0xcb4[23] = 0 for WL_A, vice versa */
+	regval_0xcb6 = (switch_polatiry_inverse == 1 ? ((regval_0xcb6 & (~(BIT(
+		7)))) | BIT(5)) : ((regval_0xcb6 & (~(BIT(5)))) | BIT(7)));
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb6, 0xff,
+					   regval_0xcb6);
+
+	u32tmp1 = btcoexist->btc_read_4byte(btcoexist, 0xcb0);
+	u32tmp2 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (After Ext Band switch setup) 0xcb0 = 0x%08x, 0xcb4 = 0x%08x**********\n",
+		    u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+#endif
+
+}
+
+void halbtc8821c2ant_set_ext_ant_switch(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u8 ctrl_type, IN u8 pos_type)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	boolean	switch_polatiry_inverse = false;
+	u8		regval_0xcb7 = 0, regval_0x64;
+	u32		u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+
+	if (!rfe_type->ext_ant_switch_exist)
+		return;
+
+	coex_dm->cur_ext_ant_switch_status = (ctrl_type << 8)  + pos_type;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ext_ant_switch_status ==
+		    coex_dm->cur_ext_ant_switch_status)
+			return;
+	}
+
+	coex_dm->pre_ext_ant_switch_status = coex_dm->cur_ext_ant_switch_status;
+
+	/* swap control polarity if use different switch control polarity*/
+	/*  Normal switch polarity for DPDT, 0xcb4[29:28] = 2b'01 => BTG to Main, WLG to Aux,  0xcb4[29:28] = 2b'10 => BTG to Aux, WLG to Main */
+	/*  Normal switch polarity for SPDT, 0xcb4[29:28] = 2b'01 => Ant to BTG,  0xcb4[29:28] = 2b'10 => Ant to WLG */
+	if (rfe_type->ext_ant_switch_ctrl_polarity)
+		switch_polatiry_inverse =  ~switch_polatiry_inverse;
+
+	/* swap control polarity if 1-Ant at Aux */
+	if (rfe_type->ant_at_main_port == false)
+		switch_polatiry_inverse =  ~switch_polatiry_inverse;
+
+	switch (pos_type) {
+	default:
+	case BT_8821C_2ANT_EXT_ANT_SWITCH_MAIN_TO_BT:
+	case BT_8821C_2ANT_EXT_ANT_SWITCH_MAIN_TO_NOCARE:
+	case BT_8821C_2ANT_EXT_ANT_SWITCH_MAIN_TO_WLA:
+
+		break;
+	case BT_8821C_2ANT_EXT_ANT_SWITCH_MAIN_TO_WLG:
+		if (!rfe_type->wlg_Locate_at_btg)
+			switch_polatiry_inverse =  ~switch_polatiry_inverse;
+
+		break;
+	}
+
+	if (board_info->ant_div_cfg)
+		ctrl_type = BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_ANTDIV;
+
+
+	switch (ctrl_type) {
+	default:
+	case BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /*  0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x1);  /* 0x4c[24] = 1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb4,
+			0xff, 0x77);	/* BB SW, DPDT use RFE_ctrl8 and RFE_ctrl9 as control pin */
+
+		regval_0xcb7 = (switch_polatiry_inverse == false ?
+			0x1 : 0x2);     /* 0xcb4[29:28] = 2b'01 for no switch_polatiry_inverse, DPDT_SEL_N =1, DPDT_SEL_P =0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb7,
+						   0x30, regval_0xcb7);
+
+		break;
+	case BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_PTA:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /* 0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x1);  /* 0x4c[24] = 1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb4,
+			0xff, 0x66);	/* PTA,  DPDT use RFE_ctrl8 and RFE_ctrl9 as control pin */
+
+		regval_0xcb7 = (switch_polatiry_inverse == false ?
+			0x2 : 0x1);     /* 0xcb4[29:28] = 2b'10 for no switch_polatiry_inverse, DPDT_SEL_N =1, DPDT_SEL_P =0  @ GNT_BT=1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb7,
+						   0x30, regval_0xcb7);
+
+		break;
+	case BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_ANTDIV:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /* 0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x1);  /* 0x4c[24] = 1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb4,
+						   0xff, 0x88);  /* */
+
+		/* no regval_0xcb7 setup required, because  antenna switch control value by antenna diversity */
+
+		break;
+	case BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_MAC:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x1);  /*  0x4c[23] = 1 */
+
+		regval_0x64 = (switch_polatiry_inverse == false ?  0x0 :
+			0x1);     /* 0x64[0] = 1b'0 for no switch_polatiry_inverse, DPDT_SEL_N =1, DPDT_SEL_P =0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x64, 0x1,
+						   regval_0x64);
+		break;
+	case BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_BT:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /* 0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x0);  /* 0x4c[24] = 0 */
+
+		/* no  setup required, because  antenna switch control value by BT vendor 0x1c[1:0] */
+		break;
+	}
+
+	/* PAPE, LNA_ON control by BT  while WLAN off for current leakage issue */
+	if (ctrl_type == BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_BT) {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+					   0x0);  /* PAPE   0x64[29] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x10,
+					   0x0);  /* LNA_ON 0x64[28] = 0 */
+	} else {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+					   0x1);  /* PAPE   0x64[29] = 1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x10,
+					   0x1);  /* LNA_ON 0x64[28] = 1 */
+	}
+
+#if BT_8821C_2ANT_COEX_DBG
+
+	u32tmp1 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u32tmp2 = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0x64) & 0xff;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], (After Ext Ant switch setup) 0xcb4 = 0x%08x, 0x4c = 0x%08x, 0x64= 0x%02x\n",
+		    u32tmp1, u32tmp2, u32tmp3);
+	BTC_TRACE(trace_buf);
+#endif
+
+}
+
+void halbtc8821c2ant_set_rfe_type(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+
+
+	/* the following setup should be got from Efuse in the future */
+	rfe_type->rfe_module_type = board_info->rfe_type & 0x1f;
+
+	rfe_type->ext_ant_switch_ctrl_polarity = 0;
+
+	switch (rfe_type->rfe_module_type) {
+	case 0:
+	default:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_2ANT_EXT_ANT_SWITCH_USE_DPDT;          /*2-Ant, DPDT, WLG*/
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 1:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_2ANT_EXT_ANT_SWITCH_USE_SPDT;          /*1-Ant, Main, DPDT or SPDT, WLG */
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 2:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_2ANT_EXT_ANT_SWITCH_USE_SPDT;            /*1-Ant, Main, DPDT or SPDT, BTG */
+		rfe_type->wlg_Locate_at_btg = true;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 3:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_2ANT_EXT_ANT_SWITCH_USE_DPDT;          /*1-Ant, Aux, DPDT, WLG */
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = false;
+		break;
+	case 4:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_2ANT_EXT_ANT_SWITCH_USE_DPDT;          /*1-Ant, Aux, DPDT, BTG */
+		rfe_type->wlg_Locate_at_btg = true;
+		rfe_type->ant_at_main_port = false;
+		break;
+	case 5:
+		rfe_type->ext_ant_switch_exist = false;        /*2-Ant, no antenna switch, WLG*/
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_2ANT_EXT_ANT_SWITCH_NONE;
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 6:
+		rfe_type->ext_ant_switch_exist = false;		 /*2-Ant, no antenna switch, WLG*/
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_2ANT_EXT_ANT_SWITCH_NONE;
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 7:
+		rfe_type->ext_ant_switch_exist = true;	 /*2-Ant, DPDT, BTG*/
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_2ANT_EXT_ANT_SWITCH_USE_DPDT;
+		rfe_type->wlg_Locate_at_btg = true;
+		rfe_type->ant_at_main_port = true;
+		break;
+	}
+
+#if 0
+	if (rfe_type->wlg_Locate_at_btg)
+		halbtc8821c2ant_set_int_block(btcoexist, FORCE_EXEC,
+			      BT_8821C_2ANT_INT_BLOCK_SWITCH_TO_WLG_OF_BTG);
+	else
+		halbtc8821c2ant_set_int_block(btcoexist, FORCE_EXEC,
+			      BT_8821C_2ANT_INT_BLOCK_SWITCH_TO_WLG_OF_WLAG);
+#endif
+
+}
+
+
+void halbtc8821c2ant_set_ant_path(IN struct btc_coexist *btcoexist,
+				  IN u8 ant_pos_type, IN boolean force_exec,
+				  IN u8 phase)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u32			cnt_bt_cal_chk = 0;
+	boolean			is_in_mp_mode = false;
+	u8			u8tmp = 0;
+	u32			u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+	u16			u16tmp1 = 0;
+
+	u32tmp1 = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist,
+			0x38);
+
+	/* To avoid indirect access fail  */
+	if (((u32tmp1 & 0xf000) >> 12) != ((u32tmp1 & 0x0f00) >> 8)) {
+		force_exec = true;
+		coex_sta->gnt_error_cnt++;
+	}
+
+
+#if BT_8821C_2ANT_COEX_DBG
+
+	u32tmp2 = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist,
+			0x54);
+	u8tmp  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], (Before Ant Setup) 0xcb4 = 0x%x, 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x\n",
+		    u32tmp3, u8tmp, u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+#endif
+
+	coex_dm->cur_ant_pos_type = (ant_pos_type << 8)  + phase;
+
+	if (!force_exec) {
+		if (coex_dm->cur_ant_pos_type == coex_dm->pre_ant_pos_type)
+			return;
+	}
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+
+
+	switch (phase) {
+	case BT_8821C_2ANT_PHASE_COEX_POWERON:
+
+		/* set Path control owner to WL at initial step */
+		halbtc8821c2ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8821C_2ANT_PCO_BTSIDE);
+
+		/* set GNT_BT to SW high */
+		halbtc8821c2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_2ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW high */
+		halbtc8821c2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_2ANT_SIG_STA_SET_TO_HIGH);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_MAIN;
+			else
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_AUX;
+		}
+
+		coex_sta->run_time_state = false;
+
+		break;
+	case BT_8821C_2ANT_PHASE_COEX_INIT:
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8821c2ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8821c2ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8821C_2ANT_CTT_WL_VS_LTE,
+			0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8821c2ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8821C_2ANT_CTT_BT_VS_LTE,
+			0xffff);
+
+
+		/* Wait If BT IQK running, because Path control owner is at BT during BT IQK (setup by WiFi firmware) */
+		while (cnt_bt_cal_chk <= 20) {
+			u8tmp = btcoexist->btc_read_1byte(
+					btcoexist, 0x49c);
+			cnt_bt_cal_chk++;
+
+			if (u8tmp & BIT(1)) {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ########### BT is calibrating (wait cnt=%d) ###########\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				delay_ms(50);
+			} else {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ********** BT is NOT calibrating (wait cnt=%d)**********\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				break;
+			}
+		}
+
+		/* set Path control owner to WL at initial step */
+		halbtc8821c2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8821C_2ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW high */
+		halbtc8821c2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_2ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW high */
+		halbtc8821c2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_2ANT_SIG_STA_SET_TO_HIGH);
+
+		coex_sta->run_time_state = false;
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_MAIN;
+			else
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_AUX;
+		}
+
+		break;
+	case BT_8821C_2ANT_PHASE_WLANONLY_INIT:
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8821c2ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8821c2ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8821C_2ANT_CTT_WL_VS_LTE,
+			0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8821c2ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8821C_2ANT_CTT_BT_VS_LTE,
+			0xffff);
+
+		/* set Path control owner to WL at initial step */
+		halbtc8821c2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8821C_2ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW Low */
+		halbtc8821c2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_2ANT_SIG_STA_SET_TO_LOW);
+		/* Set GNT_WL to SW high */
+		halbtc8821c2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_2ANT_SIG_STA_SET_TO_HIGH);
+
+		coex_sta->run_time_state = false;
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_MAIN;
+			else
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_AUX;
+		}
+
+		break;
+	case BT_8821C_2ANT_PHASE_WLAN_OFF:
+		/* Disable LTE Coex Function in WiFi side */
+		halbtc8821c2ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* set Path control owner to BT */
+		halbtc8821c2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8821C_2ANT_PCO_BTSIDE);
+
+		/* Set Ext Ant Switch to BT control at wifi off step */
+		halbtc8821c2ant_set_ext_ant_switch(btcoexist,
+						   FORCE_EXEC,
+				   BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_BT,
+				   BT_8821C_2ANT_EXT_ANT_SWITCH_MAIN_TO_NOCARE);
+		coex_sta->run_time_state = false;
+		break;
+	case BT_8821C_2ANT_PHASE_2G_RUNTIME:
+	case BT_8821C_2ANT_PHASE_2G_RUNTIME_CONCURRENT:
+
+		while (cnt_bt_cal_chk <= 20) {
+			/* 0x49c[0]=1 WL IQK, 0x49c[1]=1 BT IQK*/
+			u8tmp = btcoexist->btc_read_1byte(btcoexist,
+							  0x49c);
+
+			cnt_bt_cal_chk++;
+			if (u8tmp & BIT(0)) {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ########### WL is IQK (wait cnt=%d)\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				delay_ms(50);
+			} else if (u8tmp & BIT(1)) {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ########### BT is IQK (wait cnt=%d)\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				delay_ms(50);
+			} else {
+				BTC_SPRINTF(trace_buf,
+					    BT_TMP_BUF_SIZE,
+					"[BTCoex], ********** WL and BT is NOT IQK (wait cnt=%d)\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				break;
+			}
+		}
+
+		/* set Path control owner to WL at runtime step */
+		halbtc8821c2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8821C_2ANT_PCO_WLSIDE);
+
+		if (phase ==
+		    BT_8821C_2ANT_PHASE_2G_RUNTIME_CONCURRENT) {
+			/* set GNT_BT to PTA */
+			halbtc8821c2ant_ltecoex_set_gnt_bt(
+				btcoexist,
+				BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+				BT_8821C_2ANT_GNT_TYPE_CTRL_BY_PTA,
+				BT_8821C_2ANT_SIG_STA_SET_BY_HW);
+
+			/* Set GNT_WL to SW High */
+			halbtc8821c2ant_ltecoex_set_gnt_wl(
+				btcoexist,
+				BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+				BT_8821C_2ANT_GNT_TYPE_CTRL_BY_SW,
+				BT_8821C_2ANT_SIG_STA_SET_TO_HIGH);
+		} else {
+			/* set GNT_BT to PTA */
+			halbtc8821c2ant_ltecoex_set_gnt_bt(
+				btcoexist,
+				BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+				BT_8821C_2ANT_GNT_TYPE_CTRL_BY_PTA,
+				BT_8821C_2ANT_SIG_STA_SET_BY_HW);
+
+			/* Set GNT_WL to PTA */
+			halbtc8821c2ant_ltecoex_set_gnt_wl(
+				btcoexist,
+				BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+				BT_8821C_2ANT_GNT_TYPE_CTRL_BY_PTA,
+				BT_8821C_2ANT_SIG_STA_SET_BY_HW);
+		}
+		coex_sta->run_time_state = true;
+
+		if (rfe_type->wlg_Locate_at_btg)
+			halbtc8821c2ant_set_int_block(btcoexist,
+						      NORMAL_EXEC,
+				BT_8821C_2ANT_INT_BLOCK_SWITCH_TO_WLG_OF_BTG);
+		else
+			halbtc8821c2ant_set_int_block(btcoexist,
+						      NORMAL_EXEC,
+				BT_8821C_2ANT_INT_BLOCK_SWITCH_TO_WLG_OF_WLAG);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_MAIN;
+			else
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_AUX;
+		}
+
+		break;
+	case BT_8821C_2ANT_PHASE_5G_RUNTIME:
+
+		/* set Path control owner to WL at runtime step */
+		halbtc8821c2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8821C_2ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW Hi */
+		halbtc8821c2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_2ANT_GNT_TYPE_CTRL_BY_PTA,
+					   BT_8821C_2ANT_SIG_STA_SET_BY_HW);
+
+		/* Set GNT_WL to SW Hi */
+		halbtc8821c2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_2ANT_SIG_STA_SET_TO_HIGH);
+
+		coex_sta->run_time_state = true;
+
+		halbtc8821c2ant_set_int_block(btcoexist,
+					      NORMAL_EXEC,
+			      BT_8821C_2ANT_INT_BLOCK_SWITCH_TO_WLA_OF_WLAG);
+
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_MAIN;
+			else
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_AUX;
+		}
+
+
+		break;
+	case BT_8821C_2ANT_PHASE_BTMPMODE:
+		/* Disable LTE Coex Function in WiFi side */
+		halbtc8821c2ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* set Path control owner to WL */
+		halbtc8821c2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8821C_2ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW Hi */
+		halbtc8821c2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_2ANT_SIG_STA_SET_TO_HIGH);
+
+		/* Set GNT_WL to SW Lo */
+		halbtc8821c2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_2ANT_SIG_STA_SET_TO_LOW);
+
+		coex_sta->run_time_state = false;
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_MAIN;
+			else
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_AUX;
+		}
+
+		break;
+	case BT_8821C_2ANT_PHASE_ANTENNA_DET:
+		halbtc8821c2ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8821C_2ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to high */
+		halbtc8821c2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_2ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to high */
+		halbtc8821c2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8821C_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8821C_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8821C_2ANT_SIG_STA_SET_TO_HIGH);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_MAIN;
+			else
+				ant_pos_type =
+					BTC_ANT_WIFI_AT_AUX;
+		}
+
+		coex_sta->run_time_state = false;
+
+		break;
+	}
+
+	if (phase != BT_8821C_2ANT_PHASE_WLAN_OFF) {
+		switch (ant_pos_type) {
+		default:
+		case BTC_ANT_WIFI_AT_MAIN
+				:
+			halbtc8821c2ant_set_ext_ant_switch(
+				btcoexist,
+				force_exec,
+				BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW,
+				BT_8821C_2ANT_EXT_ANT_SWITCH_MAIN_TO_WLG);
+			break;
+		case BTC_ANT_WIFI_AT_AUX
+				:
+			halbtc8821c2ant_set_ext_ant_switch(
+				btcoexist,
+				force_exec,
+				BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW,
+				BT_8821C_2ANT_EXT_ANT_SWITCH_MAIN_TO_BT);
+			break;
+		case BTC_ANT_WIFI_AT_DIVERSITY
+				:
+			halbtc8821c2ant_set_ext_ant_switch(
+				btcoexist,
+				force_exec,
+				BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_ANTDIV,
+				BT_8821C_2ANT_EXT_ANT_SWITCH_MAIN_TO_NOCARE);
+			break;
+		}
+
+	}
+
+
+
+#if BT_8821C_2ANT_COEX_DBG
+	u32tmp1 = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u8tmp  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], (After Ant-Setup phase---%d) 0xcb4 = 0x%x, 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x\n",
+		    phase, u32tmp3, u8tmp, u32tmp1, u32tmp2);
+
+	BTC_TRACE(trace_buf);
+#endif
+
+}
+
+
+u8 halbtc8821c2ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8821C_2ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 0) {
+
+		if (bt_link_info->acl_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], No-Profile busy\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8821C_2ANT_COEX_ALGO_NOPROFILEBUSY;
+		}
+	} else if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8821C_2ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821C_2ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821C_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821C_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + A2DP ==> A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821C_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821C_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				{
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821C_2ANT_COEX_ALGO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], SCO + HID + A2DP ==> HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821C_2ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_PANEDR_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_PANEDR_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821C_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+
+
+void halbtc8821c2ant_action_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* fw all off */
+	halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+	halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+}
+
+void halbtc8821c2ant_action_bt_whql_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+}
+
+void halbtc8821c2ant_action_bt_hs(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex],  scan_ap_num = %d, wl_noisy = %d\n",
+		    coex_sta->scan_ap_num, coex_sta->wl_noisy_level);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->wl_noisy_level == 0))
+		wifi_turbo = true;
+#endif
+
+
+	wifi_rssi_state = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+
+	} else {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}
+
+}
+
+
+void halbtc8821c2ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+
+	boolean	wifi_connected = false;
+	boolean	wifi_scan = false, wifi_link = false, wifi_roam = false;
+	boolean			wifi_busy = false;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &wifi_link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &wifi_roam);
+
+	if ((coex_sta->bt_create_connection) && ((wifi_link) || (wifi_roam)
+		|| (wifi_scan) || (wifi_busy) || (coex_sta->wifi_is_high_pri_task))) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi link/roam/Scan/busy/hi-pri-task + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     8);
+
+		if ((bt_link_info->a2dp_exist) && (!bt_link_info->pan_exist))
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						15);
+		else
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						11);
+	}  else if ((!wifi_connected) && (!wifi_scan)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi no-link + no-scan + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (bt_link_info->pan_exist) {
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+
+	} else if (bt_link_info->a2dp_exist) {
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 16);
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+	} else {
+
+		if ((wifi_link) || (wifi_roam) || (wifi_scan) || (wifi_busy)
+			|| (coex_sta->wifi_is_high_pri_task))
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+		else
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 23);
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+	}
+
+	halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 0xd8);
+	halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+}
+
+
+void halbtc8821c2ant_action_bt_relink(IN struct btc_coexist *btcoexist)
+{
+	/*halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 8);
+	halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1); */
+	halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	coex_sta->bt_relink_downcount = 2;
+}
+
+
+void halbtc8821c2ant_action_bt_idle(IN struct btc_coexist *btcoexist)
+{
+
+	boolean			wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_busy) {
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist,
+						     NORMAL_EXEC, 8);
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+	} else {  /* if wl busy */
+
+		if (BT_8821C_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status) {
+
+			halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		} else {
+
+			halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC,
+							     8);
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						12);
+		}
+	}
+
+	halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 0xd8);
+	halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+}
+
+
+/* SCO only or SCO+PAN(HS) */
+void halbtc8821c2ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean			wifi_busy = false;
+	u32  wifi_bw = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,
+			   &wifi_bw);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}  else {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist,
+						     NORMAL_EXEC,
+						     1);
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 8);
+	}
+
+}
+
+
+void halbtc8821c2ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false;
+	u32  wifi_bw = 1;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,  &wifi_bw);
+
+	wifi_rssi_state = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}  else {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		/*for 4/18 hid */
+		if (coex_sta->hid_busy_num >= 2) {
+
+			if (wifi_bw == 0) {   /* if 11bg mode */
+
+				halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+				halbtc8821c2ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x1, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							111);
+			} else {
+
+				if (wifi_busy) {
+					halbtc8821c2ant_coex_table_with_type(
+						btcoexist,
+						NORMAL_EXEC, 8);
+					halbtc8821c2ant_set_wltoggle_coex_table(btcoexist,
+								NORMAL_EXEC,
+								0x2, 0xaa,
+								0x5a, 0xaa,
+								0xaa);
+					halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+								111);
+				} else {
+
+					halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC,
+									     3);
+					halbtc8821c2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+				}
+			}
+		} else {
+
+			halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC,
+							     3);
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+		}
+	}
+
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8821c2ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false, wifi_turbo = false;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex],  scan_ap_num = %d, wl_noisy = %d\n",
+		    coex_sta->scan_ap_num, coex_sta->wl_noisy_level);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->wl_noisy_level == 0))
+		wifi_turbo = true;
+#endif
+
+	wifi_rssi_state = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy)
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						true, 1);
+		else
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						16);
+	} else {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if ((coex_sta->bt_relink_downcount != 0)
+			&& (wifi_busy)) {
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Re-Link + A2DP + WL busy\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+			halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+
+		} else {
+
+			if (wifi_turbo)
+				halbtc8821c2ant_coex_table_with_type(btcoexist,
+								     NORMAL_EXEC, 6);
+			else
+				halbtc8821c2ant_coex_table_with_type(btcoexist,
+								     NORMAL_EXEC,
+								     7);
+
+			if (wifi_busy)
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 101);
+			else
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							16);
+			/*	halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							102); */
+		}
+
+	}
+
+}
+
+void halbtc8821c2ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex],  scan_ap_num = %d, wl_noisy = %d\n",
+		    coex_sta->scan_ap_num, coex_sta->wl_noisy_level);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->wl_noisy_level == 0))
+		wifi_turbo = true;
+#endif
+
+	wifi_rssi_state = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+#if 0
+	halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	coex_dm->is_switch_to_1dot5_ant = false;
+
+	halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+#endif
+
+
+#if 1
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy)
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						3);
+		else
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						4);
+	} else {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (wifi_turbo)
+			halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+		else
+			halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC,
+							     7);
+
+		if (wifi_busy)
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						103);
+		else
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						104);
+
+	}
+
+#endif
+
+}
+
+void halbtc8821c2ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean			wifi_busy = false;
+	u32  wifi_bw = 1;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,
+			   &wifi_bw);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy)
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						true, 1);
+		else
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						1);
+	} else {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if ((coex_sta->bt_relink_downcount != 0)
+			&& (wifi_busy)) {
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Re-Link + A2DP + WL busy\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+			halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+		} else if (wifi_busy) {
+			if (coex_sta->hid_busy_num >= 2) {
+				halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+
+				if (wifi_bw == 0)  /* 11bg mode */
+					halbtc8821c2ant_set_wltoggle_coex_table(
+					btcoexist,
+					NORMAL_EXEC,
+					0x1, 0xaa,
+					0x5a, 0xaa,
+					0xaa);
+				else
+					halbtc8821c2ant_set_wltoggle_coex_table(
+					btcoexist,
+					NORMAL_EXEC,
+					0x2, 0xaa,
+					0x5a, 0xaa,
+					0xaa);
+
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 109);
+			} else {
+				halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 101);
+			}
+		} else {
+			halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC,
+							     1);
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						15);
+			/* halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						102); */
+		}
+
+	}
+
+}
+
+
+void halbtc8821c2ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex],  scan_ap_num = %d, wl_noisy = %d\n",
+		    coex_sta->scan_ap_num, coex_sta->wl_noisy_level);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->wl_noisy_level == 0))
+		wifi_turbo = true;
+#endif
+
+
+	wifi_rssi_state = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy) {
+
+			if ((coex_sta->a2dp_bit_pool > 40) &&
+			    (coex_sta->a2dp_bit_pool < 255))
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 7);
+			else
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 5);
+		} else
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						6);
+
+	} else {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (wifi_turbo)
+			halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+		else
+			halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC,
+							     7);
+
+		if (wifi_busy) {
+
+			if ((coex_sta->a2dp_bit_pool > 40) &&
+			    (coex_sta->a2dp_bit_pool < 255))
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 107);
+			else
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 105);
+		} else
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						106);
+
+	}
+
+}
+
+
+
+/* PAN(EDR)+A2DP */
+void halbtc8821c2ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex],  scan_ap_num = %d, wl_noisy = %d\n",
+		    coex_sta->scan_ap_num, coex_sta->wl_noisy_level);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->wl_noisy_level == 0))
+		wifi_turbo = true;
+#endif
+
+
+	wifi_rssi_state = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy) {
+
+			if (((coex_sta->a2dp_bit_pool > 40) &&
+			     (coex_sta->a2dp_bit_pool < 255)) ||
+			    (!coex_sta->is_A2DP_3M))
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 7);
+			else
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 5);
+		} else
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						6);
+	} else {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (wifi_turbo)
+			halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+		else
+			halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC,
+							     7);
+
+		if (wifi_busy) {
+
+			if ((coex_sta->a2dp_bit_pool > 40) &&
+			    (coex_sta->a2dp_bit_pool < 255))
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 107);
+			else if (wifi_turbo)
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 108);
+			else
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 105);
+		} else
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						106);
+
+	}
+
+}
+
+void halbtc8821c2ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8	wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false;
+	u32	wifi_bw = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,
+			   &wifi_bw);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy)
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						3);
+		else
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						4);
+	} else {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (coex_sta->hid_busy_num >= 2) {
+
+			halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+			if (wifi_bw == 0)  /* 11bg mode */
+					halbtc8821c2ant_set_wltoggle_coex_table(
+					btcoexist,
+					NORMAL_EXEC,
+					0x1, 0xaa,
+					0x5a, 0xaa,
+					0xaa);
+			else
+					halbtc8821c2ant_set_wltoggle_coex_table(
+					btcoexist,
+					NORMAL_EXEC,
+					0x2, 0xaa,
+					0x5a, 0xaa,
+					0xaa);
+
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						110);
+		} else {
+
+			halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+
+			if (wifi_busy)
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							103);
+			else
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							104);
+		}
+
+	}
+
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8821c2ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8	wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false;
+	u32	wifi_bw = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,
+			   &wifi_bw);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8821c2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8821c2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy) {
+
+			if (((coex_sta->a2dp_bit_pool > 40) &&
+			     (coex_sta->a2dp_bit_pool < 255)) ||
+			    (!coex_sta->is_A2DP_3M))
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 7);
+			else
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 5);
+		} else
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						6);
+	} else {
+
+		halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (coex_sta->hid_busy_num >= 2) {
+			halbtc8821c2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+
+			if (wifi_bw == 0)  /* 11bg mode */
+					halbtc8821c2ant_set_wltoggle_coex_table(
+					btcoexist,
+					NORMAL_EXEC,
+					0x1, 0xaa,
+					0x5a, 0xaa,
+					0xaa);
+			else
+					halbtc8821c2ant_set_wltoggle_coex_table(
+					btcoexist,
+					NORMAL_EXEC,
+					0x2, 0xaa,
+					0x5a, 0xaa,
+					0xaa);
+
+			halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						110);
+		} else {
+			halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+
+			if (wifi_busy) {
+
+				if ((coex_sta->a2dp_bit_pool > 40) &&
+				    (coex_sta->a2dp_bit_pool < 255))
+					halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+								true, 107);
+				else
+					halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+								true, 105);
+			} else
+				halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+							106);
+		}
+	}
+
+}
+
+void halbtc8821c2ant_action_wifi_under5g(IN struct btc_coexist *btcoexist)
+{
+
+	/* fw all off */
+	halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821c2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8821C_2ANT_PHASE_5G_RUNTIME);
+}
+
+void halbtc8821c2ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* hw all off */
+	halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+}
+void halbtc8821c2ant_action_wifi_linkscan_process(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 0xd8);
+	halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+
+	if (bt_link_info->pan_exist) {
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+
+	} else if (bt_link_info->a2dp_exist) {
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 16);
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+	} else {
+
+		halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+
+		halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+	}
+
+}
+
+void halbtc8821c2ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* fw all off */
+	halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+	halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8821c2ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	switch (coex_dm->cur_algorithm) {
+
+	case BT_8821C_2ANT_COEX_ALGO_SCO:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, algorithm = SCO.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_sco(btcoexist);
+		break;
+	case BT_8821C_2ANT_COEX_ALGO_HID:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, algorithm = HID.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_hid(btcoexist);
+		break;
+	case BT_8821C_2ANT_COEX_ALGO_A2DP:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, algorithm = A2DP.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_a2dp(btcoexist);
+		break;
+	case BT_8821C_2ANT_COEX_ALGO_A2DP_PANHS:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_a2dp_pan_hs(btcoexist);
+		break;
+	case BT_8821C_2ANT_COEX_ALGO_PANEDR:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_pan_edr(btcoexist);
+		break;
+	case BT_8821C_2ANT_COEX_ALGO_PANEDR_A2DP:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_pan_edr_a2dp(btcoexist);
+		break;
+	case BT_8821C_2ANT_COEX_ALGO_PANEDR_HID:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_pan_edr_hid(btcoexist);
+		break;
+	case BT_8821C_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_hid_a2dp_pan_edr(
+			btcoexist);
+		break;
+	case BT_8821C_2ANT_COEX_ALGO_HID_A2DP:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_hid_a2dp(btcoexist);
+		break;
+	case BT_8821C_2ANT_COEX_ALGO_NOPROFILEBUSY:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = No-Profile busy.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_bt_idle(btcoexist);
+		break;
+	default:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_coex_all_off(btcoexist);
+		break;
+	}
+
+	coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+
+}
+
+
+void halbtc8821c2ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8				algorithm = 0;
+	u32				num_of_wifi_link = 0;
+	u32				wifi_link_status = 0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean				miracast_plus_bt = false;
+	boolean				scan = false, link = false, roam = false,
+					under_4way = false,
+					wifi_connected = false, wifi_under_5g =
+							false,
+							bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (!coex_sta->run_time_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], return for run_time_state = false !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->freeze_coexrun_by_btinfo) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), return for freeze_coexrun_by_btinfo\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (wifi_under_5g) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under 5G!!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_action_wifi_under5g(btcoexist);
+		return;
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under 2G!!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+					     BT_8821C_2ANT_PHASE_2G_RUNTIME);
+	}
+
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_bt_whql_test(btcoexist);
+		return;
+	}
+
+	if (coex_sta->bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is disabled!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_coex_all_off(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_bt_inquiry(btcoexist);
+		return;
+	}
+
+	if (coex_sta->is_setupLink) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is re-link !!!\n");
+		halbtc8821c2ant_action_bt_relink(btcoexist);
+		return;
+	}
+
+	/* for P2P */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist)
+			miracast_plus_bt = true;
+		else
+			miracast_plus_bt = false;
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+
+		if (scan || link || roam || under_4way) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], scan = %d, link = %d, roam = %d 4way = %d!!!\n",
+				    scan, link, roam, under_4way);
+			BTC_TRACE(trace_buf);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], wifi is under linkscan process + Multi-Port !!\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8821c2ant_action_wifi_linkscan_process(btcoexist);
+		} else
+			halbtc8821c2ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	} else {
+		miracast_plus_bt = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+	}
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (bt_hs_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "############# [BTCoex],  BT Is hs\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_bt_hs(btcoexist);
+		return;
+	}
+
+	if ((BT_8821C_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	     coex_dm->bt_status) ||
+	    (BT_8821C_2ANT_BT_STATUS_CONNECTED_IDLE ==
+	     coex_dm->bt_status)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, bt idle!!.\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_action_bt_idle(btcoexist);
+		return;
+	}
+
+	algorithm = halbtc8821c2ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Algorithm = %d\n",
+		    coex_dm->cur_algorithm);
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	if (scan || link || roam || under_4way) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under Link Process !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_wifi_linkscan_process(btcoexist);
+	} else if (wifi_connected) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, wifi connected!!.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_wifi_connected(btcoexist);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, wifi not-connected!!.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821c2ant_action_wifi_not_connected(btcoexist);
+	}
+}
+
+void halbtc8821c2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821c2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, false);
+
+	halbtc8821c2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* fw all off */
+	halbtc8821c2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+	halbtc8821c2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8821c2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	coex_sta->pop_event_cnt = 0;
+	coex_sta->cnt_RemoteNameReq = 0;
+	coex_sta->cnt_ReInit = 0;
+	coex_sta->cnt_setupLink = 0;
+	coex_sta->cnt_IgnWlanAct = 0;
+	coex_sta->cnt_Page = 0;
+	coex_sta->cnt_RoleSwitch = 0;
+
+	halbtc8821c2ant_query_bt_info(btcoexist);
+}
+
+
+void halbtc8821c2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean wifi_only)
+{
+	u8	u8tmp = 0;
+	u32	 vendor;
+	u32				u32tmp0 = 0, u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+	u8 i;
+
+
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u32tmp1 = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], (Before Init HW config) 0xcb4 = 0x%x, 0x38= 0x%x, 0x54= 0x%x\n",
+		    u32tmp3, u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 2Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	coex_sta->bt_coex_supported_feature = 0;
+	coex_sta->bt_coex_supported_version = 0;
+	coex_sta->bt_ble_scan_type = 0;
+	coex_sta->bt_ble_scan_para[0] = 0;
+	coex_sta->bt_ble_scan_para[1] = 0;
+	coex_sta->bt_ble_scan_para[2] = 0;
+	coex_sta->bt_reg_vendor_ac = 0xffff;
+	coex_sta->bt_reg_vendor_ae = 0xffff;
+	coex_sta->isolation_btween_wb = BT_8821C_2ANT_DEFAULT_ISOLATION;
+	coex_sta->gnt_error_cnt = 0;
+	coex_sta->bt_relink_downcount = 0;
+
+	for (i = 0; i <= 9; i++)
+		coex_sta->bt_afh_map[i] = 0;
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	coex_sta->dis_ver_info_cnt = 0;
+
+	halbtc8821c2ant_coex_switch_threshold(btcoexist,
+					      coex_sta->isolation_btween_wb);
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+
+	/* BT report packet sample rate	 */
+	btcoexist->btc_write_1byte(btcoexist, 0x790, 0x5);
+
+	/* Init 0x778 = 0x1 for 2-Ant */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+
+	/* Enable PTA (3-wire function form BT side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x41, 0x02, 0x1);
+
+	/* Enable PTA (tx/rx signal form WiFi side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4c6, 0x10, 0x1);
+
+	/* set GNT_BT=1 for coex table select both */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x763, 0x10, 0x1);
+
+	halbtc8821c2ant_enable_gnt_to_gpio(btcoexist, true);
+
+#if 0
+	/* check if WL firmware download ok */
+	/*if (btcoexist->btc_read_1byte(btcoexist, 0x80) == 0xc6)*/
+	halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_ONOFF, true);
+#endif
+
+	/* Enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e,
+			   0x4); /* 0x76e[3] =1, WLAN_Act control by PTA */
+
+	/* WLAN_Tx by GNT_WL  0x950[29] = 0 */
+	/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x953, 0x20, 0x0); */
+
+	halbtc8821c2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8821c2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+
+	psd_scan->ant_det_is_ant_det_available = true;
+
+	if (wifi_only) {
+		coex_sta->concurrent_rx_mode_on = false;
+		/* Path config	 */
+		/* Set Antenna Path */
+		halbtc8821c2ant_set_ant_path(btcoexist,	BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_2ANT_PHASE_WLANONLY_INIT);
+
+		btcoexist->stop_coex_dm = true;
+	} else {
+		/*Set BT polluted packet on for Tx rate adaptive not including Tx retry break by PTA, 0x45c[19] =1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x45e, 0x8, 0x1);
+
+		coex_sta->concurrent_rx_mode_on = true;
+		/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x953, 0x2, 0x1); */
+
+		/* RF 0x1[1] = 0->Set GNT_WL_RF_Rx always = 1 for con-current Rx, mask Tx only */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0x2, 0x0);
+
+		/* Set Antenna Path */
+		halbtc8821c2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_2ANT_PHASE_COEX_INIT);
+
+		btcoexist->stop_coex_dm = false;
+	}
+
+
+}
+
+
+
+/* ************************************************************
+ * work around function start with wa_halbtc8821c2ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8821c2ant_
+ * ************************************************************ */
+void ex_halbtc8821c2ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x0;
+	u16 u16tmp = 0x0;
+	u32	value = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"xxxxxxxxxxxxxxxx Execute 8821c 2-Ant PowerOn Setting xxxxxxxxxxxxxxxx!!\n");
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "Ant Det Finish = %s, Ant Det Number  = %d\n",
+		    (board_info->btdm_ant_det_finish ? "Yes" : "No"),
+		    board_info->btdm_ant_num_by_ant_det);
+	BTC_TRACE(trace_buf);
+
+
+	btcoexist->stop_coex_dm = true;
+	psd_scan->ant_det_is_ant_det_available = false;
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write BB Register correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+
+	/* Check efuse 0xc3[6] for Single Antenna Path */
+	if (board_info->single_ant_path == 0) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], **********  Single Antenna, Antenna at Aux Port\n");
+		BTC_TRACE(trace_buf);
+
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+
+		u8tmp = 7;
+	} else if (board_info->single_ant_path == 1) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], **********  Single Antenna, Antenna at Main Port\n");
+		BTC_TRACE(trace_buf);
+
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+
+		u8tmp = 6;
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (Power On) single_ant_path  = %d, btdm_ant_pos = %d\n",
+		    board_info->single_ant_path , board_info->btdm_ant_pos);
+	BTC_TRACE(trace_buf);
+
+	/* Setup RF front end type */
+	halbtc8821c2ant_set_rfe_type(btcoexist);
+
+	/* Set Antenna Path to BT side */
+	halbtc8821c2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+				     BT_8821C_2ANT_PHASE_COEX_POWERON);
+
+	/* Save"single antenna position" info in Local register setting for FW reading, because FW may not ready at  power on */
+	if (btcoexist->chip_interface == BTC_INTF_PCI)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x3e0, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_USB)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60, u8tmp);
+
+	/* enable GNT_WL/GNT_BT debug signal to GPIO14/15 */
+	halbtc8821c2ant_enable_gnt_to_gpio(btcoexist, true);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********  LTE coex Reg 0x38 (Power-On) = 0x%x**********\n",
+		    halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist, 0x38));
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********  MAC Reg 0x70/ BB Reg 0xcb4 (Power-On) = 0x%x / 0x%x\n",
+		    btcoexist->btc_read_4byte(btcoexist, 0x70),
+		    btcoexist->btc_read_4byte(btcoexist, 0xcb4));
+	BTC_TRACE(trace_buf);
+
+}
+
+void ex_halbtc8821c2ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x4; /* Set BIT2 by default since it's 2ant case */
+
+	/* */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+	if (btcoexist->chip_interface == BTC_INTF_USB) {
+		/* fixed at S0 for USB interface */
+		u8tmp |= 0x1;	/* antenna inverse */
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	} else {
+		/* for PCIE and SDIO interface, we check efuse 0xc3[6] */
+		if (board_info->single_ant_path == 0) {
+		} else if (board_info->single_ant_path == 1) {
+			/* set to S0 */
+			u8tmp |= 0x1;	/* antenna inverse */
+		}
+
+		if (btcoexist->chip_interface == BTC_INTF_PCI)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x3e0,
+							     u8tmp);
+		else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60,
+							     u8tmp);
+	}
+}
+
+
+void ex_halbtc8821c2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8821c2ant_init_hw_config(btcoexist, wifi_only);
+}
+
+void ex_halbtc8821c2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8821c2ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8821c2ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, ps_tdma_case = 0;
+	u32				u32tmp[4];
+	u16				u16tmp[4];
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+	u32				fw_ver = 0, bt_patch_ver = 0, bt_coex_ver = 0;
+	static u8			pop_report_in_10s = 0;
+	u32			phyver = 0;
+	boolean			lte_coex_on = false;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	if (psd_scan->ant_det_try_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %s / %d",
+			   "Ant PG Num/ Mech/ Pos/ RFE",
+			   board_info->pg_ant_num, board_info->btdm_ant_num,
+			   (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT
+			    ? "Main" : "Aux"),
+			   rfe_type->rfe_module_type);
+		CL_PRINTF(cli_buf);
+	} else {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %s/ %d  (%d/%d/%d)",
+			   "Ant PG Num/ Mech(Ant_Det)/ Pos/ RFE",
+			   board_info->pg_ant_num,
+			   board_info->btdm_ant_num_by_ant_det,
+			   (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT
+			    ? "Main" : "Aux"),
+			   rfe_type->rfe_module_type,
+			   psd_scan->ant_det_try_count,
+			   psd_scan->ant_det_fail_count,
+			   psd_scan->ant_det_result);
+		CL_PRINTF(cli_buf);
+
+
+		if (board_info->btdm_ant_det_finish) {
+
+			if (psd_scan->ant_det_result != 12)
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					   "\r\n %-35s = %s",
+					   "Ant Det PSD Value",
+					   psd_scan->ant_det_peak_val);
+			else
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					   "\r\n %-35s = %d",
+					   "Ant Det PSD Value",
+					   psd_scan->ant_det_psd_scan_peak_val
+					   / 100);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+
+	bt_coex_ver = (coex_sta->bt_coex_supported_version & 0xff);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+		   "CoexVer WL/  BT_Desired/ BT_Report",
+		   glcoex_ver_date_8821c_2ant, glcoex_ver_8821c_2ant,
+		   glcoex_ver_btdesired_8821c_2ant,
+		   bt_coex_ver,
+		   (bt_coex_ver == 0xff ? "Unknown" :
+		    (coex_sta->bt_disabled ? "BT-disable" :
+		     (bt_coex_ver >= glcoex_ver_btdesired_8821c_2ant ?
+		      "Match" : "Mis-Match"))));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d/ %c",
+		   "W_FW/ B_FW/ Phy/ Kt",
+		   fw_ver, bt_patch_ver, phyver,
+		   coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "AFH Map to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d ",
+		   "Isolation/WL_Thres/BT_Thres",
+		   coex_sta->isolation_btween_wb,
+		   coex_sta->wifi_coex_thres,
+		   coex_sta->bt_coex_thres);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	pop_report_in_10s++;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = [%s/ %d dBm/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt/ popCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+			   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page")
+			   : ((BT_8821C_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8821C_2ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi - 100, coex_sta->bt_retry_cnt,
+		   coex_sta->pop_event_cnt);
+	CL_PRINTF(cli_buf);
+
+	if (pop_report_in_10s >= 5) {
+		coex_sta->pop_event_cnt = 0;
+		pop_report_in_10s = 0;
+	}
+
+
+	if (coex_sta->num_of_profile != 0)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %s%s%s%s%s",
+			   "Profiles",
+			   ((bt_link_info->a2dp_exist) ? "A2DP," : ""),
+			   ((bt_link_info->sco_exist) ?  "HFP," : ""),
+			   ((bt_link_info->hid_exist) ?
+			    ((coex_sta->hid_busy_num >= 2) ? "HID(4/18)," :
+			     "HID(2/18),") : ""),
+			   ((bt_link_info->pan_exist) ?  "PAN," : ""),
+			   ((coex_sta->voice_over_HOGP) ? "Voice" : ""));
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = None", "Profiles");
+
+	CL_PRINTF(cli_buf);
+
+
+	if (bt_link_info->a2dp_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %d/ %s",
+			   "A2DP Rate/Bitpool/Auto_Slot",
+			   ((coex_sta->is_A2DP_3M) ? "3M" : "No_3M"),
+			   coex_sta->a2dp_bit_pool,
+			   ((coex_sta->is_autoslot) ? "On" : "Off")
+			  );
+		CL_PRINTF(cli_buf);
+	}
+
+	if (bt_link_info->hid_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+			   "HID PairNum/Forbid_Slot",
+			   coex_sta->hid_pair_cnt,
+			   coex_sta->forbidden_slot
+			  );
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %d/ %s/ 0x%x",
+				"Role/RoleSwCnt/IgnWlact/Feature",
+				((bt_link_info->slave_role) ? "Slave" : "Master"),
+				coex_sta->cnt_RoleSwitch,
+				((coex_dm->cur_ignore_wlan_act) ? "Yes" : "No"),
+				coex_sta->bt_coex_supported_feature);
+	CL_PRINTF(cli_buf);
+
+	if ((coex_sta->bt_ble_scan_type & 0x7) != 0x0) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+				"BLEScan Type/TV/Init/Ble",
+				coex_sta->bt_ble_scan_type,
+				(coex_sta->bt_ble_scan_type & 0x1 ?
+				coex_sta->bt_ble_scan_para[0] : 0x0),
+				(coex_sta->bt_ble_scan_type & 0x2 ?
+				coex_sta->bt_ble_scan_para[1] : 0x0),
+				(coex_sta->bt_ble_scan_type & 0x4 ?
+				coex_sta->bt_ble_scan_para[2] : 0x0));
+			CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d",
+		   "ReInit/ReLink/IgnWlact/Page/NameReq",
+		   coex_sta->cnt_ReInit,
+		   coex_sta->cnt_setupLink,
+		   coex_sta->cnt_IgnWlanAct,
+		   coex_sta->cnt_Page,
+		   coex_sta->cnt_RemoteNameReq
+		  );
+	CL_PRINTF(cli_buf);
+
+	halbtc8821c2ant_read_score_board(btcoexist,	&u16tmp[0]);
+
+	if ((coex_sta->bt_reg_vendor_ae == 0xffff) ||
+	    (coex_sta->bt_reg_vendor_ac == 0xffff))
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = x/ x/ %04x",
+			   "0xae[4]/0xac[1:0]/Scoreboard", u16tmp[0]);
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = 0x%x/ 0x%x/ %04x",
+			   "0xae[4]/0xac[1:0]/Scoreboard",
+			   ((coex_sta->bt_reg_vendor_ae & BIT(4)) >> 4),
+			   coex_sta->bt_reg_vendor_ac & 0x3, u16tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	if (coex_sta->num_of_profile > 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
+			"AFH MAP",
+			coex_sta->bt_afh_map[0],
+			coex_sta->bt_afh_map[1],
+			coex_sta->bt_afh_map[2],
+			coex_sta->bt_afh_map[3],
+			coex_sta->bt_afh_map[4],
+			coex_sta->bt_afh_map[5],
+			coex_sta->bt_afh_map[6],
+			coex_sta->bt_afh_map[7],
+			coex_sta->bt_afh_map[8],
+			coex_sta->bt_afh_map[9]
+			   );
+		CL_PRINTF(cli_buf);
+	}
+
+	for (i = 0; i < BT_INFO_SRC_8821C_2ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8821c_2ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	/* Sw mechanism	 */
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[mechanism] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[Mechanism]============");
+
+	CL_PRINTF(cli_buf);
+
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x (case-%d, %s, %s)",
+		   "TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   (coex_dm->cur_ps_tdma_on ? "TDMA On" : "TDMA Off"),
+		   (coex_dm->is_switch_to_1dot5_ant ? "1.5Ant" : "2Ant"));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d/ 0x%x/ 0x%x/ 0x%x",
+		   "Table/0x6c0/0x6c4/0x6c8",
+		   coex_sta->coex_table_type, u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x778/0x6cc",
+		   u8tmp[0], u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s",
+		   "AntDiv/ForceLPS/LPRA",
+		   ((board_info->ant_div_cfg) ? "On" : "Off"),
+		   ((coex_sta->force_lps_on) ? "On" : "Off"),
+		   ((coex_dm->cur_low_penalty_ra) ? "On" : "Off"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "WL_DACSwing/ BT_Dec_Pwr", coex_dm->cur_fw_dac_swing_lvl,
+		   coex_dm->cur_bt_dec_pwr_lvl);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	lte_coex_on = ((u32tmp[0] & BIT(7)) >> 7) ?  true : false;
+
+	if (lte_coex_on) {
+
+		u32tmp[0] = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa0);
+		u32tmp[1] = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa4);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+			   "LTE Coex Table W_L/B_L",
+			   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff);
+		CL_PRINTF(cli_buf);
+
+
+		u32tmp[0] = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa8);
+		u32tmp[1] = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xac);
+		u32tmp[2] = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xb0);
+		u32tmp[3] = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xb4);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+			   "LTE Break Table W_L/B_L/L_W/L_B",
+			   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff,
+			   u32tmp[2] & 0xffff, u32tmp[3] & 0xffff);
+		CL_PRINTF(cli_buf);
+
+	}
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp[1] = halbtc8821c2ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s",
+		   "LTE Coex/Path Owner",
+		   ((lte_coex_on) ? "On" : "Off") ,
+		   ((u8tmp[0] & BIT(2)) ? "WL" : "BT"));
+	CL_PRINTF(cli_buf);
+
+	if (lte_coex_on) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %d/ %d",
+			   "LTE 3Wire/OPMode/UART/UARTMode",
+			   (int)((u32tmp[0] & BIT(6)) >> 6),
+			   (int)((u32tmp[0] & (BIT(5) | BIT(4))) >> 4),
+			   (int)((u32tmp[0] & BIT(3)) >> 3),
+			   (int)(u32tmp[0] & (BIT(2) | BIT(1) | BIT(0))));
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+			   "LTE_Busy/UART_Busy",
+			   (int)((u32tmp[1] & BIT(1)) >> 1),
+			   (int)(u32tmp[1] & BIT(0)));
+		CL_PRINTF(cli_buf);
+	}
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %s (BB:%s)/ %s (BB:%s)/ %s %d",
+		   "GNT_WL_Ctrl/GNT_BT_Ctrl/Dbg",
+		   ((u32tmp[0] & BIT(12)) ? "SW" : "HW"),
+		   ((u32tmp[0] & BIT(8)) ?  "SW" : "HW"),
+		   ((u32tmp[0] & BIT(14)) ? "SW" : "HW"),
+		   ((u32tmp[0] & BIT(10)) ?  "SW" : "HW"),
+		   ((u8tmp[0] & BIT(3)) ? "On" : "Off"),
+		   coex_sta->gnt_error_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "GNT_WL/GNT_BT",
+		   (int)((u32tmp[1] & BIT(2)) >> 2),
+		   (int)((u32tmp[1] & BIT(3)) >> 3));
+	CL_PRINTF(cli_buf);
+
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xcb0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xcba);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%04x/ 0x%04x/ 0x%02x %s",
+		   "0xcb0/0xcb4/0xcb8[23:16]",
+		   u32tmp[0], u32tmp[1], u8tmp[0],
+		   ((u8tmp[0] & 0x1) == 0x1 ?  "(BTG)" :   "(WL_A+G)"));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0x64);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x4c6);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "4c[24:23]/64[0]/4c6[4]/40[5]",
+		   (u32tmp[0] & (BIT(24) | BIT(23))) >> 23 , u8tmp[2] & 0x1 ,
+		   (int)((u8tmp[0] & BIT(4)) >> 4),
+		   (int)((u8tmp[1] & BIT(5)) >> 5));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x953);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0xc50);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ %s/ 0x%x",
+		   "0x550/0x522/4-RxAGC/0xc50",
+		u32tmp[0], u8tmp[0], (u8tmp[1] & 0x2) ? "On" : "Off", u8tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+#if 1
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11ac",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11ac",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+#endif
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s/ %d",
+		   "WlHiPri/ Locking/ Locked/ Noisy",
+		   (coex_sta->wifi_is_high_pri_task ? "Yes" : "No"),
+		   (coex_sta->cck_lock ? "Yes" : "No"),
+		   (coex_sta->cck_ever_lock ? "Yes" : "No"),
+		   coex_sta->wl_noisy_level);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d %s",
+		   "0x770(Hi-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx,
+		   (coex_sta->is_hiPri_rx_overhead ? "(scan overhead!!)" :
+		    ""));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d %s",
+		   "0x774(Lo-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx,
+		   (bt_link_info->slave_role ? "(Slave!!)" : (
+		   coex_sta->is_tdma_btautoslot_hang ? "(auto-slot hang!!)" : "")));
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8821c2ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+		coex_sta->under_lps = false;
+
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+				BT_8821C_2ANT_SCOREBOARD_ACTIVE |
+				BT_8821C_2ANT_SCOREBOARD_ONOFF |
+				BT_8821C_2ANT_SCOREBOARD_SCAN |
+				BT_8821C_2ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		halbtc8821c2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_2ANT_PHASE_WLAN_OFF);
+
+		halbtc8821c2ant_action_coex_all_off(btcoexist);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+#if 0
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_ACTIVE, true);
+
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+				 BT_8821C_2ANT_SCOREBOARD_ONOFF, true);
+#endif
+
+		halbtc8821c2ant_init_hw_config(btcoexist, false);
+		halbtc8821c2ant_init_coex_dm(btcoexist);
+		halbtc8821c2ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8821c2ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+		coex_sta->under_ips = false;
+
+		if (coex_sta->force_lps_on == true) { /* LPS No-32K */
+			/* Write WL "Active" in Score-board for PS-TDMA */
+			halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_ACTIVE, true);
+
+		} else { /* LPS-32K, need check if this h2c 0x71 can work?? (2015/08/28) */
+			/* Write WL "Non-Active" in Score-board for Native-PS */
+			halbtc8821c2ant_post_state_to_bt(btcoexist,
+				 BT_8821C_2ANT_SCOREBOARD_ACTIVE, false);
+		}
+
+
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_ACTIVE, true);
+	}
+}
+
+void ex_halbtc8821c2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean	wifi_connected = false;
+	boolean wifi_under_5g = false;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], SCAN notify()\n");
+	BTC_TRACE(trace_buf);
+
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	/*  this can't be removed for RF off_on event, or BT would dis-connect */
+	halbtc8821c2ant_query_bt_info(btcoexist);
+
+	if (BTC_SCAN_START == type) {
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G,
+				   &wifi_under_5g);
+
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+					BT_8821C_2ANT_SCOREBOARD_ACTIVE |
+					BT_8821C_2ANT_SCOREBOARD_SCAN |
+					BT_8821C_2ANT_SCOREBOARD_ONOFF,
+					true);
+
+		if (wifi_under_5g) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** SCAN START notify (5g)\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8821c2ant_action_wifi_under5g(btcoexist);
+			return;
+		}
+
+		coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** SCAN START notify (2g)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_2ANT_PHASE_2G_RUNTIME);
+
+		halbtc8821c2ant_run_coexist_mechanism(
+			btcoexist);
+
+		return;
+	}
+
+
+	if (BTC_SCAN_START_2G == type) {
+
+		if (!wifi_connected)
+			coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify (2G)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_ACTIVE |
+					 BT_8821C_2ANT_SCOREBOARD_SCAN |
+					 BT_8821C_2ANT_SCOREBOARD_ONOFF,
+					 true);
+
+		halbtc8821c2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_2ANT_PHASE_2G_RUNTIME);
+
+		halbtc8821c2ant_run_coexist_mechanism(btcoexist);
+
+	} else if (BTC_SCAN_FINISH == type) {
+
+		coex_sta->wifi_is_high_pri_task = false;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify  (Scan-AP = %d)\n",
+			    coex_sta->scan_ap_num);
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_run_coexist_mechanism(btcoexist);
+	}
+
+}
+
+void ex_halbtc8821c2ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (type == BTC_SWITCH_TO_5G) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], switchband_notify ---  switch to 5G\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_action_wifi_under5g(btcoexist);
+
+	} else if (type == BTC_SWITCH_TO_24G_NOFORSCAN) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** switchband_notify BTC_SWITCH_TO_2G (no for scan)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_run_coexist_mechanism(btcoexist);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], switchband_notify ---  switch to 2G\n");
+		BTC_TRACE(trace_buf);
+
+		ex_halbtc8821c2ant_scan_notify(btcoexist,
+					       BTC_SCAN_START_2G);
+	}
+}
+
+
+void ex_halbtc8821c2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_ACTIVE |
+					 BT_8821C_2ANT_SCOREBOARD_SCAN |
+					 BT_8821C_2ANT_SCOREBOARD_ONOFF,
+					 true);
+
+	if ((BTC_ASSOCIATE_5G_START == type) ||
+	    (BTC_ASSOCIATE_5G_FINISH == type)) {
+
+		if (BTC_ASSOCIATE_5G_START == type)
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], connect_notify ---  5G start\n");
+		else
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], connect_notify ---  5G finish\n");
+
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_action_wifi_under5g(btcoexist);
+		return;
+	}
+
+
+	if (BTC_ASSOCIATE_START == type) {
+
+		coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify (2G)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_2ANT_PHASE_2G_RUNTIME);
+
+		halbtc8821c2ant_run_coexist_mechanism(btcoexist);
+
+		/* To keep TDMA case during connect process,
+		to avoid changed by Btinfo and runcoexmechanism */
+		coex_sta->freeze_coexrun_by_btinfo = true;
+
+		coex_dm->arp_cnt = 0;
+
+	} else if (BTC_ASSOCIATE_FINISH == type) {
+
+		coex_sta->wifi_is_high_pri_task = false;
+		coex_sta->freeze_coexrun_by_btinfo = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify	(2G)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_run_coexist_mechanism(btcoexist);
+	}
+}
+
+void ex_halbtc8821c2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	u8			ap_num = 0;
+	boolean		wifi_under_b_mode = false, wifi_under_5g = false;
+
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (BTC_MEDIA_CONNECT == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_ACTIVE |
+					 BT_8821C_2ANT_SCOREBOARD_ONOFF,
+					 true);
+
+		if (wifi_under_5g) {
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], WiFi is under 5G!!!\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8821c2ant_action_wifi_under5g(btcoexist);
+			return;
+		}
+
+		halbtc8821c2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_2ANT_PHASE_2G_RUNTIME);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+				 BT_8821C_2ANT_SCOREBOARD_ACTIVE, false);
+	}
+
+
+	halbtc8821c2ant_update_wifi_channel_info(btcoexist, type);
+}
+
+void ex_halbtc8821c2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean under_4way = false, wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (wifi_under_5g) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under 5G!!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_action_wifi_under5g(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (under_4way) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ---- under_4way!!\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+
+	} else if (BTC_PACKET_ARP == type) {
+
+		coex_dm->arp_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ARP notify -cnt = %d\n",
+			    coex_dm->arp_cnt);
+		BTC_TRACE(trace_buf);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet DHCP or EAPOL notify [Type = %d]\n",
+			    type);
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+	}
+
+	if (coex_sta->wifi_is_high_pri_task) {
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_SCAN, true);
+		halbtc8821c2ant_run_coexist_mechanism(btcoexist);
+	}
+
+}
+
+void ex_halbtc8821c2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8			i, rsp_source = 0;
+	boolean			wifi_connected = false;
+	boolean	wifi_scan = false, wifi_link = false, wifi_roam = false,
+			wifi_busy = false;
+	static boolean is_scoreboard_scan = false;
+
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8821C_2ANT_MAX)
+		rsp_source = BT_INFO_SRC_8821C_2ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt_info[%d], len=%d, data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	coex_sta->bt_info = coex_sta->bt_info_c2h[rsp_source][1];
+	coex_sta->bt_info_ext = coex_sta->bt_info_c2h[rsp_source][4];
+	coex_sta->bt_info_ext2 = coex_sta->bt_info_c2h[rsp_source][5];
+
+	if (BT_INFO_SRC_8821C_2ANT_WIFI_FW != rsp_source) {
+
+		/* if 0xff, it means BT is under WHCK test */
+		coex_sta->bt_whck_test = ((coex_sta->bt_info == 0xff) ? true :
+					  false);
+
+		coex_sta->bt_create_connection = ((
+			coex_sta->bt_info_c2h[rsp_source][2] & 0x80) ? true :
+						  false);
+
+		/* unit: %, value-100 to translate to unit: dBm */
+		coex_sta->bt_rssi = coex_sta->bt_info_c2h[rsp_source][3] * 2 +
+				    10;
+
+		coex_sta->c2h_bt_remote_name_req = ((
+			coex_sta->bt_info_c2h[rsp_source][2] & 0x20) ? true :
+						    false);
+
+		coex_sta->is_A2DP_3M = ((coex_sta->bt_info_c2h[rsp_source][2] &
+					 0x10) ? true : false);
+
+		coex_sta->acl_busy = ((coex_sta->bt_info_c2h[rsp_source][1] &
+				       0x9) ? true : false);
+
+		coex_sta->voice_over_HOGP = ((coex_sta->bt_info_ext & 0x10) ?
+					     true : false);
+
+		coex_sta->c2h_bt_inquiry_page = ((coex_sta->bt_info &
+			  BT_INFO_8821C_2ANT_B_INQ_PAGE) ? true : false);
+
+		coex_sta->a2dp_bit_pool = (((
+			coex_sta->bt_info_c2h[rsp_source][1] & 0x49) == 0x49) ?
+				   coex_sta->bt_info_c2h[rsp_source][6] : 0);
+
+		coex_sta->bt_retry_cnt = coex_sta->bt_info_c2h[rsp_source][2] &
+					 0xf;
+
+		coex_sta->is_autoslot = coex_sta->bt_info_ext2 & 0x8;
+
+		coex_sta->forbidden_slot = coex_sta->bt_info_ext2 & 0x7;
+
+		coex_sta->hid_busy_num = (coex_sta->bt_info_ext2 & 0x30) >> 4;
+
+		coex_sta->hid_pair_cnt = (coex_sta->bt_info_ext2 & 0xc0) >> 6;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->c2h_bt_remote_name_req)
+			coex_sta->cnt_RemoteNameReq++;
+
+		if (coex_sta->bt_info_ext & BIT(1))
+			coex_sta->cnt_ReInit++;
+
+
+		if (coex_sta->bt_info_ext & BIT(2)) {
+			coex_sta->cnt_setupLink++;
+			coex_sta->is_setupLink = true;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Re-Link start in BT info!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			coex_sta->is_setupLink = false;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Re-Link stop in BT info!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+
+		if (coex_sta->bt_info_ext & BIT(3))
+			coex_sta->cnt_IgnWlanAct++;
+
+		if (coex_sta->bt_info_ext & BIT(6))
+			coex_sta->cnt_RoleSwitch++;
+
+		if (coex_sta->bt_create_connection) {
+			coex_sta->cnt_Page++;
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY,
+					   &wifi_busy);
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &wifi_link);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &wifi_roam);
+
+			if ((wifi_link) || (wifi_roam) || (wifi_scan) ||
+			    (coex_sta->wifi_is_high_pri_task) || (wifi_busy)) {
+
+				is_scoreboard_scan = true;
+				halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_SCAN, true);
+
+			} else
+				halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_SCAN, false);
+
+		} else {
+				if (is_scoreboard_scan) {
+					halbtc8821c2ant_post_state_to_bt(btcoexist,
+						 BT_8821C_2ANT_SCOREBOARD_SCAN, false);
+					is_scoreboard_scan = false;
+				}
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+
+		if ((!btcoexist->manual_control) &&
+		    (!btcoexist->stop_coex_dm)) {
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+
+			/*  Re-Init */
+			if ((coex_sta->bt_info_ext & BIT(1))) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+				BTC_TRACE(trace_buf);
+				if (wifi_connected)
+					halbtc8821c2ant_update_wifi_channel_info(
+						btcoexist, BTC_MEDIA_CONNECT);
+				else
+					halbtc8821c2ant_update_wifi_channel_info(
+						btcoexist,
+						BTC_MEDIA_DISCONNECT);
+			}
+
+
+			/*  If Ignore_WLanAct && not SetUp_Link */
+			if ((coex_sta->bt_info_ext & BIT(3)) &&
+				(!(coex_sta->bt_info_ext & BIT(2))) &&
+				(!(coex_sta->bt_info_ext & BIT(6)))) {
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821c2ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			} else {
+				if (coex_sta->bt_info_ext & BIT(2)) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ignore Wlan active because Re-link!!\n");
+					BTC_TRACE(trace_buf);
+				} else if (coex_sta->bt_info_ext & BIT(6)) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ignore Wlan active because Role-Switch!!\n");
+					BTC_TRACE(trace_buf);
+				}
+			}
+		}
+
+	}
+
+	if ((coex_sta->bt_info_ext & BIT(5))) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BT ext info bit4 check, query BLE Scan type!!\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_ble_scan_type = btcoexist->btc_get_ble_scan_type_from_bt(
+						     btcoexist);
+
+		if ((coex_sta->bt_ble_scan_type & 0x1) == 0x1)
+			coex_sta->bt_ble_scan_para[0]  =
+				btcoexist->btc_get_ble_scan_para_from_bt(btcoexist,
+						0x1);
+		if ((coex_sta->bt_ble_scan_type & 0x2) == 0x2)
+			coex_sta->bt_ble_scan_para[1]  =
+				btcoexist->btc_get_ble_scan_para_from_bt(btcoexist,
+						0x2);
+		if ((coex_sta->bt_ble_scan_type & 0x4) == 0x4)
+			coex_sta->bt_ble_scan_para[2]  =
+				btcoexist->btc_get_ble_scan_para_from_bt(btcoexist,
+						0x4);
+	}
+
+	halbtc8821c2ant_update_bt_link_info(btcoexist);
+
+	halbtc8821c2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8821c2ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->stop_coex_dm = false;
+#if 0
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_ONOFF, true);
+#endif
+	} else if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821c2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8821C_2ANT_PHASE_WLAN_OFF);
+
+		halbtc8821c2ant_action_coex_all_off(btcoexist);
+
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+				BT_8821C_2ANT_SCOREBOARD_ACTIVE |
+				BT_8821C_2ANT_SCOREBOARD_ONOFF |
+				BT_8821C_2ANT_SCOREBOARD_SCAN |
+				BT_8821C_2ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		btcoexist->stop_coex_dm = true;
+
+	}
+}
+
+void ex_halbtc8821c2ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821c2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+				     BT_8821C_2ANT_PHASE_WLAN_OFF);
+
+	ex_halbtc8821c2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	halbtc8821c2ant_post_state_to_bt(btcoexist,
+				BT_8821C_2ANT_SCOREBOARD_ACTIVE |
+				BT_8821C_2ANT_SCOREBOARD_ONOFF |
+				BT_8821C_2ANT_SCOREBOARD_SCAN |
+				BT_8821C_2ANT_SCOREBOARD_UNDERTEST,
+				false);
+}
+
+void ex_halbtc8821c2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	boolean wifi_under_5g = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if ((BTC_WIFI_PNP_SLEEP == pnp_state) ||
+	    (BTC_WIFI_PNP_SLEEP_KEEP_ANT == pnp_state)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+				BT_8821C_2ANT_SCOREBOARD_ACTIVE |
+				BT_8821C_2ANT_SCOREBOARD_ONOFF |
+				BT_8821C_2ANT_SCOREBOARD_SCAN |
+				BT_8821C_2ANT_SCOREBOARD_UNDERTEST,
+				false);
+
+		if (BTC_WIFI_PNP_SLEEP_KEEP_ANT == pnp_state) {
+
+			if (wifi_under_5g)
+				halbtc8821c2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO, FORCE_EXEC,
+					     BT_8821C_2ANT_PHASE_5G_RUNTIME);
+			else
+				halbtc8821c2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO, FORCE_EXEC,
+					     BT_8821C_2ANT_PHASE_2G_RUNTIME);
+		} else {
+
+			halbtc8821c2ant_set_ant_path(btcoexist,
+						     BTC_ANT_PATH_AUTO,
+						     FORCE_EXEC,
+					     BT_8821C_2ANT_PHASE_WLAN_OFF);
+		}
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+#if 0
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+					 BT_8821C_2ANT_SCOREBOARD_ONOFF, true);
+#endif
+	}
+}
+
+void ex_halbtc8821c2ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	boolean wifi_busy = false;
+	u32 bt_patch_ver;
+	static u8 cnt = 0;
+	boolean bt_relink_finish = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ************* Periodical *************\n");
+	BTC_TRACE(trace_buf);
+
+#if (BT_AUTO_REPORT_ONLY_8821C_2ANT == 0)
+	halbtc8821c2ant_query_bt_info(btcoexist);
+#endif
+
+	halbtc8821c2ant_monitor_bt_ctr(btcoexist);
+	halbtc8821c2ant_monitor_wifi_ctr(btcoexist);
+	halbtc8821c2ant_monitor_bt_enable_disable(btcoexist);
+
+#if 0
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	/* halbtc8821c2ant_read_score_board(btcoexist, &bt_scoreboard_val); */
+
+	if (wifi_busy) {
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+				BT_8821C_2ANT_SCOREBOARD_UNDERTEST, true);
+		/*
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+				BT_8821C_2ANT_SCOREBOARD_WLBUSY, true);
+
+		if (bt_scoreboard_val & BIT(6))
+			halbtc8821c2ant_query_bt_info(btcoexist); */
+	} else {
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+			BT_8821C_2ANT_SCOREBOARD_UNDERTEST, false);
+		/*
+		halbtc8821c2ant_post_state_to_bt(btcoexist,
+			BT_8821C_2ANT_SCOREBOARD_WLBUSY,
+				false);  */
+	}
+#endif
+
+	if (coex_sta->bt_relink_downcount != 0) {
+		coex_sta->bt_relink_downcount--;
+
+		if (coex_sta->bt_relink_downcount == 0)
+			bt_relink_finish = true;
+	}
+
+	/* for 4-way, DHCP, EAPOL packet */
+	if (coex_sta->specific_pkt_period_cnt > 0) {
+
+		coex_sta->specific_pkt_period_cnt--;
+
+		if ((coex_sta->specific_pkt_period_cnt == 0) &&
+		    (coex_sta->wifi_is_high_pri_task))
+			coex_sta->wifi_is_high_pri_task = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ***************** Hi-Pri Task = %s\n",
+			    (coex_sta->wifi_is_high_pri_task ? "Yes" :
+			     "No"));
+		BTC_TRACE(trace_buf);
+
+	}
+
+	if (!coex_sta->bt_disabled) {
+			if (coex_sta->bt_coex_supported_feature == 0)
+				btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_FEATURE,
+							&coex_sta->bt_coex_supported_feature);
+
+			if ((coex_sta->bt_coex_supported_version == 0) ||
+				(coex_sta->bt_coex_supported_version == 0xffff))
+				btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION,
+							&coex_sta->bt_coex_supported_version);
+
+			if (coex_sta->bt_reg_vendor_ac == 0xffff)
+				coex_sta->bt_reg_vendor_ac = (u16)(
+						btcoexist->btc_get_bt_reg(btcoexist, 3,
+						0xac) & 0xffff);
+
+			if (coex_sta->bt_reg_vendor_ae == 0xffff)
+				coex_sta->bt_reg_vendor_ae = (u16)(
+						btcoexist->btc_get_bt_reg(btcoexist, 3,
+						0xae) & 0xffff);
+
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER,
+							&bt_patch_ver);
+			btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+
+			if (coex_sta->num_of_profile > 0) {
+			cnt++;
+
+			if (cnt >= 3) {
+				btcoexist->btc_get_bt_afh_map_from_bt(btcoexist, 0,
+					&coex_sta->bt_afh_map[0]);
+				cnt = 0;
+			}
+		}
+	}
+
+	if (halbtc8821c2ant_is_wifibt_status_changed(btcoexist) || (bt_relink_finish))
+		halbtc8821c2ant_run_coexist_mechanism(btcoexist);
+}
+
+
+/*#pragma optimize( "", off )*/
+void ex_halbtc8821c2ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+}
+
+
+void ex_halbtc8821c2ant_display_ant_detection(IN struct btc_coexist *btcoexist)
+{
+
+}
+
+
+#endif
+
+#endif	/*  #if (RTL8821C_SUPPORT == 1) */
+
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8821c2ant.h
@@ -0,0 +1,490 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821C_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8821C 2Ant BT Co-exist definition
+ * ******************************************* */
+#define	BT_8821C_2ANT_COEX_DBG					0
+#define	BT_AUTO_REPORT_ONLY_8821C_2ANT				1
+
+
+#define	BT_INFO_8821C_2ANT_B_FTP						BIT(7)
+#define	BT_INFO_8821C_2ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8821C_2ANT_B_HID						BIT(5)
+#define	BT_INFO_8821C_2ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8821C_2ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8821C_2ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8821C_2ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8821C_2ANT_B_CONNECTION				BIT(0)
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8821C_2ANT		2
+
+
+#define	BT_8821C_2ANT_WIFI_RSSI_COEXSWITCH_THRES1				80  /* unit: % WiFi RSSI Threshold for   2-Ant free-run/2-Ant TDMA translation, default = 42 */
+#define	BT_8821C_2ANT_BT_RSSI_COEXSWITCH_THRES1				80 /*  unit: % BT RSSI Threshold for      2-Ant free-run/2-Ant TDMA translation, default = 46 */
+#define	BT_8821C_2ANT_WIFI_RSSI_COEXSWITCH_THRES2				80  /* unit: % WiFi RSSI Threshold for   1-Ant TDMA/1-Ant PS-TDMA translation, default = 42 */
+#define	BT_8821C_2ANT_BT_RSSI_COEXSWITCH_THRES2				80 /*  unit: % BT RSSI Threshold for      1-Ant TDMA/1-Ant PS-TDMA translation, default = 46 */
+#define	BT_8821C_2ANT_DEFAULT_ISOLATION						15	 /*  unit: dB */
+#define   BT_8821C_2ANT_WIFI_MAX_TX_POWER						15	 /*  unit: dBm */
+#define   BT_8821C_2ANT_BT_MAX_TX_POWER							3	 /*  unit: dBm */
+#define   BT_8821C_2ANT_WIFI_SIR_THRES1							-15  /*  unit: dB */
+#define   BT_8821C_2ANT_WIFI_SIR_THRES2							-30  /*  unit: dB */
+#define   BT_8821C_2ANT_BT_SIR_THRES1							-15		 /*  unit: dB */
+#define   BT_8821C_2ANT_BT_SIR_THRES2							-30		 /*  unit: dB */
+
+
+/* for Antenna detection */
+#define	BT_8821C_2ANT_ANTDET_PSDTHRES_BACKGROUND						50
+#define	BT_8821C_2ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION				70
+#define	BT_8821C_2ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION			52
+#define	BT_8821C_2ANT_ANTDET_PSDTHRES_1ANT							40
+#define	BT_8821C_2ANT_ANTDET_RETRY_INTERVAL							10	/* retry timer if ant det is fail, unit: second */
+#define	BT_8821C_2ANT_ANTDET_SWEEPPOINT_DELAY							60000
+#define	BT_8821C_2ANT_ANTDET_ENABLE										0
+#define	BT_8821C_2ANT_ANTDET_BTTXTIME									100
+#define	BT_8821C_2ANT_ANTDET_BTTXCHANNEL								39
+#define	BT_8821C_2ANT_ANTDET_PSD_SWWEEPCOUNT						50
+
+
+#define	BT_8821C_2ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT		30000
+
+enum bt_8821c_2ant_signal_state {
+	BT_8821C_2ANT_SIG_STA_SET_TO_LOW		= 0x0,
+	BT_8821C_2ANT_SIG_STA_SET_BY_HW		= 0x0,
+	BT_8821C_2ANT_SIG_STA_SET_TO_HIGH		= 0x1,
+	BT_8821C_2ANT_SIG_STA_MAX
+};
+
+enum bt_8821c_2ant_path_ctrl_owner {
+	BT_8821C_2ANT_PCO_BTSIDE		= 0x0,
+	BT_8821C_2ANT_PCO_WLSIDE	= 0x1,
+	BT_8821C_2ANT_PCO_MAX
+};
+
+enum bt_8821c_2ant_gnt_ctrl_type {
+	BT_8821C_2ANT_GNT_TYPE_CTRL_BY_PTA		= 0x0,
+	BT_8821C_2ANT_GNT_TYPE_CTRL_BY_SW		= 0x1,
+	BT_8821C_2ANT_GNT_TYPE_MAX
+};
+
+enum bt_8821c_2ant_gnt_ctrl_block {
+	BT_8821C_2ANT_GNT_BLOCK_RFC_BB		= 0x0,
+	BT_8821C_2ANT_GNT_BLOCK_RFC			= 0x1,
+	BT_8821C_2ANT_GNT_BLOCK_BB			= 0x2,
+	BT_8821C_2ANT_GNT_BLOCK_MAX
+};
+
+enum bt_8821c_2ant_lte_coex_table_type {
+	BT_8821C_2ANT_CTT_WL_VS_LTE			= 0x0,
+	BT_8821C_2ANT_CTT_BT_VS_LTE			= 0x1,
+	BT_8821C_2ANT_CTT_MAX
+};
+
+enum bt_8821c_2ant_lte_break_table_type {
+	BT_8821C_2ANT_LBTT_WL_BREAK_LTE			= 0x0,
+	BT_8821C_2ANT_LBTT_BT_BREAK_LTE				= 0x1,
+	BT_8821C_2ANT_LBTT_LTE_BREAK_WL			= 0x2,
+	BT_8821C_2ANT_LBTT_LTE_BREAK_BT				= 0x3,
+	BT_8821C_2ANT_LBTT_MAX
+};
+
+enum bt_info_src_8821c_2ant {
+	BT_INFO_SRC_8821C_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8821C_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8821C_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8821C_2ANT_MAX
+};
+
+enum bt_8821c_2ant_bt_status {
+	BT_8821C_2ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8821C_2ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8821C_2ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8821C_2ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8821C_2ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8821C_2ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8821C_2ANT_BT_STATUS_MAX
+};
+
+enum bt_8821c_2ant_coex_algo {
+	BT_8821C_2ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8821C_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8821C_2ANT_COEX_ALGO_HID				= 0x2,
+	BT_8821C_2ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8821C_2ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8821C_2ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8821C_2ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8821C_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8821C_2ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8821C_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8821C_2ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8821C_2ANT_COEX_ALGO_NOPROFILEBUSY		= 0xb,
+	BT_8821C_2ANT_COEX_ALGO_MAX
+};
+
+enum bt_8821c_2ant_ext_ant_switch_type {
+	BT_8821C_2ANT_EXT_ANT_SWITCH_USE_DPDT		= 0x0,
+	BT_8821C_2ANT_EXT_ANT_SWITCH_USE_SPDT		= 0x1,
+	BT_8821C_2ANT_EXT_ANT_SWITCH_NONE			= 0x2,
+	BT_8821C_2ANT_EXT_ANT_SWITCH_MAX
+};
+
+enum bt_8821c_2ant_ext_ant_switch_ctrl_type {
+	BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW	= 0x0,
+	BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_PTA		= 0x1,
+	BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_ANTDIV	= 0x2,
+	BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_MAC		= 0x3,
+	BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_BY_BT		= 0x4,
+	BT_8821C_2ANT_EXT_ANT_SWITCH_CTRL_MAX
+};
+
+enum bt_8821c_2ant_ext_ant_switch_pos_type {
+	BT_8821C_2ANT_EXT_ANT_SWITCH_MAIN_TO_BT			= 0x0,
+	BT_8821C_2ANT_EXT_ANT_SWITCH_MAIN_TO_WLG			= 0x1,
+	BT_8821C_2ANT_EXT_ANT_SWITCH_MAIN_TO_WLA			= 0x2,
+	BT_8821C_2ANT_EXT_ANT_SWITCH_MAIN_TO_NOCARE		= 0x3,
+	BT_8821C_2ANT_EXT_ANT_SWITCH_MAIN_TO_MAX
+};
+
+enum bt_8821c_2ant_ext_band_switch_pos_type {
+	BT_8821C_2ANT_EXT_BAND_SWITCH_TO_WLG			= 0x0,
+	BT_8821C_2ANT_EXT_BAND_SWITCH_TO_WLA			= 0x1,
+	BT_8821C_2ANT_EXT_BAND_SWITCH_TO_MAX
+};
+
+enum bt_8821c_2ant_int_block {
+	BT_8821C_2ANT_INT_BLOCK_SWITCH_TO_WLG_OF_BTG			= 0x0,
+	BT_8821C_2ANT_INT_BLOCK_SWITCH_TO_WLG_OF_WLAG		= 0x1,
+	BT_8821C_2ANT_INT_BLOCK_SWITCH_TO_WLA_OF_WLAG		= 0x2,
+	BT_8821C_2ANT_INT_BLOCK_SWITCH_TO_MAX
+};
+
+enum bt_8821c_2ant_phase {
+	BT_8821C_2ANT_PHASE_COEX_INIT								= 0x0,
+	BT_8821C_2ANT_PHASE_WLANONLY_INIT							= 0x1,
+	BT_8821C_2ANT_PHASE_WLAN_OFF								= 0x2,
+	BT_8821C_2ANT_PHASE_2G_RUNTIME								= 0x3,
+	BT_8821C_2ANT_PHASE_5G_RUNTIME								= 0x4,
+	BT_8821C_2ANT_PHASE_BTMPMODE								= 0x5,
+	BT_8821C_2ANT_PHASE_ANTENNA_DET								= 0x6,
+	BT_8821C_2ANT_PHASE_COEX_POWERON							= 0x7,
+	BT_8821C_2ANT_PHASE_2G_RUNTIME_CONCURRENT					= 0x8,
+	BT_8821C_2ANT_PHASE_MAX
+};
+
+enum bt_8821c_2ant_Scoreboard {
+	BT_8821C_2ANT_SCOREBOARD_ACTIVE								= BIT(0),
+	BT_8821C_2ANT_SCOREBOARD_ONOFF								= BIT(1),
+	BT_8821C_2ANT_SCOREBOARD_SCAN								= BIT(2),
+	BT_8821C_2ANT_SCOREBOARD_UNDERTEST							= BIT(3),
+	BT_8821C_2ANT_SCOREBOARD_WLBUSY								= BIT(6)
+};
+
+
+
+struct coex_dm_8821c_2ant {
+	/* hw setting */
+	u32		pre_ant_pos_type;
+	u32		cur_ant_pos_type;
+	/* fw mechanism */
+	u8		pre_bt_dec_pwr_lvl;
+	u8		cur_bt_dec_pwr_lvl;
+	u8		pre_fw_dac_swing_lvl;
+	u8		cur_fw_dac_swing_lvl;
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		reset_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+
+	/* sw mechanism */
+	boolean		pre_rf_rx_lpf_shrink;
+	boolean		cur_rf_rx_lpf_shrink;
+	u32		bt_rf_0x1e_backup;
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	boolean		pre_dac_swing_on;
+	u32		pre_dac_swing_lvl;
+	boolean		cur_dac_swing_on;
+	u32		cur_dac_swing_lvl;
+	boolean		pre_adc_back_off;
+	boolean		cur_adc_back_off;
+	boolean	pre_agc_table_en;
+	boolean		cur_agc_table_en;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	boolean		need_recover0x948;
+	u32		backup0x948;
+
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	boolean		is_switch_to_1dot5_ant;
+	u8		switch_thres_offset;
+	u32					arp_cnt;
+
+	u32		pre_ext_ant_switch_status;
+	u32		cur_ext_ant_switch_status;
+
+	u8		pre_ext_band_switch_status;
+	u8		cur_ext_band_switch_status;
+
+	u8		pre_int_block_status;
+	u8		cur_int_block_status;
+};
+
+struct coex_sta_8821c_2ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	boolean             is_hiPri_rx_overhead;
+	u8					bt_rssi;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	u8					bt_info_c2h[BT_INFO_SRC_8821C_2ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8821C_2ANT_MAX];
+	boolean				bt_whck_test;
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_remote_name_req;
+
+	u8					bt_info_ext;
+	u8					bt_info_ext2;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+	u8					bt_retry_cnt;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_vht;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_vht;
+
+	boolean					cck_lock;
+	boolean					pre_ccklock;
+	boolean					cck_ever_lock;
+
+	u8					coex_table_type;
+	boolean					force_lps_on;
+
+	u8					dis_ver_info_cnt;
+
+	u8					a2dp_bit_pool;
+	u8					cut_version;
+
+	boolean					concurrent_rx_mode_on;
+
+	u16					score_board;
+	u8					isolation_btween_wb;   /* 0~ 50 */
+	u8					wifi_coex_thres;
+	u8					bt_coex_thres;
+	u8					wifi_coex_thres2;
+	u8					bt_coex_thres2;
+
+	u8					num_of_profile;
+	boolean				acl_busy;
+	boolean				bt_create_connection;
+	boolean				wifi_is_high_pri_task;
+	u32					specific_pkt_period_cnt;
+	u32					bt_coex_supported_feature;
+	u32					bt_coex_supported_version;
+
+	u8					bt_ble_scan_type;
+	u32					bt_ble_scan_para[3];
+
+	boolean				run_time_state;
+	boolean				freeze_coexrun_by_btinfo;
+
+	boolean				is_A2DP_3M;
+	boolean				voice_over_HOGP;
+	u8                  bt_info;
+	boolean				is_autoslot;
+	u8					forbidden_slot;
+	u8					hid_busy_num;
+	u8					hid_pair_cnt;
+
+	u32					cnt_RemoteNameReq;
+	u32					cnt_setupLink;
+	u32					cnt_ReInit;
+	u32					cnt_IgnWlanAct;
+	u32					cnt_Page;
+	u32					cnt_RoleSwitch;
+
+	u16					bt_reg_vendor_ac;
+	u16					bt_reg_vendor_ae;
+
+	boolean				is_setupLink;
+	u8				    wl_noisy_level;
+	u32                 gnt_error_cnt;
+
+	u8					bt_afh_map[10];
+	u8					bt_relink_downcount;
+	boolean				is_tdma_btautoslot;
+	boolean				is_tdma_btautoslot_hang;
+};
+
+
+#define  BT_8821C_2ANT_EXT_BAND_SWITCH_USE_DPDT	0
+#define  BT_8821C_2ANT_EXT_BAND_SWITCH_USE_SPDT	1
+
+
+struct rfe_type_8821c_2ant {
+
+	u8			rfe_module_type;
+	boolean		ext_ant_switch_exist;
+	u8			ext_ant_switch_type;			/* 0:DPDT, 1:SPDT */
+	u8			ext_ant_switch_ctrl_polarity;		/*  iF 0: DPDT_P=0, DPDT_N=1 => BTG to Main, WL_A+G to Aux */
+
+	boolean		ext_band_switch_exist;
+	u8			ext_band_switch_type;			/* 0:DPDT, 1:SPDT */
+	u8			ext_band_switch_ctrl_polarity;
+
+	boolean		ant_at_main_port;
+
+	boolean		wlg_Locate_at_btg;				/*  If true:  WLG at BTG, If false: WLG at WLAG */
+
+	boolean		ext_ant_switch_diversity;		/* If diversity on */
+};
+
+#define BT_8821C_2ANT_ANTDET_PSD_POINTS			256	/* MAX:1024 */
+#define BT_8821C_2ANT_ANTDET_PSD_AVGNUM		1	/* MAX:3 */
+#define BT_8821C_2ANT_ANTDET_BUF_LEN			16
+
+struct psdscan_sta_8821c_2ant {
+
+	u32			ant_det_bt_le_channel;  /* BT LE Channel ex:2412 */
+	u32			ant_det_bt_tx_time;
+	u32			ant_det_pre_psdscan_peak_val;
+	boolean			ant_det_is_ant_det_available;
+	u32			ant_det_psd_scan_peak_val;
+	boolean			ant_det_is_btreply_available;
+	u32			ant_det_psd_scan_peak_freq;
+
+	u8			ant_det_result;
+	u8			ant_det_peak_val[BT_8821C_2ANT_ANTDET_BUF_LEN];
+	u8			ant_det_peak_freq[BT_8821C_2ANT_ANTDET_BUF_LEN];
+	u32			ant_det_try_count;
+	u32			ant_det_fail_count;
+	u32			ant_det_inteval_count;
+	u32			ant_det_thres_offset;
+
+	u32			real_cent_freq;
+	s32			real_offset;
+	u32			real_span;
+
+	u32			psd_band_width;  /* unit: Hz */
+	u32			psd_point;		/* 128/256/512/1024 */
+	u32			psd_report[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_report_max_hold[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_start_point;
+	u32			psd_stop_point;
+	u32			psd_max_value_point;
+	u32			psd_max_value;
+	u32			psd_max_value2;
+	u32			psd_avg_value;   /* filter loop_max_value that below BT_8821C_1ANT_ANTDET_PSDTHRES_1ANT, and average the rest*/
+	u32			psd_loop_max_value[BT_8821C_2ANT_ANTDET_PSD_SWWEEPCOUNT];  /*max value in each loop */
+	u32			psd_start_base;
+	u32			psd_avg_num;	/* 1/8/16/32 */
+	u32			psd_gen_count;
+	boolean			is_AntDet_running;
+	boolean			is_psd_show_max_only;
+};
+
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8821c2ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821c2ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821c2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8821c2ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821c2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821c2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821c2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8821c2ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821c2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8821c2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821c2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821c2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8821c2ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821c2ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821c2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8821c2ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821c2ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821c2ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+void ex_halbtc8821c2ant_display_ant_detection(IN struct btc_coexist *btcoexist);
+
+
+#else
+#define	ex_halbtc8821c2ant_power_on_setting(btcoexist)
+#define	ex_halbtc8821c2ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8821c2ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8821c2ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8821c2ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8821c2ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8821c2ant_scan_notify(btcoexist, type)
+#define   ex_halbtc8821c2ant_switchband_notify(btcoexist,type)
+#define	ex_halbtc8821c2ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8821c2ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8821c2ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8821c2ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8821c2ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8821c2ant_halt_notify(btcoexist)
+#define	ex_halbtc8821c2ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8821c2ant_periodical(btcoexist)
+#define	ex_halbtc8821c2ant_display_coex_info(btcoexist)
+#define	ex_halbtc8821c2ant_display_ant_detection(btcoexist)
+#define	ex_halbtc8821c2ant_antenna_detection(btcoexist, cent_freq, offset, span, seconds)
+#endif
+
+#endif
+
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8821cwifionly.c
@@ -0,0 +1,186 @@
+#include "mp_precomp.h"
+
+static struct	rfe_type_8821c_wifi_only	gl_rfe_type_8821c_1ant;
+static struct	rfe_type_8821c_wifi_only	*rfe_type = &gl_rfe_type_8821c_1ant;
+
+
+
+VOID hal8821c_wifi_only_switch_antenna(
+	IN struct wifi_only_cfg *pwifionlycfg,
+	IN u1Byte is_5g
+	)
+{
+	boolean switch_polatiry_inverse = false;
+	u8	regval_0xcb7 = 0;
+	u8	pos_type, ctrl_type;
+
+	if (!rfe_type->ext_ant_switch_exist)
+		return;
+
+	/* swap control polarity if use different switch control polarity*/
+	/*	Normal switch polarity for DPDT, 0xcb4[29:28] = 2b'01 => BTG to Main, WLG to Aux,  0xcb4[29:28] = 2b'10 => BTG to Aux, WLG to Main */
+	/*	Normal switch polarity for SPDT, 0xcb4[29:28] = 2b'01 => Ant to BTG,  0xcb4[29:28] = 2b'10 => Ant to WLG */
+	if (rfe_type->ext_ant_switch_ctrl_polarity)
+		switch_polatiry_inverse =  !switch_polatiry_inverse;
+
+	/* swap control polarity if 1-Ant at Aux */
+	if (rfe_type->ant_at_main_port == false)
+		switch_polatiry_inverse =  !switch_polatiry_inverse;
+
+	if (is_5g)
+		pos_type = BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_TO_WLA;
+	else
+		pos_type = BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_TO_WLG;
+
+	switch (pos_type) {
+	default:
+	case BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_TO_WLA:
+
+		break;
+	case BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_TO_WLG:
+		if (!rfe_type->wlg_Locate_at_btg)
+			switch_polatiry_inverse =  !switch_polatiry_inverse;
+		break;
+	}
+
+	if (pwifionlycfg->haldata_info.ant_div_cfg)
+		ctrl_type = BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_CTRL_BY_ANTDIV;
+	else
+		ctrl_type = BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_CTRL_BY_BBSW;
+
+
+	switch (ctrl_type) {
+	default:
+	case BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_CTRL_BY_BBSW:
+		halwifionly_phy_set_bb_reg(pwifionlycfg, 0x4c,  0x01800000, 0x2);
+
+		/* BB SW, DPDT use RFE_ctrl8 and RFE_ctrl9 as control pin */
+		halwifionly_phy_set_bb_reg(pwifionlycfg, 0xcb4, 0x000000ff,	0x77);
+
+		regval_0xcb7 = (switch_polatiry_inverse == false ? 0x1 : 0x2);
+
+		/* 0xcb4[29:28] = 2b'01 for no switch_polatiry_inverse, DPDT_SEL_N =1, DPDT_SEL_P =0 */
+		halwifionly_phy_set_bb_reg(pwifionlycfg, 0xcb4, 0x30000000,	regval_0xcb7);
+		break;
+
+	case BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_CTRL_BY_ANTDIV:
+		halwifionly_phy_set_bb_reg(pwifionlycfg, 0x4c,  0x01800000, 0x2);
+
+		/* BB SW, DPDT use RFE_ctrl8 and RFE_ctrl9 as control pin */
+		halwifionly_phy_set_bb_reg(pwifionlycfg, 0xcb4, 0x000000ff,	0x88);
+
+		/* no regval_0xcb7 setup required, because	antenna switch control value by antenna diversity */
+
+		break;
+
+	}
+
+}
+
+
+VOID halbtc8821c_wifi_only_set_rfe_type(
+	IN struct wifi_only_cfg *pwifionlycfg
+	)
+{
+
+	/* the following setup should be got from Efuse in the future */
+	rfe_type->rfe_module_type = (pwifionlycfg->haldata_info.rfe_type) & 0x1f;
+
+	rfe_type->ext_ant_switch_ctrl_polarity = 0;
+
+	switch (rfe_type->rfe_module_type) {
+	case 0:
+	default:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_USE_DPDT;          /*2-Ant, DPDT, WLG*/
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 1:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_USE_SPDT;          /*1-Ant, Main, DPDT or SPDT, WLG */
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 2:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_USE_SPDT;            /*1-Ant, Main, DPDT or SPDT, BTG */
+		rfe_type->wlg_Locate_at_btg = true;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 3:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_USE_DPDT;          /*1-Ant, Aux, DPDT, WLG */
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = false;
+		break;
+	case 4:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_USE_DPDT;          /*1-Ant, Aux, DPDT, BTG */
+		rfe_type->wlg_Locate_at_btg = true;
+		rfe_type->ant_at_main_port = false;
+		break;
+	case 5:
+		rfe_type->ext_ant_switch_exist = false;					 /*2-Ant, no antenna switch, WLG*/
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_NONE;
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 6:
+		rfe_type->ext_ant_switch_exist = false;				 /*2-Ant, no antenna switch, WLG*/
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_NONE;
+		rfe_type->wlg_Locate_at_btg = false;
+		rfe_type->ant_at_main_port = true;
+		break;
+	case 7:
+		rfe_type->ext_ant_switch_exist = true;				/*2-Ant, DPDT, BTG*/
+		rfe_type->ext_ant_switch_type =
+			BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_USE_DPDT;
+		rfe_type->wlg_Locate_at_btg = true;
+		rfe_type->ant_at_main_port = true;
+		break;
+	}
+
+}
+
+
+VOID
+ex_hal8821c_wifi_only_hw_config(
+	IN struct wifi_only_cfg *pwifionlycfg
+	)
+{
+	halbtc8821c_wifi_only_set_rfe_type(pwifionlycfg);
+
+	/* set gnt_wl, gnt_bt control owner to WL*/
+	halwifionly_phy_set_bb_reg(pwifionlycfg, 0x70, 0x400000, 0x1);
+
+	/*gnt_wl=1 , gnt_bt=0*/
+	halwifionly_phy_set_bb_reg(pwifionlycfg, 0x1704, 0xffffffff, 0x7700);
+	halwifionly_phy_set_bb_reg(pwifionlycfg, 0x1700, 0xffffffff, 0xc00f0038);
+}
+
+VOID
+ex_hal8821c_wifi_only_scannotify(
+	IN struct wifi_only_cfg *pwifionlycfg,
+	IN u1Byte  is_5g
+	)
+{
+	hal8821c_wifi_only_switch_antenna(pwifionlycfg, is_5g);
+}
+
+VOID
+ex_hal8821c_wifi_only_switchbandnotify(
+	IN struct wifi_only_cfg *pwifionlycfg,
+	IN u1Byte  is_5g
+	)
+{
+	hal8821c_wifi_only_switch_antenna(pwifionlycfg, is_5g);
+}
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8821cwifionly.h
@@ -0,0 +1,70 @@
+#ifndef __INC_HAL8821CWIFIONLYHWCFG_H
+#define __INC_HAL8821CWIFIONLYHWCFG_H
+
+
+struct rfe_type_8821c_wifi_only {
+
+	u8			rfe_module_type;
+	boolean		ext_ant_switch_exist;
+	u8			ext_ant_switch_type;			/* 0:DPDT, 1:SPDT */
+	u8			ext_ant_switch_ctrl_polarity;		/*  iF 0: DPDT_P=0, DPDT_N=1 => BTG to Main, WL_A+G to Aux */
+
+	boolean		ant_at_main_port;
+
+	boolean		wlg_Locate_at_btg;				/*  If true:  WLG at BTG, If false: WLG at WLAG */
+
+	boolean		ext_ant_switch_diversity;		/* If diversity on */
+};
+
+enum bt_8821c_wifi_only_ext_ant_switch_type {
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_USE_DPDT		= 0x0,
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_USE_SPDT		= 0x1,
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_NONE			= 0x2,
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_MAX
+};
+
+enum bt_8821c_wifi_only_ext_ant_switch_ctrl_type {
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_CTRL_BY_BBSW		= 0x0,
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_CTRL_BY_PTA		= 0x1,
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_CTRL_BY_ANTDIV	= 0x2,
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_CTRL_BY_MAC		= 0x3,
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_CTRL_BY_BT		= 0x4,
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_CTRL_MAX
+};
+
+enum bt_8821c_wifi_only_ext_ant_switch_pos_type {
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_TO_BT				= 0x0,
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_TO_WLG			= 0x1,
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_TO_WLA			= 0x2,
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_TO_NOCARE			= 0x3,
+	BT_8821C_WIFI_ONLY_EXT_ANT_SWITCH_TO_MAX
+};
+
+
+VOID
+hal8821c_wifi_only_switch_antenna(
+	IN struct wifi_only_cfg *pwifionlycfg,
+	IN u1Byte  is_5g
+	);
+
+VOID
+halbtc8821c_wifi_only_set_rfe_type(
+	IN struct wifi_only_cfg *pwifionlycfg
+	);
+
+
+VOID
+ex_hal8821c_wifi_only_hw_config(
+	IN struct wifi_only_cfg *pwifionlycfg
+	);
+VOID
+ex_hal8821c_wifi_only_scannotify(
+	IN struct wifi_only_cfg *pwifionlycfg,
+	IN u1Byte  is_5g
+	);
+VOID
+ex_hal8821c_wifi_only_switchbandnotify(
+	IN struct wifi_only_cfg *pwifionlycfg,
+	IN u1Byte  is_5g
+	);
+#endif
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8822b1ant.c
@@ -0,0 +1,7002 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8822B Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+/*only for rf4ce*/
+#include "mp_precomp.h"
+
+/*#include "mp_precomp.h" */
+
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8822B_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8822b_1ant		glcoex_dm_8822b_1ant;
+static struct  coex_dm_8822b_1ant	*coex_dm = &glcoex_dm_8822b_1ant;
+static struct  coex_sta_8822b_1ant		glcoex_sta_8822b_1ant;
+static struct  coex_sta_8822b_1ant	*coex_sta = &glcoex_sta_8822b_1ant;
+static struct  psdscan_sta_8822b_1ant	gl_psd_scan_8822b_1ant;
+static struct  psdscan_sta_8822b_1ant *psd_scan = &gl_psd_scan_8822b_1ant;
+static struct	rfe_type_8822b_1ant		gl_rfe_type_8822b_1ant;
+static struct	rfe_type_8822b_1ant		*rfe_type = &gl_rfe_type_8822b_1ant;
+
+
+
+const char *const glbt_info_src_8822b_1ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8822b_1ant = 20161124;
+u32	glcoex_ver_8822b_1ant = 0x3f;
+u32	glcoex_ver_btdesired_8822b_1ant = 0x28;
+
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8822b1ant_
+ * ************************************************************ */
+u8 halbtc8822b1ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8822B_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8822B_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8822B_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8822b1ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8822B_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8822B_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8822B_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8822b1ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8822b1ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8822b1ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8822b1ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8822b1ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8822b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8822b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8822b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8822b1ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8822b1ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8822b1ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+/*
+rx agg size setting :
+1:      true / don't care / don't care
+max: false / false / don't care
+7:     false / true / 7
+*/
+
+void halbtc8822b1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8822b1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+void halbtc8822b1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u8		num_of_bt_counter_chk = 0, cnt_slave = 0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* to avoid 0x76e[3] = 1 (WLAN_Act control by PTA) during IPS */
+	/* if (! (btcoexist->btc_read_1byte(btcoexist, 0x76e) & 0x8) ) */
+
+	if (coex_sta->under_ips) {
+		/* coex_sta->high_priority_tx = 65535; */
+		/* coex_sta->high_priority_rx = 65535; */
+		/* coex_sta->low_priority_tx = 65535; */
+		/* coex_sta->low_priority_rx = 65535; */
+		/* return; */
+	}
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Hi-Pri Rx/Tx: %d/%d, Lo-Pri Rx/Tx: %d/%d\n",
+		    reg_hp_rx, reg_hp_tx, reg_lp_rx, reg_lp_tx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	if ((coex_sta->low_priority_tx > 1150)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	if ((coex_sta->low_priority_rx >= 1150) &&
+	    (coex_sta->low_priority_rx >= coex_sta->low_priority_tx)
+	    && (!coex_sta->under_ips)  &&
+	    (!coex_sta->c2h_bt_inquiry_page) &&
+	    (coex_sta->bt_link_exist))	{
+		if (cnt_slave >= 3) {
+			bt_link_info->slave_role = true;
+			cnt_slave = 3;
+		} else
+			cnt_slave++;
+	} else {
+		if (cnt_slave == 0)	{
+			bt_link_info->slave_role = false;
+			cnt_slave = 0;
+		} else
+			cnt_slave--;
+
+	}
+
+	if ((coex_sta->high_priority_tx == 0) &&
+	    (coex_sta->high_priority_rx == 0) &&
+	    (coex_sta->low_priority_tx == 0) &&
+	    (coex_sta->low_priority_rx == 0)) {
+		num_of_bt_counter_chk++;
+
+		if (num_of_bt_counter_chk >= 3) {
+			halbtc8822b1ant_query_bt_info(
+				btcoexist);
+			num_of_bt_counter_chk = 0;
+		}
+	}
+#if 0
+	/* Add Hi-Pri Tx/Rx counter to avoid false detection */
+	if (((coex_sta->hid_exist) || (coex_sta->sco_exist)) &&
+	    (coex_sta->high_priority_tx + coex_sta->high_priority_rx
+	     >= 160)
+	    && (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->bt_hi_pri_link_exist = true;
+	else
+		coex_sta->bt_hi_pri_link_exist = false;
+
+	if ((coex_sta->acl_busy) &&
+	    (coex_sta->num_of_profile == 0)) {
+		if (coex_sta->low_priority_tx +
+		    coex_sta->low_priority_rx >= 160) {
+			coex_sta->pan_exist = true;
+			coex_sta->num_of_profile++;
+			coex_sta->wrong_profile_notification++;
+		}
+	}
+#endif
+
+}
+
+
+void halbtc8822b1ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+	s32 wifi_rssi = 0;
+	boolean wifi_busy = false, wifi_under_b_mode = false;
+	static u8 cck_lock_counter = 0;
+	u32 total_cnt;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+			   &wifi_under_b_mode);
+
+	if (coex_sta->under_ips) {
+		coex_sta->crc_ok_cck = 0;
+		coex_sta->crc_ok_11g = 0;
+		coex_sta->crc_ok_11n = 0;
+		coex_sta->crc_ok_11n_agg = 0;
+
+		coex_sta->crc_err_cck = 0;
+		coex_sta->crc_err_11g = 0;
+		coex_sta->crc_err_11n = 0;
+		coex_sta->crc_err_11n_agg = 0;
+	} else {
+		coex_sta->crc_ok_cck	= btcoexist->btc_read_2byte(
+						  btcoexist,
+						  0xf04);
+		coex_sta->crc_ok_11g	= btcoexist->btc_read_2byte(
+						  btcoexist,
+						  0xf14);
+		coex_sta->crc_ok_11n	= btcoexist->btc_read_2byte(
+						  btcoexist,
+						  0xf10);
+		coex_sta->crc_ok_11n_agg = btcoexist->btc_read_2byte(
+						   btcoexist,
+						   0xf0c);
+
+		coex_sta->crc_err_cck	 = btcoexist->btc_read_2byte(
+			   btcoexist, 0xf00) +  btcoexist->btc_read_2byte(
+						   btcoexist, 0xf06);
+
+		coex_sta->crc_err_11g	 = btcoexist->btc_read_2byte(
+						   btcoexist,
+						   0xf16);
+		coex_sta->crc_err_11n	 = btcoexist->btc_read_2byte(
+						   btcoexist,
+						   0xf12);
+		coex_sta->crc_err_11n_agg = btcoexist->btc_read_2byte(
+						    btcoexist,
+						    0xf0e);
+	}
+
+
+	/* reset counter */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xb58, 0x1, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xb58, 0x1, 0x0);
+
+	if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+		total_cnt = coex_sta->crc_ok_cck + coex_sta->crc_ok_11g
+			    +
+			    coex_sta->crc_ok_11n +
+			    coex_sta->crc_ok_11n_agg;
+
+		if ((coex_dm->bt_status ==
+		     BT_8822B_1ANT_BT_STATUS_ACL_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8822B_1ANT_BT_STATUS_ACL_SCO_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8822B_1ANT_BT_STATUS_SCO_BUSY)) {
+			if (coex_sta->crc_ok_cck > (total_cnt -
+						    coex_sta->crc_ok_cck)) {
+				if (cck_lock_counter < 3)
+					cck_lock_counter++;
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+	} else {
+		if (cck_lock_counter > 0)
+			cck_lock_counter--;
+	}
+
+	if (!coex_sta->pre_ccklock) {
+
+		if (cck_lock_counter >= 3)
+			coex_sta->cck_lock = true;
+		else
+			coex_sta->cck_lock = false;
+	} else {
+		if (cck_lock_counter == 0)
+			coex_sta->cck_lock = false;
+		else
+			coex_sta->cck_lock = true;
+	}
+
+	if (coex_sta->cck_lock)
+		coex_sta->cck_ever_lock = true;
+
+	coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+
+}
+
+
+boolean halbtc8822b1ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false, pre_rf4ce_enabled = false, pre_bt_off = false;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false, rf4ce_enabled = false;
+	boolean wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (coex_sta->bt_disabled != pre_bt_off) {
+		pre_bt_off = coex_sta->bt_disabled;
+
+		if (coex_sta->bt_disabled)
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+		else
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is enabled !!\n");
+
+		BTC_TRACE(trace_buf);
+
+		coex_sta->bt_coex_supported_feature = 0;
+		coex_sta->bt_coex_supported_version = 0;
+		return true;
+	}
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_RF4CE_CONNECTED, &rf4ce_enabled);
+
+		if (rf4ce_enabled != pre_rf4ce_enabled) {
+		pre_rf4ce_enabled = rf4ce_enabled;
+
+		if (rf4ce_enabled)
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], rf4ce is enabled !!\n");
+		else
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], rf4ce is disabled !!\n");
+
+		BTC_TRACE(trace_buf);
+
+
+		return true;
+	}
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void halbtc8822b1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+	bt_link_info->bt_hi_pri_link_exist = coex_sta->bt_hi_pri_link_exist;
+	bt_link_info->acl_busy = coex_sta->acl_busy;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+void halbtc8822b1ant_update_wifi_channel_info(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+
+		h2c_parameter[0] =
+			0x1;  /* enable BT AFH skip WL channel for 8822b because BT Rx LO interference */
+		h2c_parameter[1] = wifi_central_chnl;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+
+}
+
+u8 halbtc8822b1ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8822B_1ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Profile = SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8822B_1ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8822B_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8822B_1ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_1ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_1ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8822B_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8822B_1ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8822B_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8822B_1ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_1ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_1ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8822B_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8822B_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_1ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! BT Profile = SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8822b1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8822b1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8822b1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+
+
+void halbtc8822b1ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf7;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf8;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf9;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8822b1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+#if 1
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra ==
+		    coex_dm->cur_low_penalty_ra)
+			return;
+	}
+
+	if (low_penalty_ra)
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 25);
+	else
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 0);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+
+#endif
+}
+
+void halbtc8822b1ant_write_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16				bitpos,
+	IN	boolean		state
+)
+{
+
+	static u16 originalval = 0x8002;
+
+	if (state)
+		originalval = originalval | bitpos;
+	else
+		originalval = originalval & (~bitpos);
+
+	btcoexist->btc_write_2byte(btcoexist, 0xaa, originalval);
+}
+
+void halbtc8822b1ant_read_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN   u16				*score_board_val
+)
+{
+
+	*score_board_val = (btcoexist->btc_read_2byte(btcoexist,
+			    0xaa)) & 0x7fff;
+}
+
+void halbtc8822b1ant_post_state_to_bt(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16						type,
+	IN  boolean                 state
+)
+{
+
+	halbtc8822b1ant_write_score_board(btcoexist, (u16) type, state);
+
+}
+
+
+void halbtc8822b1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false,
+				wifi_under_5g = false;
+	u16		u16tmp;
+
+	/* This function check if bt is disabled */
+#if 0
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+
+
+#else
+
+	/* Read BT on/off status from scoreboard[1], enable this only if BT patch support this feature */
+	halbtc8822b1ant_read_score_board(btcoexist, &u16tmp);
+
+	bt_active = u16tmp & BIT(1);
+
+
+#endif
+
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	} else {
+
+		bt_disable_cnt++;
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			bt_disable_cnt = 2;
+		}
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	}
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G,
+			   &wifi_under_5g);
+
+	if ((wifi_under_5g) || (bt_disabled))
+		halbtc8822b1ant_low_penalty_ra(btcoexist,
+					       NORMAL_EXEC, false);
+	else
+		halbtc8822b1ant_low_penalty_ra(btcoexist,
+					       NORMAL_EXEC, true);
+
+
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" :
+			     "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+	}
+
+}
+
+
+
+void halbtc8822b1ant_enable_gnt_to_gpio(IN struct btc_coexist *btcoexist,
+					boolean isenable)
+{
+	static u8			bitVal[5] = {0, 0, 0, 0, 0};
+	static boolean		state = false;
+
+	if (state == isenable)
+		return;
+
+	state = isenable;
+
+	if (isenable) {
+
+		/* enable GNT_WL, GNT_BT to GPIO for debug */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x1);
+
+		/* store original value */
+		bitVal[0] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x66) & BIT(4)) >> 4;	/*0x66[4] */
+		bitVal[1] = (btcoexist->btc_read_1byte(btcoexist,
+					       0x67) & BIT(0));		/*0x66[8] */
+		bitVal[2] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x42) & BIT(3)) >> 3;  /*0x40[19] */
+		bitVal[3] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x65) & BIT(7)) >> 7;  /*0x64[15] */
+		bitVal[4] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x72) & BIT(2)) >> 2;  /*0x70[18] */
+
+		/*  switch GPIO Mux */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x66, BIT(4),
+						   0x0);  /*0x66[4] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, BIT(0),
+						   0x0);  /*0x66[8] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x42, BIT(3),
+						   0x0);  /*0x40[19] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x65, BIT(7),
+						   0x0);  /*0x64[15] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x72, BIT(2),
+						   0x0);  /*0x70[18] = 0 */
+
+
+	} else {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x0);
+
+		/*  Restore original value  */
+		/*  switch GPIO Mux */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x66, BIT(4),
+						   bitVal[0]);  /*0x66[4] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, BIT(0),
+						   bitVal[1]);  /*0x66[8] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x42, BIT(3),
+					   bitVal[2]);  /*0x40[19] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x65, BIT(7),
+					   bitVal[3]);  /*0x64[15] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x72, BIT(2),
+					   bitVal[4]);  /*0x70[18] = 0 */
+	}
+
+}
+
+
+u32 halbtc8822b1ant_ltecoex_indirect_read_reg(IN struct btc_coexist *btcoexist,
+		IN u16 reg_addr)
+{
+	u32 j = 0, delay_count = 0;
+
+
+	/* wait for ready bit before access 0x1700		 */
+	btcoexist->btc_write_4byte(btcoexist, 0x1700, 0x800F0000 | reg_addr);
+#if 0
+	do {
+		j++;
+	} while (((btcoexist->btc_read_1byte(btcoexist,
+					     0x1703) & BIT(5)) == 0) &&
+		 (j < BT_8822B_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+#endif
+	while (1) {
+		if ((btcoexist->btc_read_1byte(btcoexist, 0x1703)&BIT(5)) == 0) {
+			delay_ms(50);
+			delay_count++;
+			if (delay_count >= 10) {
+				delay_count = 0;
+				break;
+			}
+		} else
+			break;
+	}
+	return btcoexist->btc_read_4byte(btcoexist,
+					 0x1708);  /* get read data */
+
+}
+
+void halbtc8822b1ant_ltecoex_indirect_write_reg(IN struct btc_coexist
+		*btcoexist,
+		IN u16 reg_addr, IN u32 bit_mask, IN u32 reg_value)
+{
+	u32 val, i = 0, j = 0, bitpos = 0, delay_count = 0;
+
+
+	if (bit_mask == 0x0)
+		return;
+	if (bit_mask == 0xffffffff) {
+		btcoexist->btc_write_4byte(btcoexist, 0x1704,
+					   reg_value); /* put write data */
+
+		/* wait for ready bit before access 0x1700 */
+#if 0
+		do {
+			j++;
+		} while (((btcoexist->btc_read_1byte(btcoexist,
+						     0x1703) & BIT(5)) == 0) &&
+			(j < BT_8822B_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+#endif
+
+		while (1) {
+			if ((btcoexist->btc_read_1byte(btcoexist, 0x1703)&BIT(5)) == 0) {
+				delay_ms(50);
+				delay_count++;
+				if (delay_count >= 10)	{
+					delay_count = 0;
+					break;
+}
+			} else
+				break;
+		}
+		btcoexist->btc_write_4byte(btcoexist, 0x1700,
+					   0xc00F0000 | reg_addr);
+	} else {
+		for (i = 0; i <= 31; i++) {
+			if (((bit_mask >> i) & 0x1) == 0x1) {
+				bitpos = i;
+				break;
+			}
+		}
+
+		/* read back register value before write */
+		val = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+				reg_addr);
+		val = (val & (~bit_mask)) | (reg_value << bitpos);
+
+		/* put write data value */
+		btcoexist->btc_write_4byte(btcoexist, 0x1704,
+					   val); /* put write data */
+
+		/* wait for ready bit before access 0x1700		 */
+#if	0
+		do {
+			j++;
+		} while (((btcoexist->btc_read_1byte(btcoexist,
+						     0x1703) & BIT(5)) == 0) &&
+			(j < BT_8822B_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+#endif
+
+		while (1) {
+			if ((btcoexist->btc_read_1byte(btcoexist, 0x1703)&BIT(5)) == 0) {
+				delay_ms(50);
+				delay_count++;
+				if (delay_count >= 10)	{
+					delay_count = 0;
+					break;
+				}
+			} else
+				break;
+		}
+
+
+
+		btcoexist->btc_write_4byte(btcoexist, 0x1700,
+					   0xc00F0000 | reg_addr);
+
+	}
+
+}
+
+void halbtc8822b1ant_ltecoex_enable(IN struct btc_coexist *btcoexist,
+				    IN boolean enable)
+{
+	u8 val;
+
+	val = (enable) ? 1 : 0;
+	/* 0x38[7] */
+	halbtc8822b1ant_ltecoex_indirect_write_reg(btcoexist, 0x38, 0x80,
+			val);  /* 0x38[7] */
+
+}
+
+
+void halbtc8822b1ant_ltecoex_pathcontrol_owner(IN struct btc_coexist *btcoexist,
+		IN boolean wifi_control)
+{
+	u8 val;
+
+	val = (wifi_control) ? 1 : 0;
+	/* 0x70[26] */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x4,
+					   val); /* 0x70[26] */
+
+}
+
+void halbtc8822b1ant_ltecoex_set_gnt_bt(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, bit_mask;
+
+	state = state & 0x1;
+	/*LTE indirect 0x38=0xccxx (sw : gnt_wl=1,sw gnt_bt=1)
+	0x38=0xddxx (sw : gnt_bt=1 , sw gnt_wl=0)
+	0x38=0x55xx(hw pta :gnt_wl /gnt_bt ) */
+	val = (sw_control) ? ((state << 1) | 0x1) : 0;
+
+	switch (control_block) {
+	case BT_8822B_1ANT_GNT_BLOCK_RFC_BB:
+	default:
+		bit_mask = 0xc000;
+		halbtc8822b1ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[15:14] */
+		bit_mask = 0x0c00;
+		halbtc8822b1ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[11:10]						 */
+		break;
+	case BT_8822B_1ANT_GNT_BLOCK_RFC:
+		bit_mask = 0xc000;
+		halbtc8822b1ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[15:14] */
+		break;
+	case BT_8822B_1ANT_GNT_BLOCK_BB:
+		bit_mask = 0x0c00;
+		halbtc8822b1ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[11:10] */
+		break;
+
+	}
+
+}
+
+void halbtc8822b1ant_ltecoex_set_gnt_wl(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, bit_mask;
+	/*LTE indirect 0x38=0xccxx (sw : gnt_wl=1,sw gnt_bt=1)
+	0x38=0xddxx (sw : gnt_bt=1 , sw gnt_wl=0)
+	0x38=0x55xx(hw pta :gnt_wl /gnt_bt ) */
+
+	state = state & 0x1;
+	val = (sw_control) ? ((state << 1) | 0x1) : 0;
+
+	switch (control_block) {
+	case BT_8822B_1ANT_GNT_BLOCK_RFC_BB:
+	default:
+		bit_mask = 0x3000;
+		halbtc8822b1ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[13:12] */
+		bit_mask = 0x0300;
+		halbtc8822b1ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[9:8]						 */
+		break;
+	case BT_8822B_1ANT_GNT_BLOCK_RFC:
+		bit_mask = 0x3000;
+		halbtc8822b1ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[13:12] */
+		break;
+	case BT_8822B_1ANT_GNT_BLOCK_BB:
+		bit_mask = 0x0300;
+		halbtc8822b1ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[9:8] */
+		break;
+
+	}
+
+}
+
+void halbtc8822b1ant_ltecoex_set_coex_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u16 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8822B_1ANT_CTT_WL_VS_LTE:
+		reg_addr = 0xa0;
+		break;
+	case BT_8822B_1ANT_CTT_BT_VS_LTE:
+		reg_addr = 0xa4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8822b1ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xffff, table_content); /* 0xa0[15:0] or 0xa4[15:0] */
+
+
+}
+
+
+void halbtc8822b1ant_ltcoex_set_break_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u8 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8822B_1ANT_LBTT_WL_BREAK_LTE:
+		reg_addr = 0xa8;
+		break;
+	case BT_8822B_1ANT_LBTT_BT_BREAK_LTE:
+		reg_addr = 0xac;
+		break;
+	case BT_8822B_1ANT_LBTT_LTE_BREAK_WL:
+		reg_addr = 0xb0;
+		break;
+	case BT_8822B_1ANT_LBTT_LTE_BREAK_BT:
+		reg_addr = 0xb4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8822b1ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xff, table_content); /* 0xa8[15:0] or 0xb4[15:0] */
+
+
+}
+
+void halbtc8822b1ant_set_wltoggle_coex_table(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec,  IN u8 interval,
+		IN u8 val0x6c4_b0, IN u8 val0x6c4_b1, IN u8 val0x6c4_b2,
+		IN u8 val0x6c4_b3)
+{
+	static u8 pre_h2c_parameter[6] = {0};
+	u8	cur_h2c_parameter[6] = {0};
+	u8 i, match_cnt = 0;
+
+	cur_h2c_parameter[0] = 0x7;	/* op_code, 0x7= wlan toggle slot*/
+
+	cur_h2c_parameter[1] = interval;
+	cur_h2c_parameter[2] = val0x6c4_b0;
+	cur_h2c_parameter[3] = val0x6c4_b1;
+	cur_h2c_parameter[4] = val0x6c4_b2;
+	cur_h2c_parameter[5] = val0x6c4_b3;
+
+	if (!force_exec) {
+		for (i = 1; i <= 5; i++) {
+			if (cur_h2c_parameter[i] != pre_h2c_parameter[i])
+				break;
+
+			match_cnt++;
+		}
+
+		if (match_cnt == 5)
+			return;
+	}
+
+	for (i = 1; i <= 5; i++)
+		pre_h2c_parameter[i] = cur_h2c_parameter[i];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, cur_h2c_parameter);
+}
+
+void halbtc8822b1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8822b1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8822b1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8822b1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	u32	break_table;
+	u8	select_table;
+
+
+
+	coex_sta->coex_table_type = type;
+
+	if (coex_sta->concurrent_rx_mode_on == true) {
+		break_table = 0xf0ffffff;	/* set WL hi-pri can break BT */
+		select_table = 0x3;		/* set Tx response = Hi-Pri (ex: Transmitting ACK,BA,CTS) */
+	} else {
+		break_table = 0xffffff;
+		select_table = 0x3;
+	}
+
+	switch (type) {
+	case 0:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0x55555555, 0x55555555, break_table,
+					   select_table);
+		break;
+	case 1:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0x55555555, 0x5a5a5a5a, break_table,
+					   select_table);
+		break;
+	case 2:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0xaa5a5a5a, 0xaa5a5a5a, break_table,
+					   select_table);
+		break;
+	case 3:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0x55555555, 0xaa5a5a5a, break_table,
+					   select_table);
+		break;
+	case 4:
+		halbtc8822b1ant_coex_table(btcoexist,
+					   force_exec, 0xaa555555, 0xaa5a5a5a,
+					   break_table, select_table);
+		break;
+	case 5:
+		halbtc8822b1ant_coex_table(btcoexist,
+					   force_exec, 0x5a5a5a5a, 0x5a5a5a5a,
+					   break_table, select_table);
+		break;
+	case 6:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0x55555555, 0xaaaaaaaa, break_table,
+					   select_table);
+		break;
+	case 7:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0xaaaaaaaa, 0xaaaaaaaa, break_table,
+					   select_table);
+		break;
+	case 8:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0xffffffff, 0xffffffff, break_table,
+					   select_table);
+		break;
+	case 9:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0x5a5a5555, 0xaaaa5a5a, break_table,
+					   select_table);
+		break;
+	case 10:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0xaaaa5aaa, 0xaaaa5aaa, break_table,
+					   select_table);
+		break;
+	case 11:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0xaaaaa5aa, 0xaaaaaaaa, break_table,
+					   select_table);
+		break;
+	case 12:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0xaaaaa5aa, 0xaaaaa5aa, break_table,
+					   select_table);
+		break;
+	case 13:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0x55555555, 0xaaaa5a5a, break_table,
+					   select_table);
+		break;
+	case 14:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0x5a5a555a, 0xaaaa5a5a, break_table,
+					   select_table);
+		break;
+	case 15:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0x55555555, 0xaaaa55aa, break_table,
+					   select_table);
+		break;
+	case 16:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0x5a5a555a, 0x5a5a555a, break_table,
+					   select_table);
+		break;
+	case 17:
+		halbtc8822b1ant_coex_table(btcoexist, force_exec,
+					   0xaaaa55aa, 0xaaaa55aa, break_table,
+					   select_table);
+		break;
+
+	default:
+		break;
+	}
+}
+
+void halbtc8822b1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+
+
+	u8			h2c_parameter[1] = {0};
+
+	if (enable)
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8822b1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act) {
+
+			coex_dm->pre_ignore_wlan_act =
+				coex_dm->cur_ignore_wlan_act;
+			return;
+		}
+	}
+
+	halbtc8822b1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8822b1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8822b1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8822b1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8822b1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0x8, 0, 0, 0, 0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) { /* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+
+void halbtc8822b1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		coex_sta->force_lps_on = false;
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+
+		coex_sta->force_lps_on = true;
+		halbtc8822b1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8822b1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+
+		coex_sta->force_lps_on = false;
+		halbtc8822b1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+
+void halbtc8822b1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean		ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for 1Ant AP mode\n");
+			BTC_TRACE(trace_buf);
+
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8822b1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0,
+							 0x0);
+		}
+	} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+
+		halbtc8822b1ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50,
+						 0x4);
+	} else {
+		halbtc8822b1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0,
+						 0x0);
+	}
+
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8822b1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	boolean			wifi_busy = false;
+	static u8			psTdmaByte4Modify = 0x0, pre_psTdmaByte4Modify = 0x0;
+	static boolean	 pre_wifi_busy = false;
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (wifi_busy != pre_wifi_busy) {
+		force_exec = true;
+		pre_wifi_busy = wifi_busy;
+	}
+
+	/* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+	if ((bt_link_info->slave_role) && (bt_link_info->a2dp_exist))
+		psTdmaByte4Modify = 0x1;
+	else
+		psTdmaByte4Modify = 0x0;
+
+	if (pre_psTdmaByte4Modify != psTdmaByte4Modify) {
+
+		force_exec = true;
+		pre_psTdmaByte4Modify = psTdmaByte4Modify;
+	}
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], **********TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], return for no-TDMA case change\n");
+			BTC_TRACE(trace_buf);
+
+			return;
+		}
+	}
+
+
+	if (turn_on) {
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+
+		switch (type) {
+		default:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 1:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x3a, 0x03, 0x11, 0x10);
+			break;
+		case 3:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x3a, 0x03, 0x10, 0x10);
+			break;
+		case 4:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x21, 0x03, 0x10, 0x10);
+			break;
+		case 5:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x15, 0x3, 0x11, 0x11);
+			break;
+		case 7:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x10, 0x03, 0x10,  0x14 |
+						      psTdmaByte4Modify);
+			break;
+		case 8:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x10, 0x03, 0x10,  0x14 |
+						      psTdmaByte4Modify);
+			break;
+		case 13:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x25, 0x03, 0x10,  0x10 |
+						      psTdmaByte4Modify);
+			break;
+		case 14:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x15, 0x03, 0x10,  0x10 |
+						      psTdmaByte4Modify);
+			break;
+		case 15:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x20, 0x03, 0x10,  0x10 |
+						      psTdmaByte4Modify);
+			break;
+		case 17:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x10, 0x03, 0x11,  0x14 |
+						      psTdmaByte4Modify);
+			break;
+
+		case 20:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x30, 0x03, 0x11, 0x10);
+			break;
+		case 22:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x25, 0x03, 0x11, 0x10);
+			break;
+		case 32:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x35, 0x3, 0x11, 0x11);
+			break;
+		case 33:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x35, 0x03, 0x11, 0x10);
+			break;
+		case 41:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x45, 0x3, 0x11, 0x11);
+			break;
+		case 42:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x1e, 0x3, 0x10, 0x14 |
+						      psTdmaByte4Modify);
+			break;
+		case 43:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x45, 0x3, 0x10, 0x14);
+			break;
+		case 44:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x25, 0x3, 0x10, 0x10);
+			break;
+		case 45:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x29, 0x3, 0x10, 0x10);
+			break;
+		case 46:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x1a, 0x3, 0x10, 0x10);
+			break;
+		case 47:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x32, 0x3, 0x10, 0x10);
+			break;
+		case 48:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x29, 0x3, 0x10, 0x10);
+			break;
+		case 49:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x55, 0x1e, 0x3, 0x10, 0x54);
+			break;
+		case 50:
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x4a, 0x3, 0x10, 0x10);
+			break;
+
+		}
+	} else {
+
+		switch (type) {
+		case 0:
+		default:  /* Software control, Antenna at BT side */
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+						      0x0, 0x0, 0x0, 0x0, 0x0);
+			/*
+			halbtc8822b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_BT, FORCE_EXEC, false,
+						     false); */
+			break;
+		case 8: /* PTA Control */
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+						      0x8, 0x0, 0x0, 0x0, 0x0);
+			/*
+			halbtc8822b1ant_set_ant_path(btcoexist,
+				     BTC_ANT_PATH_PTA, FORCE_EXEC,  false,
+				     false);  */
+			break;
+		case 9:   /* Software control, Antenna at WiFi side */
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+						      0x0, 0x0, 0x0, 0x0, 0x0);
+			/*
+			halbtc8822b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_WIFI, FORCE_EXEC,false,false); */
+			break;
+		case 10:	/* under 5G , 0x778=1*/
+			halbtc8822b1ant_set_fw_pstdma(btcoexist,
+						      0x0, 0x0, 0x0, 0x0, 0x0);
+
+			/*
+			halbtc8822b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_WIFI5G, FORCE_EXEC, false,
+						     false);	*/
+
+			break;
+		}
+	}
+
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+
+void halbtc8822b1ant_sw_mechanism(IN struct btc_coexist *btcoexist,
+				  IN boolean low_penalty_ra)
+{
+	halbtc8822b1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+/*rf4 type by efuse , and for ant at main aux inverse use , because is 2x2 ,and control types are the same ,does not need */
+
+void halbtc8822b1ant_set_rfe_type(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+
+	/* Ext switch buffer mux */
+		btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x1991, 0x3, 0x0);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbe, 0x8, 0x0);
+
+	/* the following setup should be got from Efuse in the future */
+	rfe_type->rfe_module_type = board_info->rfe_type;
+
+	rfe_type->ext_ant_switch_ctrl_polarity = 0;
+
+	switch (rfe_type->rfe_module_type) {
+	case 0:
+	default:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8822B_1ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 1:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8822B_1ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 2:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8822B_1ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 3:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+			BT_8822B_1ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 4:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+BT_8822B_1ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 5:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+BT_8822B_1ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 6:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+BT_8822B_1ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 7:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+BT_8822B_1ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	}
+
+
+}
+
+/*anttenna control by bb mac bt antdiv pta to write 0x4c 0xcb4,0xcbd*/
+
+void halbtc8822b1ant_set_ext_ant_switch(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u8 ctrl_type, IN u8 pos_type)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	boolean	switch_polatiry_inverse = false;
+	u8		regval_0xcbd = 0, regval_0x64;
+	u32		u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+	/* Ext switch buffer mux */
+		btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x1991, 0x3, 0x0);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbe, 0x8, 0x0);
+
+	if (!rfe_type->ext_ant_switch_exist)
+		return;
+
+	coex_dm->cur_ext_ant_switch_status = (ctrl_type << 8)  + pos_type;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ext_ant_switch_status ==
+		    coex_dm->cur_ext_ant_switch_status)
+			return;
+	}
+
+	coex_dm->pre_ext_ant_switch_status = coex_dm->cur_ext_ant_switch_status;
+
+	/* swap control polarity if use different switch control polarity*/
+	/*  Normal switch polarity for SPDT, 0xcbd[1:0] = 2b'01 => Ant to BTG,  0xcbd[1:0] = 2b'10 => Ant to WLG */
+	switch_polatiry_inverse = (rfe_type->ext_ant_switch_ctrl_polarity == 1 ?
+			   ~switch_polatiry_inverse : switch_polatiry_inverse);
+
+
+	switch (pos_type) {
+	default:
+	case BT_8822B_1ANT_EXT_ANT_SWITCH_TO_BT:
+	case BT_8822B_1ANT_EXT_ANT_SWITCH_TO_NOCARE:
+
+		break;
+	case BT_8822B_1ANT_EXT_ANT_SWITCH_TO_WLG:
+		break;
+	case BT_8822B_1ANT_EXT_ANT_SWITCH_TO_WLA:
+		break;
+	}
+
+
+	if (rfe_type->ext_ant_switch_type ==
+	    BT_8822B_1ANT_EXT_ANT_SWITCH_USE_SPDT) {
+		switch (ctrl_type) {
+		default:
+		case BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW:
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0x4e, 0x80,
+				0x0);  /*  0x4c[23] = 0 */
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0x4f, 0x01,
+				0x1);  /* 0x4c[24] = 1 */
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0xcb4, 0xff,
+				0x77);	/* BB SW, DPDT use RFE_ctrl8 and RFE_ctrl9 as conctrol pin */
+
+			regval_0xcbd = (switch_polatiry_inverse
+					== false ?  0x1 :
+				0x2);    /* 0xcbd[1:0] = 2b'01 for no switch_polatiry_inverse, ANTSWB =1, ANTSW =0  */
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0xcbd, 0x3,
+				regval_0xcbd);
+
+			break;
+		case BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_PTA:
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0x4e, 0x80,
+				0x0);  /* 0x4c[23] = 0 */
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0x4f, 0x01,
+				0x1);  /* 0x4c[24] = 1 */
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0xcb4, 0xff,
+				0x66);	/* PTA,  DPDT use RFE_ctrl8 and RFE_ctrl9 as conctrol pin */
+
+			regval_0xcbd = (switch_polatiry_inverse
+					== false ?  0x2 :
+				0x1);    /* 0xcbd[1:0] = 2b'10 for no switch_polatiry_inverse, ANTSWB =1, ANTSW =0  @ GNT_BT=1 */
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0xcbd, 0x3,
+				regval_0xcbd);
+
+			break;
+		case BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_ANTDIV
+				:
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0x4e, 0x80,
+				0x0);  /* 0x4c[23] = 0 */
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0x4f, 0x01,
+				0x1);  /* 0x4c[24] = 1 */
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0xcb4, 0xff,
+				0x88);  /* */
+
+			/* no regval_0xcbd setup required, because  antenna switch control value by antenna diversity */
+
+			break;
+		case BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_MAC:
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0x4e, 0x80,
+				0x1);  /*  0x4c[23] = 1 */
+
+			regval_0x64 = (switch_polatiry_inverse
+				       == false ?  0x0 :
+				0x1);    /* 0x64[0] = 1b'0 for no switch_polatiry_inverse, DPDT_SEL_N =1, DPDT_SEL_P =0 */
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0x64, 0x1,
+				regval_0x64);
+			break;
+		case BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_BT:
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0x4e, 0x80,
+				0x0);  /* 0x4c[23] = 0 */
+			btcoexist->btc_write_1byte_bitmask(
+				btcoexist, 0x4f, 0x01,
+				0x0);  /* 0x4c[24] = 0 */
+
+			/* no  setup required, because  antenna switch control value by BT vendor 0xac[1:0] */
+			break;
+		}
+	}
+
+	u32tmp1 = btcoexist->btc_read_4byte(btcoexist, 0xcbc);
+	u32tmp2 = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0x64) & 0xff;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (After Ext Ant switch setup) 0xcbc = 0x%08x, 0x4c = 0x%08x, 0x64= 0x%02x**********\n",
+		    u32tmp1, u32tmp2, u32tmp3);
+	BTC_TRACE(trace_buf);
+
+
+}
+
+/*set gnt_wl gnt_bt control by sw high low , or hwpta while in power on,ini,wlan off,wlan only ,wl2g non-currrent ,wl2g current,wl5g*/
+
+void halbtc8822b1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+				  IN u8 ant_pos_type, IN boolean force_exec,
+				  IN u8 phase)
+
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u8			u8tmp = 0;
+	u32			u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+	/* Ext switch buffer mux */
+		btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x1991, 0x3, 0x0);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbe, 0x8, 0x0);
+
+	coex_dm->cur_ant_pos_type = (ant_pos_type << 8)  + phase;
+
+	if (!force_exec) {
+		if (coex_dm->cur_ant_pos_type ==
+		    coex_dm->pre_ant_pos_type)
+			return;
+	}
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+
+#if 1
+	u32tmp1 = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0x38);
+	u32tmp2 = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0x54);
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+
+	u8tmp  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (Before Ant Setup) 0xcb4 = 0x%x, 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x**********\n",
+		    u32tmp3, u8tmp, u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+#endif
+
+	switch (phase) {
+	case BT_8822B_1ANT_PHASE_COEX_INIT:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (set_ant_path - 1ANT_PHASE_COEX_INIT) **********\n");
+		BTC_TRACE(trace_buf);
+
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8822b1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8822b1ant_ltecoex_set_coex_table(btcoexist,
+					       BT_8822B_1ANT_CTT_WL_VS_LTE,
+						       0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8822b1ant_ltecoex_set_coex_table(btcoexist,
+					       BT_8822B_1ANT_CTT_BT_VS_LTE,
+						       0xffff);
+
+		/* set GNT_BT to SW high */
+		halbtc8822b1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8822B_1ANT_GNT_BLOCK_RFC_BB,
+						   BT_8822B_1ANT_GNT_CTRL_BY_SW,
+					   BT_8822B_1ANT_SIG_STA_SET_TO_HIGH);
+
+		/* set GNT_WL to SW low */
+		halbtc8822b1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8822B_1ANT_GNT_BLOCK_RFC_BB,
+						   BT_8822B_1ANT_GNT_CTRL_BY_SW,
+					   BT_8822B_1ANT_SIG_STA_SET_TO_LOW);
+
+		/* set Path control owner to WL at initial step */
+		halbtc8822b1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8822B_1ANT_PCO_WLSIDE);
+
+		coex_sta->run_time_state = false;
+
+		/* Ext switch buffer mux */
+		btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x1991,
+						   0x3, 0x0);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbe,
+						   0x8, 0x0);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		break;
+	case BT_8822B_1ANT_PHASE_WLANONLY_INIT:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (set_ant_path - 1ANT_PHASE_WLANONLY_INIT) **********\n");
+		BTC_TRACE(trace_buf);
+
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8822b1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8822b1ant_ltecoex_set_coex_table(btcoexist,
+					       BT_8822B_1ANT_CTT_WL_VS_LTE,
+						       0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8822b1ant_ltecoex_set_coex_table(btcoexist,
+					       BT_8822B_1ANT_CTT_BT_VS_LTE,
+						       0xffff);
+
+		/* set GNT_BT to SW Low */
+		halbtc8822b1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8822B_1ANT_GNT_BLOCK_RFC_BB,
+						   BT_8822B_1ANT_GNT_CTRL_BY_SW,
+					   BT_8822B_1ANT_SIG_STA_SET_TO_LOW);
+
+		/* Set GNT_WL to SW high */
+		halbtc8822b1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8822B_1ANT_GNT_BLOCK_RFC_BB,
+						   BT_8822B_1ANT_GNT_CTRL_BY_SW,
+					   BT_8822B_1ANT_SIG_STA_SET_TO_HIGH);
+
+		/* set Path control owner to WL at initial step */
+		halbtc8822b1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8822B_1ANT_PCO_WLSIDE);
+
+		coex_sta->run_time_state = false;
+
+		/* Ext switch buffer mux */
+		btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x1991,
+						   0x3, 0x0);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbe,
+						   0x8, 0x0);
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_WIFI;
+
+		break;
+	case BT_8822B_1ANT_PHASE_WLAN_OFF:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (set_ant_path - 1ANT_PHASE_WLAN_OFF) **********\n");
+		BTC_TRACE(trace_buf);
+
+		/* Disable LTE Coex Function in WiFi side */
+		halbtc8822b1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* set Path control owner to BT */
+		halbtc8822b1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8822B_1ANT_PCO_BTSIDE);
+
+		/* Set Ext Ant Switch to BT control at wifi off step */
+		halbtc8822b1ant_set_ext_ant_switch(btcoexist,
+						   FORCE_EXEC,
+				   BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_BT,
+				   BT_8822B_1ANT_EXT_ANT_SWITCH_TO_NOCARE);
+
+		coex_sta->run_time_state = false;
+
+		break;
+	case BT_8822B_1ANT_PHASE_2G_RUNTIME:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (set_ant_path - 1ANT_PHASE_2G_RUNTIME) **********\n");
+		BTC_TRACE(trace_buf);
+
+		/* set GNT_BT to PTA */
+		halbtc8822b1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8822B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_1ANT_GNT_CTRL_BY_PTA,
+					   BT_8822B_1ANT_SIG_STA_SET_BY_HW);
+
+		/* Set GNT_WL to PTA */
+		halbtc8822b1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8822B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_1ANT_GNT_CTRL_BY_PTA,
+					   BT_8822B_1ANT_SIG_STA_SET_BY_HW);
+
+		/* set Path control owner to WL at runtime step */
+		halbtc8822b1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8822B_1ANT_PCO_WLSIDE);
+
+		coex_sta->run_time_state = true;
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_PTA;
+
+		break;
+	case BT_8822B_1ANT_PHASE_5G_RUNTIME:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (set_ant_path - 1ANT_PHASE_5G_RUNTIME) **********\n");
+		BTC_TRACE(trace_buf);
+
+		/* set GNT_BT to SW Hi */
+		halbtc8822b1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8822B_1ANT_GNT_BLOCK_RFC_BB,
+						   BT_8822B_1ANT_GNT_CTRL_BY_SW,
+					   BT_8822B_1ANT_SIG_STA_SET_TO_HIGH);
+
+		/* Set GNT_WL to SW Hi */
+		halbtc8822b1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8822B_1ANT_GNT_BLOCK_RFC_BB,
+						   BT_8822B_1ANT_GNT_CTRL_BY_SW,
+					   BT_8822B_1ANT_SIG_STA_SET_TO_HIGH);
+
+		/* set Path control owner to WL at runtime step */
+		halbtc8822b1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8822B_1ANT_PCO_WLSIDE);
+
+		coex_sta->run_time_state = true;
+
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type =
+				BTC_ANT_PATH_WIFI5G;
+
+		break;
+	case BT_8822B_1ANT_PHASE_BTMPMODE:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (set_ant_path - 1ANT_PHASE_BTMPMODE) **********\n");
+		BTC_TRACE(trace_buf);
+
+		/* Disable LTE Coex Function in WiFi side */
+		halbtc8822b1ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* set GNT_BT to SW Hi */
+		halbtc8822b1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8822B_1ANT_GNT_BLOCK_RFC_BB,
+						   BT_8822B_1ANT_GNT_CTRL_BY_SW,
+					   BT_8822B_1ANT_SIG_STA_SET_TO_HIGH);
+
+		/* Set GNT_WL to SW Lo */
+		halbtc8822b1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8822B_1ANT_GNT_BLOCK_RFC_BB,
+						   BT_8822B_1ANT_GNT_CTRL_BY_SW,
+					   BT_8822B_1ANT_SIG_STA_SET_TO_LOW);
+
+		/* set Path control owner to WL */
+		halbtc8822b1ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8822B_1ANT_PCO_WLSIDE);
+
+		coex_sta->run_time_state = false;
+
+		/* Set Ext Ant Switch to BT side at BT MP mode */
+		if (BTC_ANT_PATH_AUTO == ant_pos_type)
+			ant_pos_type = BTC_ANT_PATH_BT;
+
+		break;
+	}
+
+
+	if (phase != BT_8822B_1ANT_PHASE_WLAN_OFF) {
+		switch (ant_pos_type) {
+		case BTC_ANT_PATH_WIFI:
+			halbtc8822b1ant_set_ext_ant_switch(
+				btcoexist,
+				force_exec,
+				BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW,
+				BT_8822B_1ANT_EXT_ANT_SWITCH_TO_WLG);
+			break;
+		case BTC_ANT_PATH_WIFI5G
+				:
+			halbtc8822b1ant_set_ext_ant_switch(
+				btcoexist,
+				force_exec,
+				BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW,
+				BT_8822B_1ANT_EXT_ANT_SWITCH_TO_WLA);
+			break;
+		case BTC_ANT_PATH_BT:
+			halbtc8822b1ant_set_ext_ant_switch(
+				btcoexist,
+				force_exec,
+				BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW,
+				BT_8822B_1ANT_EXT_ANT_SWITCH_TO_BT);
+			break;
+		default:
+		case BTC_ANT_PATH_PTA:
+			halbtc8822b1ant_set_ext_ant_switch(
+				btcoexist,
+				force_exec,
+				BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_PTA,
+				BT_8822B_1ANT_EXT_ANT_SWITCH_TO_NOCARE);
+			break;
+		}
+
+	}
+#if 1
+	u32tmp1 = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+
+	u8tmp  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (After Ant Setup) 0xcb4 = 0x%x, 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x**********\n",
+		    u32tmp3, u8tmp, u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+
+#endif
+
+}
+
+
+void halbtc8822b1ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* sw all off */
+	halbtc8822b1ant_sw_mechanism(btcoexist, false);
+
+	/* hw all off */
+	halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+boolean halbtc8822b1ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected &&
+	    BT_8822B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8822b1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8822B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8822b1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (!wifi_connected &&
+		   (BT_8822B_1ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8822b1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8822B_1ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8822b1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (!wifi_connected &&
+		   (BT_8822B_1ANT_BT_STATUS_CONNECTED_IDLE !=
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non connected-idle + BT Busy!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8822b1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else {
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		common = false;
+	}
+
+	return common;
+}
+
+void halbtc8822b1ant_action_wifi_under5g(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], under 5g start\n");
+	BTC_TRACE(trace_buf);
+	/* for test : s3 bt disappear , fail rate 1/600*/
+/*
+	halbtc8822b1ant_ignore_wlan_act(btcoexist, NORMAL_EXEC, true);
+*/
+/*set sw gnt wl bt  high*/
+	halbtc8822b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+							 BT_8822B_1ANT_PHASE_5G_RUNTIME);
+
+	halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd,
+						   0x3, 1);
+/*
+	halbtc8822b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+	halbtc8822b1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 5);
+*/
+}
+
+
+
+void halbtc8822b1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	boolean wifi_under_5g = false, rf4ce_enabled = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		halbtc8822b1ant_action_wifi_under5g(btcoexist);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (wlan only -- under 5g ) **********\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (rf4ce_enabled) {
+				btcoexist->btc_write_1byte_bitmask(
+					btcoexist, 0x45e, 0x8, 0x1);
+
+				halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true,
+							50);
+
+				halbtc8822b1ant_coex_table_with_type(btcoexist,
+				NORMAL_EXEC, 1);
+		return;
+		}
+	halbtc8822b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+	halbtc8822b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+
+	halbtc8822b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+				     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (wlan only -- under 2g ) **********\n");
+	BTC_TRACE(trace_buf);
+
+}
+
+/* *********************************************
+ *
+ *	Software Coex Mechanism start
+ *
+ * ********************************************* */
+
+/* SCO only or SCO+PAN(HS) */
+
+/*
+void halbtc8822b1ant_action_sco(IN struct btc_coexist* btcoexist)
+{
+	halbtc8822b1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8822b1ant_action_hid(IN struct btc_coexist* btcoexist)
+{
+	halbtc8822b1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8822b1ant_action_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8822b1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8822b1ant_action_a2dp_pan_hs(IN struct btc_coexist* btcoexist)
+{
+	halbtc8822b1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8822b1ant_action_pan_edr(IN struct btc_coexist* btcoexist)
+{
+	halbtc8822b1ant_sw_mechanism(btcoexist, false);
+}
+
+
+void halbtc8822b1ant_action_pan_hs(IN struct btc_coexist* btcoexist)
+{
+	halbtc8822b1ant_sw_mechanism(btcoexist, false);
+}
+
+
+void halbtc8822b1ant_action_pan_edr_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8822b1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8822b1ant_action_pan_edr_hid(IN struct btc_coexist* btcoexist)
+{
+	halbtc8822b1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8822b1ant_action_hid_a2dp_pan_edr(IN struct btc_coexist* btcoexist)
+{
+	halbtc8822b1ant_sw_mechanism(btcoexist, true);
+}
+
+void halbtc8822b1ant_action_hid_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8822b1ant_sw_mechanism(btcoexist, true);
+}
+
+*/
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+void halbtc8822b1ant_action_bt_whck_test(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex],action_bt_whck_test\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+	halbtc8822b1ant_set_ant_path(btcoexist,
+				     BTC_ANT_PATH_AUTO,
+				     NORMAL_EXEC,
+				     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+	halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8822b1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex],action_wifi_multi_port\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+	halbtc8822b1ant_set_ant_path(btcoexist,
+				     BTC_ANT_PATH_AUTO,
+				     NORMAL_EXEC,
+				     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+	halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8822b1ant_action_hs(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], action_hs\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+
+	halbtc8822b1ant_set_ant_path(btcoexist,
+				     BTC_ANT_PATH_AUTO,
+				     NORMAL_EXEC,
+				     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+	halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+}
+
+/*"""bt inquiry"""" + wifi any + bt any*/
+void halbtc8822b1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_connected = false, ap_enable = false, wifi_busy = false,
+				bt_busy = false, rf4ce_enabled = false;
+
+
+	boolean		wifi_scan = false, link = false, roam = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** (bt inquiry) **********\n");
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &wifi_scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** scan = %d,  link =%d, roam = %d**********\n",
+		    wifi_scan, link, roam);
+	BTC_TRACE(trace_buf);
+
+	if ((link) || (roam) || (coex_sta->wifi_is_high_pri_task)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (bt inquiry wifi  connect or scan ) **********\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 1);
+
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 6);
+
+	} else if ((wifi_scan) && (coex_sta->bt_create_connection)) {
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 6);
+
+	} else if ((!wifi_connected) && (!wifi_scan)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (bt inquiry wifi non connect) **********\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	} else if ((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) {
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (bt_link_info->a2dp_exist) {
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	} else if (wifi_scan) {
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (wifi_busy) {
+
+		/* for BT inquiry/page fail after S4 resume */
+		/* halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);		 */
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+/*aaaa->55aa for bt connect while wl busy*/
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     15);
+	if (rf4ce_enabled) {
+				btcoexist->btc_write_1byte_bitmask(
+					btcoexist, 0x45e, 0x8, 0x1);
+
+				halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true,
+							50);
+
+				halbtc8822b1ant_coex_table_with_type(btcoexist,
+				NORMAL_EXEC, 0);
+
+		}
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (bt inquiry wifi connect) **********\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+		halbtc8822b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+					     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     4);
+	}
+
+	/*
+		if ((wifi_link) || (wifi_roam) || (coex_sta->wifi_is_high_pri_task)) {
+
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+			halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 6);
+
+		} else if ((wifi_scan) && (coex_sta->bt_create_connection)) {
+
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+			halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 6);
+
+		} else if ((!wifi_connected) && (!wifi_scan)) {
+
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+			halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		} else if ((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) {
+
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+			halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		} else if (bt_link_info->a2dp_exist) {
+
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+
+			halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		} else if (wifi_scan) {
+
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+
+			halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		} else if (wifi_busy) {
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+
+			halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		} else {
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 19);
+
+			halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		}
+	*/
+}
+
+void halbtc8822b1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x45e, 0x8, 0x1);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** (bt sco hid only busy) **********\n");
+	BTC_TRACE(trace_buf);
+
+	/*SCO  + wifi connected idle or busy / 0x778=1@wifi slot*/
+	if (bt_link_info->sco_exist) {
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x45e, 0x8, 0x1);
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+		/*case16 for connect SCO first then connect a2sp fail issue*/
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 16);
+
+	} else { /* HID  + wifi connected idle or busy / 0x778=1@wifi slot */
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x45e, 0x8, 0x1);
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+		/*case16 for connect HID first then connect a2sp fail issue*/
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 16);
+
+	}
+}
+
+/*wifi connected + bt acl busy*/
+void halbtc8822b1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+
+	u8		bt_rssi_state;
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_busy = false, wifi_turbo = false;
+	u32  wifi_bw = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW,
+				   &wifi_bw);
+btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+	bt_rssi_state = halbtc8822b1ant_bt_rssi_state(2, 28, 0);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+"[BTCoex], ********** (wifi connect acl busy) **********\n");
+	BTC_TRACE(trace_buf);
+
+
+
+	if (bt_link_info->hid_only) { /* HID  + wifi connected idle or busy / 0x778=1@wifi slot */
+
+
+
+
+		btcoexist->btc_write_1byte_bitmask(
+			btcoexist, 0x45e, 0x8, 0x1);
+
+
+
+		halbtc8822b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				wifi_status);
+		return;
+	} else if (
+		bt_link_info->a2dp_only) { /* A2DP  + wifi connected idle or busy */
+		if (BT_8822B_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifi_status) {
+
+
+			btcoexist->btc_write_1byte_bitmask(btcoexist, 0x45e,
+							   0x8, 0x1);
+
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8822b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+		} else {
+			if (coex_sta->scan_ap_num >=
+			    BT_8822B_1ANT_WIFI_NOISY_THRESH)  {
+				halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true,
+							17);
+			}	else {
+
+
+
+
+				btcoexist->btc_write_1byte_bitmask(
+					btcoexist, 0x45e, 0x8, 0x1);
+
+				halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true,
+							42);
+
+				halbtc8822b1ant_coex_table_with_type(btcoexist,
+				NORMAL_EXEC, 1);
+		}
+/*
+			halbtc8822b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+*/
+			coex_dm->auto_tdma_adjust = true;
+		}
+
+		/* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+	} else if (((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x45e, 0x8, 0x1);
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 47);
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     6);
+	} else if (bt_link_info->hid_exist &&
+		   bt_link_info->a2dp_exist) { /* HID+A2DP */
+
+		btcoexist->btc_write_1byte_bitmask(
+			btcoexist, 0x45e, 0x8, 0x1);
+		if (!wifi_busy) {
+/*a2dp glitch while wl idle , change the 0x6c0=5a5a5a5a->5555or aaaa55aa*/
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+								true,
+								32);
+			} else if (wifi_bw == 0) { /* 11bg mode */
+			halbtc8822b1ant_coex_table_with_type(btcoexist,
+										 NORMAL_EXEC, 1);
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+								true,
+								42);
+		} else {
+		/*if in open space , and ask wl tp , 0x60=6135031111,55555555,aaaa55aa*/
+		halbtc8822b1ant_coex_table_with_type(btcoexist,
+										 NORMAL_EXEC, 1);
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 42);
+}
+		/*
+				halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+								     1);
+		*/
+
+
+
+
+	} else if ((bt_link_info->pan_only) || (bt_link_info->hid_exist &&
+		bt_link_info->pan_exist)) { /* PAN(OPP,FTP), HID+PAN(OPP,FTP)*/
+		/*
+		if (BT_8723D_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifi_status)
+			halbtc8723d1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						4);
+		else
+		*/
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x45e, 0x8, 0x1);
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 47);
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     1);
+	} else {
+		/* BT no-profile busy (0x9) */
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x45e, 0x8, 0x1);
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     1);
+	}
+}
+
+/*wifi not connected + bt action*/
+void halbtc8822b1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	boolean wifi_under_5g = false, rf4ce_enabled = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** (wifi not connect) **********\n");
+	BTC_TRACE(trace_buf);
+
+	/* tdma and coex table */
+	if (rf4ce_enabled) {
+				btcoexist->btc_write_1byte_bitmask(
+					btcoexist, 0x45e, 0x8, 0x1);
+
+				halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true,
+							50);
+
+				halbtc8822b1ant_coex_table_with_type(btcoexist,
+				NORMAL_EXEC, 1);
+		return;
+		}
+	halbtc8822b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+
+	halbtc8822b1ant_set_ant_path(btcoexist,
+				     BTC_ANT_PATH_AUTO,
+				     NORMAL_EXEC,
+				     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+	halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+/*""""wl not connected scan"""" + bt action*/
+void halbtc8822b1ant_action_wifi_not_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (wifi non connect scan) **********\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if (num_of_wifi_link >= 2) {
+		halbtc8822b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8822b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+
+		if (coex_sta->c2h_bt_inquiry_page) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is Inquirying\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b1ant_action_bt_inquiry(btcoexist);
+		} else
+			halbtc8822b1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8822b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8822b1ant_action_hs(btcoexist);
+		return;
+	}
+
+	/* tdma and coex table */
+	if (BT_8822B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8822b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8822b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		} else {
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8822b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		}
+	} else if ((BT_8822B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8822B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8822b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8822B_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8822b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+					     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     5);
+	}
+}
+
+/*""""wl not connected asso"""" + bt action*/
+void halbtc8822b1ant_action_wifi_not_connected_asso_auth(
+	IN struct btc_coexist *btcoexist)
+{
+
+	struct	btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32 wifi_link_status = 0;
+	u32 num_of_wifi_link = 0;
+	boolean bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (wifi non connect asso_auth) **********\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if (num_of_wifi_link >= 2) {
+
+		halbtc8822b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8822b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size,
+					   agg_buf_size);
+
+		if (coex_sta->c2h_bt_inquiry_page) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is Inquirying\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b1ant_action_bt_inquiry(btcoexist);
+		} else
+			halbtc8822b1ant_action_wifi_multi_port(
+				btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8822b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8822b1ant_action_hs(btcoexist);
+		return;
+	}
+
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist)  || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8822b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8822b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 4);
+	} else {
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8822b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+					     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+		halbtc8822b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 2);
+	}
+}
+
+/*""""wl  connected scan"""" + bt action*/
+void halbtc8822b1ant_action_wifi_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** (wifi connect scan) **********\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if (num_of_wifi_link >= 2) {
+		halbtc8822b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8822b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+
+		if (coex_sta->c2h_bt_inquiry_page) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is Inquirying\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b1ant_action_bt_inquiry(btcoexist);
+		} else
+			halbtc8822b1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8822b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8822b1ant_action_hs(btcoexist);
+		return;
+	}
+
+	/* tdma and coex table */
+	if (BT_8822B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8822b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8822b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		} else {
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8822b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		}
+	} else if ((BT_8822B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8822B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8822b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8822B_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8822b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+					     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     6);
+	}
+}
+
+/*""""wl  connected specific packet"""" + bt action*/
+void halbtc8822b1ant_action_wifi_connected_specific_packet(
+	IN struct btc_coexist *btcoexist)
+{
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+	boolean wifi_busy = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (wifi connect specific packet) **********\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if (num_of_wifi_link >= 2) {
+		halbtc8822b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8822b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+
+		if (coex_sta->c2h_bt_inquiry_page) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is Inquirying\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b1ant_action_bt_inquiry(btcoexist);
+		} else
+			halbtc8822b1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8822b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8822b1ant_action_hs(btcoexist);
+		return;
+	}
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	/* no specific packet process for both WiFi and BT very busy */
+	if ((wifi_busy) && ((bt_link_info->pan_exist) ||
+			    (coex_sta->num_of_profile >= 2)))
+		return;
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist)) {
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	} else if (bt_link_info->a2dp_exist) {
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		/*for a2dp glitch,change from 1 to 15*/
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     15);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     1);
+	} else {
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8822b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+					     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     5);
+	}
+}
+
+/*wifi connected input point : to set different ps and tdma case (+bt different case)*/
+void halbtc8822b1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+
+	boolean	wifi_busy = false, rf4ce_enabled = false;
+	boolean		scan = false, link = false, roam = false;
+	boolean		under_4way = false, ap_enable = false, wifi_under_5g = false;
+	u8 wifi_rssi_state;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (wifi_under_5g) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under 5g<===\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b1ant_action_wifi_under5g(btcoexist);
+
+		return;
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], CoexForWifiConnect(), return for wifi is under 2g<===\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8822b1ant_set_ant_path(btcoexist,
+				     BTC_ANT_PATH_AUTO,
+				     NORMAL_EXEC,
+				     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (under_4way) {
+		halbtc8822b1ant_action_wifi_connected_specific_packet(
+			btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under 4way<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	if (scan || link || roam) {
+		if (scan)
+			halbtc8822b1ant_action_wifi_connected_scan(btcoexist);
+		else
+			halbtc8822b1ant_action_wifi_connected_specific_packet(
+				btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under scan<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	/* tdma and coex table */
+	if (!wifi_busy) {
+		if (BT_8822B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8822b1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8822B_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else if ((BT_8822B_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8822B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8822b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8822B_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else {
+
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+
+			halbtc8822b1ant_set_ant_path(btcoexist,
+						     BTC_ANT_PATH_AUTO,
+						     NORMAL_EXEC,
+					     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+			if ((coex_sta->high_priority_tx) +
+			    (coex_sta->high_priority_rx) <= 60)
+				/*sy modify case16 -> case17*/
+				halbtc8822b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+			else
+				halbtc8822b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		}
+	} else {
+		if (BT_8822B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8822b1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8822B_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else if ((BT_8822B_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8822B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8822b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8822B_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else {
+				if (rf4ce_enabled) {
+				btcoexist->btc_write_1byte_bitmask(
+					btcoexist, 0x45e, 0x8, 0x1);
+
+				halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true,
+							50);
+
+				halbtc8822b1ant_coex_table_with_type(btcoexist,
+				NORMAL_EXEC, 1);
+		return;
+		}
+
+
+
+			halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+
+			halbtc8822b1ant_set_ant_path(btcoexist,
+						     BTC_ANT_PATH_AUTO,
+						     NORMAL_EXEC,
+					     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+			/*
+
+						halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+											32);
+
+						halbtc8822b1ant_set_ant_path(btcoexist,
+						BTC_ANT_PATH_AUTO, NORMAL_EXEC, BT_8822B_1ANT_PHASE_2G_RUNTIME);
+			*/
+
+
+
+			wifi_rssi_state = halbtc8822b1ant_wifi_rssi_state(
+						  btcoexist, 1, 2, 25, 0);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** before  **********\n");
+			BTC_TRACE(trace_buf);
+/*
+			if ((BT_8822B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			     coex_dm->bt_status)  &&
+			    (coex_sta->scan_ap_num <= 3) &&
+			    (wifi_rssi_state == BTC_RSSI_STATE_LOW ||
+			     wifi_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+*/
+			if (BT_8822B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			coex_dm->bt_status) {
+					if (rf4ce_enabled) {
+				btcoexist->btc_write_1byte_bitmask(
+					btcoexist, 0x45e, 0x8, 0x1);
+
+				halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true,
+							50);
+
+				halbtc8822b1ant_coex_table_with_type(btcoexist,
+				NORMAL_EXEC, 1);
+		return;
+		}
+
+
+				halbtc8822b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+			} else
+
+				halbtc8822b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+
+
+
+			/*
+						else if ((coex_sta->high_priority_tx +
+										 coex_sta->high_priority_rx) <= 60)
+							halbtc8822b1ant_coex_table_with_type(btcoexist,
+										     NORMAL_EXEC, 1);
+						else
+							halbtc8822b1ant_coex_table_with_type(btcoexist,
+										     NORMAL_EXEC, 4);
+			*/
+		}
+	}
+}
+
+void halbtc8822b1ant_run_sw_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+
+	u8				algorithm = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** (runswcoexmech) **********\n");
+	BTC_TRACE(trace_buf);
+	algorithm = halbtc8822b1ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+
+	if (halbtc8822b1ant_is_common_action(btcoexist)) {
+
+	} else {
+		switch (coex_dm->cur_algorithm) {
+		case BT_8822B_1ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8822b1ant_action_sco(btcoexist); */
+			break;
+		case BT_8822B_1ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8822b1ant_action_hid(btcoexist); */
+			break;
+		case BT_8822B_1ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8822b1ant_action_a2dp(btcoexist); */
+			break;
+		case BT_8822B_1ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8822b1ant_action_a2dp_pan_hs(btcoexist); */
+			break;
+		case BT_8822B_1ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8822b1ant_action_pan_edr(btcoexist); */
+			break;
+		case BT_8822B_1ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8822b1ant_action_pan_hs(btcoexist); */
+			break;
+		case BT_8822B_1ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8822b1ant_action_pan_edr_a2dp(btcoexist); */
+			break;
+		case BT_8822B_1ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8822b1ant_action_pan_edr_hid(btcoexist); */
+			break;
+		case BT_8822B_1ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8822b1ant_action_hid_a2dp_pan_edr(btcoexist); */
+			break;
+		case BT_8822B_1ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8822b1ant_action_hid_a2dp(btcoexist); */
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8822b1ant_coex_all_off(btcoexist); */
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8822b1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, bt_hs_on = false;
+	boolean	increase_scan_dev_num = false;
+	boolean	bt_ctrl_agg_buf_size = false;
+	boolean	miracast_plus_bt = false;
+	u8	agg_buf_size = 5;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0, wifi_bw;
+	u8	iot_peer = BTC_IOT_PEER_UNKNOWN;
+	boolean wifi_under_5g = false;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (!coex_sta->run_time_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], return for run_time_state = false !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		halbtc8822b1ant_action_wifi_under5g(btcoexist);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under 5G!!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], WiFi is under 2G!!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8822b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+				     NORMAL_EXEC,
+				     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8822b1ant_action_bt_whck_test(btcoexist);
+		return;
+	}
+
+	if (coex_sta->bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is disabled !!!\n");
+		halbtc8822b1ant_action_wifi_only(btcoexist);
+		return;
+	}
+
+	if ((BT_8822B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8822B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8822B_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+			   &increase_scan_dev_num);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist) {
+			halbtc8822b1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1,
+						   0, 1);
+			miracast_plus_bt = true;
+		} else {
+			halbtc8822b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0,
+						   0, 0);
+			miracast_plus_bt = false;
+		}
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+		halbtc8822b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+
+		if ((bt_link_info->a2dp_exist) &&
+		    (coex_sta->c2h_bt_inquiry_page)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is Inquirying\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b1ant_action_bt_inquiry(btcoexist);
+		} else
+			halbtc8822b1ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	}
+
+	miracast_plus_bt = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+			   &miracast_plus_bt);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_link_info->bt_link_exist) && (wifi_connected)) {
+		halbtc8822b1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1, 0, 1);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_IOT_PEER, &iot_peer);
+
+		if (BTC_IOT_PEER_CISCO != iot_peer) {
+			if (bt_link_info->sco_exist) /* if (bt_link_info->bt_hi_pri_link_exist) */
+				halbtc8822b1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, true, false, 0x5);
+			else
+				halbtc8822b1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, false, false, 0x5);
+		} else {
+			if (bt_link_info->sco_exist)
+				halbtc8822b1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, true, false, 0x5);
+			else {
+				if (BTC_WIFI_BW_HT40 == wifi_bw)
+					halbtc8822b1ant_limited_rx(btcoexist,
+						NORMAL_EXEC, false, true, 0x10);
+				else
+					halbtc8822b1ant_limited_rx(btcoexist,
+						NORMAL_EXEC, false, true, 0x8);
+			}
+		}
+
+		halbtc8822b1ant_sw_mechanism(btcoexist, true);
+		halbtc8822b1ant_run_sw_coexist_mechanism(
+			btcoexist);  /* just print debug message */
+	} else {
+		halbtc8822b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+		halbtc8822b1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x5);
+
+		halbtc8822b1ant_sw_mechanism(btcoexist, false);
+		halbtc8822b1ant_run_sw_coexist_mechanism(
+			btcoexist); /* just print debug message */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "############# [BTCoex],  BT Is Inquirying\n");
+		BTC_TRACE(trace_buf);
+		halbtc8822b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8822b1ant_action_hs(btcoexist);
+		return;
+	}
+
+
+	if (!wifi_connected) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is non connected-idle !!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (scan || link || roam) {
+			if (scan)
+				halbtc8822b1ant_action_wifi_not_connected_scan(
+					btcoexist);
+			else
+				halbtc8822b1ant_action_wifi_not_connected_asso_auth(
+					btcoexist);
+		} else
+			halbtc8822b1ant_action_wifi_not_connected(btcoexist);
+	} else	/* wifi LPS/Busy */
+		halbtc8822b1ant_action_wifi_connected(btcoexist);
+}
+
+u32 halbtc8822b1ant_psd_log2base(IN struct btc_coexist *btcoexist, IN u32 val)
+{
+	u8	j;
+	u32	tmp, tmp2, val_integerd_b = 0, tindex, shiftcount = 0;
+	u32	result, val_fractiond_b = 0, table_fraction[21] = {0, 432, 332, 274, 232, 200,
+				   174, 151, 132, 115, 100, 86, 74, 62, 51, 42,
+							   32, 23, 15, 7, 0
+							      };
+
+	if (val == 0)
+		return 0;
+
+	tmp = val;
+
+	while (1) {
+		if (tmp == 1)
+			break;
+
+		tmp = (tmp >> 1);
+		shiftcount++;
+	}
+
+
+	val_integerd_b = shiftcount + 1;
+
+	tmp2 = 1;
+	for (j = 1; j <= val_integerd_b; j++)
+		tmp2 = tmp2 * 2;
+
+	tmp = (val * 100) / tmp2;
+	tindex = tmp / 5;
+
+	if (tindex > 20)
+		tindex = 20;
+
+	val_fractiond_b = table_fraction[tindex];
+
+	result = val_integerd_b * 100 - val_fractiond_b;
+
+	return result;
+
+
+}
+
+void halbtc8822b1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+
+	halbtc8822b1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, false);
+
+	/* sw all off */
+	halbtc8822b1ant_sw_mechanism(btcoexist, false);
+
+	/* halbtc8822b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8); */
+	/* halbtc8822b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0); */
+
+	coex_sta->pop_event_cnt = 0;
+}
+
+void halbtc8822b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up, IN boolean wifi_only)
+{
+
+	u8	u8tmp = 0;
+	boolean			wifi_under_5g = false;
+	u32				u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+
+
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u32tmp1 = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (Before Init HW config) 0xcb4 = 0x%x, 0x38= 0x%x, 0x54= 0x%x**********\n",
+		    u32tmp3, u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	coex_sta->bt_coex_supported_feature = 0;
+	coex_sta->bt_coex_supported_version = 0;
+
+	/* Setup RF front end type */
+	halbtc8822b1ant_set_rfe_type(btcoexist);
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+
+	/* BT report packet sample rate	 */
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* Enable BT counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+
+	/* Enable PTA (3-wire function form BT side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x41, 0x02, 0x1);
+
+	/* Enable PTA (tx/rx signal form WiFi side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4c6, 0x10, 0x1);
+	/*GNT_BT=1 while select both */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x763, 0x10, 0x1);
+
+	/* enable GNT_WL/GNT_BT debug signal to GPIO14/15 */
+	/*btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x1);*/
+
+	/* enable GNT_WL */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e, 0x40, 0x0);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x1, 0x0);
+
+	if (btcoexist->btc_read_1byte(btcoexist, 0x80) == 0xc6)
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+					 BT_8822B_1ANT_SCOREBOARD_ONOFF, true);
+
+	/* Antenna config */
+	if (wifi_only) {
+
+		coex_sta->concurrent_rx_mode_on = false;
+		halbtc8822b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_WIFI,
+					     FORCE_EXEC,
+					     BT_8822B_1ANT_PHASE_WLANONLY_INIT);
+	} else {
+
+		coex_sta->concurrent_rx_mode_on = true;
+
+		halbtc8822b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8822B_1ANT_PHASE_COEX_INIT);
+	}
+
+
+	/* PTA parameter */
+	halbtc8822b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8822b1ant_enable_gnt_to_gpio(btcoexist, true);
+
+}
+
+
+void halbtc8822b1ant_init_hw_config_without_bt(IN struct btc_coexist *btcoexist,
+		IN boolean back_up, IN boolean wifi_only)
+{
+
+	u8	u8tmp = 0;
+	boolean		wifi_under_5g = false;
+	u32			u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	/* enable TBTT interrupt */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);
+
+	/* enable GNT_WL */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e, 0x40, 0x0);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x1, 0x0);
+
+	/* Antenna config */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e, 0x80,
+					   0x0);  /*  0x4c[23] = 0 */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f, 0x01,
+					   0x1);  /* 0x4c[24] = 1 */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb4, 0xff,
+		0x77);	/* BB SW, DPDT use RFE_ctrl8 and RFE_ctrl9 as conctrol pin */
+
+
+	/* Ext switch buffer mux */
+	btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x1991, 0x3, 0x0);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbe, 0x8, 0x0);
+
+	/*enable sw control gnt_wl=1 / gnt_bt=1 */
+	btcoexist->btc_write_1byte(btcoexist, 0x73, 0x0e);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x1704, 0x0000ff00);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x1700, 0xc00f0038);
+
+
+	/* ant switch WL2G or WL5G*/
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G,
+			   &wifi_under_5g);
+	if (wifi_under_5g)
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd,
+						   0x3, 1);
+
+	else
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd,
+						   0x3, 2);
+
+}
+
+void halbtc8822b1ant_psd_showdata(IN struct btc_coexist *btcoexist)
+{
+	u8		*cli_buf = btcoexist->cli_buf;
+	u32		delta_freq_per_point;
+	u32		freq, freq1, freq2, n = 0, i = 0, j = 0, m = 0, psd_rep1, psd_rep2;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n\n============[PSD info]  (%d)============\n",
+		   psd_scan->psd_gen_count);
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->psd_gen_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n No data !!\n");
+		CL_PRINTF(cli_buf);
+		return;
+	}
+
+	if (psd_scan->psd_point == 0)
+		delta_freq_per_point = 0;
+	else
+		delta_freq_per_point = psd_scan->psd_band_width /
+				       psd_scan->psd_point;
+
+	/* if (psd_scan->is_psd_show_max_only) */
+	if (0) {
+		psd_rep1 = psd_scan->psd_max_value / 100;
+		psd_rep2 = psd_scan->psd_max_value - psd_rep1 * 100;
+
+		freq = ((psd_scan->real_cent_freq - 20) * 1000000 +
+			psd_scan->psd_max_value_point * delta_freq_per_point);
+		freq1 = freq / 1000000;
+		freq2 = freq / 1000 - freq1 * 1000;
+
+		if (freq2 < 100)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n Freq = %d.0%d MHz",
+				   freq1, freq2);
+		else
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n Freq = %d.%d MHz",
+				   freq1, freq2);
+
+		if (psd_rep2 < 10)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   ", Value = %d.0%d dB, (%d)\n",
+				   psd_rep1, psd_rep2, psd_scan->psd_max_value);
+		else
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   ", Value = %d.%d dB, (%d)\n",
+				   psd_rep1, psd_rep2, psd_scan->psd_max_value);
+
+		CL_PRINTF(cli_buf);
+	} else {
+		m = psd_scan->psd_start_point;
+		n = psd_scan->psd_start_point;
+		i = 1;
+		j = 1;
+
+		while (1) {
+			do {
+				freq = ((psd_scan->real_cent_freq - 20) *
+					1000000 + m *
+					delta_freq_per_point);
+				freq1 = freq / 1000000;
+				freq2 = freq / 1000 - freq1 * 1000;
+
+				if (i == 1) {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Freq%6d.000",
+							   freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Freq%6d.0%2d",
+							   freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Freq%6d.%3d",
+							   freq1,
+							   freq2);
+				} else if ((i % 8 == 0) ||
+					   (m == psd_scan->psd_stop_point)) {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.000\n", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.0%2d\n", freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.%3d\n", freq1,
+							   freq2);
+				} else {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.000", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.0%2d", freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%6d.%3d", freq1,
+							   freq2);
+				}
+
+				i++;
+				m++;
+				CL_PRINTF(cli_buf);
+
+			} while ((i <= 8) && (m <= psd_scan->psd_stop_point));
+
+
+			do {
+				psd_rep1 = psd_scan->psd_report_max_hold[n] /
+					   100;
+				psd_rep2 = psd_scan->psd_report_max_hold[n] -
+					   psd_rep1 *
+					   100;
+
+				if (j == 1) {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Val %7d.0%d",
+							   psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "\r\n Val %7d.%d",
+							   psd_rep1,
+							   psd_rep2);
+				} else if ((j % 8 == 0)  ||
+					   (n == psd_scan->psd_stop_point)) {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							"%7d.0%d\n", psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%7d.%d\n", psd_rep1,
+							   psd_rep2);
+				} else {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%7d.0%d", psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf,
+							   BT_TMP_BUF_SIZE,
+							   "%7d.%d", psd_rep1,
+							   psd_rep2);
+				}
+
+				j++;
+				n++;
+				CL_PRINTF(cli_buf);
+
+			} while ((j <= 8) && (n <= psd_scan->psd_stop_point));
+
+			if ((m > psd_scan->psd_stop_point) ||
+			    (n > psd_scan->psd_stop_point))
+				break;
+
+			i = 1;
+			j = 1;
+
+		}
+	}
+
+
+}
+
+void halbtc8822b1ant_psd_max_holddata(IN struct btc_coexist *btcoexist,
+				      IN u32 gen_count)
+{
+	u32	i = 0, i_max = 0, val_max = 0;
+
+	if (gen_count == 1) {
+		memcpy(psd_scan->psd_report_max_hold,
+		       psd_scan->psd_report,
+		       BT_8822B_1ANT_ANTDET_PSD_POINTS * sizeof(u32));
+
+		for (i = psd_scan->psd_start_point;
+		     i <= psd_scan->psd_stop_point; i++) {
+
+		}
+
+		psd_scan->psd_max_value_point = 0;
+		psd_scan->psd_max_value = 0;
+
+	} else {
+		for (i = psd_scan->psd_start_point;
+		     i <= psd_scan->psd_stop_point; i++) {
+			if (psd_scan->psd_report[i] >
+			    psd_scan->psd_report_max_hold[i])
+				psd_scan->psd_report_max_hold[i] =
+					psd_scan->psd_report[i];
+
+			/* search Max Value */
+			if (i == psd_scan->psd_start_point) {
+				i_max = i;
+				val_max = psd_scan->psd_report_max_hold[i];
+			} else {
+				if (psd_scan->psd_report_max_hold[i] >
+				    val_max) {
+					i_max = i;
+					val_max = psd_scan->psd_report_max_hold[i];
+				}
+			}
+
+
+
+		}
+
+		psd_scan->psd_max_value_point = i_max;
+		psd_scan->psd_max_value = val_max;
+
+	}
+
+
+}
+
+u32 halbtc8822b1ant_psd_getdata(IN struct btc_coexist *btcoexist, IN u32 point)
+{
+	/* reg 0x808[9:0]: FFT data x */
+	/* reg 0x808[22]: 0-->1 to get 1 FFT data y */
+	/* reg 0x8b4[15:0]: FFT data y report */
+
+	u32 val = 0, psd_report = 0;
+
+	val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+
+	val &= 0xffbffc00;
+	val |= point;
+
+	btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+	val |= 0x00400000;
+	btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+
+	val = btcoexist->btc_read_4byte(btcoexist, 0x8b4);
+
+	psd_report = val & 0x0000ffff;
+
+	return psd_report;
+}
+
+
+void halbtc8822b1ant_psd_sweep_point(IN struct btc_coexist *btcoexist,
+	     IN u32 cent_freq, IN s32 offset, IN u32 span, IN u32 points,
+				     IN u32 avgnum)
+{
+	u32	 i, val, n, k = 0;
+	u32	points1 = 0, psd_report = 0;
+	u32	start_p = 0, stop_p = 0, delta_freq_per_point = 156250;
+	u32    psd_center_freq = 20 * 10 ^ 6, freq, freq1, freq2;
+	boolean outloop = false;
+	u8	 flag = 0;
+	u32	tmp, psd_rep1, psd_rep2;
+	u32	wifi_original_channel = 1;
+
+	psd_scan->is_psd_running = true;
+
+	do {
+		switch (flag) {
+		case 0:  /* Get PSD parameters */
+		default:
+
+			psd_scan->psd_band_width = 40 * 1000000;
+			psd_scan->psd_point = points;
+			psd_scan->psd_start_base = points / 2;
+			psd_scan->psd_avg_num = avgnum;
+			psd_scan->real_cent_freq = cent_freq;
+			psd_scan->real_offset = offset;
+			psd_scan->real_span = span;
+
+
+			points1 = psd_scan->psd_point;
+			delta_freq_per_point = psd_scan->psd_band_width /
+					       psd_scan->psd_point;
+
+			/* PSD point setup */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+			val &= 0xffff0fff;
+
+			switch (psd_scan->psd_point) {
+			case 128:
+				val |= 0x0;
+				break;
+			case 256:
+			default:
+				val |= 0x00004000;
+				break;
+			case 512:
+				val |= 0x00008000;
+				break;
+			case 1024:
+				val |= 0x0000c000;
+				break;
+			}
+
+			switch (psd_scan->psd_avg_num) {
+			case 1:
+				val |= 0x0;
+				break;
+			case 8:
+				val |= 0x00001000;
+				break;
+			case 16:
+				val |= 0x00002000;
+				break;
+			case 32:
+			default:
+				val |= 0x00003000;
+				break;
+			}
+			btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+			flag = 1;
+			break;
+		case 1:	  /* calculate the PSD point index from freq/offset/span */
+			psd_center_freq = psd_scan->psd_band_width / 2 +
+					  offset * (1000000);
+
+			start_p = psd_scan->psd_start_base + (psd_center_freq -
+				span * (1000000) / 2) / delta_freq_per_point;
+			psd_scan->psd_start_point = start_p -
+						    psd_scan->psd_start_base;
+
+			stop_p = psd_scan->psd_start_base + (psd_center_freq +
+				span * (1000000) / 2) / delta_freq_per_point;
+			psd_scan->psd_stop_point = stop_p -
+						   psd_scan->psd_start_base - 1;
+
+			flag = 2;
+			break;
+		case 2:  /* set RF channel/BW/Mode */
+
+			/* set 3-wire off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x88c);
+			val |= 0x00300000;
+			btcoexist->btc_write_4byte(btcoexist, 0x88c, val);
+
+			/* CCK off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x800);
+			val &= 0xfeffffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x800, val);
+
+			/* store WiFi original channel */
+			wifi_original_channel = btcoexist->btc_get_rf_reg(
+					btcoexist, BTC_RF_A, 0x18, 0x3ff);
+
+			/* Set RF channel */
+			if (cent_freq == 2484)
+				btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A,
+							  0x18, 0x3ff, 0xe);
+			else
+				btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A,
+					  0x18, 0x3ff, (cent_freq - 2412) / 5 +
+						  1); /* WiFi TRx Mask on */
+
+			/* Set  RF mode = Rx, RF Gain = 0x8a0 */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x0,
+						  0xfffff, 0x308a0);
+
+			/* Set RF Rx filter corner */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+						  0xfffff, 0x3e4);
+
+			/* Set TRx mask off */
+			/* un-lock TRx Mask setup */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdd,
+						  0x80, 0x1);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdf,
+						  0x1, 0x1);
+
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+
+			flag = 3;
+			break;
+		case 3:
+			memset(psd_scan->psd_report, 0,
+			       psd_scan->psd_point * sizeof(u32));
+			start_p = psd_scan->psd_start_point +
+				  psd_scan->psd_start_base;
+			stop_p = psd_scan->psd_stop_point +
+				 psd_scan->psd_start_base + 1;
+
+			i = start_p;
+
+			while (i < stop_p) {
+				if (i >= points1)
+					psd_report =
+						halbtc8822b1ant_psd_getdata(
+							btcoexist, i - points1);
+				else
+					psd_report =
+						halbtc8822b1ant_psd_getdata(
+							btcoexist, i);
+
+				if (psd_report == 0)
+					tmp = 0;
+				else
+					/* tmp =  20*log10((double)psd_report); */
+					/* 20*log2(x)/log2(10), log2Base return theresult of the psd_report*100 */
+					tmp = 6 * halbtc8822b1ant_psd_log2base(
+						      btcoexist, psd_report);
+
+				n = i - psd_scan->psd_start_base;
+				psd_scan->psd_report[n] =  tmp;
+				psd_rep1 = psd_scan->psd_report[n] / 100;
+				psd_rep2 = psd_scan->psd_report[n] - psd_rep1 *
+					   100;
+
+				freq = ((cent_freq - 20) * 1000000 + n *
+					delta_freq_per_point);
+				freq1 = freq / 1000000;
+				freq2 = freq / 1000 - freq1 * 1000;
+
+				i++;
+
+				k = 0;
+
+				/* Add Delay between PSD point */
+				while (1) {
+					if (k++ > 20000)
+						break;
+				}
+
+			}
+
+			flag = 100;
+			break;
+		case 99:	/* error */
+
+			outloop = true;
+			break;
+		case 100: /* recovery */
+
+			/* set 3-wire on */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x88c);
+			val &= 0xffcfffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x88c, val);
+
+			/* CCK on */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x800);
+			val |= 0x01000000;
+			btcoexist->btc_write_4byte(btcoexist, 0x800, val);
+
+			/* PSD off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+			val &= 0xffbfffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+			/* TRx Mask on */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x780);
+
+			/* lock TRx Mask setup */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdd,
+						  0x80, 0x0);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdf,
+						  0x1, 0x0);
+
+			/* Set RF Rx filter corner */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+						  0xfffff, 0x0);
+
+			/* restore WiFi original channel */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x18,
+						  0x3ff, wifi_original_channel);
+
+			outloop = true;
+			break;
+
+		}
+
+	} while (!outloop);
+
+
+
+	psd_scan->is_psd_running = false;
+
+
+}
+
+#if (BTC_COEX_OFFLOAD == 1)
+void halbtc8822b1ant_wifi_info_notify(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_para[4] = {0};
+	u8			opcode_ver = 0;
+	u8			ap_num = 0;
+	s32			wifi_rssi = 0;
+	boolean			wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM, &ap_num);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	h2c_para[0] = ap_num;					/* AP number */
+	h2c_para[1] = (u8)wifi_busy;		/* Busy */
+	h2c_para[2] = (u8)wifi_rssi;			/* RSSI */
+
+	btcoexist->btc_coex_h2c_process(btcoexist, COL_OP_WIFI_INFO_NOTIFY,
+					opcode_ver, &h2c_para[0], 3);
+}
+
+void halbtc8822b1ant_setManual(IN struct btc_coexist *btcoexist,
+			       IN boolean manual)
+{
+	u8			h2c_para[4] = {0};
+	u8			opcode_ver = 0;
+	u8			set_type = 0;
+
+	if (manual)
+		set_type = 1;
+	else
+		set_type = 0;
+
+	h2c_para[0] = set_type;				/* set_type */
+
+	btcoexist->btc_coex_h2c_process(btcoexist, COL_OP_SET_CONTROL,
+					opcode_ver,
+					&h2c_para[0], 1);
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8822b1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8822b1ant_
+ * ************************************************************ */
+
+void ex_halbtc8822b1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{}
+void ex_halbtc8822b1ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{}
+void ex_halbtc8822b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{}
+void ex_halbtc8822b1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{}
+void ex_halbtc8822b1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	u8			h2c_para[4] = {0};
+	u8			opcode_ver = 0;
+	u8			ips_notify = 0;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		ips_notify = 1;
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	h2c_para[0] = ips_notify;		/* IPS notify */
+	h2c_para[1] = 0xff;			/* LPS notify */
+	h2c_para[2] = 0xff;			/* RF state notify */
+	h2c_para[3] = 0xff;			/* pnp notify */
+
+	btcoexist->btc_coex_h2c_process(btcoexist,
+					COL_OP_WIFI_POWER_STATE_NOTIFY,
+					opcode_ver, &h2c_para[0], 4);
+}
+void ex_halbtc8822b1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	u8			h2c_para[4] = {0};
+	u8			opcode_ver = 0;
+	u8			lps_notify = 0;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		lps_notify = 1;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	h2c_para[0] = 0xff;			/* IPS notify */
+	h2c_para[1] = lps_notify;		/* LPS notify */
+	h2c_para[2] = 0xff;			/* RF state notify */
+	h2c_para[3] = 0xff;			/* pnp notify */
+
+	btcoexist->btc_coex_h2c_process(btcoexist,
+					COL_OP_WIFI_POWER_STATE_NOTIFY,
+					opcode_ver, &h2c_para[0], 4);
+}
+
+void ex_halbtc8822b1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	u8			h2c_para[4] = {0};
+	u8			opcode_ver = 0;
+	u8			scan_start = 0;
+	boolean			under_4way = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+	if (BTC_SCAN_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+		scan_start = 1;
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	h2c_para[0] = scan_start;		/* scan notify */
+	h2c_para[1] = 0xff;			/* connect notify */
+	h2c_para[2] = 0xff;			/* specific packet notify */
+	if (under_4way)
+		h2c_para[3] = 1;			/* under 4way progress */
+	else
+		h2c_para[3] = 0;
+
+	btcoexist->btc_coex_h2c_process(btcoexist, COL_OP_WIFI_PROGRESS_NOTIFY,
+					opcode_ver, &h2c_para[0], 4);
+}
+
+void ex_halbtc8822b1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	u8			h2c_para[4] = {0};
+	u8			opcode_ver = 0;
+	u8			connect_start = 0;
+	boolean			under_4way = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+	if (BTC_ASSOCIATE_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		connect_start = 1;
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	h2c_para[0] = 0xff;			/* scan notify */
+	h2c_para[1] = connect_start;	/* connect notify */
+	h2c_para[2] = 0xff;			/* specific packet notify */
+	if (under_4way)
+		h2c_para[3] = 1;			/* under 4way progress */
+	else
+		h2c_para[3] = 0;
+
+	btcoexist->btc_coex_h2c_process(btcoexist, COL_OP_WIFI_PROGRESS_NOTIFY,
+					opcode_ver, &h2c_para[0], 4);
+}
+
+void ex_halbtc8822b1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	u8			h2c_para[5] = {0};
+	u8			opcode_ver = 0;
+	u8			port = 0, connected = 0, freq = 0, bandwidth = 0, iot_peer = 0;
+	boolean			wifi_under_5g = false;
+
+	if (BTC_MEDIA_CONNECT == type)
+		connected = 1;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	bandwidth = (u8)wifi_bw;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g)
+		freq = 1;
+	else
+		freq = 0;
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_IOT_PEER, &iot_peer);
+
+	h2c_para[0] = (connected << 4) |
+		port;	/* port need to be implemented in the future (p2p port, ...) */
+	h2c_para[1] = (freq << 4) | bandwidth;
+	h2c_para[2] = wifi_central_chnl;
+	h2c_para[3] = iot_peer;
+	btcoexist->btc_coex_h2c_process(btcoexist, COL_OP_WIFI_STATUS_NOTIFY,
+					opcode_ver, &h2c_para[0], 4);
+}
+
+void ex_halbtc8822b1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_para[4] = {0};
+	u8			opcode_ver = 0;
+	u8			connect_start = 0;
+	boolean			under_4way = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	h2c_para[0] = 0xff;			/* scan notify */
+	h2c_para[1] = 0xff;			/* connect notify */
+	h2c_para[2] = type;			/* specific packet notify */
+	if (under_4way)
+		h2c_para[3] = 1;			/* under 4way progress */
+	else
+		h2c_para[3] = 0;
+
+	btcoexist->btc_coex_h2c_process(btcoexist, COL_OP_WIFI_PROGRESS_NOTIFY,
+					opcode_ver, &h2c_para[0], 4);
+}
+
+void ex_halbtc8822b1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{}
+void ex_halbtc8822b1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_para[4] = {0};
+	u8			opcode_ver = 0;
+	u8			rfstate_notify = 0;
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+		rfstate_notify = 1;
+	} else if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	h2c_para[0] = 0xff;			/* IPS notify */
+	h2c_para[1] = 0xff;			/* LPS notify */
+	h2c_para[2] = rfstate_notify;	/* RF state notify */
+	h2c_para[3] = 0xff;			/* pnp notify */
+
+	btcoexist->btc_coex_h2c_process(btcoexist,
+					COL_OP_WIFI_POWER_STATE_NOTIFY,
+					opcode_ver, &h2c_para[0], 4);
+}
+
+void ex_halbtc8822b1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{}
+void ex_halbtc8822b1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	u8			h2c_para[4] = {0};
+	u8			opcode_ver = 0;
+	u8			pnp_notify = 0;
+
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+		pnp_notify = 1;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	h2c_para[0] = 0xff;			/* IPS notify */
+	h2c_para[1] = 0xff;			/* LPS notify */
+	h2c_para[2] = 0xff;			/* RF state notify */
+	h2c_para[3] = pnp_notify;		/* pnp notify */
+
+	btcoexist->btc_coex_h2c_process(btcoexist,
+					COL_OP_WIFI_POWER_STATE_NOTIFY,
+					opcode_ver, &h2c_para[0], 4);
+}
+
+void ex_halbtc8822b1ant_coex_dm_reset(IN struct btc_coexist *btcoexist)
+{}
+void ex_halbtc8822b1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8822b1ant_wifi_info_notify(btcoexist);
+}
+
+void ex_halbtc8822b1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_stack_info		*stack_info = &btcoexist->stack_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+	u32				fw_ver = 0, bt_patch_ver = 0, bt_coex_ver = 0;
+	static u8			pop_report_in_10s = 0;
+	u32			phyver = 0;
+	boolean			lte_coex_on = false;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	if (psd_scan->ant_det_try_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %s / %d",
+			   "Ant PG Num/ Mech/ Pos/ RFE",
+			   board_info->pg_ant_num, board_info->btdm_ant_num,
+			   (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT
+			    ? "Main" : "Aux"),
+			   rfe_type->rfe_module_type);
+		CL_PRINTF(cli_buf);
+	} else {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %s/ %d  (%d/%d/%d)",
+			   "Ant PG Num/ Mech(Ant_Det)/ Pos/ RFE",
+			   board_info->pg_ant_num,
+			   board_info->btdm_ant_num_by_ant_det,
+			   (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT
+			    ? "Main" : "Aux"),
+			   rfe_type->rfe_module_type,
+			   psd_scan->ant_det_try_count,
+			   psd_scan->ant_det_fail_count,
+			   psd_scan->ant_det_result);
+		CL_PRINTF(cli_buf);
+
+		if (board_info->btdm_ant_det_finish) {
+			if (psd_scan->ant_det_result != 12)
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+					"Ant Det PSD Value",
+					psd_scan->ant_det_peak_val);
+			else
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					"\r\n %-35s = %d",
+					"Ant Det PSD Value",
+				psd_scan->ant_det_psd_scan_peak_val / 100);
+
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%x/ 0x%x/ 0x%x(%d)",
+		   "CoexVer/ FwVer/ PatchVer",
+		   glcoex_ver_date_8822b_1ant, glcoex_ver_8822b_1ant, fw_ver,
+		   bt_patch_ver, bt_patch_ver);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s",
+		   "WifibHiPri/ Ccklock/ CckEverLock",
+		   (coex_sta->wifi_is_high_pri_task ? "Yes" : "No"),
+		   (coex_sta->cck_lock ? "Yes" : "No"),
+		   (coex_sta->cck_ever_lock ? "Yes" : "No"));
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	pop_report_in_10s++;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt/ popCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8822B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8822B_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi - 100, coex_sta->bt_retry_cnt,
+		   coex_sta->pop_event_cnt);
+	CL_PRINTF(cli_buf);
+
+	if (pop_report_in_10s >= 5) {
+		coex_sta->pop_event_cnt = 0;
+		pop_report_in_10s = 0;
+	}
+
+	if (coex_sta->num_of_profile != 0)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n %-35s = %s%s%s%s%s",
+			"Profiles",
+			((bt_link_info->a2dp_exist) ? "A2DP," : ""),
+			((bt_link_info->sco_exist) ?  "SCO," : ""),
+			((bt_link_info->hid_exist) ?
+			((coex_sta->hid_busy_num >= 2) ? "HID(4/18)," : "HID(2/18),") : ""),
+			((bt_link_info->pan_exist) ?  "PAN," : ""),
+			((coex_sta->voice_over_HOGP) ? "Voice" : ""));
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n %-35s = None", "Profiles");
+
+	CL_PRINTF(cli_buf);
+
+	if (bt_link_info->a2dp_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %d/ %s",
+			"A2DP Rate/Bitpool/Auto_Slot",
+			((coex_sta->is_A2DP_3M) ? "3M" : "No_3M"),
+			coex_sta->a2dp_bit_pool,
+			((coex_sta->is_autoslot) ? "On" : "Off"));
+		CL_PRINTF(cli_buf);
+	}
+
+	if (bt_link_info->hid_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+			   "HID PairNum/Forbid_Slot",
+			 coex_sta->hid_pair_cnt,
+			 coex_sta->forbidden_slot
+			 );
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ 0x%x/ 0x%x",
+		"Role/IgnWlanAct/Feature/BLEScan",
+		((bt_link_info->slave_role) ? "Slave" : "Master"),
+		((coex_dm->cur_ignore_wlan_act) ? "Yes":"No"),
+		coex_sta->bt_coex_supported_feature,
+		coex_sta->bt_ble_scan_type);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d",
+				   "ReInit/ReLink/IgnWlact/Page/NameReq",
+			 coex_sta->cnt_ReInit,
+		   coex_sta->cnt_setupLink,
+			 coex_sta->cnt_IgnWlanAct,
+				 coex_sta->cnt_Page,
+			 coex_sta->cnt_RemoteNameReq
+			 );
+		CL_PRINTF(cli_buf);
+
+	halbtc8822b1ant_read_score_board(btcoexist,	&u16tmp[0]);
+
+	if ((coex_sta->bt_reg_vendor_ae == 0xffff) ||
+	    (coex_sta->bt_reg_vendor_ac == 0xffff))
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = x/ x/ %04x",
+			   "0xae[4]/0xac[1:0]/Scoreboard", u16tmp[0]);
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = 0x%x/ 0x%x/ %04x",
+			   "0xae[4]/0xac[1:0]/Scoreboard",
+			 ((coex_sta->bt_reg_vendor_ae & BIT(4))>>4),
+			   coex_sta->bt_reg_vendor_ac & 0x3, u16tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8822B_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8822b_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[mechanisms] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[mechanisms]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "SM[LowPenaltyRA]",
+		   coex_dm->cur_low_penalty_ra);
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (%s,%s)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   (coex_dm->cur_ps_tdma_on ? "On" : "Off"),
+		   (coex_dm->auto_tdma_adjust ? "Adj" : "Fix"));
+
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "WL/BT Coex Table Type",
+		   coex_sta->coex_table_type);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x778/0x6cc/IgnWlanAct",
+		   u8tmp[0], u32tmp[0],  coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0xa0);
+	u32tmp[1] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0xa4);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "LTE Coex Table W_L/B_L",
+		   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0xa8);
+	u32tmp[1] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0xac);
+	u32tmp[2] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0xb0);
+	u32tmp[3] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0xb4);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "LTE Break Table W_L/B_L/L_W/L_B",
+		   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff,
+		   u32tmp[2] & 0xffff, u32tmp[3] & 0xffff);
+	CL_PRINTF(cli_buf);
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+/*
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "0x430/0x434/0x42a/0x456",
+		   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+*/
+
+	u32tmp[0] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp[1] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %s",
+		   "LTE CoexOn/Path Ctrl Owner",
+		   (int)((u32tmp[0]&BIT(7)) >> 7),
+		   ((u8tmp[0]&BIT(2)) ? "WL" : "BT"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "LTE 3Wire/OPMode/UART/UARTMode",
+		   (int)((u32tmp[0]&BIT(6)) >> 6),
+		   (int)((u32tmp[0] & (BIT(5) | BIT(4))) >> 4),
+		   (int)((u32tmp[0]&BIT(3)) >> 3),
+		   (int)(u32tmp[0] & (BIT(2) | BIT(1) | BIT(0))));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %s",
+		   "GNT_WL_SWCtrl/GNT_BT_SWCtrl/Dbg",
+		   (int)((u32tmp[0]&BIT(12)) >> 12),
+		   (int)((u32tmp[0]&BIT(14)) >> 14),
+		   ((u8tmp[0]&BIT(3)) ? "On" : "Off"));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "GNT_WL/GNT_BT/LTE_Busy/UART_Busy",
+		   (int)((u32tmp[0]&BIT(2)) >> 2),
+		   (int)((u32tmp[0]&BIT(3)) >> 3),
+		   (int)((u32tmp[0]&BIT(1)) >> 1), (int)(u32tmp[0]&BIT(0)));
+	CL_PRINTF(cli_buf);
+
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x4c6);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x4c6[4]/0x40[5] (WL/BT PTA)",
+		   (int)((u8tmp[0] & BIT(4)) >> 4),
+		   (int)((u8tmp[1] & BIT(5)) >> 5));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x953);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ %s",
+		   "0x550(bcn ctrl)/0x522/4-RxAGC",
+		   u32tmp[0], u8tmp[0], (u8tmp[1] & 0x2) ? "On" : "Off");
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xda0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xda4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0xda8);
+	u32tmp[3] = btcoexist->btc_read_4byte(btcoexist, 0xcf0);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xa5b);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xa5c);
+
+	fa_ofdm = ((u32tmp[0] & 0xffff0000) >> 16) + ((u32tmp[1] & 0xffff0000)
+			>> 16) + (u32tmp[1] & 0xffff) + (u32tmp[2] & 0xffff) +
+		   ((u32tmp[3] & 0xffff0000) >> 16) + (u32tmp[3] &
+				   0xffff);
+	fa_cck = (u8tmp[0] << 8) + u8tmp[1];
+
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0xc50/OFDM-CCA/OFDM-FA/CCK-FA",
+		   u32tmp[1] & 0xff, u32tmp[0] & 0xffff, fa_ofdm, fa_cck);
+	CL_PRINTF(cli_buf);
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-Agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_agg);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-Agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_agg);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8822B_1ANT == 1)
+	/* halbtc8822b1ant_monitor_bt_ctr(btcoexist); */
+#endif
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+void ex_halbtc8822b1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{}
+void ex_halbtc8822b1ant_display_ant_detection(IN struct btc_coexist *btcoexist)
+{}
+void ex_halbtc8822b1ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata)
+{
+	switch (op_code) {
+	case BTC_DBG_SET_COEX_MANUAL_CTRL: {
+		boolean		manual = (boolean) *pdata;
+
+		halbtc8822b1ant_setManual(btcoexist, manual);
+	}
+	break;
+	default:
+		break;
+	}
+}
+
+#else
+void ex_halbtc8822b1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x0;
+	u16 u16tmp = 0x0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"xxxxxxxxxxxxxxxx Execute 8822b 1-Ant PowerOn Setting!! xxxxxxxxxxxxxxxx\n");
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "Ant Det Finish = %s, Ant Det Number  = %d\n",
+		    board_info->btdm_ant_det_finish ? "Yes" : "No",
+		    board_info->btdm_ant_num_by_ant_det);
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = true;
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write 0x948 correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+	/* set Path control owner to WiFi */
+	halbtc8822b1ant_ltecoex_pathcontrol_owner(btcoexist,
+			BT_8822B_1ANT_PCO_WLSIDE);
+
+	/* set GNT_BT to high */
+	halbtc8822b1ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8822B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_1ANT_GNT_CTRL_BY_SW,
+					   BT_8822B_1ANT_SIG_STA_SET_TO_HIGH);
+	/* Set GNT_WL to low */
+	halbtc8822b1ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8822B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_1ANT_GNT_CTRL_BY_SW,
+					   BT_8822B_1ANT_SIG_STA_SET_TO_LOW);
+
+	/* set WLAN_ACT = 0 */
+	/* btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4); */
+
+	/* SD1 Chunchu red x issue */
+	btcoexist->btc_write_1byte(btcoexist, 0xff1a, 0x0);
+
+	halbtc8822b1ant_enable_gnt_to_gpio(btcoexist, true);
+
+	/* */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+
+	u8tmp = 0;
+	board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+
+	if (btcoexist->chip_interface == BTC_INTF_USB)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60, u8tmp);
+
+	BTC_TRACE(trace_buf);
+
+
+}
+
+void ex_halbtc8822b1ant_power_on_setting_without_bt(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x0;
+	u16 u16tmp = 0x0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    " 8822b 1-Ant PowerOn Setting without bt\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = true;
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write 0x948 correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+
+	/* SD1 Chunchu red x issue */
+	btcoexist->btc_write_1byte(btcoexist, 0xff1a, 0x0);
+
+	u8tmp = 0;
+	board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+
+	if (btcoexist->chip_interface == BTC_INTF_USB)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60, u8tmp);
+
+
+
+}
+
+
+void ex_halbtc8822b1ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8822b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** (ini hw config) **********\n");
+
+	halbtc8822b1ant_init_hw_config(btcoexist, true, wifi_only);
+	btcoexist->stop_coex_dm = false;
+}
+
+void ex_halbtc8822b1ant_init_hw_config_without_bt(IN struct btc_coexist
+		*btcoexist,
+		IN boolean wifi_only)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** (ini hw config) **********\n");
+
+	halbtc8822b1ant_init_hw_config_without_bt(btcoexist, true, wifi_only);
+	btcoexist->stop_coex_dm = true;
+}
+
+void ex_halbtc8822b1ant_antenna_switch_without_bt(IN struct btc_coexist
+		*btcoexist)
+{
+
+	boolean wifi_under_5g = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (wifi_under_5g)
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd,
+						   0x3, 1);
+
+	else
+		btcoexist->btc_write_1byte_bitmask(btcoexist,
+						   0xcbd, 0x3, 2);
+
+
+}
+
+void ex_halbtc8822b1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = false;
+
+	halbtc8822b1ant_init_coex_dm(btcoexist);
+
+	halbtc8822b1ant_query_bt_info(btcoexist);
+}
+
+void ex_halbtc8822b1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+	u32				u32tmp[4];
+	u32				fa_of_dm;
+	u32				fw_ver = 0, bt_patch_ver = 0;
+	static u8			pop_report_in_10s = 0;
+	u32                       phyver = 0;
+	 /*u32 pnp_wake_cnt=0;*/
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** (display coexinfo) **********\n");
+	BTC_TRACE(trace_buf);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** displaycoexinfostart, 0xcb4/0xcbd = 0x%x/0x%x\n",
+		    btcoexist->btc_read_1byte(btcoexist, 0xcb4),
+		    btcoexist->btc_read_1byte(btcoexist, 0xcbd));
+	BTC_TRACE(trace_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	if (psd_scan->ant_det_try_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %d/ %d",
+			   "Ant PG Num/ Mech/ Pos/ RFE",
+			   board_info->pg_ant_num, board_info->btdm_ant_num,
+			   board_info->btdm_ant_pos,
+			   rfe_type->rfe_module_type);
+		CL_PRINTF(cli_buf);
+	} else {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %d/ %d  (%d/%d/%d)",
+			   "Ant PG Num/ Mech(Ant_Det)/ Pos/ RFE",
+			   board_info->pg_ant_num,
+			   board_info->btdm_ant_num_by_ant_det,
+			   board_info->btdm_ant_pos,
+			   rfe_type->rfe_module_type,
+			   psd_scan->ant_det_try_count,
+			   psd_scan->ant_det_fail_count,
+			   psd_scan->ant_det_result);
+		CL_PRINTF(cli_buf);
+
+		if (board_info->btdm_ant_det_finish) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+				   "Ant Det PSD Value",
+				   psd_scan->ant_det_peak_val);
+			CL_PRINTF(cli_buf);
+		}
+	}
+	/*btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);*/
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+		   "CoexVer WL/  BT_Desired/ BT_Report",
+		   glcoex_ver_date_8822b_1ant, glcoex_ver_8822b_1ant,
+		   glcoex_ver_btdesired_8822b_1ant,
+		   ((coex_sta->bt_coex_supported_version & 0xff00) >>
+		    8),
+		   (((coex_sta->bt_coex_supported_version & 0xff00) >>
+		     8) >=
+		    glcoex_ver_btdesired_8822b_1ant ? "Match" :
+		    "Mis-Match"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d/ %c",
+		   "W_FW/ B_FW/ Phy/ Kt",
+		   fw_ver, bt_patch_ver, phyver,
+		   coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s",
+		   "WifibHiPri/ Ccklock/ CckEverLock",
+		   (coex_sta->wifi_is_high_pri_task ? "Yes" : "No"),
+		   (coex_sta->cck_lock ? "Yes" : "No"),
+		   (coex_sta->cck_ever_lock ? "Yes" : "No"));
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	pop_report_in_10s++;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt/ popCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8822B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8822B_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi - 100, coex_sta->bt_retry_cnt,
+		   coex_sta->pop_event_cnt);
+	CL_PRINTF(cli_buf);
+	/*bt rssi */
+	/*bt pop_even_cnt : bt retry*/
+
+	if (pop_report_in_10s >= 5) {
+		coex_sta->pop_event_cnt = 0;
+		pop_report_in_10s = 0;
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d / %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP/Hi-Pri",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist,
+		   bt_link_info->bt_hi_pri_link_exist);
+	CL_PRINTF(cli_buf);
+
+	{
+		bt_info_ext = coex_sta->bt_info_ext;
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %s / %s / %d/ %x/ %02x",
+			   "Role/A2DP Rate/Bitpool/Feature/Ver",
+			   ((bt_link_info->slave_role) ? "Slave" : "Master"),
+			   (bt_info_ext & BIT(0)) ? "BR" : "EDR",
+			   coex_sta->a2dp_bit_pool,
+			   coex_sta->bt_coex_supported_feature,
+			((coex_sta->bt_coex_supported_version & 0xff00) >> 8));
+		CL_PRINTF(cli_buf);
+	}
+
+	/*bt info*/
+	for (i = 0; i < BT_INFO_SRC_8822B_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8822b_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[mechanisms] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[mechanisms]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "SM[LowPenaltyRA]",
+		   coex_dm->cur_low_penalty_ra);
+	CL_PRINTF(cli_buf);
+
+	/*(ps)tdma*/
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (%s,%s)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   (coex_dm->cur_ps_tdma_on ? "On" : "Off"),
+		   (coex_dm->auto_tdma_adjust ? "Adj" : "Fix"));
+
+	CL_PRINTF(cli_buf);
+
+	/*coex table type*/
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "WL/BT Coex Table Type",
+		   coex_sta->coex_table_type);
+	CL_PRINTF(cli_buf);
+
+	/*coex table :0x6c0 0x6c4 , break table: 0x6c8*/
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	/*PTA : 0x778=1/3/d , WL BA,RTS,CTS :0x6cc  H/L pri */
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x778/0x6cc/IgnWlanAct",
+		   u8tmp[0], u32tmp[0],  coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+
+	/*LTE : WL/LTE coex table : 0xa0 */
+
+	u32tmp[0] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0xa0);
+
+	/*LTE : BT/LTE coex table : 0xa4 */
+	u32tmp[1] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0xa4);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "LTE Coex Table W_L/B_L",
+		   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff);
+	CL_PRINTF(cli_buf);
+
+	/*LTE : WL/LTE break table : 0xa8 */
+	u32tmp[0] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0xa8);
+	/*LTE : WL/LTE break table : 0xac */
+	u32tmp[1] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0xac);
+	/*LTE : LTE/WL break table : 0xb0 */
+	u32tmp[2] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0xb0);
+	/*LTE : LTE/BT break table : 0xb4 */
+	u32tmp[3] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist,
+			0xb4);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "LTE Break Table W_L/B_L/L_W/L_B",
+		   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff,
+		   u32tmp[2] & 0xffff, u32tmp[3] & 0xffff);
+	CL_PRINTF(cli_buf);
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "0x430/0x434/0x42a/0x456",
+		   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	/*ANT setting*/
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xcb4);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0xcbd);
+	u8tmp[3] = btcoexist->btc_read_1byte(btcoexist, 0x1991);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0xcb4/0xcbd/0x1991",
+		   u8tmp[1], u8tmp[2], u8tmp[3]);
+	CL_PRINTF(cli_buf);
+
+	/*LTE on/off , Path ctrl owner*/
+	/*sy add*/
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x73);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x64);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x73/ 0x4c/ 0x64[0]", u8tmp[0],
+		   (u32tmp[0] & (BIT(24) | BIT(23))) >> 23,
+		   u8tmp[1] & 0x1);
+	CL_PRINTF(cli_buf);
+
+
+	u32tmp[0] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %s",
+		   "LTE CoexOn/Path Ctrl Owner",
+		   (int)((u32tmp[0]&BIT(7)) >> 7),
+		   ((u8tmp[0]&BIT(2)) ? "WL" : "BT"));
+	CL_PRINTF(cli_buf);
+
+	/*LTE mode*/
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "LTE 3Wire/OPMode/UART/UARTMode",
+		   (int)((u32tmp[0]&BIT(6)) >> 6),
+		   (int)((u32tmp[0] & (BIT(5) | BIT(4))) >> 4),
+		   (int)((u32tmp[0]&BIT(3)) >> 3),
+		   (int)(u32tmp[0] & (BIT(2) | BIT(1) | BIT(0))));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %s",
+		   "GNT_WL_SWCtrl/GNT_BT_SWCtrl/Dbg",
+		   (int)((u32tmp[0]&BIT(12)) >> 12),
+		   (int)((u32tmp[0]&BIT(14)) >> 14),
+		   ((u8tmp[0]&BIT(3)) ? "On" : "Off"));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8822b1ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "GNT_WL/GNT_BT/LTE_Busy/UART_Busy",
+		   (int)((u32tmp[0]&BIT(2)) >> 2),
+		   (int)((u32tmp[0]&BIT(3)) >> 3),
+		   (int)((u32tmp[0]&BIT(1)) >> 1), (int)(u32tmp[0]&BIT(0)));
+	CL_PRINTF(cli_buf);
+
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x4c6);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x4c6[4]/0x40[5] (WL/BT PTA)",
+		   (int)((u8tmp[0] & BIT(4)) >> 4),
+		   (int)((u8tmp[1] & BIT(5)) >> 5));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x953);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0xc50);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ %s/ 0x%x",
+		   "0x550/0x522/4-RxAGC/0xc50",
+		u32tmp[0], u8tmp[0], (u8tmp[1] & 0x2) ? "On" : "Off", u8tmp[2]);
+	CL_PRINTF(cli_buf);
+
+#if 0 /* phydm v008 doesn't support this feature */
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+#endif
+
+
+#if 1
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11ac",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11ac",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+#endif
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s",
+		   "Wifi-HiPri/ Ccklock/ CckEverLock",
+		   (coex_sta->wifi_is_high_pri_task ? "Yes" : "No"),
+		   (coex_sta->cck_lock ? "Yes" : "No"),
+		   (coex_sta->cck_ever_lock ? "Yes" : "No"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	/*0x774:bt low pri trx*/
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+
+	halbtc8822b1ant_read_score_board(btcoexist,	&u16tmp[0]);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %04x",
+		   "ScoreBoard[14:0] (from BT)", u16tmp[0]);
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** displaycoexinfo end, 0xcb4/0xcbd = 0x%x/0x%x\n",
+		    btcoexist->btc_read_1byte(btcoexist, 0xcb4),
+		    btcoexist->btc_read_1byte(btcoexist, 0xcbd));
+	BTC_TRACE(trace_buf);
+	/*
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** pnp_wake_cnt = %d\n", pnp_wake_cnt);
+	BTC_TRACE(trace_buf);
+	*/
+}
+
+
+void ex_halbtc8822b1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+
+	if (BTC_IPS_ENTER == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+
+		/* Write WL "Active" in Score-board for LPS off */
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+				BT_8822B_1ANT_SCOREBOARD_ACTIVE, false);
+
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+				BT_8822B_1ANT_SCOREBOARD_ONOFF, false);
+
+		halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+		halbtc8822b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8822B_1ANT_PHASE_WLAN_OFF);
+
+		halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (BTC_IPS_LEAVE == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+				BT_8822B_1ANT_SCOREBOARD_ACTIVE, true);
+
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+				BT_8822B_1ANT_SCOREBOARD_ONOFF, true);
+
+		/*leave IPS : run ini hw config (exclude wifi only)*/
+		halbtc8822b1ant_init_hw_config(btcoexist, false, false);
+		/*sw all off*/
+		halbtc8822b1ant_init_coex_dm(btcoexist);
+		/*leave IPS : Query bt info*/
+		halbtc8822b1ant_query_bt_info(btcoexist);
+
+		coex_sta->under_ips = false;
+	}
+}
+
+void ex_halbtc8822b1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+
+		if (coex_sta->force_lps_on == true) { /* LPS No-32K */
+			/* Write WL "Active" in Score-board for PS-TDMA */
+			halbtc8822b1ant_post_state_to_bt(btcoexist,
+					 BT_8822B_1ANT_SCOREBOARD_ACTIVE, true);
+
+		} else { /* LPS-32K, need check if this h2c 0x71 can work?? (2015/08/28) */
+			/* Write WL "Non-Active" in Score-board for Native-PS */
+			halbtc8822b1ant_post_state_to_bt(btcoexist,
+				 BT_8822B_1ANT_SCOREBOARD_ACTIVE, false);
+
+		}
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+
+		/* Write WL "Active" in Score-board for LPS off */
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+					 BT_8822B_1ANT_SCOREBOARD_ACTIVE, true);
+
+	}
+}
+
+
+void ex_halbtc8822b1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean	wifi_connected = false;
+	boolean wifi_under_5g = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], SCAN notify()\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_SCAN_START == type) {
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+		if (wifi_under_5g) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** (scan_notify_5g_scan_start) **********\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b1ant_action_wifi_under5g(btcoexist);
+			return;
+		}
+
+		/* under 2.4G */
+		coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (scan_notify_2g_scan_start) **********\n");
+		BTC_TRACE(trace_buf);
+
+		if (!wifi_connected) {	/* non-connected scan */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** wifi is not connected scan **********\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b1ant_action_wifi_not_connected_scan(
+				btcoexist);
+		} else {	/* wifi is connected */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** wifi is connected scan **********\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b1ant_action_wifi_connected_scan(
+				btcoexist);
+		}
+
+		return;
+	}
+
+	if (BTC_SCAN_START_2G == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (scan_notify_2g_sacn_start_for_switch_band_used) **********\n");
+		BTC_TRACE(trace_buf);
+
+		if (!wifi_connected) {	/* non-connected scan */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** wifi is not connected **********\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8822b1ant_action_wifi_not_connected_scan(
+				btcoexist);
+		} else	{ /* wifi is connected */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** wifi is connected **********\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b1ant_action_wifi_connected_scan(btcoexist);
+		}
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+
+		/*WL scan finish , then get and update sacn ap numbers */
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (scan_finish_notify) **********\n");
+		BTC_TRACE(trace_buf);
+
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8822b1ant_action_wifi_not_connected(btcoexist);
+		else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** scan_finish_notify wifi is connected **********\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b1ant_action_wifi_connected(btcoexist);
+		}
+	}
+}
+
+
+
+void ex_halbtc8822b1ant_scan_notify_without_bt(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+
+	boolean wifi_under_5g = false;
+
+	if (BTC_SCAN_START == type) {
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+		if (wifi_under_5g) {
+			btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd,
+							   0x3, 1);
+			return;
+		}
+
+		/* under 2.4G */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd,
+						   0x3, 2);
+		return;
+	}
+	if (BTC_SCAN_START_2G == type)
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd, 0x3, 2);
+}
+
+void ex_halbtc8822b1ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+
+	boolean wifi_connected = false;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** (switchband_notify) **********\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+
+	if (type == BTC_SWITCH_TO_5G) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (switchband_notify BTC_SWITCH_TO_5G) **********\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b1ant_action_wifi_under5g(btcoexist);
+		return;
+	} else if (type == BTC_SWITCH_TO_24G_NOFORSCAN) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (switchband_notify BTC_SWITCH_TO_2G (no for scan)) **********\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b1ant_run_coexist_mechanism(btcoexist);
+
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (switchband_notify BTC_SWITCH_TO_2G) **********\n");
+		BTC_TRACE(trace_buf);
+
+		ex_halbtc8822b1ant_scan_notify(btcoexist,
+					       BTC_SCAN_START_2G);
+	}
+
+}
+
+
+void ex_halbtc8822b1ant_switchband_notify_without_bt(IN struct btc_coexist
+		*btcoexist,
+		IN u8 type)
+{
+	boolean wifi_under_5g = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (type == BTC_SWITCH_TO_5G) {
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd,
+						   0x3, 1);
+		return;
+	} else if (type == BTC_SWITCH_TO_24G_NOFORSCAN) {
+
+		if (wifi_under_5g)
+
+			btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd,
+							   0x3, 1);
+
+		else
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcbd, 0x3, 2);
+	} else {
+
+		ex_halbtc8822b1ant_scan_notify_without_bt(btcoexist,
+				BTC_SCAN_START_2G);
+	}
+
+}
+
+void ex_halbtc8822b1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	boolean	wifi_connected = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** (connect notify) **********\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8822b1ant_post_state_to_bt(btcoexist,
+					 BT_8822B_1ANT_SCOREBOARD_SCAN, true);
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+
+	if ((BTC_ASSOCIATE_5G_START == type) ||
+	    (BTC_ASSOCIATE_5G_FINISH == type)) {
+
+		if (BTC_ASSOCIATE_5G_START == type) {
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** (5G associate start notify) **********\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8822b1ant_action_wifi_under5g(btcoexist);
+
+		} else if (BTC_ASSOCIATE_5G_FINISH == type) {
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** (5G associate finish notify) **********\n");
+			BTC_TRACE(trace_buf);
+
+		}
+
+		return;
+
+	}
+
+
+	if (BTC_ASSOCIATE_START == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], 2G CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+
+		halbtc8822b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+		coex_dm->arp_cnt = 0;
+
+		halbtc8822b1ant_action_wifi_not_connected_asso_auth(btcoexist);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], 2G CONNECT Finish notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->wifi_is_high_pri_task = false;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+				   &wifi_connected);
+
+		if (!wifi_connected) /* non-connected scan */
+			halbtc8822b1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8822b1ant_action_wifi_connected(btcoexist);
+	}
+
+}
+
+void ex_halbtc8822b1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean			wifi_under_b_mode = false;
+	boolean wifi_under_5g = false;
+	u32			cnt_bt_cal_chk = 0;
+	boolean			is_in_mp_mode = false;
+	u8			u8tmp = 0;
+	u32			u32tmp1 = 0, u32tmp2 = 0;
+
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+
+
+
+	if (BTC_MEDIA_CONNECT == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], 2g media connect notify");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+					 BT_8822B_1ANT_SCOREBOARD_ACTIVE, true);
+
+		if (wifi_under_5g) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], 5g media notify\n");
+BTC_TRACE(trace_buf);
+
+			halbtc8822b1ant_action_wifi_under5g(btcoexist);
+			return;
+		}
+		/* Force antenna setup for no scan result issue */
+		halbtc8822b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8822B_1ANT_PHASE_2G_RUNTIME);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** (media status notity under b mode) **********\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+			/* btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x10); */ /*CCK Tx */
+			/* btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x10); */ /*CCK Rx */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** (media status notity not under b mode) **********\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], 2g media disconnect notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+				 BT_8822B_1ANT_SCOREBOARD_ACTIVE, false);
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+
+		coex_sta->cck_ever_lock = false;
+	}
+
+	halbtc8822b1ant_update_wifi_channel_info(btcoexist, type);
+
+}
+
+void ex_halbtc8822b1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	under_4way = false, wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], 5g special packet notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b1ant_action_wifi_under5g(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (under_4way) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ---- under_4way!!\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+	} else if (BTC_PACKET_ARP == type) {
+
+		coex_dm->arp_cnt++;
+
+		if (coex_sta->wifi_is_high_pri_task) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], specific Packet ARP notify -cnt = %d\n",
+				    coex_dm->arp_cnt);
+			BTC_TRACE(trace_buf);
+		}
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet DHCP or EAPOL notify [Type = %d]\n",
+			    type);
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+	}
+
+	if (coex_sta->wifi_is_high_pri_task)
+		halbtc8822b1ant_action_wifi_connected_specific_packet(
+			btcoexist);
+
+}
+
+void ex_halbtc8822b1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8				bt_info = 0;
+	u8				i, rsp_source = 0;
+	boolean				bt_busy = false;
+	boolean				wifi_connected = false;
+	boolean wifi_under_5g = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	coex_sta->c2h_bt_info_req_sent = false;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** (BtInfo Notify) **********\n");
+	BTC_TRACE(trace_buf);
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8822B_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8822B_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+
+	if (BT_INFO_SRC_8822B_1ANT_WIFI_FW != rsp_source) {
+
+		/* if 0xff, it means BT is under WHCK test */
+		if (bt_info == 0xff)
+			coex_sta->bt_whck_test = true;
+		else
+			coex_sta->bt_whck_test = false;
+
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->bt_info_c2h[rsp_source][2] & 0x20)
+			coex_sta->c2h_bt_page = true;
+		else
+			coex_sta->c2h_bt_page = false;
+
+		if (coex_sta->bt_info_c2h[rsp_source][2] & 0x80)
+			coex_sta->bt_create_connection = true;
+		else
+			coex_sta->bt_create_connection = false;
+
+		/* unit: %, value-100 to translate to unit: dBm */
+		coex_sta->bt_rssi = coex_sta->bt_info_c2h[rsp_source][3] * 2 +
+				    10;
+
+		/* coex_sta->bt_info_c2h[rsp_source][3] * 2 - 90; */
+
+		if ((coex_sta->bt_info_c2h[rsp_source][1] & 0x49) == 0x49) {
+			coex_sta->a2dp_bit_pool =
+				coex_sta->bt_info_c2h[rsp_source][6];
+		} else
+			coex_sta->a2dp_bit_pool = 0;
+
+		if (coex_sta->bt_info_c2h[rsp_source][1] & 0x9)
+			coex_sta->acl_busy = true;
+		else
+			coex_sta->acl_busy = false;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+
+		if ((!btcoexist->manual_control) &&
+		    (!btcoexist->stop_coex_dm)) {
+
+			/*	Re-Init */
+			if (coex_sta->bt_info_ext & BIT(1)) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+				BTC_TRACE(trace_buf);
+				btcoexist->btc_get(btcoexist,
+						   BTC_GET_BL_WIFI_CONNECTED,
+						   &wifi_connected);
+				if (wifi_connected)
+					halbtc8822b1ant_update_wifi_channel_info(
+						btcoexist,
+						BTC_MEDIA_CONNECT);
+				else
+					halbtc8822b1ant_update_wifi_channel_info(
+						btcoexist,
+						BTC_MEDIA_DISCONNECT);
+			}
+
+			/*	If Ignore_WLanAct && not SetUp_Link */
+			if ((coex_sta->bt_info_ext & BIT(3)) &&
+			    (!(coex_sta->bt_info_ext & BIT(2)))) {
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8822b1ant_ignore_wlan_act(btcoexist,
+								FORCE_EXEC,
+								false);
+			}
+		}
+		/* check BIT2 first ==> check if bt is under inquiry or page scan */
+		if (bt_info & BT_INFO_8822B_1ANT_B_INQ_PAGE)
+			coex_sta->c2h_bt_inquiry_page = true;
+		else
+			coex_sta->c2h_bt_inquiry_page = false;
+	}
+
+	coex_sta->num_of_profile = 0;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8822B_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+
+		coex_sta->bt_hi_pri_link_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8822B_1ANT_B_FTP) {
+			coex_sta->pan_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8822B_1ANT_B_A2DP) {
+			coex_sta->a2dp_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8822B_1ANT_B_HID) {
+			coex_sta->hid_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8822B_1ANT_B_SCO_ESCO) {
+			coex_sta->sco_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->sco_exist = false;
+
+	}
+
+	halbtc8822b1ant_update_bt_link_info(btcoexist);
+
+	bt_info = bt_info &
+		0x1f;  /* mask profile bit for connect-ilde identification ( for CSR case: A2DP idle --> 0x41) */
+
+	if (!(bt_info & BT_INFO_8822B_1ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8822B_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8822B_1ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8822B_1ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8822B_1ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8822B_1ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8822B_1ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8822B_1ANT_B_ACL_BUSY) {
+		if (BT_8822B_1ANT_BT_STATUS_ACL_BUSY != coex_dm->bt_status)
+			coex_dm->bt_status = BT_8822B_1ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8822B_1ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8822B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8822B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8822B_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	halbtc8822b1ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8822b1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+					 BT_8822B_1ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+					 BT_8822B_1ANT_SCOREBOARD_ONOFF, true);
+
+	} else if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+				 BT_8822B_1ANT_SCOREBOARD_ACTIVE, false);
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+					 BT_8822B_1ANT_SCOREBOARD_ONOFF, false);
+		halbtc8822b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+
+		halbtc8822b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8822B_1ANT_PHASE_WLAN_OFF);
+		/* for test : s3 bt disppear , fail rate 1/600*/
+
+		halbtc8822b1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+		btcoexist->stop_coex_dm = true;
+	}
+}
+
+void ex_halbtc8822b1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8822b1ant_post_state_to_bt(btcoexist,
+				 BT_8822B_1ANT_SCOREBOARD_ACTIVE, false);
+	halbtc8822b1ant_post_state_to_bt(btcoexist,
+					 BT_8822B_1ANT_SCOREBOARD_ONOFF, false);
+
+	halbtc8822b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+
+	halbtc8822b1ant_set_ant_path(btcoexist,
+				     BTC_ANT_PATH_AUTO,
+				     FORCE_EXEC,
+				     BT_8822B_1ANT_PHASE_WLAN_OFF);
+	/* for test : s3 bt disppear , fail rate 1/600*/
+
+	halbtc8822b1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8822b1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	halbtc8822b1ant_enable_gnt_to_gpio(btcoexist, false);
+
+	btcoexist->stop_coex_dm = true;
+}
+
+
+void ex_halbtc8822b1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	boolean wifi_under_5g = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+				 BT_8822B_1ANT_SCOREBOARD_ACTIVE, false);
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+					 BT_8822B_1ANT_SCOREBOARD_ONOFF, false);
+		/*
+				halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+				halbtc8822b1ant_set_ant_path(btcoexist,
+									BTC_ANT_PATH_AUTO,
+								FORCE_EXEC,
+								BT_8822B_1ANT_PHASE_WLAN_OFF);
+
+				halbtc8822b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+								     5);
+
+				halbtc8822b1ant_enable_gnt_to_gpio(btcoexist, false);
+		*/
+		btcoexist->stop_coex_dm = true;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		/*pnp_wake_cnt++;*/
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+					 BT_8822B_1ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+					 BT_8822B_1ANT_SCOREBOARD_ONOFF, true);
+
+		btcoexist->stop_coex_dm = false;
+	}
+}
+
+void ex_halbtc8822b1ant_coex_dm_reset(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], *****************Coex DM Reset*****************\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8822b1ant_init_hw_config(btcoexist, false, false);
+	halbtc8822b1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8822b1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	boolean wifi_busy = false;
+	u16 bt_scoreboard_val = 0;
+	u32 bt_patch_ver;
+	static u8 cnt = 0;
+	boolean bt_relink_finish = false;
+	boolean rf4ce_connected = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ==========================Periodical===========================\n");
+	BTC_TRACE(trace_buf);
+
+#if (BT_AUTO_REPORT_ONLY_8822B_1ANT == 0)
+	halbtc8822b1ant_query_bt_info(btcoexist);
+#endif
+
+	halbtc8822b1ant_monitor_bt_ctr(btcoexist);
+	halbtc8822b1ant_monitor_wifi_ctr(btcoexist);
+
+	halbtc8822b1ant_monitor_bt_enable_disable(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	halbtc8822b1ant_read_score_board(btcoexist, &bt_scoreboard_val);
+
+	/*RF4CE for arris , rf4ce always on*/
+	/*
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_RF4CE_CONNECTED, &rf4ce_connected);
+	if (rf4ce_connected){
+		btcoexist->btc_write_1byte_bitmask(
+					btcoexist, 0x45e, 0x8, 0x1);
+
+				halbtc8822b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true,
+							50);
+
+				halbtc8822b1ant_coex_table_with_type(btcoexist,
+				NORMAL_EXEC, 1);
+				return;
+		}
+		*/
+
+	if (wifi_busy) {
+		/*WL scoreboard to BT,BT see WL Ccoreboard bit[6]=1 WL BUSY*/
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+			BT_8822B_1ANT_SCOREBOARD_WLBUSY, true);
+		/*BT scoreboard to WL  , let WL see BT scoreboard bit[6]=1*/
+		if (bt_scoreboard_val & BIT(6))
+			/*btcoexist->btc_set_bt_wake(btcoexist, 45, 1);*/
+			halbtc8822b1ant_query_bt_info(btcoexist);
+	} else {
+		halbtc8822b1ant_post_state_to_bt(btcoexist,
+			BT_8822B_1ANT_SCOREBOARD_WLBUSY, false);
+	}
+
+	/* for 4-way, DHCP, EAPOL packet */
+	if (coex_sta->specific_pkt_period_cnt > 0) {
+
+		coex_sta->specific_pkt_period_cnt--;
+
+		if ((coex_sta->specific_pkt_period_cnt == 0) &&
+		    (coex_sta->wifi_is_high_pri_task))
+			coex_sta->wifi_is_high_pri_task = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ***************** Hi-Pri Task = %s*****************\n",
+			    (coex_sta->wifi_is_high_pri_task ? "Yes" :
+			     "No"));
+		BTC_TRACE(trace_buf);
+	}
+
+	if (!coex_sta->bt_disabled) {
+		if (coex_sta->bt_coex_supported_feature == 0)
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_FEATURE, &coex_sta->bt_coex_supported_feature);
+
+		if ((coex_sta->bt_coex_supported_version == 0) ||
+			(coex_sta->bt_coex_supported_version == 0xffff))
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION, &coex_sta->bt_coex_supported_version);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+		btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+
+		if (halbtc8822b1ant_is_wifi_status_changed(btcoexist))
+			halbtc8822b1ant_run_coexist_mechanism(btcoexist);
+
+	}
+}
+
+void ex_halbtc8822b1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+}
+
+void ex_halbtc8822b1ant_antenna_isolation(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+
+}
+
+void ex_halbtc8822b1ant_psd_scan(IN struct btc_coexist *btcoexist,
+		 IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+
+}
+
+void ex_halbtc8822b1ant_display_ant_detection(IN struct btc_coexist *btcoexist)
+{
+
+}
+
+void ex_halbtc8822b1ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata)
+{}
+#endif	/*  #if(BTC_COEX_OFFLOAD == 1) */
+
+#endif
+
+#else
+
+void ex_halbtc8822b1ant_switch_band_without_bt(IN struct btc_coexist *btcoexist,
+		IN boolean wifi_only_5g)
+{
+	/* ant switch WL2G or WL5G*/
+	if (wifi_only_5g)
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd, 0x3, 1);
+
+	else
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd, 0x3, 2);
+
+}
+
+void ex_halbtc8822b1ant_init_hw_config_without_bt(IN struct btc_coexist
+		*btcoexist)
+{
+	/* enable GNT_WL */
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x1,
+					   0x0);
+
+	/* Antenna config */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /*  0x4c[23] = 0 */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x1);  /* 0x4c[24] = 1 */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb4,
+		0xff, 0x77);	/* BB SW, DPDT use RFE_ctrl8 and RFE_ctrl9 as conctrol pin */
+
+
+	/* Ext switch buffer mux */
+	btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x1991,
+					   0x3, 0x0);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbe,
+					   0x8, 0x0);
+
+	/*enable sw control gnt_wl=1 / gnt_bt=1 */
+	btcoexist->btc_write_1byte(btcoexist, 0x73, 0x0e);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x1704,
+				   0x0000ff00);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x1700,
+				   0xc00f0038);
+}
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
+
+
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8822b1ant.h
@@ -0,0 +1,434 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8822B_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8822B 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8822B_1ANT				1
+
+#define	BT_INFO_8822B_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8822B_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8822B_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8822B_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8822B_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8822B_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8822B_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8822B_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8822B_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+		(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8822B_1ANT		2
+
+#define  BT_8822B_1ANT_WIFI_NOISY_THRESH							150  /* max: 255 */
+
+/* for Antenna detection */
+#define	BT_8822B_1ANT_ANTDET_PSDTHRES_BACKGROUND					50
+#define	BT_8822B_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION				70
+#define	BT_8822B_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION			55
+#define	BT_8822B_1ANT_ANTDET_PSDTHRES_1ANT							35
+#define	BT_8822B_1ANT_ANTDET_RETRY_INTERVAL							10	/* retry timer if ant det is fail, unit: second */
+#define	BT_8822B_1ANT_ANTDET_ENABLE									0
+#define	BT_8822B_1ANT_ANTDET_COEXMECHANISMSWITCH_ENABLE				0
+
+#define	BT_8822B_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT		30000
+
+
+
+enum bt_8822b_1ant_signal_state {
+	BT_8822B_1ANT_SIG_STA_SET_TO_LOW		= 0x0,
+	BT_8822B_1ANT_SIG_STA_SET_BY_HW		= 0x0,
+	BT_8822B_1ANT_SIG_STA_SET_TO_HIGH		= 0x1,
+	BT_8822B_1ANT_SIG_STA_MAX
+};
+
+enum bt_8822b_1ant_path_ctrl_owner {
+	BT_8822B_1ANT_PCO_BTSIDE		= 0x0,
+	BT_8822B_1ANT_PCO_WLSIDE	= 0x1,
+	BT_8822B_1ANT_PCO_MAX
+};
+
+enum bt_8822b_1ant_gnt_ctrl_type {
+	BT_8822B_1ANT_GNT_CTRL_BY_PTA		= 0x0,
+	BT_8822B_1ANT_GNT_CTRL_BY_SW		= 0x1,
+	BT_8822B_1ANT_GNT_CTRL_MAX
+};
+
+enum bt_8822b_1ant_gnt_ctrl_block {
+	BT_8822B_1ANT_GNT_BLOCK_RFC_BB		= 0x0,
+	BT_8822B_1ANT_GNT_BLOCK_RFC			= 0x1,
+	BT_8822B_1ANT_GNT_BLOCK_BB			= 0x2,
+	BT_8822B_1ANT_GNT_BLOCK_MAX
+};
+
+enum bt_8822b_1ant_lte_coex_table_type {
+	BT_8822B_1ANT_CTT_WL_VS_LTE			= 0x0,
+	BT_8822B_1ANT_CTT_BT_VS_LTE			= 0x1,
+	BT_8822B_1ANT_CTT_MAX
+};
+
+enum bt_8822b_1ant_lte_break_table_type {
+	BT_8822B_1ANT_LBTT_WL_BREAK_LTE			= 0x0,
+	BT_8822B_1ANT_LBTT_BT_BREAK_LTE				= 0x1,
+	BT_8822B_1ANT_LBTT_LTE_BREAK_WL			= 0x2,
+	BT_8822B_1ANT_LBTT_LTE_BREAK_BT				= 0x3,
+	BT_8822B_1ANT_LBTT_MAX
+};
+
+enum bt_info_src_8822b_1ant {
+	BT_INFO_SRC_8822B_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8822B_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8822B_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8822B_1ANT_MAX
+};
+
+enum bt_8822b_1ant_bt_status {
+	BT_8822B_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8822B_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8822B_1ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8822B_1ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8822B_1ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8822B_1ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8822B_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8822b_1ant_wifi_status {
+	BT_8822B_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8822B_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8822B_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8822B_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT				= 0x3,
+	BT_8822B_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8822B_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8822B_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8822b_1ant_coex_algo {
+	BT_8822B_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8822B_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8822B_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8822B_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8822B_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8822B_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8822B_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8822B_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8822B_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8822B_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8822B_1ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8822B_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+enum bt_8822b_1ant_ext_ant_switch_type {
+	BT_8822B_1ANT_EXT_ANT_SWITCH_USE_SPDT		= 0x0,
+	BT_8822B_1ANT_EXT_ANT_SWITCH_USE_SP3T		= 0x1,
+	BT_8822B_1ANT_EXT_ANT_SWITCH_MAX
+};
+
+enum bt_8822b_1ant_ext_ant_switch_ctrl_type {
+	BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW	= 0x0,
+	BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_PTA	= 0x1,
+	BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_ANTDIV	= 0x2,
+	BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_MAC	= 0x3,
+	BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_BY_BT		= 0x4,
+	BT_8822B_1ANT_EXT_ANT_SWITCH_CTRL_MAX
+};
+
+enum bt_8822b_1ant_ext_ant_switch_pos_type {
+	BT_8822B_1ANT_EXT_ANT_SWITCH_TO_BT			= 0x0,
+	BT_8822B_1ANT_EXT_ANT_SWITCH_TO_WLG			= 0x1,
+	BT_8822B_1ANT_EXT_ANT_SWITCH_TO_WLA			= 0x2,
+	BT_8822B_1ANT_EXT_ANT_SWITCH_TO_NOCARE		= 0x3,
+	BT_8822B_1ANT_EXT_ANT_SWITCH_TO_MAX
+};
+
+enum bt_8822b_1ant_phase {
+	BT_8822B_1ANT_PHASE_COEX_INIT				= 0x0,
+	BT_8822B_1ANT_PHASE_WLANONLY_INIT			= 0x1,
+	BT_8822B_1ANT_PHASE_WLAN_OFF				= 0x2,
+	BT_8822B_1ANT_PHASE_2G_RUNTIME				= 0x3,
+	BT_8822B_1ANT_PHASE_5G_RUNTIME				= 0x4,
+	BT_8822B_1ANT_PHASE_BTMPMODE				= 0x5,
+	BT_8822B_1ANT_PHASE_MAX
+};
+
+/*ADD SCOREBOARD TO FIX BT LPS 32K ISSUE WHILE WL BUSY*/
+enum bt_8822b_1ant_Scoreboard {
+	BT_8822B_1ANT_SCOREBOARD_ACTIVE                            = BIT(0),
+	BT_8822B_1ANT_SCOREBOARD_ONOFF                             = BIT(1),
+	BT_8822B_1ANT_SCOREBOARD_SCAN                               = BIT(2),
+	BT_8822B_1ANT_SCOREBOARD_UNDERTEST							= BIT(3),
+	BT_8822B_1ANT_SCOREBOARD_WLBUSY                          = BIT(6)
+};
+
+struct coex_dm_8822b_1ant {
+	/* hw setting */
+	u32		pre_ant_pos_type;
+	u32		cur_ant_pos_type;
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u32		pre_ext_ant_switch_status;
+	u32		cur_ext_ant_switch_status;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8822b_1ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+	boolean					bt_hi_pri_link_exist;
+	u8					num_of_profile;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	s8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8822B_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8822B_1ANT_MAX];
+	boolean					bt_whck_test;
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_page;				/* Add for win8.1 page out issue */
+	boolean					wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_agg;
+	u32					crc_ok_11n_vht;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_agg;
+	u32					crc_err_11n_vht;
+
+	boolean					cck_lock;
+	boolean					pre_ccklock;
+	boolean					cck_ever_lock;
+	u8					coex_table_type;
+
+	boolean					force_lps_on;
+	u32					wrong_profile_notification;
+
+	boolean					concurrent_rx_mode_on;
+
+	u32					special_pkt_period_cnt;
+
+	u16					score_board;
+
+	u8					a2dp_bit_pool;
+	u8					cut_version;
+	boolean				acl_busy;
+	boolean				wl_rf_off_on_event;
+	boolean				bt_create_connection;
+	boolean				run_time_state;
+
+	u32					bt_coex_supported_feature;
+	u32					bt_coex_supported_version;
+	boolean                               rf4ce_enabled;
+};
+
+struct rfe_type_8822b_1ant {
+
+	u8			rfe_module_type;
+	boolean		ext_ant_switch_exist;
+	u8			ext_ant_switch_type;
+	u8			ext_ant_switch_ctrl_polarity;		/*  iF 0: ANTSW(rfe_sel9)=0, ANTSWB(rfe_sel8)=1 =>  Ant to BT/5G */
+};
+
+
+#define  BT_8822B_1ANT_ANTDET_PSD_POINTS			256	/* MAX:1024 */
+#define  BT_8822B_1ANT_ANTDET_PSD_AVGNUM			1	/* MAX:3 */
+#define	BT_8822B_1ANT_ANTDET_BUF_LEN				16
+
+struct psdscan_sta_8822b_1ant {
+
+	u32			ant_det_bt_le_channel;  /* BT LE Channel ex:2412 */
+	u32			ant_det_bt_tx_time;
+	u32			ant_det_pre_psdscan_peak_val;
+	boolean			ant_det_is_ant_det_available;
+	u32			ant_det_psd_scan_peak_val;
+	boolean			ant_det_is_btreply_available;
+	u32			ant_det_psd_scan_peak_freq;
+
+	u8			ant_det_result;
+	u8			ant_det_peak_val[BT_8822B_1ANT_ANTDET_BUF_LEN];
+	u8			ant_det_peak_freq[BT_8822B_1ANT_ANTDET_BUF_LEN];
+	u32			ant_det_try_count;
+	u32			ant_det_fail_count;
+	u32			ant_det_inteval_count;
+	u32			ant_det_thres_offset;
+
+	u32			real_cent_freq;
+	s32			real_offset;
+	u32			real_span;
+
+	u32			psd_band_width;  /* unit: Hz */
+	u32			psd_point;		/* 128/256/512/1024 */
+	u32			psd_report[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_report_max_hold[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_start_point;
+	u32			psd_stop_point;
+	u32			psd_max_value_point;
+	u32			psd_max_value;
+	u32			psd_start_base;
+	u32			psd_avg_num;	/* 1/8/16/32 */
+	u32			psd_gen_count;
+	boolean			is_psd_running;
+	boolean			is_psd_show_max_only;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8822b1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8822b1ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8822b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8822b1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8822b1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8822b1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8822b1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8822b1ant_scan_notify_without_bt(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8822b1ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8822b1ant_switchband_notify_without_bt(IN struct btc_coexist
+		*btcoexist,
+		IN u8 type);
+void ex_halbtc8822b1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8822b1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8822b1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8822b1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8822b1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8822b1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8822b1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8822b1ant_ScoreBoardStatusNotify(IN struct btc_coexist *btcoexist,
+		IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8822b1ant_coex_dm_reset(IN struct btc_coexist *btcoexist);
+void ex_halbtc8822b1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8822b1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8822b1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+void ex_halbtc8822b1ant_antenna_isolation(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+
+void ex_halbtc8822b1ant_psd_scan(IN struct btc_coexist *btcoexist,
+		 IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+void ex_halbtc8822b1ant_display_ant_detection(IN struct btc_coexist *btcoexist);
+
+void ex_halbtc8822b1ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata);
+
+#else
+#define	ex_halbtc8822b1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8822b1ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8822b1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8822b1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8822b1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8822b1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8822b1ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8822b1ant_scan_notify_without_bt(btcoexist, type)
+#define	ex_halbtc8822b1ant_switchband_notify(btcoexist, type)
+#define	ex_halbtc8822b1ant_switchband_notify_without_bt(btcoexist, type)
+#define	ex_halbtc8822b1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8822b1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8822b1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8822b1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8822b1ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8822b1ant_halt_notify(btcoexist)
+#define	ex_halbtc8822b1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8822b1ant_ScoreBoardStatusNotify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8822b1ant_coex_dm_reset(btcoexist)
+#define	ex_halbtc8822b1ant_periodical(btcoexist)
+#define	ex_halbtc8822b1ant_display_coex_info(btcoexist)
+#define	ex_halbtc8822b1ant_antenna_detection(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8822b1ant_antenna_isolation(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8822b1ant_psd_scan(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8822b1ant_display_ant_detection(btcoexist)
+#define	ex_halbtc8822b1ant_dbg_control(btcoexist, op_code, op_len, pdata)
+#endif
+#else
+
+void ex_halbtc8822b1ant_init_hw_config_without_bt(IN struct btc_coexist
+		*btcoexist);
+void ex_halbtc8822b1ant_switch_band_without_bt(IN struct btc_coexist *btcoexist,
+		IN boolean wifi_only_5g);
+
+
+#endif
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8822b2ant.c
@@ -0,0 +1,5583 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8822B Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "mp_precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8822B_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	*trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8822b_2ant		glcoex_dm_8822b_2ant;
+static struct  coex_dm_8822b_2ant	*coex_dm = &glcoex_dm_8822b_2ant;
+static struct  coex_sta_8822b_2ant		glcoex_sta_8822b_2ant;
+static struct  coex_sta_8822b_2ant	*coex_sta = &glcoex_sta_8822b_2ant;
+static struct  psdscan_sta_8822b_2ant	gl_psd_scan_8822b_2ant;
+static struct  psdscan_sta_8822b_2ant *psd_scan = &gl_psd_scan_8822b_2ant;
+static struct	rfe_type_8822b_2ant		gl_rfe_type_8822b_2ant;
+static struct	rfe_type_8822b_2ant		*rfe_type = &gl_rfe_type_8822b_2ant;
+
+const char *const glbt_info_src_8822b_2ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8822b_2ant = 20161124;
+u32	glcoex_ver_8822b_2ant = 0x3f;
+u32 glcoex_ver_btdesired_8822b_2ant = 0x28;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8822b2ant_
+ * ************************************************************ */
+u8 halbtc8822b2ant_bt_rssi_state(u8 *ppre_bt_rssi_state, u8 level_num,
+				 u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = *ppre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8822B_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return *ppre_bt_rssi_state;
+		}
+
+		if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8822B_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+			(*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8822B_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	*ppre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8822b2ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 *pprewifi_rssi_state, IN u8 level_num, IN u8 rssi_thresh,
+				   IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = *pprewifi_rssi_state;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((*pprewifi_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8822B_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return *pprewifi_rssi_state;
+		}
+
+		if ((*pprewifi_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8822B_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((*pprewifi_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+			(*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8822B_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	*pprewifi_rssi_state = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8822b2ant_coex_switch_threshold(IN struct btc_coexist *btcoexist,
+		IN u8 isolation_measuared)
+{
+	s8	interference_wl_tx = 0, interference_bt_tx = 0;
+
+
+	interference_wl_tx = BT_8822B_2ANT_WIFI_MAX_TX_POWER -
+			     isolation_measuared;
+	interference_bt_tx = BT_8822B_2ANT_BT_MAX_TX_POWER -
+			     isolation_measuared;
+
+
+
+	coex_sta->wifi_coex_thres		 = BT_8822B_2ANT_WIFI_RSSI_COEXSWITCH_THRES1;
+	coex_sta->wifi_coex_thres2	 = BT_8822B_2ANT_WIFI_RSSI_COEXSWITCH_THRES2;
+
+	coex_sta->bt_coex_thres		 = BT_8822B_2ANT_BT_RSSI_COEXSWITCH_THRES1;
+	coex_sta->bt_coex_thres2		 = BT_8822B_2ANT_BT_RSSI_COEXSWITCH_THRES2;
+
+
+	/*
+		coex_sta->wifi_coex_thres		= interference_wl_tx + BT_8822B_2ANT_WIFI_SIR_THRES1;
+		coex_sta->wifi_coex_thres2		= interference_wl_tx + BT_8822B_2ANT_WIFI_SIR_THRES2;
+
+		coex_sta->bt_coex_thres		= interference_bt_tx + BT_8822B_2ANT_BT_SIR_THRES1;
+		coex_sta->bt_coex_thres2		= interference_bt_tx + BT_8822B_2ANT_BT_SIR_THRES2;
+	*/
+
+
+
+
+
+	/*
+		if  ( BT_8822B_2ANT_WIFI_RSSI_COEXSWITCH_THRES1 < (isolation_measuared -
+					BT_8822B_2ANT_DEFAULT_ISOLATION) )
+			coex_sta->wifi_coex_thres	 = BT_8822B_2ANT_WIFI_RSSI_COEXSWITCH_THRES1;
+		else
+			coex_sta->wifi_coex_thres =  BT_8822B_2ANT_WIFI_RSSI_COEXSWITCH_THRES1 -  (isolation_measuared -
+					BT_8822B_2ANT_DEFAULT_ISOLATION);
+
+		if  ( BT_8822B_2ANT_BT_RSSI_COEXSWITCH_THRES1 < (isolation_measuared -
+					BT_8822B_2ANT_DEFAULT_ISOLATION) )
+			coex_sta->bt_coex_thres	 = BT_8822B_2ANT_BT_RSSI_COEXSWITCH_THRES1;
+		else
+			coex_sta->bt_coex_thres =  BT_8822B_2ANT_BT_RSSI_COEXSWITCH_THRES1 -  (isolation_measuared -
+					BT_8822B_2ANT_DEFAULT_ISOLATION);
+
+	*/
+}
+
+
+void halbtc8822b2ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+}
+
+void halbtc8822b2ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+	boolean		RTL97F_8822B = false;
+
+	if (RTL97F_8822B == true)
+		return;
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+void halbtc8822b2ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u8		num_of_bt_counter_chk = 0, cnt_slave = 0;
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	if ((coex_sta->low_priority_tx > 1050)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	if ((coex_sta->low_priority_rx >= 950) &&
+	    (coex_sta->low_priority_rx >= coex_sta->low_priority_tx)
+	    && (!coex_sta->under_ips)  && (!coex_sta->c2h_bt_inquiry_page) &&
+	    (coex_sta->bt_link_exist))	{
+		if (cnt_slave >= 2) {
+			bt_link_info->slave_role = true;
+			cnt_slave = 2;
+		} else
+			cnt_slave++;
+	} else {
+		if (cnt_slave == 0)	{
+			bt_link_info->slave_role = false;
+			cnt_slave = 0;
+		} else
+			cnt_slave--;
+
+	}
+
+	if ((coex_sta->high_priority_tx == 0) &&
+	    (coex_sta->high_priority_rx == 0) &&
+	    (coex_sta->low_priority_tx == 0) &&
+	    (coex_sta->low_priority_rx == 0)) {
+		num_of_bt_counter_chk++;
+		if (num_of_bt_counter_chk >= 3) {
+			halbtc8822b2ant_query_bt_info(btcoexist);
+			num_of_bt_counter_chk = 0;
+		}
+	}
+
+}
+
+void halbtc8822b2ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+#if 0
+	s32 wifi_rssi = 0;
+	boolean wifi_busy = false, wifi_under_b_mode = false;
+	static u8 cck_lock_counter = 0;
+	u32 total_cnt, reg_val1, reg_val2;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+			   &wifi_under_b_mode);
+
+	if (coex_sta->under_ips) {
+		coex_sta->crc_ok_cck = 0;
+		coex_sta->crc_ok_11g = 0;
+		coex_sta->crc_ok_11n = 0;
+		coex_sta->crc_ok_11n_agg = 0;
+
+		coex_sta->crc_err_cck = 0;
+		coex_sta->crc_err_11g = 0;
+		coex_sta->crc_err_11n = 0;
+		coex_sta->crc_err_11n_agg = 0;
+	} else {
+
+		reg_val1 = btcoexist->btc_read_4byte(btcoexist, 0xf00);
+		reg_val2 = btcoexist->btc_read_4byte(btcoexist, 0xf04);
+		coex_sta->crc_ok_cck = reg_val2 & 0xffff;
+		coex_sta->crc_err_cck = (reg_val1 & 0xffff) + ((reg_val2
+					& 0xffff0000) >> 16);
+
+		reg_val1 = btcoexist->btc_read_4byte(btcoexist, 0xf0c);
+		coex_sta->crc_ok_11n_agg = reg_val1 & 0xffff;
+		coex_sta->crc_err_11n_agg = (reg_val1 & 0xffff0000) >>
+					    16;
+
+		reg_val1 = btcoexist->btc_read_4byte(btcoexist, 0xf10);
+		coex_sta->crc_ok_11n = reg_val1 & 0xffff;
+		coex_sta->crc_err_11n = (reg_val1 & 0xffff0000) >> 16;
+
+		reg_val1 = btcoexist->btc_read_4byte(btcoexist, 0xf14);
+		coex_sta->crc_ok_11g = reg_val1 & 0xffff;
+		coex_sta->crc_err_11n = (reg_val1 & 0xffff0000) >> 16;
+	}
+
+
+	/* reset counter */
+	/*btcoexist->btc_write_1byte_bitmask(btcoexist, 0xb58, 0x1, 0x1);*/
+	/*btcoexist->btc_write_1byte_bitmask(btcoexist, 0xb58, 0x1, 0x0);*/
+
+	if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+		total_cnt = coex_sta->crc_ok_cck + coex_sta->crc_ok_11g
+			    +
+			    coex_sta->crc_ok_11n +
+			    coex_sta->crc_ok_11n_agg;
+
+		if ((coex_dm->bt_status ==
+		     BT_8822B_2ANT_BT_STATUS_ACL_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8822B_2ANT_BT_STATUS_ACL_SCO_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8822B_2ANT_BT_STATUS_SCO_BUSY)) {
+			if (coex_sta->crc_ok_cck > (total_cnt -
+						    coex_sta->crc_ok_cck)) {
+				if (cck_lock_counter < 3)
+					cck_lock_counter++;
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+	} else {
+		if (cck_lock_counter > 0)
+			cck_lock_counter--;
+	}
+
+	if (!coex_sta->pre_ccklock) {
+
+		if (cck_lock_counter >= 3)
+			coex_sta->cck_lock = true;
+		else
+			coex_sta->cck_lock = false;
+	} else {
+		if (cck_lock_counter == 0)
+			coex_sta->cck_lock = false;
+		else
+			coex_sta->cck_lock = true;
+	}
+
+	if (coex_sta->cck_lock)
+		coex_sta->cck_ever_lock = true;
+
+	coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+#endif
+}
+
+boolean halbtc8822b2ant_is_wifibt_status_changed(IN struct btc_coexist
+		*btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false, pre_bt_off = false;
+	static u8 pre_hid_busy_num = 0;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (coex_sta->bt_disabled != pre_bt_off) {
+		pre_bt_off = coex_sta->bt_disabled;
+
+		if (coex_sta->bt_disabled)
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+		else
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is enabled !!\n");
+
+		BTC_TRACE(trace_buf);
+
+		coex_sta->bt_coex_supported_feature = 0;
+		coex_sta->bt_coex_supported_version = 0;
+		coex_sta->bt_ble_scan_type = 0;
+		coex_sta->bt_ble_scan_para[0] = 0;
+		coex_sta->bt_ble_scan_para[1] = 0;
+		coex_sta->bt_ble_scan_para[2] = 0;
+		coex_sta->bt_reg_vendor_ac = 0xffff;
+		coex_sta->bt_reg_vendor_ae = 0xffff;
+		return true;
+	}
+
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+
+		if (!coex_sta->bt_disabled) {
+
+			if (coex_sta->hid_busy_num != pre_hid_busy_num) {
+				pre_hid_busy_num = coex_sta->hid_busy_num;
+				return true;
+			}
+		}
+	}
+
+	return false;
+}
+
+
+void halbtc8822b2ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+
+	struct	btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean			bt_hs_on = false;
+	boolean		bt_busy = false;
+
+	coex_sta->num_of_profile = 0;
+
+	/* set link exist status */
+	if (!(coex_sta->bt_info & BT_INFO_8822B_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (coex_sta->bt_info & BT_INFO_8822B_1ANT_B_FTP) {
+			coex_sta->pan_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->pan_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8822B_1ANT_B_A2DP) {
+			coex_sta->a2dp_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->a2dp_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8822B_1ANT_B_HID) {
+			coex_sta->hid_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->hid_exist = false;
+
+		if (coex_sta->bt_info & BT_INFO_8822B_1ANT_B_SCO_ESCO) {
+			coex_sta->sco_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->sco_exist = false;
+
+	}
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+	bt_link_info->acl_busy = coex_sta->acl_busy;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+
+	if (!(coex_sta->bt_info & BT_INFO_8822B_2ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8822B_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+	} else if (coex_sta->bt_info == BT_INFO_8822B_2ANT_B_CONNECTION) {
+		/* connection exists but no busy */
+		coex_dm->bt_status = BT_8822B_2ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+	} else if (((coex_sta->bt_info & BT_INFO_8822B_2ANT_B_SCO_ESCO) ||
+		    (coex_sta->bt_info & BT_INFO_8822B_2ANT_B_SCO_BUSY)) &&
+		   (coex_sta->bt_info & BT_INFO_8822B_2ANT_B_ACL_BUSY)) {
+		coex_dm->bt_status = BT_8822B_2ANT_BT_STATUS_ACL_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL SCO busy!!!\n");
+	} else if ((coex_sta->bt_info & BT_INFO_8822B_2ANT_B_SCO_ESCO) ||
+		   (coex_sta->bt_info & BT_INFO_8822B_2ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8822B_2ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+	} else if (coex_sta->bt_info & BT_INFO_8822B_2ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8822B_2ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+	} else {
+		coex_dm->bt_status = BT_8822B_2ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+	}
+
+	BTC_TRACE(trace_buf);
+
+	if ((BT_8822B_2ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8822B_2ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8822B_2ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+}
+
+void halbtc8822b2ant_update_wifi_channel_info(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8	h2c_parameter[3] = {0};
+	u32	wifi_bw;
+	u8	wifi_central_chnl;
+	u32	RTL97F_8822B = 0;
+
+	if (RTL97F_8822B == true)
+		return;
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] =
+			0x1;  /* enable BT AFH skip WL channel for 8822b because BT Rx LO interference */
+		/* h2c_parameter[0] = 0x0; */
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+
+}
+
+void halbtc8822b2ant_set_fw_dac_swing_level(IN struct btc_coexist *btcoexist,
+		IN u8 dac_swing_lvl)
+{
+	u8	h2c_parameter[1] = {0};
+	u32	RTL97F_8822B = 0;
+
+	if (RTL97F_8822B == true)
+			return;
+
+	/* There are several type of dacswing */
+	/* 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6 */
+	h2c_parameter[0] = dac_swing_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
+}
+
+void halbtc8822b2ant_fw_dac_swing_lvl(IN struct btc_coexist *btcoexist,
+			      IN boolean force_exec, IN u8 fw_dac_swing_lvl)
+{
+	u32	RTL97F_8822B = 0;
+
+	if (RTL97F_8822B == true)
+		return;
+
+	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swing_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_fw_dac_swing_lvl ==
+		    coex_dm->cur_fw_dac_swing_lvl)
+			return;
+	}
+
+	halbtc8822b2ant_set_fw_dac_swing_level(btcoexist,
+					       coex_dm->cur_fw_dac_swing_lvl);
+
+	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
+}
+
+void halbtc8822b2ant_set_fw_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				       IN u8 dec_bt_pwr_lvl)
+{
+	u32	RTL97F_8822B = 0;
+	u8	h2c_parameter[1] = {0};
+
+	if (RTL97F_8822B == true)
+		return;
+
+	h2c_parameter[0] = dec_bt_pwr_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x62, 1, h2c_parameter);
+}
+
+void halbtc8822b2ant_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN u8 dec_bt_pwr_lvl)
+{
+	coex_dm->cur_bt_dec_pwr_lvl = dec_bt_pwr_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_dec_pwr_lvl == coex_dm->cur_bt_dec_pwr_lvl)
+			return;
+	}
+	halbtc8822b2ant_set_fw_dec_bt_pwr(btcoexist,
+					  coex_dm->cur_bt_dec_pwr_lvl);
+
+	coex_dm->pre_bt_dec_pwr_lvl = coex_dm->cur_bt_dec_pwr_lvl;
+}
+
+
+void halbtc8822b2ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+
+#if 1
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra ==
+		    coex_dm->cur_low_penalty_ra)
+			return;
+	}
+
+	if (low_penalty_ra)
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 50);
+	else
+		btcoexist->btc_phydm_modify_RA_PCR_threshold(btcoexist, 0, 0);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+
+#endif
+
+}
+
+
+void halbtc8822b2ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8	h2c_parameter[1] = {0};
+	u32	RTL97F_8822B = 0;
+
+	if (RTL97F_8822B == true)
+		return;
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8822b2ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8822b2ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8822b2ant_write_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16				bitpos,
+	IN	boolean		state
+)
+{
+
+	static u16 originalval = 0x8002;
+
+	if (state)
+		originalval = originalval | bitpos;
+	else
+		originalval = originalval & (~bitpos);
+
+
+	btcoexist->btc_write_2byte(btcoexist, 0xaa, originalval);
+
+}
+
+void halbtc8822b2ant_read_score_board(
+	IN	struct  btc_coexist		*btcoexist,
+	IN   u16				*score_board_val
+)
+{
+
+	*score_board_val = (btcoexist->btc_read_2byte(btcoexist,
+			    0xaa)) & 0x7fff;
+}
+
+void halbtc8822b2ant_post_state_to_bt(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16						type,
+	IN  BOOLEAN                 state
+)
+{
+
+	halbtc8822b2ant_write_score_board(btcoexist, (u16) type, state);
+
+}
+
+
+
+void halbtc8822b2ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false, wifi_under_5g = false;
+	u16			u16tmp;
+
+	/* This function check if bt is disabled */
+#if 0
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+
+
+#else
+
+	/* Read BT on/off status from scoreboard[1], enable this only if BT patch support this feature */
+	halbtc8822b2ant_read_score_board(btcoexist,	&u16tmp);
+
+	bt_active = u16tmp & BIT(1);
+
+
+#endif
+
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	} else {
+
+		bt_disable_cnt++;
+		if (bt_disable_cnt >= 10) {
+			bt_disabled = true;
+			bt_disable_cnt = 10;
+		}
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if ((wifi_under_5g) || (bt_disabled))
+		halbtc8822b2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, false);
+	else
+		halbtc8822b2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, true);
+
+
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+	}
+
+}
+
+void halbtc8822b2ant_enable_gnt_to_gpio(IN struct btc_coexist *btcoexist,
+					boolean isenable)
+{
+#if BT_8822B_2ANT_COEX_DBG
+	static u8			bitVal[5] = {0, 0, 0, 0, 0};
+	static boolean		state = false;
+	/*
+		if (state ==isenable)
+			return;
+		else
+			state = isenable;
+	*/
+	if (isenable) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], enable_gnt_to_gpio!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* enable GNT_WL, GNT_BT to GPIO for debug */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x1);
+
+		/* store original value */
+		bitVal[0] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x66) & BIT(4)) >> 4;	/*0x66[4] */
+		bitVal[1] = (btcoexist->btc_read_1byte(btcoexist,
+					       0x67) & BIT(0));		/*0x66[8] */
+		bitVal[2] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x42) & BIT(3)) >> 3;  /*0x40[19] */
+		bitVal[3] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x65) & BIT(7)) >> 7;  /*0x64[15] */
+		bitVal[4] = (btcoexist->btc_read_1byte(btcoexist,
+				       0x72) & BIT(2)) >> 2;  /*0x70[18] */
+
+		/*  switch GPIO Mux */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x66, BIT(4),
+						   0x0);  /*0x66[4] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, BIT(0),
+						   0x0);  /*0x66[8] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x42, BIT(3),
+						   0x0);  /*0x40[19] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x65, BIT(7),
+						   0x0);  /*0x64[15] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x72, BIT(2),
+						   0x0);  /*0x70[18] = 0 */
+
+
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], disable_gnt_to_gpio!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x0);
+
+		/*  Restore original value  */
+		/*  switch GPIO Mux */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x66, BIT(4),
+						   bitVal[0]);  /*0x66[4] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, BIT(0),
+						   bitVal[1]);  /*0x66[8] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x42, BIT(3),
+					   bitVal[2]);  /*0x40[19] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x65, BIT(7),
+					   bitVal[3]);  /*0x64[15] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x72, BIT(2),
+					   bitVal[4]);  /*0x70[18] = 0 */
+	}
+
+#endif
+}
+
+u32 halbtc8822b2ant_ltecoex_indirect_read_reg(IN struct btc_coexist *btcoexist,
+		IN u16 reg_addr)
+{
+	u32 j = 0, delay_count = 0;
+
+
+	/* wait for ready bit before access 0x1700		 */
+	btcoexist->btc_write_4byte(btcoexist, 0x1700, 0x800F0000 | reg_addr);
+#if 0
+	do {
+		j++;
+	} while (((btcoexist->btc_read_1byte(btcoexist,
+					     0x1703)&BIT(5)) == 0) &&
+		 (j < BT_8822B_2ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+#endif
+	while (1) {
+		if ((btcoexist->btc_read_1byte(btcoexist, 0x1703)&BIT(5)) == 0) {
+			delay_ms(50);
+			delay_count++;
+			if (delay_count >= 10) {
+				delay_count = 0;
+				break;
+			}
+		} else
+			break;
+	}
+
+
+	return btcoexist->btc_read_4byte(btcoexist,
+					 0x1708);  /* get read data */
+
+}
+
+void halbtc8822b2ant_ltecoex_indirect_write_reg(IN struct btc_coexist
+		*btcoexist,
+		IN u16 reg_addr, IN u32 bit_mask, IN u32 reg_value)
+{
+	u32 val, i = 0, j = 0, bitpos = 0, delay_count = 0;
+
+
+	if (bit_mask == 0x0)
+		return;
+	if (bit_mask == 0xffffffff) {
+		btcoexist->btc_write_4byte(btcoexist, 0x1704,
+					   reg_value); /* put write data */
+
+		/* wait for ready bit before access 0x1700 */
+#if 0
+		do {
+			j++;
+		} while (((btcoexist->btc_read_1byte(btcoexist,
+						     0x1703)&BIT(5)) == 0) &&
+			(j < BT_8822B_2ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+#endif
+
+		while (1) {
+			if ((btcoexist->btc_read_1byte(btcoexist, 0x1703)&BIT(5)) == 0) {
+				delay_ms(50);
+				delay_count++;
+				if (delay_count >= 10) {
+					delay_count = 0;
+					break;
+}
+			} else
+				break;
+		}
+		btcoexist->btc_write_4byte(btcoexist, 0x1700,
+					   0xc00F0000 | reg_addr);
+	} else {
+		for (i = 0; i <= 31; i++) {
+			if (((bit_mask >> i) & 0x1) == 0x1) {
+				bitpos = i;
+				break;
+			}
+		}
+
+		/* read back register value before write */
+		val = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist,
+				reg_addr);
+		val = (val & (~bit_mask)) | (reg_value << bitpos);
+
+		btcoexist->btc_write_4byte(btcoexist, 0x1704,
+					   val); /* put write data */
+
+		/* wait for ready bit before access 0x7c0		 */
+#if 0
+		do {
+			j++;
+		} while (((btcoexist->btc_read_1byte(btcoexist,
+						     0x1703)&BIT(5)) == 0) &&
+			(j < BT_8822B_2ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+#endif
+
+		while (1) {
+			if ((btcoexist->btc_read_1byte(btcoexist, 0x1703)&BIT(5)) == 0) {
+				delay_ms(50);
+				delay_count++;
+				if (delay_count >= 10) {
+					delay_count = 0;
+					break;
+				}
+			} else
+				break;
+		}
+		btcoexist->btc_write_4byte(btcoexist, 0x1700,
+					   0xc00F0000 | reg_addr);
+
+	}
+
+}
+
+void halbtc8822b2ant_ltecoex_enable(IN struct btc_coexist *btcoexist,
+				    IN boolean enable)
+{
+	u8 val;
+
+	val = (enable) ? 1 : 0;
+	halbtc8822b2ant_ltecoex_indirect_write_reg(btcoexist, 0x38, 0x80,
+			val);  /* 0x38[7] */
+
+}
+
+void halbtc8822b2ant_ltecoex_pathcontrol_owner(IN struct btc_coexist *btcoexist,
+		IN boolean wifi_control)
+{
+	u8 val;
+
+	val = (wifi_control) ? 1 : 0;
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x4,
+					   val); /* 0x70[26] */
+
+}
+
+void halbtc8822b2ant_ltecoex_set_gnt_bt(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, bit_mask;
+
+	state = state & 0x1;
+	val = (sw_control) ? ((state << 1) | 0x1) : 0;
+
+	switch (control_block) {
+	case BT_8822B_2ANT_GNT_BLOCK_RFC_BB:
+	default:
+		bit_mask = 0xc000;
+		halbtc8822b2ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[15:14] */
+		bit_mask = 0x0c00;
+		halbtc8822b2ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[11:10]						 */
+		break;
+	case BT_8822B_2ANT_GNT_BLOCK_RFC:
+		bit_mask = 0xc000;
+		halbtc8822b2ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[15:14] */
+		break;
+	case BT_8822B_2ANT_GNT_BLOCK_BB:
+		bit_mask = 0x0c00;
+		halbtc8822b2ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[11:10] */
+		break;
+
+	}
+
+}
+
+void halbtc8822b2ant_ltecoex_set_gnt_wl(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, bit_mask;
+
+	state = state & 0x1;
+	val = (sw_control) ? ((state << 1) | 0x1) : 0;
+
+	switch (control_block) {
+	case BT_8822B_2ANT_GNT_BLOCK_RFC_BB:
+	default:
+		bit_mask = 0x3000;
+		halbtc8822b2ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[13:12] */
+		bit_mask = 0x0300;
+		halbtc8822b2ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[9:8]						 */
+		break;
+	case BT_8822B_2ANT_GNT_BLOCK_RFC:
+		bit_mask = 0x3000;
+		halbtc8822b2ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[13:12] */
+		break;
+	case BT_8822B_2ANT_GNT_BLOCK_BB:
+		bit_mask = 0x0300;
+		halbtc8822b2ant_ltecoex_indirect_write_reg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[9:8] */
+		break;
+
+	}
+
+}
+
+void halbtc8822b2ant_ltecoex_set_coex_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u16 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8822B_2ANT_CTT_WL_VS_LTE:
+		reg_addr = 0xa0;
+		break;
+	case BT_8822B_2ANT_CTT_BT_VS_LTE:
+		reg_addr = 0xa4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8822b2ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xffff, table_content); /* 0xa0[15:0] or 0xa4[15:0] */
+
+
+}
+
+
+void halbtc8822b2ant_ltecoex_set_break_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u8 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8822B_2ANT_LBTT_WL_BREAK_LTE:
+		reg_addr = 0xa8;
+		break;
+	case BT_8822B_2ANT_LBTT_BT_BREAK_LTE:
+		reg_addr = 0xac;
+		break;
+	case BT_8822B_2ANT_LBTT_LTE_BREAK_WL:
+		reg_addr = 0xb0;
+		break;
+	case BT_8822B_2ANT_LBTT_LTE_BREAK_BT:
+		reg_addr = 0xb4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8822b2ant_ltecoex_indirect_write_reg(btcoexist, reg_addr,
+			0xff, table_content); /* 0xa8[15:0] or 0xb4[15:0] */
+
+
+}
+
+
+void halbtc8822b2ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8822b2ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8822b2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8822b2ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	u32	break_table;
+	u8	select_table;
+
+	coex_sta->coex_table_type = type;
+
+	if (coex_sta->concurrent_rx_mode_on == true) {
+		break_table = 0xf0ffffff;  /* set WL hi-pri can break BT */
+		select_table =
+			0x3;		/* 0xb/0x3,set Tx response = Hi-Pri/LO-Pri (ex: Transmitting ACK,BA,CTS) */
+	} else {
+		break_table = 0xffffff;
+		select_table = 0x3;
+	}
+
+	switch (type) {
+	case 0:
+		halbtc8822b2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0x55555555, break_table, select_table);
+		break;
+	case 1:
+		halbtc8822b2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0x5a5a5a5a, break_table, select_table);
+		break;
+	case 2:
+		halbtc8822b2ant_coex_table(btcoexist, force_exec,
+			   0x5a5a5a5a, 0x5a5a5a5a, break_table, select_table);
+		break;
+	case 3:
+		halbtc8822b2ant_coex_table(btcoexist, force_exec,
+			   0x5a5a5a5a, 0x5a5a5a5a, break_table, select_table);
+		break;
+	case 4:
+		halbtc8822b2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0x5a5a5a5a, break_table, select_table);
+		break;
+	case 5:
+		halbtc8822b2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0x5a5a5a5a, break_table, select_table);
+		break;
+	case 6:
+		halbtc8822b2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0xaaaa5aaa, break_table, select_table);
+		break;
+	case 7:
+		halbtc8822b2ant_coex_table(btcoexist, force_exec,
+			   0xa5555555, 0xaa5a5a5a, break_table, select_table);
+		break;
+	case 8:
+		halbtc8822b2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0x5a5a5a5a, break_table, select_table);
+		break;
+	case 9:
+		halbtc8822b2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0xaaaa555a, break_table, select_table);
+		break;
+	case 10:
+		halbtc8822b2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0xaaaa5aaa, break_table, select_table);
+		break;
+	case 11:
+		halbtc8822b2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0xaaaaa5aa, break_table, select_table);
+		break;
+	case 12:
+		halbtc8822b2ant_coex_table(btcoexist, force_exec,
+			   0x55555555, 0xaaaa55aa, break_table, select_table);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8822b2ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+	u32	RTL97F_8822B = 0;
+
+	if (RTL97F_8822B == true)
+			return;
+
+	if (enable)
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8822b2ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8822b2ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8822b2ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8822b2ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8822b2ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8822b2ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0, 0, 0, 0x40, 0};
+	u32	RTL97F_8822B = 0;
+
+	if (RTL97F_8822B == true)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			/*halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			/*halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);*/
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5,
+						h2c_parameter);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8822b2ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8822b2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8822b2ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8822b2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+
+
+void halbtc8822b2ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8822b2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0,
+							 0x0);
+		}
+	} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+
+		halbtc8822b2ant_power_save_state(
+			btcoexist, BTC_PS_LPS_ON, 0x50,
+			0x4);
+	} else {
+		halbtc8822b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0,
+						 0x0);
+	}
+
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8822b2ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+
+	static u8			psTdmaByte4Modify = 0x0, pre_psTdmaByte4Modify = 0x0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	/* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+	if ((bt_link_info->slave_role) && (bt_link_info->a2dp_exist))
+		psTdmaByte4Modify = 0x1;
+	else
+		psTdmaByte4Modify = 0x0;
+
+	if (pre_psTdmaByte4Modify != psTdmaByte4Modify) {
+
+		force_exec = true;
+		pre_psTdmaByte4Modify = psTdmaByte4Modify;
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+
+	if (turn_on) {
+		switch (type) {
+		case 1:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x03, 0xf1,
+						      0x54 | psTdmaByte4Modify);
+			break;
+		case 2:
+		default:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x35, 0x03, 0x71,
+						      0x11 | psTdmaByte4Modify);
+			break;
+		case 3:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3a, 0x3, 0xf1,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 4:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x21, 0x3, 0xf1,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 5:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0xf1,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 6:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0xf1,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 7:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x20, 0x3, 0xf1,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 11:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x30, 0x03, 0x71,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 12:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x21, 0x03, 0x71,
+						      0x11 | psTdmaByte4Modify);
+			break;
+		case 13:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x03, 0x71,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 14:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x30, 0x03, 0x71,
+						      0x11);
+			break;
+		case 51:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x03, 0xf1,
+						      0x10 | psTdmaByte4Modify);
+			break;
+		case 101:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x10, 0x03, 0x70,
+						      0x54 | psTdmaByte4Modify);
+			break;
+		case 102:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x35, 0x03, 0x71,
+						      0x11 | psTdmaByte4Modify);
+			break;
+		case 103:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x3a, 0x3, 0x70,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 104:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x21, 0x3, 0x70,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 105:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x25, 0x3, 0x70,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 106:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x10, 0x3, 0x70,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 107:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x20, 0x3, 0x70,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 151:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x10, 0x03, 0x70,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 0:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		case 1:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x48, 0x0);
+			break;
+		default:
+			halbtc8822b2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8822b2ant_set_ext_band_switch(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 pos_type)
+{
+
+#if 0
+	boolean	switch_polatiry_inverse = false;
+	u8		regval_0xcb6;
+	u32		u32tmp1 = 0, u32tmp2 = 0;
+
+	if (!rfe_type->ext_band_switch_exist)
+		return;
+
+	coex_dm->cur_ext_band_switch_status = pos_type;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ext_band_switch_status ==
+		    coex_dm->cur_ext_band_switch_status)
+			return;
+	}
+
+	coex_dm->pre_ext_band_switch_status =
+		coex_dm->cur_ext_band_switch_status;
+
+	/* swap control polarity if use different switch control polarity*/
+	switch_polatiry_inverse = (rfe_type->ext_band_switch_ctrl_polarity == 1
+		   ? ~switch_polatiry_inverse : switch_polatiry_inverse);
+
+	/*swap control polarity for WL_A, default polarity 0xcb4[21] = 0 && 0xcb4[23] = 1 is for WL_G */
+	switch_polatiry_inverse = (pos_type ==
+		BT_8822B_2ANT_EXT_BAND_SWITCH_TO_WLA ? ~switch_polatiry_inverse
+				   : switch_polatiry_inverse);
+
+	regval_0xcb6 =  btcoexist->btc_read_1byte(btcoexist, 0xcb6);
+
+	/* for normal switch polrity, 0xcb4[21] =1 && 0xcb4[23] = 0 for WL_A, vice versa */
+	regval_0xcb6 = (switch_polatiry_inverse == 1 ? ((regval_0xcb6 & (~(BIT(
+		7)))) | BIT(5)) : ((regval_0xcb6 & (~(BIT(5)))) | BIT(7)));
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb6, 0xff,
+					   regval_0xcb6);
+
+	u32tmp1 = btcoexist->btc_read_4byte(btcoexist, 0xcb0);
+	u32tmp2 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (After Ext Band switch setup) 0xcb0 = 0x%08x, 0xcb4 = 0x%08x**********\n",
+		    u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+#endif
+
+}
+
+/*anttenna control by bb mac bt antdiv pta to write 0x4c 0xcb4,0xcbd*/
+void halbtc8822b2ant_set_ext_ant_switch(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u8 ctrl_type, IN u8 pos_type)
+{
+
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	boolean	switch_polatiry_inverse = false;
+	u8		regval_0xcbc = 0, regval_0x64;
+	u32		u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+
+	if (!rfe_type->ext_ant_switch_exist)
+		return;
+
+	coex_dm->cur_ext_ant_switch_status = (ctrl_type << 8)  + pos_type;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ext_ant_switch_status ==
+		    coex_dm->cur_ext_ant_switch_status)
+			return;
+}
+	coex_dm->pre_ext_ant_switch_status = coex_dm->cur_ext_ant_switch_status;
+	/*
+	switch (pos_type) {
+	default:
+	case BT_8822B_2ANT_EXT_ANT_SWITCH_MAIN_TO_BT:
+	case BT_8822B_2ANT_EXT_ANT_SWITCH_MAIN_TO_NOCARE:
+		break;
+	case BT_8822B_2ANT_EXT_ANT_SWITCH_MAIN_TO_WLG:
+		break;
+	case BT_8822B_2ANT_EXT_ANT_SWITCH_MAIN_TO_WLA:
+		break;
+	}
+*/
+	if (board_info->ant_div_cfg)
+		/*ctrl_type = BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_BY_ANTDIV;*/
+
+	/* Ext switch buffer mux */
+		btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x1991, 0x3, 0x0);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbe, 0x8, 0x0);
+
+
+	switch (ctrl_type) {
+	default:
+	case BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /*  0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x1);  /* 0x4c[24] = 1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb4,
+			0xff, 0x77);	/* BB SW, DPDT use RFE_ctrl8 and RFE_ctrl9 as conctrol pin */
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd,
+						   0x03, 01);
+
+		break;
+	case BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_BY_PTA:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /* 0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x1);  /* 0x4c[24] = 1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb4,
+			0xff, 0x66);	/* PTA,  DPDT use RFE_ctrl8 and RFE_ctrl9 as conctrol pin */
+
+		regval_0xcbc = (switch_polatiry_inverse == false ?
+			0x2 : 0x1);     /* 0xcb4[29:28] = 2b'10 for no switch_polatiry_inverse, DPDT_SEL_N =1, DPDT_SEL_P =0  @ GNT_BT=1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbc,
+						   0x03, regval_0xcbc);
+
+		break;
+	case BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_BY_ANTDIV:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /* 0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x1);/* 0x4c[24] = 1 */
+btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb4, 0xff, 0x88);
+break;
+	case BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_BY_MAC:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x1);  /*  0x4c[23] = 1 */
+
+		regval_0x64 = (switch_polatiry_inverse == false ?  0x0 :
+			0x1);     /* 0x64[0] = 1b'0 for no switch_polatiry_inverse, DPDT_SEL_N =1, DPDT_SEL_P =0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x64, 0x1,
+						   regval_0x64);
+		break;
+	case BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_BY_BT:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /* 0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x0);  /* 0x4c[24] = 0 */
+
+		/* no  setup required, because  antenna switch control value by BT vendor 0x1c[1:0] */
+		break;
+	}
+
+	/* PAPE, LNA_ON control by BT  while WLAN off for current leakage issue */
+	if (ctrl_type == BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_BY_BT) {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+					   0x0);  /* PAPE   0x64[29] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x10,
+					   0x0);  /* LNA_ON 0x64[28] = 0 */
+	} else {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+					   0x1);  /* PAPE   0x64[29] = 1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x10,
+					   0x1);  /* LNA_ON 0x64[28] = 1 */
+	}
+
+#if BT_8822B_2ANT_COEX_DBG
+
+	u32tmp1 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u32tmp2 = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0x64) & 0xff;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], (After Ext Ant switch setup) 0xcb4 = 0x%08x, 0x4c = 0x%08x, 0x64= 0x%02x\n",
+		    u32tmp1, u32tmp2, u32tmp3);
+	BTC_TRACE(trace_buf);
+#endif
+
+
+
+}
+/*rf4 type by efuse , and for ant at main aux inverse use , because is 2x2 ,and control types are the same ,does not need */
+void halbtc8822b2ant_set_rfe_type(IN struct btc_coexist *btcoexist)
+{
+
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+
+
+	rfe_type->ext_band_switch_exist = false;
+	rfe_type->ext_band_switch_type =
+		BT_8822B_2ANT_EXT_BAND_SWITCH_USE_SPDT;     /* SPDT; */
+	rfe_type->ext_band_switch_ctrl_polarity = 0;
+	/* Ext switch buffer mux */
+		btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x1991, 0x3, 0x0);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbe, 0x8, 0x0);
+
+	if (rfe_type->ext_band_switch_exist) {
+
+		/* band switch use RFE_ctrl1 (pin name: PAPE_A) and RFE_ctrl3 (pin name: LNAON_A) */
+
+		/* set RFE_ctrl1 as software control */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb0, 0xf0, 0x7);
+
+		/* set RFE_ctrl3 as software control */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb1, 0xf0, 0x7);
+
+	}
+
+
+	/* the following setup should be got from Efuse in the future */
+	rfe_type->rfe_module_type = board_info->rfe_type;
+
+	rfe_type->ext_ant_switch_ctrl_polarity = 0;
+
+	switch (rfe_type->rfe_module_type) {
+	case 0:
+	default:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type = BT_8822B_2ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 1:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type = BT_8822B_2ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 2:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type = BT_8822B_2ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 3:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type = BT_8822B_2ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 4:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type =
+	BT_8822B_2ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 5:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type = BT_8822B_2ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 6:
+		rfe_type->ext_ant_switch_exist = true;
+		rfe_type->ext_ant_switch_type = BT_8822B_2ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	case 7:
+		rfe_type->ext_ant_switch_exist = true;
+rfe_type->ext_ant_switch_type = BT_8822B_2ANT_EXT_ANT_SWITCH_USE_SPDT;
+		break;
+	}
+
+#if 0
+
+	if (rfe_type->wlg_Locate_at_btg)
+		halbtc8822b2ant_set_int_block(btcoexist, FORCE_EXEC,
+			      BT_8822B_2ANT_INT_BLOCK_SWITCH_TO_WLG_OF_BTG);
+	else
+		halbtc8822b2ant_set_int_block(btcoexist, FORCE_EXEC,
+			      BT_8822B_2ANT_INT_BLOCK_SWITCH_TO_WLG_OF_WLAG);
+#endif
+
+}
+
+/*set gnt_wl gnt_bt control by sw high low , or hwpta while in power on,ini,wlan off,wlan only ,wl2g non-currrent ,wl2g current,wl5g*/
+void halbtc8822b2ant_set_ant_path(IN struct btc_coexist *btcoexist,
+				  IN u8 ant_pos_type, IN boolean force_exec,
+				  IN u8 phase)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u32			cnt_bt_cal_chk = 0;
+	boolean			is_in_mp_mode = false;
+	u8			u8tmp = 0;
+	u32			u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+	u16			u16tmp1 = 0;
+	/* Ext switch buffer mux */
+		btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x1991, 0x3, 0x0);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbe, 0x8, 0x0);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /*  0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x1);  /* 0x4c[24] = 1 */
+
+	coex_dm->cur_ant_pos_type = (ant_pos_type << 8)  + phase;
+
+	if (!force_exec) {
+		if (coex_dm->cur_ant_pos_type == coex_dm->pre_ant_pos_type)
+			return;
+	}
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+
+#if BT_8822B_2ANT_COEX_DBG
+	u32tmp1 = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist,
+			0x38);
+	u32tmp2 = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist,
+			0x54);
+	u8tmp  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], (Before Ant Setup) 0xcb4 = 0x%x, 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x\n",
+		    u32tmp3, u8tmp, u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+#endif
+
+	switch (phase) {
+	case BT_8822B_2ANT_PHASE_COEX_POWERON:
+
+		/* set Path control owner to WL at initial step */
+		halbtc8822b2ant_ltecoex_pathcontrol_owner(btcoexist,
+				BT_8822B_2ANT_PCO_BTSIDE);
+
+		/* set GNT_BT to SW high */
+		halbtc8822b2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8822B_2ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW high */
+		halbtc8822b2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8822B_2ANT_SIG_STA_SET_TO_HIGH);
+
+		coex_sta->run_time_state = false;
+
+		break;
+	case BT_8822B_2ANT_PHASE_COEX_INIT:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /*  0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x1);  /* 0x4c[24] = 1 */
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8822b2ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8822b2ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8822B_2ANT_CTT_WL_VS_LTE,
+			0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8822b2ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8822B_2ANT_CTT_BT_VS_LTE,
+			0xffff);
+
+		/* set Path control owner to WL at initial step */
+		halbtc8822b2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8822B_2ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW high */
+		halbtc8822b2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8822B_2ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW high */
+		halbtc8822b2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8822B_2ANT_SIG_STA_SET_TO_HIGH);
+
+		coex_sta->run_time_state = false;
+
+		break;
+	case BT_8822B_2ANT_PHASE_WLANONLY_INIT:
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8822b2ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8822b2ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8822B_2ANT_CTT_WL_VS_LTE,
+			0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8822b2ant_ltecoex_set_coex_table(
+			btcoexist,
+			BT_8822B_2ANT_CTT_BT_VS_LTE,
+			0xffff);
+
+		/* set Path control owner to WL at initial step */
+		halbtc8822b2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8822B_2ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW Low */
+		halbtc8822b2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8822B_2ANT_SIG_STA_SET_TO_LOW);
+		/* Set GNT_WL to SW high */
+		halbtc8822b2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8822B_2ANT_SIG_STA_SET_TO_HIGH);
+
+		coex_sta->run_time_state = false;
+
+
+		break;
+	case BT_8822B_2ANT_PHASE_WLAN_OFF:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e,
+					   0x80, 0x0);  /* 0x4c[23] = 0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4f,
+					   0x01, 0x0);  /* 0x4c[24] = 0 */
+		/* Disable LTE Coex Function in WiFi side */
+		halbtc8822b2ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* set Path control owner to BT */
+		halbtc8822b2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8822B_2ANT_PCO_BTSIDE);
+
+		/* Set Ext Ant Switch to BT control at wifi off step */
+		halbtc8822b2ant_set_ext_ant_switch(btcoexist,
+						   FORCE_EXEC,
+				   BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_BY_BT,
+				   BT_8822B_2ANT_EXT_ANT_SWITCH_MAIN_TO_NOCARE);
+		coex_sta->run_time_state = false;
+		break;
+	case BT_8822B_2ANT_PHASE_2G_RUNTIME:
+	case BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT:
+
+		/* set Path control owner to WL at runtime step */
+		halbtc8822b2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8822B_2ANT_PCO_WLSIDE);
+
+		if (phase ==
+		    BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT) {
+			/* set GNT_BT to PTA */
+			halbtc8822b2ant_ltecoex_set_gnt_bt(
+				btcoexist,
+				BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+				BT_8822B_2ANT_GNT_TYPE_CTRL_BY_PTA,
+				BT_8822B_2ANT_SIG_STA_SET_BY_HW);
+
+			/* Set GNT_WL to SW High */
+			halbtc8822b2ant_ltecoex_set_gnt_wl(
+				btcoexist,
+				BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+				BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW,
+				BT_8822B_2ANT_SIG_STA_SET_TO_HIGH);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ************* under2g 0xcbd setting =2 *************\n");
+		BTC_TRACE(trace_buf);
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd,
+							   0x03, 02);
+		} else {
+			/* set GNT_BT to PTA */
+			halbtc8822b2ant_ltecoex_set_gnt_bt(
+				btcoexist,
+				BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+				BT_8822B_2ANT_GNT_TYPE_CTRL_BY_PTA,
+				BT_8822B_2ANT_SIG_STA_SET_BY_HW);
+
+			/* Set GNT_WL to PTA */
+			halbtc8822b2ant_ltecoex_set_gnt_wl(
+				btcoexist,
+				BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+				BT_8822B_2ANT_GNT_TYPE_CTRL_BY_PTA,
+				BT_8822B_2ANT_SIG_STA_SET_BY_HW);
+		}
+		coex_sta->run_time_state = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ************* under2g 0xcbd setting =2 *************\n");
+		BTC_TRACE(trace_buf);
+
+btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd, 0x03, 02);
+		break;
+	case BT_8822B_2ANT_PHASE_5G_RUNTIME:
+
+		/* set Path control owner to WL at runtime step */
+		halbtc8822b2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8822B_2ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW Hi */
+		halbtc8822b2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8822B_2ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW Hi */
+		halbtc8822b2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8822B_2ANT_SIG_STA_SET_TO_HIGH);
+		coex_sta->run_time_state = true;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ************* under5g 0xcbd setting =1 *************\n");
+		BTC_TRACE(trace_buf);
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcbd,
+							   0x03, 01);
+
+		break;
+	case BT_8822B_2ANT_PHASE_BTMPMODE:
+		/* Disable LTE Coex Function in WiFi side */
+		halbtc8822b2ant_ltecoex_enable(btcoexist, 0x0);
+
+		/* set Path control owner to WL */
+		halbtc8822b2ant_ltecoex_pathcontrol_owner(
+			btcoexist,
+			BT_8822B_2ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW Hi */
+		halbtc8822b2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8822B_2ANT_SIG_STA_SET_TO_HIGH);
+
+		/* Set GNT_WL to SW Lo */
+		halbtc8822b2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8822B_2ANT_SIG_STA_SET_TO_LOW);
+
+coex_sta->run_time_state = false;
+		break;
+	}
+#if BT_8822B_2ANT_COEX_DBG
+	u32tmp1 = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u8tmp  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], (After Ant-Setup phase---%d) 0xcb4 = 0x%x, 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x\n",
+		    phase, u32tmp3, u8tmp, u32tmp1, u32tmp2);
+
+	BTC_TRACE(trace_buf);
+#endif
+
+}
+
+
+u8 halbtc8822b2ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8822B_2ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 0) {
+
+		if (bt_link_info->acl_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], No-Profile busy\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8822B_2ANT_COEX_ALGO_NOPROFILEBUSY;
+		}
+	} else if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8822B_2ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8822B_2ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8822B_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8822B_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + A2DP ==> A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8822B_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8822B_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				{
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8822B_2ANT_COEX_ALGO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], SCO + HID + A2DP ==> HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8822B_2ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_PANEDR_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_PANEDR_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8822B_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+
+
+void halbtc8822b2ant_action_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+	/* fw all off */
+	halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+	halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+}
+
+void halbtc8822b2ant_action_wifi_under5g(IN struct btc_coexist *btcoexist)
+{
+
+	/* fw all off */
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ************* under5g *************\n");
+	BTC_TRACE(trace_buf);
+	halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+				     BT_8822B_2ANT_PHASE_5G_RUNTIME);
+}
+
+
+void halbtc8822b2ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+
+	boolean	wifi_connected = false;
+	boolean		scan = false, link = false, roam = false;
+	boolean			wifi_busy = false;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+	if (link || roam || coex_sta->wifi_is_high_pri_task) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi link/roam/hi-pri-task process + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     8);
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 11);
+
+	} else if (scan) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi scan process + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     8);
+
+		if (coex_sta->bt_create_connection)
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						12);
+		else
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						11);
+
+	}  else if (wifi_connected) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     8);
+
+		if (wifi_busy) {
+
+			if ((bt_link_info->a2dp_exist) &&
+			    (bt_link_info->acl_busy))
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 13);
+			else
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 11);
+
+		} else
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						13);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi no-link + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}
+
+	halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 0xd8);
+	halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8822b2ant_action_wifi_link_process(IN struct btc_coexist *btcoexist)
+{
+	u32	u32tmp, u32tmpb;
+	u8	u8tmpa;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 0xd8);
+	halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+
+	if ((bt_link_info->a2dp_exist) && (bt_link_info->acl_busy))
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+	else
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 11);
+
+}
+
+
+void halbtc8822b2ant_action_wifi_nonconnected(IN struct btc_coexist *btcoexist)
+{
+	halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+	/* fw all off */
+	halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+	halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8822b2ant_action_bt_idle(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+
+	boolean	wifi_connected = false;
+	boolean		scan = false, link = false, roam = false;
+	boolean			wifi_busy = false;
+
+	wifi_rssi_state = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+	if (scan || link || roam) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi link process + BT Idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     7);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 11);
+	} else if (wifi_connected) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT Idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		if (wifi_busy) {
+			halbtc8822b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+			halbtc8822b2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+			/*
+						if (!BTC_RSSI_HIGH(bt_rssi_state2))
+							halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+						else {
+							halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+							halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+						      BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+						}
+			*/
+		} else {
+			halbtc8822b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+			halbtc8822b2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+		}
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi no-link + BT Idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}
+
+	halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 0xd8);
+	halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+}
+
+
+/* SCO only or SCO+PAN(HS) */
+void halbtc8822b2ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean			wifi_busy = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}  else {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}
+
+}
+
+
+void halbtc8822b2ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean			wifi_busy = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}  else {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+/*
+		halbtc8822b2ant_coex_table_with_type(btcoexist,
+										 NORMAL_EXEC, 0);
+					halbtc8822b2ant_set_ant_path(btcoexist,
+								 BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+							 BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+*/
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+
+/*
+	halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 10);
+*/
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}
+
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8822b2ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "############# [BTCoex],  scan_ap_num = %d\n",
+		    coex_sta->scan_ap_num);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->scan_ap_num <= 4))
+		wifi_turbo = true;
+#endif
+
+	wifi_rssi_state = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy) {
+			if (coex_sta->is_setupLink)
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 51);
+			else {
+				halbtc8822b2ant_coex_table_with_type(btcoexist,
+						NORMAL_EXEC, 12);
+				halbtc8822b2ant_set_ant_path(btcoexist,
+						BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+						BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						true, 1);
+			}
+		} else
+
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						2);
+	} else {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (wifi_turbo)
+			halbtc8822b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+		else
+			halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+							     7);
+
+		if (wifi_busy) {
+			if (coex_sta->is_setupLink)
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 151);
+			else
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 101);
+		} else
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						102);
+
+	}
+
+}
+
+void halbtc8822b2ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "############# [BTCoex],  scan_ap_num = %d\n",
+		    coex_sta->scan_ap_num);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->scan_ap_num <= 4))
+		wifi_turbo = true;
+#endif
+
+	wifi_rssi_state = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+#if 0
+	halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	coex_dm->is_switch_to_1dot5_ant = false;
+
+	halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+	halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+#endif
+
+
+#if 1
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy) {
+			halbtc8822b2ant_coex_table_with_type(btcoexist,
+					NORMAL_EXEC, 0);
+			halbtc8822b2ant_set_ant_path(btcoexist,
+					BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+					BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						3);
+		} else
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						4);
+	} else {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (wifi_turbo)
+			halbtc8822b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+		else
+			halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+							     7);
+
+		if (wifi_busy)
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						103);
+		else
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						104);
+
+	}
+
+#endif
+
+}
+
+
+/* PAN(HS) only */
+void halbtc8822b2ant_action_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "############# [BTCoex],  scan_ap_num = %d\n",
+		    coex_sta->scan_ap_num);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->scan_ap_num <= 4))
+		wifi_turbo = true;
+#endif
+
+
+	wifi_rssi_state = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+
+	} else {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	}
+
+}
+
+
+void halbtc8822b2ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean			wifi_busy = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+
+
+
+		if (wifi_busy) {
+			if (coex_sta->is_setupLink)
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 51);
+			else
+				halbtc8822b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 12);
+			halbtc8822b2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+			/*
+							halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 1);
+			*/
+		} else
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						2);
+
+
+	} else {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if ((wifi_busy) && (coex_sta->hid_busy_num >= 2))
+			halbtc8822b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+		else
+			/*
+			halbtc8822b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 9);
+							     */
+			halbtc8822b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+
+		if (wifi_busy) {
+			if (coex_sta->is_setupLink)
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 151);
+			else
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 101);
+		} else
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						102);
+
+	}
+
+}
+
+
+void halbtc8822b2ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "############# [BTCoex],  scan_ap_num = %d\n",
+		    coex_sta->scan_ap_num);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->scan_ap_num <= 4))
+		wifi_turbo = true;
+#endif
+
+
+	wifi_rssi_state = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy) {
+
+			if ((coex_sta->a2dp_bit_pool > 40) &&
+			    (coex_sta->a2dp_bit_pool < 255))
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 7);
+			else
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 5);
+		} else
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						6);
+
+	} else {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (wifi_turbo)
+			halbtc8822b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+		else
+			halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+							     7);
+
+		if (wifi_busy) {
+
+			if ((coex_sta->a2dp_bit_pool > 40) &&
+			    (coex_sta->a2dp_bit_pool < 255))
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 107);
+			else
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 105);
+		} else
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						106);
+
+	}
+
+}
+
+
+
+/* PAN(EDR)+A2DP */
+void halbtc8822b2ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean	wifi_busy = false, wifi_turbo = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+			   &coex_sta->scan_ap_num);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "############# [BTCoex],  scan_ap_num = %d\n",
+		    coex_sta->scan_ap_num);
+	BTC_TRACE(trace_buf);
+
+#if 1
+	if ((wifi_busy) && (coex_sta->scan_ap_num <= 4))
+		wifi_turbo = true;
+#endif
+
+
+	wifi_rssi_state = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy) {
+
+			if (((coex_sta->a2dp_bit_pool > 40) &&
+			     (coex_sta->a2dp_bit_pool < 255)) ||
+			    (!coex_sta->is_A2DP_3M))
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 7);
+			else
+				halbtc8822b2ant_coex_table_with_type(btcoexist,
+											 NORMAL_EXEC, 0);
+			halbtc8822b2ant_set_ant_path(btcoexist,
+						BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+						BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 5);
+		} else
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						6);
+	} else {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		if (wifi_turbo)
+			halbtc8822b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 6);
+		else
+			halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+							     7);
+
+		if (wifi_busy) {
+
+			if ((coex_sta->a2dp_bit_pool > 40) &&
+			    (coex_sta->a2dp_bit_pool < 255))
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 107);
+			else
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 105);
+		} else
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						106);
+
+	}
+
+}
+
+void halbtc8822b2ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean			wifi_busy = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy)
+
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						3);
+		else
+
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						4);
+
+
+	} else {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+
+		if (wifi_busy)
+
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						103);
+		else
+
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						104);
+
+	}
+
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8822b2ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, bt_rssi_state;
+
+	static u8	prewifi_rssi_state2 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state2 = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state2, bt_rssi_state2;
+	boolean			wifi_busy = false;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	wifi_rssi_state = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2,
+			  coex_sta->wifi_coex_thres , 0);
+
+	wifi_rssi_state2 = halbtc8822b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state2, 2,
+			   coex_sta->wifi_coex_thres2 , 0);
+
+	bt_rssi_state = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			coex_sta->bt_coex_thres , 0);
+
+	bt_rssi_state2 = halbtc8822b2ant_bt_rssi_state(&pre_bt_rssi_state2, 2,
+			 coex_sta->bt_coex_thres2 , 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+		halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+	} else if (BTC_RSSI_HIGH(wifi_rssi_state2) &&
+		   BTC_RSSI_HIGH(bt_rssi_state2)) {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+		if (wifi_busy) {
+
+			if (((coex_sta->a2dp_bit_pool > 40) &&
+			     (coex_sta->a2dp_bit_pool < 255)) ||
+			    (!coex_sta->is_A2DP_3M))
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 7);
+			else
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 5);
+		} else
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						6);
+	} else {
+
+		halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+		halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		coex_dm->is_switch_to_1dot5_ant = true;
+
+		halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+
+		if (wifi_busy) {
+
+			if ((coex_sta->a2dp_bit_pool > 40) &&
+			    (coex_sta->a2dp_bit_pool < 255))
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 107);
+			else
+				halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 105);
+		} else
+			halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						106);
+	}
+
+}
+
+
+
+void halbtc8822b2ant_action_bt_whck_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+	halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+}
+
+void halbtc8822b2ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* hw all off */
+	halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+	halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+}
+
+void halbtc8822b2ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8				algorithm = 0;
+	u32				num_of_wifi_link = 0;
+	u32				wifi_link_status = 0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean				miracast_plus_bt = false;
+	boolean				scan = false, link = false, roam = false,
+				wifi_connected = false, wifi_under_5g = false;
+
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (!coex_sta->run_time_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], return for run_time_state = false !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->freeze_coexrun_by_btinfo) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), return for freeze_coexrun_by_btinfo\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (wifi_under_5g) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under 5G!!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_action_wifi_under5g(btcoexist);
+		return;
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], WiFi is under 2G!!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+				     NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME);
+
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8822b2ant_action_bt_whck_test(btcoexist);
+		return;
+	}
+
+	if (coex_sta->bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is disabled!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8822b2ant_action_coex_all_off(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8822b2ant_action_bt_inquiry(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+	if (scan || link || roam) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under Link Process !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8822b2ant_action_wifi_link_process(btcoexist);
+		return;
+	}
+
+	/* for P2P */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist)
+			miracast_plus_bt = true;
+		else
+			miracast_plus_bt = false;
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+		halbtc8822b2ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	}
+
+	miracast_plus_bt = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+			   &miracast_plus_bt);
+
+
+	algorithm = halbtc8822b2ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Algorithm = %d\n",
+		    coex_dm->cur_algorithm);
+	BTC_TRACE(trace_buf);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	if (!wifi_connected) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, wifi non-connected!!.\n");
+		BTC_TRACE(trace_buf);
+		halbtc8822b2ant_action_wifi_nonconnected(btcoexist);
+
+	} else if ((BT_8822B_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status) ||
+		   (BT_8822B_2ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant, bt idle!!.\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_action_bt_idle(btcoexist);
+
+	} else {
+
+		if (coex_dm->cur_algorithm != coex_dm->pre_algorithm) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], pre_algorithm=%d, cur_algorithm=%d\n",
+				coex_dm->pre_algorithm, coex_dm->cur_algorithm);
+			BTC_TRACE(trace_buf);
+		}
+
+		switch (coex_dm->cur_algorithm) {
+
+		case BT_8822B_2ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b2ant_action_sco(btcoexist);
+			break;
+		case BT_8822B_2ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b2ant_action_hid(btcoexist);
+			break;
+		case BT_8822B_2ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b2ant_action_a2dp(btcoexist);
+			break;
+		case BT_8822B_2ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b2ant_action_a2dp_pan_hs(btcoexist);
+			break;
+		case BT_8822B_2ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b2ant_action_pan_edr(btcoexist);
+			break;
+		case BT_8822B_2ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b2ant_action_pan_hs(btcoexist);
+			break;
+		case BT_8822B_2ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b2ant_action_pan_edr_a2dp(btcoexist);
+			break;
+		case BT_8822B_2ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b2ant_action_pan_edr_hid(btcoexist);
+			break;
+		case BT_8822B_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b2ant_action_hid_a2dp_pan_edr(
+				btcoexist);
+			break;
+		case BT_8822B_2ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b2ant_action_hid_a2dp(btcoexist);
+			break;
+		case BT_8822B_2ANT_COEX_ALGO_NOPROFILEBUSY:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = No-Profile busy.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b2ant_action_bt_idle(btcoexist);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8822b2ant_action_coex_all_off(btcoexist);
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8822b2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8822b2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, false);
+
+	halbtc8822b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, NORMAL_EXEC,
+				     BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT);
+
+	/* fw all off */
+	halbtc8822b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+	halbtc8822b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xd8);
+	halbtc8822b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	coex_sta->pop_event_cnt = 0;
+	coex_sta->cnt_RemoteNameReq = 0;
+	coex_sta->cnt_ReInit = 0;
+	coex_sta->cnt_setupLink = 0;
+	coex_sta->cnt_IgnWlanAct = 0;
+	coex_sta->cnt_Page = 0;
+
+	halbtc8822b2ant_query_bt_info(btcoexist);
+}
+
+
+void halbtc8822b2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean wifi_only)
+{
+	u8	u8tmp = 0;
+	u32	 vendor;
+	u32				u32tmp0 = 0, u32tmp1 = 0, u32tmp2 = 0, u32tmp3 = 0;
+	u32	RTL97F_8822B = 0;
+
+
+	u32tmp3 = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u32tmp1 = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp2 = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+
+	if (RTL97F_8822B == true) {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x66, 0x04, 0x0);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x41, 0x02, 0x0);
+
+		/* set GNT_BT to SW high */
+		halbtc8822b2ant_ltecoex_set_gnt_bt(btcoexist,
+					   BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8822B_2ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW high */
+		halbtc8822b2ant_ltecoex_set_gnt_wl(btcoexist,
+					   BT_8822B_2ANT_GNT_BLOCK_RFC_BB,
+					   BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8822B_2ANT_SIG_STA_SET_TO_HIGH);
+		 return;
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], (Before Init HW config) 0xcb4 = 0x%x, 0x38= 0x%x, 0x54= 0x%x\n",
+		    u32tmp3, u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 2Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	coex_sta->bt_coex_supported_feature = 0;
+	coex_sta->bt_coex_supported_version = 0;
+	coex_sta->bt_ble_scan_type = 0;
+	coex_sta->bt_ble_scan_para[0] = 0;
+	coex_sta->bt_ble_scan_para[1] = 0;
+	coex_sta->bt_ble_scan_para[2] = 0;
+	coex_sta->bt_reg_vendor_ac = 0xffff;
+	coex_sta->bt_reg_vendor_ae = 0xffff;
+	coex_sta->isolation_btween_wb = BT_8822B_2ANT_DEFAULT_ISOLATION;
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	coex_sta->dis_ver_info_cnt = 0;
+
+	halbtc8822b2ant_coex_switch_threshold(btcoexist,
+					      coex_sta->isolation_btween_wb);
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+
+	/* BT report packet sample rate	 */
+	btcoexist->btc_write_1byte(btcoexist, 0x790, 0x5);
+
+	/* Init 0x778 = 0x1 for 2-Ant */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+
+	/* Enable PTA (3-wire function form BT side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x41, 0x02, 0x1);
+
+	/* Enable PTA (tx/rx signal form WiFi side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4c6, 0x10, 0x1);
+
+	halbtc8822b2ant_enable_gnt_to_gpio(btcoexist, true);
+
+	/*GNT_BT=1 while select both */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x763, 0x10, 0x1);
+
+
+	/* check if WL firmware download ok */
+	/*if (btcoexist->btc_read_1byte(btcoexist, 0x80) == 0xc6)*/
+	halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ONOFF, true);
+
+	/* Enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e,
+			   0x4); /* 0x76e[3] =1, WLAN_Act control by PTA */
+
+	/* WLAN_Tx by GNT_WL  0x950[29] = 0 */
+	/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x953, 0x20, 0x0); */
+
+	halbtc8822b2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8822b2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+
+	psd_scan->ant_det_is_ant_det_available = true;
+
+	if (wifi_only) {
+		coex_sta->concurrent_rx_mode_on = false;
+		/* Path config	 */
+		/* Set Antenna Path */
+		halbtc8822b2ant_set_ant_path(btcoexist,	BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8822B_2ANT_PHASE_WLANONLY_INIT);
+
+		btcoexist->stop_coex_dm = true;
+	} else {
+		/*Set BT polluted packet on for Tx rate adaptive not including Tx retry break by PTA, 0x45c[19] =1 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x45e, 0x8, 0x1);
+
+		coex_sta->concurrent_rx_mode_on = true;
+		/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x953, 0x2, 0x1); */
+
+		/* RF 0x1[1] = 0->Set GNT_WL_RF_Rx always = 1 for con-current Rx, mask Tx only */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0x2, 0x0);
+
+		/* Set Antenna Path */
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8822B_2ANT_PHASE_COEX_INIT);
+
+		btcoexist->stop_coex_dm = false;
+	}
+}
+
+
+
+/* ************************************************************
+ * work around function start with wa_halbtc8822b2ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8822b2ant_
+ * ************************************************************ */
+void ex_halbtc8822b2ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x0;
+	u16 u16tmp = 0x0;
+	u32	value = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"xxxxxxxxxxxxxxxx Execute 8822b 2-Ant PowerOn Setting xxxxxxxxxxxxxxxx!!\n");
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "Ant Det Finish = %s, Ant Det Number  = %d\n",
+		    (board_info->btdm_ant_det_finish ? "Yes" : "No"),
+		    board_info->btdm_ant_num_by_ant_det);
+	BTC_TRACE(trace_buf);
+
+
+	btcoexist->stop_coex_dm = true;
+	psd_scan->ant_det_is_ant_det_available = false;
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write BB Register correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+
+	/* Check efuse 0xc3[6] for Single Antenna Path */
+	if (board_info->single_ant_path == 0) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], **********  Single Antenna, Antenna at Aux Port\n");
+		BTC_TRACE(trace_buf);
+
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+
+		u8tmp = 7;
+	} else if (board_info->single_ant_path == 1) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], **********  Single Antenna, Antenna at Main Port\n");
+		BTC_TRACE(trace_buf);
+
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+
+		u8tmp = 6;
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (Power On) single_ant_path  = %d, btdm_ant_pos = %d\n",
+		    board_info->single_ant_path , board_info->btdm_ant_pos);
+	BTC_TRACE(trace_buf);
+
+	/* Setup RF front end type */
+	halbtc8822b2ant_set_rfe_type(btcoexist);
+
+	/* Set Antenna Path to BT side */
+	halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+				     BT_8822B_2ANT_PHASE_COEX_POWERON);
+
+	/* Save"single antenna position" info in Local register setting for FW reading, because FW may not ready at  power on */
+	if (btcoexist->chip_interface == BTC_INTF_PCI)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x3e0, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_USB)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60, u8tmp);
+
+	/* enable GNT_WL/GNT_BT debug signal to GPIO14/15 */
+	halbtc8822b2ant_enable_gnt_to_gpio(btcoexist, true);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********  LTE coex Reg 0x38 (Power-On) = 0x%x**********\n",
+		    halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist, 0x38));
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********  MAC Reg 0x70/ BB Reg 0xcb4 (Power-On) = 0x%x / 0x%x\n",
+		    btcoexist->btc_read_4byte(btcoexist, 0x70),
+		    btcoexist->btc_read_4byte(btcoexist, 0xcb4));
+	BTC_TRACE(trace_buf);
+
+}
+
+void ex_halbtc8822b2ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x4; /* Set BIT2 by default since it's 2ant case */
+
+	/* */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+	if (btcoexist->chip_interface == BTC_INTF_USB) {
+		/* fixed at S0 for USB interface */
+		u8tmp |= 0x1;	/* antenna inverse */
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	} else {
+		/* for PCIE and SDIO interface, we check efuse 0xc3[6] */
+		if (board_info->single_ant_path == 0) {
+		} else if (board_info->single_ant_path == 1) {
+			/* set to S0 */
+			u8tmp |= 0x1;	/* antenna inverse */
+		}
+
+		if (btcoexist->chip_interface == BTC_INTF_PCI)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x3e0,
+							     u8tmp);
+		else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60,
+							     u8tmp);
+	}
+}
+
+
+void ex_halbtc8822b2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8822b2ant_init_hw_config(btcoexist, wifi_only);
+}
+
+void ex_halbtc8822b2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8822b2ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8822b2ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, ps_tdma_case = 0;
+	u32				u32tmp[4];
+	u16				u16tmp[4];
+	u32				fa_ofdm, fa_cck, cca_ofdm, cca_cck;
+	u32				fw_ver = 0, bt_patch_ver = 0, bt_coex_ver = 0;
+	static u8			pop_report_in_10s = 0;
+	u32			phyver = 0;
+	boolean			lte_coex_on = false;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	if (psd_scan->ant_det_try_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %s / %d",
+			   "Ant PG Num/ Mech/ Pos/ RFE",
+			   board_info->pg_ant_num, board_info->btdm_ant_num,
+			   (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT
+			    ? "Main" : "Aux"),
+			   rfe_type->rfe_module_type);
+		CL_PRINTF(cli_buf);
+	} else {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %s/ %d  (%d/%d/%d)",
+			   "Ant PG Num/ Mech(Ant_Det)/ Pos/ RFE",
+			   board_info->pg_ant_num,
+			   board_info->btdm_ant_num_by_ant_det,
+			   (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT
+			    ? "Main" : "Aux"),
+			   rfe_type->rfe_module_type,
+			   psd_scan->ant_det_try_count,
+			   psd_scan->ant_det_fail_count,
+			   psd_scan->ant_det_result);
+		CL_PRINTF(cli_buf);
+
+
+		if (board_info->btdm_ant_det_finish) {
+
+			if (psd_scan->ant_det_result != 12)
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+					   "Ant Det PSD Value",
+					   psd_scan->ant_det_peak_val);
+			else
+				CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+					   "\r\n %-35s = %d",
+					   "Ant Det PSD Value",
+					   psd_scan->ant_det_psd_scan_peak_val
+					   / 100);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+
+	/*bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;*/
+	bt_patch_ver = btcoexist->bt_info.bt_get_fw_ver;
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	phyver = btcoexist->btc_get_bt_phydm_version(btcoexist);
+
+	bt_coex_ver = (coex_sta->bt_coex_supported_version & 0xff);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%02x/ 0x%02x/ 0x%02x (%s)",
+		   "CoexVer WL/  BT_Desired/ BT_Report",
+		   glcoex_ver_date_8822b_2ant, glcoex_ver_8822b_2ant,
+		   glcoex_ver_btdesired_8822b_2ant,
+		   bt_coex_ver,
+		   (bt_coex_ver == 0xff ? "Unknown" :
+		    (bt_coex_ver >= glcoex_ver_btdesired_8822b_2ant ?
+		     "Match" : "Mis-Match")));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ v%d/ %c",
+		   "W_FW/ B_FW/ Phy/ Kt",
+		   fw_ver, bt_patch_ver, phyver,
+		   coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "AFH Map to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d ",
+		   "Isolation/WL_Thres/BT_Thres",
+		   coex_sta->isolation_btween_wb,
+		   coex_sta->wifi_coex_thres,
+		   coex_sta->bt_coex_thres);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	pop_report_in_10s++;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = [%s/ %d dBm/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt/ popCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+			   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page")
+			   : ((BT_8822B_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8822B_2ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi - 100, coex_sta->bt_retry_cnt,
+		   coex_sta->pop_event_cnt);
+	CL_PRINTF(cli_buf);
+
+	if (pop_report_in_10s >= 5) {
+		coex_sta->pop_event_cnt = 0;
+		pop_report_in_10s = 0;
+	}
+
+
+	if (coex_sta->num_of_profile != 0)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %s%s%s%s%s",
+			   "Profiles",
+			   ((bt_link_info->a2dp_exist) ? "A2DP," : ""),
+			   ((bt_link_info->sco_exist) ?  "SCO," : ""),
+			   ((bt_link_info->hid_exist) ?
+			    ((coex_sta->hid_busy_num >= 2) ? "HID(4/18)," :
+			     "HID(2/18),") : ""),
+			   ((bt_link_info->pan_exist) ?  "PAN," : ""),
+			   ((coex_sta->voice_over_HOGP) ? "Voice" : ""));
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = None", "Profiles");
+
+	CL_PRINTF(cli_buf);
+
+
+	if (bt_link_info->a2dp_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %d/ %s",
+			   "A2DP Rate/Bitpool/Auto_Slot",
+			   ((coex_sta->is_A2DP_3M) ? "3M" : "No_3M"),
+			   coex_sta->a2dp_bit_pool,
+			   ((coex_sta->is_autoslot) ? "On" : "Off")
+			   );
+		CL_PRINTF(cli_buf);
+	}
+
+	if (bt_link_info->hid_exist) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+			   "HID PairNum/Forbid_Slot",
+			   coex_sta->hid_pair_cnt,
+			   coex_sta->forbidden_slot
+			  );
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ 0x%x",
+		   "Role/IgnWlanAct/Feature",
+		   ((bt_link_info->slave_role) ? "Slave" : "Master"),
+		   ((coex_dm->cur_ignore_wlan_act) ? "Yes" : "No"),
+		   coex_sta->bt_coex_supported_feature);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d",
+		   "ReInit/ReLink/IgnWlact/Page/NameReq",
+		   coex_sta->cnt_ReInit,
+		   coex_sta->cnt_setupLink,
+		   coex_sta->cnt_IgnWlanAct,
+		   coex_sta->cnt_Page,
+		   coex_sta->cnt_RemoteNameReq
+		  );
+	CL_PRINTF(cli_buf);
+
+	halbtc8822b2ant_read_score_board(btcoexist,	&u16tmp[0]);
+
+	if ((coex_sta->bt_reg_vendor_ae == 0xffff) ||
+	    (coex_sta->bt_reg_vendor_ac == 0xffff))
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = x/ x/ %04x",
+			   "0xae[4]/0xac[1:0]/Scoreboard", u16tmp[0]);
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = 0x%x/ 0x%x/ %04x",
+			   "0xae[4]/0xac[1:0]/Scoreboard",
+			   ((coex_sta->bt_reg_vendor_ae & BIT(4)) >> 4),
+			   coex_sta->bt_reg_vendor_ac & 0x3, u16tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8822B_2ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8822b_2ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	/* Sw mechanism	 */
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[mechanism] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[Mechanism]============");
+
+	CL_PRINTF(cli_buf);
+
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x (case-%d, %s, %s)",
+		   "TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   (coex_dm->cur_ps_tdma_on ? "TDMA On" : "TDMA Off"),
+		   (coex_dm->is_switch_to_1dot5_ant ? "1.5Ant" : "2Ant"));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d/ 0x%x/ 0x%x/ 0x%x",
+		   "Table/0x6c0/0x6c4/0x6c8",
+		   coex_sta->coex_table_type, u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x778/0x6cc",
+		   u8tmp[0], u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s",
+		   "AntDiv/ForceLPS/LPRA",
+		   ((board_info->ant_div_cfg) ? "On" : "Off"),
+		   ((coex_sta->force_lps_on) ? "On" : "Off"),
+		   ((coex_dm->cur_low_penalty_ra) ? "On" : "Off"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "WL_DACSwing/ BT_Dec_Pwr", coex_dm->cur_fw_dac_swing_lvl,
+		   coex_dm->cur_bt_dec_pwr_lvl);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	lte_coex_on = ((u32tmp[0] & BIT(7)) >> 7) ?  true : false;
+
+	if (lte_coex_on) {
+
+		u32tmp[0] = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa0);
+		u32tmp[1] = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa4);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+			   "LTE Coex Table W_L/B_L",
+			   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff);
+		CL_PRINTF(cli_buf);
+
+
+		u32tmp[0] = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xa8);
+		u32tmp[1] = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xac);
+		u32tmp[2] = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xb0);
+		u32tmp[3] = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist,
+				0xb4);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+			   "LTE Break Table W_L/B_L/L_W/L_B",
+			   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff,
+			   u32tmp[2] & 0xffff, u32tmp[3] & 0xffff);
+		CL_PRINTF(cli_buf);
+
+	}
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+	/*
+		u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+		u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+		u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+		u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+			   "0x430/0x434/0x42a/0x456",
+			   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+		CL_PRINTF(cli_buf);
+	*/
+	u32tmp[0] = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist, 0x38);
+	u32tmp[1] = halbtc8822b2ant_ltecoex_indirect_read_reg(btcoexist, 0x54);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s",
+		   "LTE Coex/Path Owner",
+		   ((lte_coex_on) ? "On" : "Off") ,
+		   ((u8tmp[0] & BIT(2)) ? "WL" : "BT"));
+	CL_PRINTF(cli_buf);
+
+	if (lte_coex_on) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+			   "LTE 3Wire/OPMode/UART/UARTMode",
+			   (int)((u32tmp[0] & BIT(6)) >> 6),
+			   (int)((u32tmp[0] & (BIT(5) | BIT(4))) >> 4),
+			   (int)((u32tmp[0] & BIT(3)) >> 3),
+			   (int)(u32tmp[0] & (BIT(2) | BIT(1) | BIT(0))));
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+			   "LTE_Busy/UART_Busy",
+			(int)((u32tmp[1] & BIT(1)) >> 1), (int)(u32tmp[1] & BIT(0)));
+		CL_PRINTF(cli_buf);
+	}
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %s (BB:%s)/ %s (BB:%s)/ %s",
+		   "GNT_WL_Ctrl/GNT_BT_Ctrl/Dbg",
+		   ((u32tmp[0] & BIT(12)) ? "SW" : "HW"),
+		   ((u32tmp[0] & BIT(8)) ?  "SW" : "HW"),
+		   ((u32tmp[0] & BIT(14)) ? "SW" : "HW"),
+		   ((u32tmp[0] & BIT(10)) ?  "SW" : "HW"),
+		   ((u8tmp[0] & BIT(3)) ? "On" : "Off"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "GNT_WL/GNT_BT",
+		   (int)((u32tmp[1] & BIT(2)) >> 2),
+		   (int)((u32tmp[1] & BIT(3)) >> 3));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xcb0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xcbd);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%04x/ 0x%04x/ 0x%x",
+		   "0xcb0/0xcb4/0xcbd",
+		   u32tmp[0], u32tmp[1], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0x64);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x4c6);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x4c[24:23]/0x64[0]/x4c6[4]/0x40[5]",
+		   (u32tmp[0] & (BIT(24) | BIT(23))) >> 23 , u8tmp[2] & 0x1 ,
+		   (int)((u8tmp[0] & BIT(4)) >> 4),
+		   (int)((u8tmp[1] & BIT(5)) >> 5));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x953);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0xc50);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ %s/ 0x%x",
+		   "0x550/0x522/4-RxAGC/0xc50",
+		u32tmp[0], u8tmp[0], (u8tmp[1] & 0x2) ? "On" : "Off", u8tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	fa_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_OFDM);
+	fa_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_FA_CCK);
+	cca_ofdm = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_OFDM);
+	cca_cck = btcoexist->btc_phydm_query_PHY_counter(btcoexist,
+			PHYDM_INFO_CCA_CCK);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA",
+		   cca_cck, fa_cck, cca_ofdm, fa_ofdm);
+	CL_PRINTF(cli_buf);
+
+#if 1
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11ac",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_vht);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11ac",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_vht);
+	CL_PRINTF(cli_buf);
+#endif
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(Hi-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(Lo-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8822b2ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+		coex_sta->under_lps = false;
+
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+				 BT_8822B_2ANT_SCOREBOARD_ACTIVE, false);
+
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+				 BT_8822B_2ANT_SCOREBOARD_ONOFF, false);
+
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8822B_2ANT_PHASE_WLAN_OFF);
+
+		halbtc8822b2ant_action_coex_all_off(btcoexist);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+				 BT_8822B_2ANT_SCOREBOARD_ONOFF, true);
+		halbtc8822b2ant_init_hw_config(btcoexist, false);
+		halbtc8822b2ant_init_coex_dm(btcoexist);
+		halbtc8822b2ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8822b2ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+		coex_sta->under_ips = false;
+
+		if (coex_sta->force_lps_on == true) { /* LPS No-32K */
+			/* Write WL "Active" in Score-board for PS-TDMA */
+			halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ACTIVE, true);
+
+		} else { /* LPS-32K, need check if this h2c 0x71 can work?? (2015/08/28) */
+			/* Write WL "Non-Active" in Score-board for Native-PS */
+			halbtc8822b2ant_post_state_to_bt(btcoexist,
+				 BT_8822B_2ANT_SCOREBOARD_ACTIVE, false);
+		}
+
+
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ACTIVE, true);
+	}
+}
+
+void ex_halbtc8822b2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean	wifi_connected = false;
+	boolean wifi_under_5g = false;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], SCAN notify()\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ACTIVE, true);
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	/*  this can't be removed for RF off_on event, or BT would dis-connect */
+	halbtc8822b2ant_query_bt_info(btcoexist);
+
+	if (BTC_SCAN_START == type) {
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G,
+				   &wifi_under_5g);
+
+		if (wifi_under_5g) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** SCAN START notify (5g)\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8822b2ant_action_wifi_under5g(btcoexist);
+			return;
+		}
+
+		coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** SCAN START notify (2g)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_run_coexist_mechanism(
+			btcoexist);
+
+		return;
+	}
+
+
+	if (BTC_SCAN_START_2G == type) {
+
+		if (!wifi_connected)
+			coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify (2G)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_SCAN, true);
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ACTIVE, true);
+
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8822B_2ANT_PHASE_2G_RUNTIME);
+
+		halbtc8822b2ant_run_coexist_mechanism(btcoexist);
+
+	} else if (BTC_SCAN_FINISH == type) {
+
+		coex_sta->wifi_is_high_pri_task = false;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify  (Scan-AP = %d)\n",
+			    coex_sta->scan_ap_num);
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_SCAN, false);
+
+		halbtc8822b2ant_run_coexist_mechanism(btcoexist);
+	}
+
+}
+
+void ex_halbtc8822b2ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (type == BTC_SWITCH_TO_5G) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], switchband_notify ---  switch to 5G\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_action_wifi_under5g(btcoexist);
+
+	} else if (type == BTC_SWITCH_TO_24G_NOFORSCAN) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** switchband_notify BTC_SWITCH_TO_2G (no for scan)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_run_coexist_mechanism(btcoexist);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], switchband_notify ---  switch to 2G\n");
+		BTC_TRACE(trace_buf);
+
+		ex_halbtc8822b2ant_scan_notify(btcoexist,
+					       BTC_SCAN_START_2G);
+	}
+}
+
+
+void ex_halbtc8822b2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+
+	halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ACTIVE, true);
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if ((BTC_ASSOCIATE_5G_START == type) ||
+	    (BTC_ASSOCIATE_5G_FINISH == type)) {
+
+		if (BTC_ASSOCIATE_5G_START == type)
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], connect_notify ---  5G start\n");
+		else
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], connect_notify ---  5G finish\n");
+
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_action_wifi_under5g(btcoexist);
+		return;
+	}
+
+
+	if (BTC_ASSOCIATE_START == type) {
+
+		coex_sta->wifi_is_high_pri_task = true;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify (2G)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8822B_2ANT_PHASE_2G_RUNTIME);
+
+		halbtc8822b2ant_action_wifi_link_process(btcoexist);
+
+		/* To keep TDMA case during connect process,
+		to avoid changed by Btinfo and runcoexmechanism */
+		coex_sta->freeze_coexrun_by_btinfo = true;
+
+		coex_dm->arp_cnt = 0;
+
+	} else if (BTC_ASSOCIATE_FINISH == type) {
+
+		coex_sta->wifi_is_high_pri_task = false;
+		coex_sta->freeze_coexrun_by_btinfo = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify	(2G)\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_run_coexist_mechanism(btcoexist);
+	}
+}
+
+void ex_halbtc8822b2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	u8			ap_num = 0;
+	boolean		wifi_under_b_mode = false, wifi_under_5g = false;
+
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (BTC_MEDIA_CONNECT == type) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ACTIVE, true);
+
+		if (wifi_under_5g) {
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], WiFi is under 5G!!!\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8822b2ant_action_wifi_under5g(btcoexist);
+			return;
+		}
+
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8822B_2ANT_PHASE_2G_RUNTIME);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+				 BT_8822B_2ANT_SCOREBOARD_ACTIVE, false);
+	}
+
+
+	halbtc8822b2ant_update_wifi_channel_info(btcoexist, type);
+}
+
+void ex_halbtc8822b2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean under_4way = false, wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (wifi_under_5g) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under 5G!!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_action_wifi_under5g(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (under_4way) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ---- under_4way!!\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+
+	} else if (BTC_PACKET_ARP == type) {
+
+		coex_dm->arp_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], specific Packet ARP notify -cnt = %d\n",
+			    coex_dm->arp_cnt);
+		BTC_TRACE(trace_buf);
+
+	} else {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet DHCP or EAPOL notify [Type = %d]\n",
+			    type);
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wifi_is_high_pri_task = true;
+		coex_sta->specific_pkt_period_cnt = 2;
+	}
+
+	if (coex_sta->wifi_is_high_pri_task)
+		halbtc8822b2ant_run_coexist_mechanism(btcoexist);
+
+}
+
+void ex_halbtc8822b2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8			i, rsp_source = 0;
+	boolean			wifi_connected = false;
+
+	if (psd_scan->is_AntDet_running == true) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], bt_info_notify return for AntDet is running\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8822B_2ANT_MAX)
+		rsp_source = BT_INFO_SRC_8822B_2ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt_info[%d], len=%d, data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	coex_sta->bt_info = coex_sta->bt_info_c2h[rsp_source][1];
+	coex_sta->bt_info_ext = coex_sta->bt_info_c2h[rsp_source][4];
+	coex_sta->bt_info_ext2 = coex_sta->bt_info_c2h[rsp_source][5];
+
+	if (BT_INFO_SRC_8822B_2ANT_WIFI_FW != rsp_source) {
+
+		/* if 0xff, it means BT is under WHCK test */
+		coex_sta->bt_whck_test = ((coex_sta->bt_info == 0xff) ? true :
+					  false);
+
+		coex_sta->bt_create_connection = ((
+			coex_sta->bt_info_c2h[rsp_source][2] & 0x80) ? true :
+						  false);
+
+		/* unit: %, value-100 to translate to unit: dBm */
+		coex_sta->bt_rssi = coex_sta->bt_info_c2h[rsp_source][3] * 2 +
+				    10;
+
+		coex_sta->c2h_bt_remote_name_req = ((
+			coex_sta->bt_info_c2h[rsp_source][2] & 0x20) ? true :
+						    false);
+
+		coex_sta->is_A2DP_3M = ((coex_sta->bt_info_c2h[rsp_source][2] &
+					 0x10) ? true : false);
+
+		coex_sta->acl_busy = ((coex_sta->bt_info_c2h[rsp_source][1] &
+				       0x9) ? true : false);
+
+		coex_sta->voice_over_HOGP = ((coex_sta->bt_info_ext & 0x10) ?
+					     true : false);
+
+		coex_sta->c2h_bt_inquiry_page = ((coex_sta->bt_info &
+			  BT_INFO_8822B_2ANT_B_INQ_PAGE) ? true : false);
+
+		coex_sta->a2dp_bit_pool = (((
+			coex_sta->bt_info_c2h[rsp_source][1] & 0x49) == 0x49) ?
+				   coex_sta->bt_info_c2h[rsp_source][6] : 0);
+
+		coex_sta->bt_retry_cnt = coex_sta->bt_info_c2h[rsp_source][2] &
+					 0xf;
+
+		coex_sta->is_autoslot = coex_sta->bt_info_ext2 & 0x8;
+
+		coex_sta->forbidden_slot = coex_sta->bt_info_ext2 & 0x7;
+
+		coex_sta->hid_busy_num = (coex_sta->bt_info_ext2 & 0x30) >> 4;
+
+		coex_sta->hid_pair_cnt = (coex_sta->bt_info_ext2 & 0xc0) >> 6;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->c2h_bt_remote_name_req)
+			coex_sta->cnt_RemoteNameReq++;
+
+		if (coex_sta->bt_info_ext & BIT(1))
+			coex_sta->cnt_ReInit++;
+
+		if (coex_sta->bt_info_ext & BIT(2)) {
+			coex_sta->cnt_setupLink++;
+			coex_sta->is_setupLink = true;
+		} else
+			coex_sta->is_setupLink = false;
+
+		if (coex_sta->bt_info_ext & BIT(3))
+			coex_sta->cnt_IgnWlanAct++;
+
+		if (coex_sta->bt_create_connection)
+			coex_sta->cnt_Page++;
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+
+		if ((!btcoexist->manual_control) &&
+		    (!btcoexist->stop_coex_dm)) {
+
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+
+			/*  Re-Init */
+			if ((coex_sta->bt_info_ext & BIT(1))) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+				BTC_TRACE(trace_buf);
+				if (wifi_connected)
+					halbtc8822b2ant_update_wifi_channel_info(
+						btcoexist, BTC_MEDIA_CONNECT);
+				else
+					halbtc8822b2ant_update_wifi_channel_info(
+						btcoexist,
+						BTC_MEDIA_DISCONNECT);
+			}
+
+
+			/*  If Ignore_WLanAct && not SetUp_Link */
+			if ((coex_sta->bt_info_ext & BIT(3)) &&
+			    (!(coex_sta->bt_info_ext & BIT(2)))) {
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8822b2ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			}
+		}
+
+	}
+
+
+	halbtc8822b2ant_update_bt_link_info(btcoexist);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), No run_coexist_mechanism for Manual CTRL\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(),  No run_coexist_mechanism for Stop Coex DM\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	halbtc8822b2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8822b2ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+
+		coex_sta->wl_rf_off_on_event = true;
+		btcoexist->stop_coex_dm = false;
+
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ONOFF, true);
+	} else if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+					     FORCE_EXEC,
+					     BT_8822B_2ANT_PHASE_WLAN_OFF);
+
+		halbtc8822b2ant_action_coex_all_off(btcoexist);
+
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+				 BT_8822B_2ANT_SCOREBOARD_ACTIVE, false);
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ONOFF, false);
+		btcoexist->stop_coex_dm = true;
+		coex_sta->wl_rf_off_on_event = false;
+
+	}
+}
+
+void ex_halbtc8822b2ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO, FORCE_EXEC,
+				     BT_8822B_2ANT_PHASE_WLAN_OFF);
+
+	ex_halbtc8822b2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	halbtc8822b2ant_post_state_to_bt(btcoexist,
+				 BT_8822B_2ANT_SCOREBOARD_ACTIVE, false);
+	halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ONOFF, false);
+}
+
+void ex_halbtc8822b2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	boolean wifi_under_5g = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if ((BTC_WIFI_PNP_SLEEP == pnp_state) ||
+	    (BTC_WIFI_PNP_SLEEP_KEEP_ANT == pnp_state)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+				 BT_8822B_2ANT_SCOREBOARD_ACTIVE, false);
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ONOFF, false);
+
+
+		if (BTC_WIFI_PNP_SLEEP_KEEP_ANT == pnp_state) {
+
+			if (wifi_under_5g)
+				halbtc8822b2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO, FORCE_EXEC,
+					     BT_8822B_2ANT_PHASE_5G_RUNTIME);
+			else
+				halbtc8822b2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_AUTO, FORCE_EXEC,
+					     BT_8822B_2ANT_PHASE_2G_RUNTIME);
+		} else {
+
+			halbtc8822b2ant_set_ant_path(btcoexist, BTC_ANT_PATH_AUTO,
+						     FORCE_EXEC,
+					     BT_8822B_2ANT_PHASE_WLAN_OFF);
+		}
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ACTIVE, true);
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+					 BT_8822B_2ANT_SCOREBOARD_ONOFF, true);
+	}
+}
+
+void ex_halbtc8822b2ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	boolean wifi_busy = false;
+	u32 bt_patch_ver;
+	u16 bt_scoreboard_val = 0;
+	static u8 cnt = 0;
+	boolean bt_relink_finish = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ************* Periodical *************\n");
+	BTC_TRACE(trace_buf);
+
+#if (BT_AUTO_REPORT_ONLY_8822B_2ANT == 0)
+	halbtc8822b2ant_query_bt_info(btcoexist);
+#endif
+
+	halbtc8822b2ant_monitor_bt_ctr(btcoexist);
+	halbtc8822b2ant_monitor_wifi_ctr(btcoexist);
+	halbtc8822b2ant_monitor_bt_enable_disable(btcoexist);
+
+#if 1
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	halbtc8822b2ant_read_score_board(btcoexist, &bt_scoreboard_val);
+
+	if (wifi_busy) {
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+				BT_8822B_2ANT_SCOREBOARD_UNDERTEST, true);
+		/*for bt lps32 clock offset*/
+		if (bt_scoreboard_val & BIT(6))
+			halbtc8822b2ant_query_bt_info(btcoexist);
+	} else {
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+			BT_8822B_2ANT_SCOREBOARD_UNDERTEST, false);
+		/*
+		halbtc8822b2ant_post_state_to_bt(btcoexist,
+			BT_8822B_2ANT_SCOREBOARD_WLBUSY,
+				false);  */
+	}
+#endif
+
+	if (coex_sta->bt_relink_downcount != 0) {
+		coex_sta->bt_relink_downcount--;
+
+		if (coex_sta->bt_relink_downcount == 0)
+			bt_relink_finish = true;
+	}
+
+	/* for 4-way, DHCP, EAPOL packet */
+	if (coex_sta->specific_pkt_period_cnt > 0) {
+
+		coex_sta->specific_pkt_period_cnt--;
+
+		if ((coex_sta->specific_pkt_period_cnt == 0) &&
+		    (coex_sta->wifi_is_high_pri_task))
+			coex_sta->wifi_is_high_pri_task = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ***************** Hi-Pri Task = %s*****************\n",
+			    (coex_sta->wifi_is_high_pri_task ? "Yes" :
+			     "No"));
+		BTC_TRACE(trace_buf);
+
+	}
+
+	if (!coex_sta->bt_disabled) {
+		if (coex_sta->bt_coex_supported_feature == 0)
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_FEATURE, &coex_sta->bt_coex_supported_feature);
+
+		if ((coex_sta->bt_coex_supported_version == 0) ||
+			(coex_sta->bt_coex_supported_version == 0xffff))
+			btcoexist->btc_get(btcoexist, BTC_GET_U4_SUPPORTED_VERSION, &coex_sta->bt_coex_supported_version);
+
+		/*coex_sta->bt_ble_scan_type = btcoexist->btc_get_ble_scan_type_from_bt(btcoexist);*/
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+		btcoexist->bt_info.bt_get_fw_ver = bt_patch_ver;
+
+		if (coex_sta->bt_reg_vendor_ac == 0xffff)
+			coex_sta->bt_reg_vendor_ac = (u16)(
+				     btcoexist->btc_get_bt_reg(btcoexist, 3,
+							     0xac) & 0xffff);
+
+		if (coex_sta->bt_reg_vendor_ae == 0xffff)
+			coex_sta->bt_reg_vendor_ae = (u16)(
+				     btcoexist->btc_get_bt_reg(btcoexist, 3,
+							     0xae) & 0xffff);
+		}
+	if (halbtc8822b2ant_is_wifibt_status_changed(btcoexist))
+		halbtc8822b2ant_run_coexist_mechanism(btcoexist);
+}
+
+
+/*#pragma optimize( "", off )*/
+void ex_halbtc8822b2ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+#if 0
+	static u32 ant_det_count = 0, ant_det_fail_count = 0;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u16		u16tmp;
+	u8			AntDetval = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx Ext Call AntennaDetect()!!\n");
+	BTC_TRACE(trace_buf);
+
+#if BT_8822B_2ANT_ANTDET_ENABLE
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx Call AntennaDetect()!!\n");
+	BTC_TRACE(trace_buf);
+
+	if (seconds == 0) {
+		psd_scan->ant_det_try_count	= 0;
+		psd_scan->ant_det_fail_count	= 0;
+		ant_det_count = 0;
+		ant_det_fail_count = 0;
+		board_info->btdm_ant_det_finish = false;
+		board_info->btdm_ant_num_by_ant_det = 1;
+		return;
+	}
+
+	if (!board_info->btdm_ant_det_finish) {
+		psd_scan->ant_det_inteval_count =
+			psd_scan->ant_det_inteval_count + 2;
+
+		if (psd_scan->ant_det_inteval_count >=
+		    BT_8822B_2ANT_ANTDET_RETRY_INTERVAL) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Timer is up, Try Detect!!\n");
+			BTC_TRACE(trace_buf);
+
+			psd_scan->is_AntDet_running = true;
+
+			halbtc8822b2ant_read_score_board(btcoexist,	&u16tmp);
+
+			if (u16tmp & BIT(
+				2)) { /* Antenna detection is already done before last WL power on   */
+				board_info->btdm_ant_det_finish = true;
+				psd_scan->ant_det_try_count = 1;
+				psd_scan->ant_det_fail_count = 0;
+				board_info->btdm_ant_num_by_ant_det = (u16tmp &
+							       BIT(3)) ? 1 : 2;
+				psd_scan->ant_det_result = 12;
+
+				psd_scan->ant_det_psd_scan_peak_val =
+					btcoexist->btc_get_ant_det_val_from_bt(
+						btcoexist) * 100;
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Result from BT (%d-Ant)\n",
+					board_info->btdm_ant_num_by_ant_det);
+				BTC_TRACE(trace_buf);
+			} else
+				board_info->btdm_ant_det_finish =
+					halbtc8822b2ant_psd_antenna_detection_check(
+						btcoexist);
+
+			btcoexist->bdontenterLPS = false;
+
+			if (board_info->btdm_ant_det_finish) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Success!!\n");
+				BTC_TRACE(trace_buf);
+
+				/*for 8822b, btc_set_bt_trx_mask is just used to
+				notify BT stop le tx and Ant Det Result , not set BT RF TRx Mask  */
+				if (psd_scan->ant_det_result != 12) {
+
+					AntDetval = (u8)((
+						psd_scan->ant_det_psd_scan_peak_val
+								 / 100) & 0x7f);
+
+					AntDetval =
+						(board_info->btdm_ant_num_by_ant_det
+						 == 1) ? (AntDetval | 0x80) :
+						AntDetval;
+
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"xxxxxx AntennaDetect(), Ant Count = %d, PSD Val = %d\n",
+						    ((AntDetval &
+						      0x80) ? 1
+						     : 2), AntDetval
+						    & 0x7f);
+					BTC_TRACE(trace_buf);
+
+					if (btcoexist->btc_set_bt_trx_mask(
+						    btcoexist, AntDetval))
+						BTC_SPRINTF(trace_buf,
+							    BT_TMP_BUF_SIZE,
+							"xxxxxx AntennaDetect(), Notify BT stop le tx by set_bt_trx_mask ok!\n");
+					else
+						BTC_SPRINTF(trace_buf,
+							    BT_TMP_BUF_SIZE,
+							"xxxxxx AntennaDetect(), Notify BT stop le tx by set_bt_trx_mask fail!\n");
+
+					BTC_TRACE(trace_buf);
+				}
+
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Fail!!\n");
+				BTC_TRACE(trace_buf);
+			}
+
+			psd_scan->ant_det_inteval_count = 0;
+			psd_scan->is_AntDet_running = false;
+
+			/* stimulate coex running */
+			halbtc8822b2ant_run_coexist_mechanism(
+				btcoexist);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Stimulate Coex running\n!!");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Timer is not up! (%d)\n",
+				    psd_scan->ant_det_inteval_count);
+			BTC_TRACE(trace_buf);
+
+			if (psd_scan->ant_det_inteval_count == 8)
+				btcoexist->bdontenterLPS = true;
+			else
+				btcoexist->bdontenterLPS = false;
+		}
+
+	}
+#endif
+#endif
+
+}
+
+
+void ex_halbtc8822b2ant_display_ant_detection(IN struct btc_coexist *btcoexist)
+{
+#if 0
+#if BT_8822B_2ANT_ANTDET_ENABLE
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	if (psd_scan->ant_det_try_count != 0)	{
+		halbtc8822b2ant_psd_show_antenna_detect_result(btcoexist);
+
+		if (board_info->btdm_ant_det_finish)
+			halbtc8822b2ant_psd_showdata(btcoexist);
+	}
+#endif
+#endif
+}
+
+
+#endif
+
+#endif	/*  #if (RTL8822B_SUPPORT == 1) */
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8822b2ant.h
@@ -0,0 +1,493 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8822B_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8822B 2Ant BT Co-exist definition
+ * ******************************************* */
+#define	BT_8822B_2ANT_COEX_DBG					1
+#define	BT_AUTO_REPORT_ONLY_8822B_2ANT			1
+
+
+
+
+#define	BT_INFO_8822B_2ANT_B_FTP						BIT(7)
+#define	BT_INFO_8822B_2ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8822B_2ANT_B_HID						BIT(5)
+#define	BT_INFO_8822B_2ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8822B_2ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8822B_2ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8822B_2ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8822B_2ANT_B_CONNECTION				BIT(0)
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8822B_2ANT		2
+
+
+#define	BT_8822B_2ANT_WIFI_RSSI_COEXSWITCH_THRES1				60  /* unit: % WiFi RSSI Threshold for   2-Ant free-run/2-Ant TDMA translation, default = 42 */
+#define	BT_8822B_2ANT_BT_RSSI_COEXSWITCH_THRES1				50 /*  unit: % BT RSSI Threshold for      2-Ant free-run/2-Ant TDMA translation, default = 46 */
+#define	BT_8822B_2ANT_WIFI_RSSI_COEXSWITCH_THRES2				40 /* unit: % WiFi RSSI Threshold for   1-Ant TDMA/1-Ant PS-TDMA translation, default = 42 */
+#define	BT_8822B_2ANT_BT_RSSI_COEXSWITCH_THRES2				35 /*  unit: % BT RSSI Threshold for      1-Ant TDMA/1-Ant PS-TDMA translation, default = 46 */
+#define	BT_8822B_2ANT_DEFAULT_ISOLATION						15	 /*  unit: dB */
+#define   BT_8822B_2ANT_WIFI_MAX_TX_POWER						15	 /*  unit: dBm */
+#define   BT_8822B_2ANT_BT_MAX_TX_POWER							3	 /*  unit: dBm */
+#define   BT_8822B_2ANT_WIFI_SIR_THRES1							-15  /*  unit: dB */
+#define   BT_8822B_2ANT_WIFI_SIR_THRES2							-30  /*  unit: dB */
+#define   BT_8822B_2ANT_BT_SIR_THRES1							-15		 /*  unit: dB */
+#define   BT_8822B_2ANT_BT_SIR_THRES2							-30		 /*  unit: dB */
+
+
+/* for Antenna detection */
+#define	BT_8822B_2ANT_ANTDET_PSDTHRES_BACKGROUND						50
+#define	BT_8822B_2ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION				70
+#define	BT_8822B_2ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION			52
+#define	BT_8822B_2ANT_ANTDET_PSDTHRES_1ANT							40
+#define	BT_8822B_2ANT_ANTDET_RETRY_INTERVAL							10	/* retry timer if ant det is fail, unit: second */
+#define	BT_8822B_2ANT_ANTDET_SWEEPPOINT_DELAY							60000
+#define	BT_8822B_2ANT_ANTDET_ENABLE										0
+#define	BT_8822B_2ANT_ANTDET_BTTXTIME									100
+#define	BT_8822B_2ANT_ANTDET_BTTXCHANNEL								39
+#define	BT_8822B_2ANT_ANTDET_PSD_SWWEEPCOUNT						50
+
+
+#define	BT_8822B_2ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT		30000
+
+enum bt_8822b_2ant_signal_state {
+	BT_8822B_2ANT_SIG_STA_SET_TO_LOW		= 0x0,
+	BT_8822B_2ANT_SIG_STA_SET_BY_HW		= 0x0,
+	BT_8822B_2ANT_SIG_STA_SET_TO_HIGH		= 0x1,
+	BT_8822B_2ANT_SIG_STA_MAX
+};
+
+enum bt_8822b_2ant_path_ctrl_owner {
+	BT_8822B_2ANT_PCO_BTSIDE		= 0x0,
+	BT_8822B_2ANT_PCO_WLSIDE	= 0x1,
+	BT_8822B_2ANT_PCO_MAX
+};
+
+enum bt_8822b_2ant_gnt_ctrl_type {
+	BT_8822B_2ANT_GNT_TYPE_CTRL_BY_PTA		= 0x0,
+	BT_8822B_2ANT_GNT_TYPE_CTRL_BY_SW		= 0x1,
+	BT_8822B_2ANT_GNT_TYPE_MAX
+};
+
+enum bt_8822b_2ant_gnt_ctrl_block {
+	BT_8822B_2ANT_GNT_BLOCK_RFC_BB		= 0x0,
+	BT_8822B_2ANT_GNT_BLOCK_RFC			= 0x1,
+	BT_8822B_2ANT_GNT_BLOCK_BB			= 0x2,
+	BT_8822B_2ANT_GNT_BLOCK_MAX
+};
+
+enum bt_8822b_2ant_lte_coex_table_type {
+	BT_8822B_2ANT_CTT_WL_VS_LTE			= 0x0,
+	BT_8822B_2ANT_CTT_BT_VS_LTE			= 0x1,
+	BT_8822B_2ANT_CTT_MAX
+};
+
+enum bt_8822b_2ant_lte_break_table_type {
+	BT_8822B_2ANT_LBTT_WL_BREAK_LTE			= 0x0,
+	BT_8822B_2ANT_LBTT_BT_BREAK_LTE				= 0x1,
+	BT_8822B_2ANT_LBTT_LTE_BREAK_WL			= 0x2,
+	BT_8822B_2ANT_LBTT_LTE_BREAK_BT				= 0x3,
+	BT_8822B_2ANT_LBTT_MAX
+};
+
+enum bt_info_src_8822b_2ant {
+	BT_INFO_SRC_8822B_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8822B_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8822B_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8822B_2ANT_MAX
+};
+
+enum bt_8822b_2ant_bt_status {
+	BT_8822B_2ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8822B_2ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8822B_2ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8822B_2ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8822B_2ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8822B_2ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8822B_2ANT_BT_STATUS_MAX
+};
+
+enum bt_8822b_2ant_coex_algo {
+	BT_8822B_2ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8822B_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8822B_2ANT_COEX_ALGO_HID				= 0x2,
+	BT_8822B_2ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8822B_2ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8822B_2ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8822B_2ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8822B_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8822B_2ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8822B_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8822B_2ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8822B_2ANT_COEX_ALGO_NOPROFILEBUSY		= 0xb,
+	BT_8822B_2ANT_COEX_ALGO_MAX
+};
+
+enum bt_8822b_2ant_ext_ant_switch_type {
+	BT_8822B_2ANT_EXT_ANT_SWITCH_USE_DPDT		= 0x0,
+	BT_8822B_2ANT_EXT_ANT_SWITCH_USE_SPDT		= 0x1,
+	BT_8822B_2ANT_EXT_ANT_SWITCH_NONE			= 0x2,
+	BT_8822B_2ANT_EXT_ANT_SWITCH_MAX
+};
+
+enum bt_8822b_2ant_ext_ant_switch_ctrl_type {
+	BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_BY_BBSW	= 0x0,
+	BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_BY_PTA		= 0x1,
+	BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_BY_ANTDIV	= 0x2,
+	BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_BY_MAC		= 0x3,
+	BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_BY_BT		= 0x4,
+	BT_8822B_2ANT_EXT_ANT_SWITCH_CTRL_MAX
+};
+
+enum bt_8822b_2ant_ext_ant_switch_pos_type {
+	BT_8822B_2ANT_EXT_ANT_SWITCH_MAIN_TO_BT			= 0x0,
+	BT_8822B_2ANT_EXT_ANT_SWITCH_MAIN_TO_WLG			= 0x1,
+	BT_8822B_2ANT_EXT_ANT_SWITCH_MAIN_TO_WLA			= 0x2,
+	BT_8822B_2ANT_EXT_ANT_SWITCH_MAIN_TO_NOCARE		= 0x3,
+	BT_8822B_2ANT_EXT_ANT_SWITCH_MAIN_TO_MAX
+};
+
+enum bt_8822b_2ant_ext_band_switch_pos_type {
+	BT_8822B_2ANT_EXT_BAND_SWITCH_TO_WLG			= 0x0,
+	BT_8822B_2ANT_EXT_BAND_SWITCH_TO_WLA			= 0x1,
+	BT_8822B_2ANT_EXT_BAND_SWITCH_TO_MAX
+};
+
+enum bt_8822b_2ant_int_block {
+	BT_8822B_2ANT_INT_BLOCK_SWITCH_TO_WLG_OF_BTG			= 0x0,
+	BT_8822B_2ANT_INT_BLOCK_SWITCH_TO_WLG_OF_WLAG		= 0x1,
+	BT_8822B_2ANT_INT_BLOCK_SWITCH_TO_WLA_OF_WLAG		= 0x2,
+	BT_8822B_2ANT_INT_BLOCK_SWITCH_TO_MAX
+};
+
+enum bt_8822b_2ant_phase {
+	BT_8822B_2ANT_PHASE_COEX_INIT								= 0x0,
+	BT_8822B_2ANT_PHASE_WLANONLY_INIT							= 0x1,
+	BT_8822B_2ANT_PHASE_WLAN_OFF								= 0x2,
+	BT_8822B_2ANT_PHASE_2G_RUNTIME								= 0x3,
+	BT_8822B_2ANT_PHASE_5G_RUNTIME								= 0x4,
+	BT_8822B_2ANT_PHASE_BTMPMODE								= 0x5,
+	BT_8822B_2ANT_PHASE_ANTENNA_DET								= 0x6,
+	BT_8822B_2ANT_PHASE_COEX_POWERON							= 0x7,
+	BT_8822B_2ANT_PHASE_2G_RUNTIME_CONCURRENT					= 0x8,
+	BT_8822B_2ANT_PHASE_MAX
+};
+
+/*ADD SCOREBOARD TO FIX BT LPS 32K ISSUE WHILE WL BUSY*/
+
+enum bt_8822b_2ant_Scoreboard {
+	BT_8822B_2ANT_SCOREBOARD_ACTIVE								= BIT(0),
+	BT_8822B_2ANT_SCOREBOARD_ONOFF								= BIT(1),
+	BT_8822B_2ANT_SCOREBOARD_SCAN								= BIT(2),
+	BT_8822B_2ANT_SCOREBOARD_UNDERTEST							= BIT(3),
+	BT_8822B_2ANT_SCOREBOARD_WLBUSY                                                              = BIT(6)
+};
+
+
+
+
+
+struct coex_dm_8822b_2ant {
+	/* hw setting */
+	u32		pre_ant_pos_type;
+	u32		cur_ant_pos_type;
+	/* fw mechanism */
+	u8		pre_bt_dec_pwr_lvl;
+	u8		cur_bt_dec_pwr_lvl;
+	u8		pre_fw_dac_swing_lvl;
+	u8		cur_fw_dac_swing_lvl;
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		reset_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+
+	/* sw mechanism */
+	boolean		pre_rf_rx_lpf_shrink;
+	boolean		cur_rf_rx_lpf_shrink;
+	u32		bt_rf_0x1e_backup;
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	boolean		pre_dac_swing_on;
+	u32		pre_dac_swing_lvl;
+	boolean		cur_dac_swing_on;
+	u32		cur_dac_swing_lvl;
+	boolean		pre_adc_back_off;
+	boolean		cur_adc_back_off;
+	boolean	pre_agc_table_en;
+	boolean		cur_agc_table_en;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	boolean		need_recover0x948;
+	u32		backup0x948;
+
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	boolean		is_switch_to_1dot5_ant;
+	u8		switch_thres_offset;
+	u32					arp_cnt;
+
+	u32		pre_ext_ant_switch_status;
+	u32		cur_ext_ant_switch_status;
+
+	u8		pre_ext_band_switch_status;
+	u8		cur_ext_band_switch_status;
+
+	u8		pre_int_block_status;
+	u8		cur_int_block_status;
+};
+
+struct coex_sta_8822b_2ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	u8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8822B_2ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8822B_2ANT_MAX];
+	boolean				bt_whck_test;
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_remote_name_req;
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u8					bt_info_ext2;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_agg;
+	u32					crc_ok_11n_vht;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_agg;
+	u32					crc_err_11n_vht;
+
+	boolean					cck_lock;
+	boolean					pre_ccklock;
+	boolean					cck_ever_lock;
+
+	u8					coex_table_type;
+	boolean					force_lps_on;
+
+	u8					dis_ver_info_cnt;
+
+	u8					a2dp_bit_pool;
+	u8					cut_version;
+
+	boolean					concurrent_rx_mode_on;
+
+	u16					score_board;
+	u8					isolation_btween_wb;   /* 0~ 50 */
+	u8					wifi_coex_thres;
+	u8					bt_coex_thres;
+	u8					wifi_coex_thres2;
+	u8					bt_coex_thres2;
+
+	u8					num_of_profile;
+	boolean				acl_busy;
+	boolean				wl_rf_off_on_event;
+	boolean				bt_create_connection;
+	boolean				wifi_is_high_pri_task;
+	u32					specific_pkt_period_cnt;
+	u32					bt_coex_supported_feature;
+	u32					bt_coex_supported_version;
+
+	u8					bt_ble_scan_type;
+	u8					bt_ble_scan_para[3];
+
+	boolean				run_time_state;
+	boolean				freeze_coexrun_by_btinfo;
+
+	boolean				is_A2DP_3M;
+	boolean				voice_over_HOGP;
+	u8                  bt_info;
+	boolean				is_autoslot;
+	u8					forbidden_slot;
+	u8					hid_busy_num;
+	u8					hid_pair_cnt;
+
+	u32					cnt_RemoteNameReq;
+	u32					cnt_setupLink;
+	u32					cnt_ReInit;
+	u32					cnt_IgnWlanAct;
+	u32					cnt_Page;
+
+	u16					bt_reg_vendor_ac;
+	u16					bt_reg_vendor_ae;
+
+	boolean				is_setupLink;
+	u8				    wl_noisy_level;
+	u32                 gnt_error_cnt;
+
+	u8					bt_afh_map[10];
+	u8					bt_relink_downcount;
+};
+
+
+#define  BT_8822B_2ANT_EXT_BAND_SWITCH_USE_DPDT	0
+#define  BT_8822B_2ANT_EXT_BAND_SWITCH_USE_SPDT	1
+
+
+struct rfe_type_8822b_2ant {
+
+	u8			rfe_module_type;
+	boolean		ext_ant_switch_exist;
+	u8			ext_ant_switch_type;			/* 0:DPDT, 1:SPDT */
+	u8			ext_ant_switch_ctrl_polarity;		/*  iF 0: DPDT_P=0, DPDT_N=1 => BTG to Main, WL_A+G to Aux */
+
+	boolean		ext_band_switch_exist;
+	u8			ext_band_switch_type;			/* 0:DPDT, 1:SPDT */
+	u8			ext_band_switch_ctrl_polarity;
+
+	boolean		wlg_Locate_at_btg;				/*  If true:  WLG at BTG, If false: WLG at WLAG */
+
+	boolean		ext_ant_switch_diversity;		/* If diversity on */
+};
+
+#define BT_8822B_2ANT_ANTDET_PSD_POINTS			256	/* MAX:1024 */
+#define BT_8822B_2ANT_ANTDET_PSD_AVGNUM		1	/* MAX:3 */
+#define BT_8822B_2ANT_ANTDET_BUF_LEN			16
+
+struct psdscan_sta_8822b_2ant {
+
+	u32			ant_det_bt_le_channel;  /* BT LE Channel ex:2412 */
+	u32			ant_det_bt_tx_time;
+	u32			ant_det_pre_psdscan_peak_val;
+	boolean			ant_det_is_ant_det_available;
+	u32			ant_det_psd_scan_peak_val;
+	boolean			ant_det_is_btreply_available;
+	u32			ant_det_psd_scan_peak_freq;
+
+	u8			ant_det_result;
+	u8			ant_det_peak_val[BT_8822B_2ANT_ANTDET_BUF_LEN];
+	u8			ant_det_peak_freq[BT_8822B_2ANT_ANTDET_BUF_LEN];
+	u32			ant_det_try_count;
+	u32			ant_det_fail_count;
+	u32			ant_det_inteval_count;
+	u32			ant_det_thres_offset;
+
+	u32			real_cent_freq;
+	s32			real_offset;
+	u32			real_span;
+
+	u32			psd_band_width;  /* unit: Hz */
+	u32			psd_point;		/* 128/256/512/1024 */
+	u32			psd_report[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_report_max_hold[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_start_point;
+	u32			psd_stop_point;
+	u32			psd_max_value_point;
+	u32			psd_max_value;
+	u32			psd_max_value2;
+	u32			psd_avg_value;   /* filter loop_max_value that below BT_8822B_1ANT_ANTDET_PSDTHRES_1ANT, and average the rest*/
+	u32			psd_loop_max_value[BT_8822B_2ANT_ANTDET_PSD_SWWEEPCOUNT];  /*max value in each loop */
+	u32			psd_start_base;
+	u32			psd_avg_num;	/* 1/8/16/32 */
+	u32			psd_gen_count;
+	boolean			is_AntDet_running;
+	boolean			is_psd_show_max_only;
+};
+
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8822b2ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8822b2ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8822b2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8822b2ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8822b2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8822b2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8822b2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8822b2ant_switchband_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8822b2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8822b2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8822b2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8822b2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8822b2ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8822b2ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8822b2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8822b2ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8822b2ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8822b2ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+void ex_halbtc8822b2ant_display_ant_detection(IN struct btc_coexist *btcoexist);
+
+
+#else
+#define	ex_halbtc8822b2ant_power_on_setting(btcoexist)
+#define	ex_halbtc8822b2ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8822b2ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8822b2ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8822b2ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8822b2ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8822b2ant_scan_notify(btcoexist, type)
+#define   ex_halbtc8822b2ant_switchband_notify(btcoexist, type)
+#define	ex_halbtc8822b2ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8822b2ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8822b2ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8822b2ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8822b2ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8822b2ant_halt_notify(btcoexist)
+#define	ex_halbtc8822b2ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8822b2ant_periodical(btcoexist)
+#define	ex_halbtc8822b2ant_display_coex_info(btcoexist)
+#define	ex_halbtc8822b2ant_display_ant_detection(btcoexist)
+#define	ex_halbtc8822b2ant_antenna_detection(btcoexist, cent_freq, offset, span, seconds)
+#endif
+
+#endif
+
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8822bwifionly.c
@@ -0,0 +1,54 @@
+#include "mp_precomp.h"
+
+
+VOID
+ex_hal8822b_wifi_only_hw_config(
+	IN struct wifi_only_cfg *pwifionlycfg
+	)
+{
+	/*BB control*/
+	halwifionly_phy_set_bb_reg(pwifionlycfg, 0x4c, 0x01800000, 0x2);
+	/*SW control*/
+	halwifionly_phy_set_bb_reg(pwifionlycfg, 0xcb4, 0xff, 0x77);
+	/*antenna mux switch */
+	halwifionly_phy_set_bb_reg(pwifionlycfg, 0x974, 0x300, 0x3);
+
+	halwifionly_phy_set_bb_reg(pwifionlycfg, 0x1990, 0x300, 0x0);
+
+	halwifionly_phy_set_bb_reg(pwifionlycfg, 0xcbc, 0x80000, 0x0);
+	/*switch to WL side controller and gnt_wl gnt_bt debug signal */
+	halwifionly_phy_set_bb_reg(pwifionlycfg, 0x70, 0xff000000, 0x0e);
+	/*gnt_wl=1 , gnt_bt=0*/
+	halwifionly_phy_set_bb_reg(pwifionlycfg, 0x1704, 0xffffffff, 0x7700);
+	halwifionly_phy_set_bb_reg(pwifionlycfg, 0x1700, 0xffffffff, 0xc00f0038);
+}
+
+VOID
+ex_hal8822b_wifi_only_scannotify(
+	IN struct wifi_only_cfg *pwifionlycfg,
+	IN u1Byte  is_5g
+	)
+{
+	hal8822b_wifi_only_switch_antenna(pwifionlycfg, is_5g);
+}
+
+VOID
+ex_hal8822b_wifi_only_switchbandnotify(
+	IN struct wifi_only_cfg *pwifionlycfg,
+	IN u1Byte  is_5g
+	)
+{
+	hal8822b_wifi_only_switch_antenna(pwifionlycfg, is_5g);
+}
+
+VOID
+hal8822b_wifi_only_switch_antenna(IN struct wifi_only_cfg *pwifionlycfg,
+	IN u1Byte  is_5g
+	)
+{
+
+	if (is_5g)
+		halwifionly_phy_set_bb_reg(pwifionlycfg, 0xcbc, 0x300, 0x1);
+	else
+		halwifionly_phy_set_bb_reg(pwifionlycfg, 0xcbc, 0x300, 0x2);
+}
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtc8822bwifionly.h
@@ -0,0 +1,22 @@
+#ifndef __INC_HAL8822BWIFIONLYHWCFG_H
+#define __INC_HAL8822BWIFIONLYHWCFG_H
+
+VOID
+ex_hal8822b_wifi_only_hw_config(
+	IN struct wifi_only_cfg *pwifionlycfg
+	);
+VOID
+ex_hal8822b_wifi_only_scannotify(
+	IN struct wifi_only_cfg *pwifionlycfg,
+	IN u1Byte  is_5g
+	);
+VOID
+ex_hal8822b_wifi_only_switchbandnotify(
+	IN struct wifi_only_cfg *pwifionlycfg,
+	IN u1Byte  is_5g
+	);
+VOID
+hal8822b_wifi_only_switch_antenna(IN struct wifi_only_cfg *pwifionlycfg,
+	IN u1Byte  is_5g
+	);
+#endif
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/halbtcoutsrc.h
@@ -0,0 +1,1079 @@
+#ifndef	__HALBTC_OUT_SRC_H__
+#define __HALBTC_OUT_SRC_H__
+
+
+#define		BTC_COEX_OFFLOAD			0
+#define		BTC_TMP_BUF_SHORT		20
+
+extern u1Byte	gl_btc_trace_buf[];
+#define		BTC_SPRINTF			rsprintf
+#define		BTC_TRACE(_MSG_)\
+do {\
+	if (GLBtcDbgType[COMP_COEX] & BIT(DBG_LOUD)) {\
+		DbgPrint("%s",_MSG_);\
+	} \
+} while (0)
+
+		//RTW_INFO("%s", _MSG_);
+#define 	RTW_DBG_DUMP(_TitleString, _HexData, _HexDataLen) do {} while (0)
+#define		BT_PrintData(adapter, _MSG_, len, data)	RTW_DBG_DUMP((_MSG_), data, len)
+
+
+#define		NORMAL_EXEC					FALSE
+#define		FORCE_EXEC						TRUE
+
+#define		BTC_RF_OFF					0x0
+#define		BTC_RF_ON					0x1
+
+#define		BTC_RF_A					0x0
+#define		BTC_RF_B					0x1
+#define		BTC_RF_C					0x2
+#define		BTC_RF_D					0x3
+
+#define		BTC_SMSP				SINGLEMAC_SINGLEPHY
+#define		BTC_DMDP				DUALMAC_DUALPHY
+#define		BTC_DMSP				DUALMAC_SINGLEPHY
+#define		BTC_MP_UNKNOWN		0xff
+
+#define		BT_COEX_ANT_TYPE_PG			0
+#define		BT_COEX_ANT_TYPE_ANTDIV		1
+#define		BT_COEX_ANT_TYPE_DETECTED	2
+
+#define		BTC_MIMO_PS_STATIC			0	/* 1ss */
+#define		BTC_MIMO_PS_DYNAMIC			1	/* 2ss */
+
+#define		BTC_RATE_DISABLE			0
+#define		BTC_RATE_ENABLE				1
+
+/* single Antenna definition */
+#define		BTC_ANT_PATH_WIFI			0
+#define		BTC_ANT_PATH_BT				1
+#define		BTC_ANT_PATH_PTA			2
+#define		BTC_ANT_PATH_WIFI5G			3
+#define		BTC_ANT_PATH_AUTO			4
+/* dual Antenna definition */
+#define		BTC_ANT_WIFI_AT_MAIN		0
+#define		BTC_ANT_WIFI_AT_AUX			1
+#define		BTC_ANT_WIFI_AT_DIVERSITY	2
+/* coupler Antenna definition */
+#define		BTC_ANT_WIFI_AT_CPL_MAIN	0
+#define		BTC_ANT_WIFI_AT_CPL_AUX		1
+
+typedef enum _BTC_POWERSAVE_TYPE {
+	BTC_PS_WIFI_NATIVE			= 0,	/* wifi original power save behavior */
+	BTC_PS_LPS_ON				= 1,
+	BTC_PS_LPS_OFF				= 2,
+	BTC_PS_MAX
+} BTC_POWERSAVE_TYPE, *PBTC_POWERSAVE_TYPE;
+
+typedef enum _BTC_BT_REG_TYPE {
+	BTC_BT_REG_RF						= 0,
+	BTC_BT_REG_MODEM					= 1,
+	BTC_BT_REG_BLUEWIZE					= 2,
+	BTC_BT_REG_VENDOR					= 3,
+	BTC_BT_REG_LE						= 4,
+	BTC_BT_REG_MAX
+} BTC_BT_REG_TYPE, *PBTC_BT_REG_TYPE;
+
+typedef enum _BTC_CHIP_INTERFACE {
+	BTC_INTF_UNKNOWN	= 0,
+	BTC_INTF_PCI			= 1,
+	BTC_INTF_USB			= 2,
+	BTC_INTF_SDIO		= 3,
+	BTC_INTF_MAX
+} BTC_CHIP_INTERFACE, *PBTC_CHIP_INTERFACE;
+
+typedef enum _BTC_CHIP_TYPE {
+	BTC_CHIP_UNDEF		= 0,
+	BTC_CHIP_CSR_BC4		= 1,
+	BTC_CHIP_CSR_BC8		= 2,
+	BTC_CHIP_RTL8723A		= 3,
+	BTC_CHIP_RTL8821		= 4,
+	BTC_CHIP_RTL8723B		= 5,
+	BTC_CHIP_MAX
+} BTC_CHIP_TYPE, *PBTC_CHIP_TYPE;
+
+typedef enum _RT_MEDIA_STATUS {
+	RT_MEDIA_DISCONNECT = 0,
+	RT_MEDIA_CONNECT       = 1
+} RT_MEDIA_STATUS;
+
+/* following is for wifi link status */
+#define		WIFI_STA_CONNECTED				BIT0
+#define		WIFI_AP_CONNECTED				BIT1
+#define		WIFI_HS_CONNECTED				BIT2
+#define		WIFI_P2P_GO_CONNECTED			BIT3
+#define		WIFI_P2P_GC_CONNECTED			BIT4
+
+/* following is for command line utility */
+#define	CL_SPRINTF	rsprintf
+#define	CL_PRINTF	DCMD_Printf
+
+struct btc_board_info {
+	/* The following is some board information */
+	u8				bt_chip_type;
+	u8				pg_ant_num;	/* pg ant number */
+	u8				btdm_ant_num;	/* ant number for btdm */
+	u8				btdm_ant_num_by_ant_det;	/* ant number for btdm after antenna detection */
+	u8				btdm_ant_pos;		/* Bryant Add to indicate Antenna Position for (pg_ant_num = 2) && (btdm_ant_num =1)  (DPDT+1Ant case) */
+	u8				single_ant_path;	/* current used for 8723b only, 1=>s0,  0=>s1 */
+	boolean			tfbga_package;    /* for Antenna detect threshold */
+	boolean			btdm_ant_det_finish;
+	boolean			btdm_ant_det_already_init_phydm;
+	u8				ant_type;
+	u8				rfe_type;
+	u8				ant_div_cfg;
+	boolean			btdm_ant_det_complete_fail;
+	u8				ant_det_result;
+	boolean			ant_det_result_five_complete;
+	u32				antdetval;
+};
+
+typedef enum _BTC_DBG_OPCODE {
+	BTC_DBG_SET_COEX_NORMAL				= 0x0,
+	BTC_DBG_SET_COEX_WIFI_ONLY				= 0x1,
+	BTC_DBG_SET_COEX_BT_ONLY				= 0x2,
+	BTC_DBG_SET_COEX_DEC_BT_PWR				= 0x3,
+	BTC_DBG_SET_COEX_BT_AFH_MAP				= 0x4,
+	BTC_DBG_SET_COEX_BT_IGNORE_WLAN_ACT		= 0x5,
+	BTC_DBG_SET_COEX_MANUAL_CTRL				= 0x6,
+	BTC_DBG_MAX
+} BTC_DBG_OPCODE, *PBTC_DBG_OPCODE;
+
+typedef enum _BTC_RSSI_STATE {
+	BTC_RSSI_STATE_HIGH						= 0x0,
+	BTC_RSSI_STATE_MEDIUM					= 0x1,
+	BTC_RSSI_STATE_LOW						= 0x2,
+	BTC_RSSI_STATE_STAY_HIGH					= 0x3,
+	BTC_RSSI_STATE_STAY_MEDIUM				= 0x4,
+	BTC_RSSI_STATE_STAY_LOW					= 0x5,
+	BTC_RSSI_MAX
+} BTC_RSSI_STATE, *PBTC_RSSI_STATE;
+#define	BTC_RSSI_HIGH(_rssi_)	((_rssi_ == BTC_RSSI_STATE_HIGH || _rssi_ == BTC_RSSI_STATE_STAY_HIGH) ? TRUE:FALSE)
+#define	BTC_RSSI_MEDIUM(_rssi_)	((_rssi_ == BTC_RSSI_STATE_MEDIUM || _rssi_ == BTC_RSSI_STATE_STAY_MEDIUM) ? TRUE:FALSE)
+#define	BTC_RSSI_LOW(_rssi_)	((_rssi_ == BTC_RSSI_STATE_LOW || _rssi_ == BTC_RSSI_STATE_STAY_LOW) ? TRUE:FALSE)
+
+typedef enum _BTC_WIFI_ROLE {
+	BTC_ROLE_STATION						= 0x0,
+	BTC_ROLE_AP								= 0x1,
+	BTC_ROLE_IBSS							= 0x2,
+	BTC_ROLE_HS_MODE						= 0x3,
+	BTC_ROLE_MAX
+} BTC_WIFI_ROLE, *PBTC_WIFI_ROLE;
+
+typedef enum _BTC_WIRELESS_FREQ {
+	BTC_FREQ_2_4G					= 0x0,
+	BTC_FREQ_5G						= 0x1,
+	BTC_FREQ_MAX
+} BTC_WIRELESS_FREQ, *PBTC_WIRELESS_FREQ;
+
+typedef enum _BTC_WIFI_BW_MODE {
+	BTC_WIFI_BW_LEGACY					= 0x0,
+	BTC_WIFI_BW_HT20					= 0x1,
+	BTC_WIFI_BW_HT40					= 0x2,
+	BTC_WIFI_BW_HT80					= 0x3,
+	BTC_WIFI_BW_HT160					= 0x4,
+	BTC_WIFI_BW_MAX
+} BTC_WIFI_BW_MODE, *PBTC_WIFI_BW_MODE;
+
+typedef enum _BTC_WIFI_TRAFFIC_DIR {
+	BTC_WIFI_TRAFFIC_TX					= 0x0,
+	BTC_WIFI_TRAFFIC_RX					= 0x1,
+	BTC_WIFI_TRAFFIC_MAX
+} BTC_WIFI_TRAFFIC_DIR, *PBTC_WIFI_TRAFFIC_DIR;
+
+typedef enum _BTC_WIFI_PNP {
+	BTC_WIFI_PNP_WAKE_UP					= 0x0,
+	BTC_WIFI_PNP_SLEEP						= 0x1,
+	BTC_WIFI_PNP_SLEEP_KEEP_ANT				= 0x2,
+	BTC_WIFI_PNP_MAX
+} BTC_WIFI_PNP, *PBTC_WIFI_PNP;
+
+typedef enum _BTC_IOT_PEER {
+	BTC_IOT_PEER_UNKNOWN = 0,
+	BTC_IOT_PEER_REALTEK = 1,
+	BTC_IOT_PEER_REALTEK_92SE = 2,
+	BTC_IOT_PEER_BROADCOM = 3,
+	BTC_IOT_PEER_RALINK = 4,
+	BTC_IOT_PEER_ATHEROS = 5,
+	BTC_IOT_PEER_CISCO = 6,
+	BTC_IOT_PEER_MERU = 7,
+	BTC_IOT_PEER_MARVELL = 8,
+	BTC_IOT_PEER_REALTEK_SOFTAP = 9, /* peer is RealTek SOFT_AP, by Bohn, 2009.12.17 */
+	BTC_IOT_PEER_SELF_SOFTAP = 10, /* Self is SoftAP */
+	BTC_IOT_PEER_AIRGO = 11,
+	BTC_IOT_PEER_INTEL				= 12,
+	BTC_IOT_PEER_RTK_APCLIENT		= 13,
+	BTC_IOT_PEER_REALTEK_81XX		= 14,
+	BTC_IOT_PEER_REALTEK_WOW		= 15,
+	BTC_IOT_PEER_REALTEK_JAGUAR_BCUTAP = 16,
+	BTC_IOT_PEER_REALTEK_JAGUAR_CCUTAP = 17,
+	BTC_IOT_PEER_MAX,
+} BTC_IOT_PEER, *PBTC_IOT_PEER;
+
+/* for 8723b-d cut large current issue */
+typedef enum _BTC_WIFI_COEX_STATE {
+	BTC_WIFI_STAT_INIT,
+	BTC_WIFI_STAT_IQK,
+	BTC_WIFI_STAT_NORMAL_OFF,
+	BTC_WIFI_STAT_MP_OFF,
+	BTC_WIFI_STAT_NORMAL,
+	BTC_WIFI_STAT_ANT_DIV,
+	BTC_WIFI_STAT_MAX
+} BTC_WIFI_COEX_STATE, *PBTC_WIFI_COEX_STATE;
+
+typedef enum _BTC_ANT_TYPE {
+	BTC_ANT_TYPE_0,
+	BTC_ANT_TYPE_1,
+	BTC_ANT_TYPE_2,
+	BTC_ANT_TYPE_3,
+	BTC_ANT_TYPE_4,
+	BTC_ANT_TYPE_MAX
+} BTC_ANT_TYPE, *PBTC_ANT_TYPE;
+
+typedef enum _BTC_VENDOR {
+	BTC_VENDOR_LENOVO,
+	BTC_VENDOR_ASUS,
+	BTC_VENDOR_OTHER
+} BTC_VENDOR, *PBTC_VENDOR;
+
+
+/* defined for BFP_BTC_GET */
+typedef enum _BTC_GET_TYPE {
+	/* type BOOLEAN */
+	BTC_GET_BL_HS_OPERATION,
+	BTC_GET_BL_HS_CONNECTING,
+	BTC_GET_BL_WIFI_FW_READY,
+	BTC_GET_BL_WIFI_CONNECTED,
+	BTC_GET_BL_WIFI_BUSY,
+	BTC_GET_BL_WIFI_SCAN,
+	BTC_GET_BL_WIFI_LINK,
+	BTC_GET_BL_WIFI_ROAM,
+	BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+	BTC_GET_BL_WIFI_UNDER_5G,
+	BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+	BTC_GET_BL_WIFI_ENABLE_ENCRYPTION,
+	BTC_GET_BL_WIFI_UNDER_B_MODE,
+	BTC_GET_BL_EXT_SWITCH,
+	BTC_GET_BL_WIFI_IS_IN_MP_MODE,
+	BTC_GET_BL_IS_ASUS_8723B,
+	BTC_GET_BL_RF4CE_CONNECTED,
+
+	/* type s4Byte */
+	BTC_GET_S4_WIFI_RSSI,
+	BTC_GET_S4_HS_RSSI,
+
+	/* type u4Byte */
+	BTC_GET_U4_WIFI_BW,
+	BTC_GET_U4_WIFI_TRAFFIC_DIRECTION,
+	BTC_GET_U4_WIFI_FW_VER,
+	BTC_GET_U4_WIFI_LINK_STATUS,
+	BTC_GET_U4_BT_PATCH_VER,
+	BTC_GET_U4_VENDOR,
+	BTC_GET_U4_SUPPORTED_VERSION,
+	BTC_GET_U4_SUPPORTED_FEATURE,
+	BTC_GET_U4_WIFI_IQK_TOTAL,
+	BTC_GET_U4_WIFI_IQK_OK,
+	BTC_GET_U4_WIFI_IQK_FAIL,
+
+	/* type u1Byte */
+	BTC_GET_U1_WIFI_DOT11_CHNL,
+	BTC_GET_U1_WIFI_CENTRAL_CHNL,
+	BTC_GET_U1_WIFI_HS_CHNL,
+	BTC_GET_U1_WIFI_P2P_CHNL,
+	BTC_GET_U1_MAC_PHY_MODE,
+	BTC_GET_U1_AP_NUM,
+	BTC_GET_U1_ANT_TYPE,
+	BTC_GET_U1_IOT_PEER,
+
+	/*===== for 1Ant ======*/
+	BTC_GET_U1_LPS_MODE,
+
+	BTC_GET_MAX
+} BTC_GET_TYPE, *PBTC_GET_TYPE;
+
+/* defined for BFP_BTC_SET */
+typedef enum _BTC_SET_TYPE {
+	/* type BOOLEAN */
+	BTC_SET_BL_BT_DISABLE,
+	BTC_SET_BL_BT_ENABLE_DISABLE_CHANGE,
+	BTC_SET_BL_BT_TRAFFIC_BUSY,
+	BTC_SET_BL_BT_LIMITED_DIG,
+	BTC_SET_BL_FORCE_TO_ROAM,
+	BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+	BTC_SET_BL_BT_CTRL_AGG_SIZE,
+	BTC_SET_BL_INC_SCAN_DEV_NUM,
+	BTC_SET_BL_BT_TX_RX_MASK,
+	BTC_SET_BL_MIRACAST_PLUS_BT,
+
+	/* type u1Byte */
+	BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON,
+	BTC_SET_U1_AGG_BUF_SIZE,
+
+	/* type trigger some action */
+	BTC_SET_ACT_GET_BT_RSSI,
+	BTC_SET_ACT_AGGREGATE_CTRL,
+	BTC_SET_ACT_ANTPOSREGRISTRY_CTRL,
+	/*===== for 1Ant ======*/
+	/* type BOOLEAN */
+
+	/* type u1Byte */
+	BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE,
+	BTC_SET_U1_LPS_VAL,
+	BTC_SET_U1_RPWM_VAL,
+	/* type trigger some action */
+	BTC_SET_ACT_LEAVE_LPS,
+	BTC_SET_ACT_ENTER_LPS,
+	BTC_SET_ACT_NORMAL_LPS,
+	BTC_SET_ACT_DISABLE_LOW_POWER,
+	BTC_SET_ACT_UPDATE_RAMASK,
+	BTC_SET_ACT_SEND_MIMO_PS,
+	/* BT Coex related */
+	BTC_SET_ACT_CTRL_BT_INFO,
+	BTC_SET_ACT_CTRL_BT_COEX,
+	BTC_SET_ACT_CTRL_8723B_ANT,
+	/*=================*/
+	BTC_SET_MAX
+} BTC_SET_TYPE, *PBTC_SET_TYPE;
+
+typedef enum _BTC_DBG_DISP_TYPE {
+	BTC_DBG_DISP_COEX_STATISTICS				= 0x0,
+	BTC_DBG_DISP_BT_LINK_INFO				= 0x1,
+	BTC_DBG_DISP_WIFI_STATUS				= 0x2,
+	BTC_DBG_DISP_MAX
+} BTC_DBG_DISP_TYPE, *PBTC_DBG_DISP_TYPE;
+
+typedef enum _BTC_NOTIFY_TYPE_IPS {
+	BTC_IPS_LEAVE							= 0x0,
+	BTC_IPS_ENTER							= 0x1,
+	BTC_IPS_MAX
+} BTC_NOTIFY_TYPE_IPS, *PBTC_NOTIFY_TYPE_IPS;
+typedef enum _BTC_NOTIFY_TYPE_LPS {
+	BTC_LPS_DISABLE							= 0x0,
+	BTC_LPS_ENABLE							= 0x1,
+	BTC_LPS_MAX
+} BTC_NOTIFY_TYPE_LPS, *PBTC_NOTIFY_TYPE_LPS;
+typedef enum _BTC_NOTIFY_TYPE_SCAN {
+	BTC_SCAN_FINISH							= 0x0,
+	BTC_SCAN_START							= 0x1,
+	BTC_SCAN_START_2G						= 0x2,
+	BTC_SCAN_MAX
+} BTC_NOTIFY_TYPE_SCAN, *PBTC_NOTIFY_TYPE_SCAN;
+typedef enum _BTC_NOTIFY_TYPE_SWITCHBAND {
+	BTC_NOT_SWITCH							= 0x0,
+	BTC_SWITCH_TO_24G						= 0x1,
+	BTC_SWITCH_TO_5G						= 0x2,
+	BTC_SWITCH_TO_24G_NOFORSCAN				= 0x3,
+	BTC_SWITCH_MAX
+} BTC_NOTIFY_TYPE_SWITCHBAND, *PBTC_NOTIFY_TYPE_SWITCHBAND;
+typedef enum _BTC_NOTIFY_TYPE_ASSOCIATE {
+	BTC_ASSOCIATE_FINISH						= 0x0,
+	BTC_ASSOCIATE_START						= 0x1,
+	BTC_ASSOCIATE_5G_FINISH						= 0x2,
+	BTC_ASSOCIATE_5G_START						= 0x3,
+	BTC_ASSOCIATE_MAX
+} BTC_NOTIFY_TYPE_ASSOCIATE, *PBTC_NOTIFY_TYPE_ASSOCIATE;
+typedef enum _BTC_NOTIFY_TYPE_MEDIA_STATUS {
+	BTC_MEDIA_DISCONNECT					= 0x0,
+	BTC_MEDIA_CONNECT						= 0x1,
+	BTC_MEDIA_MAX
+} BTC_NOTIFY_TYPE_MEDIA_STATUS, *PBTC_NOTIFY_TYPE_MEDIA_STATUS;
+typedef enum _BTC_NOTIFY_TYPE_SPECIFIC_PACKET {
+	BTC_PACKET_UNKNOWN					= 0x0,
+	BTC_PACKET_DHCP							= 0x1,
+	BTC_PACKET_ARP							= 0x2,
+	BTC_PACKET_EAPOL						= 0x3,
+	BTC_PACKET_MAX
+} BTC_NOTIFY_TYPE_SPECIFIC_PACKET, *PBTC_NOTIFY_TYPE_SPECIFIC_PACKET;
+typedef enum _BTC_NOTIFY_TYPE_STACK_OPERATION {
+	BTC_STACK_OP_NONE					= 0x0,
+	BTC_STACK_OP_INQ_PAGE_PAIR_START		= 0x1,
+	BTC_STACK_OP_INQ_PAGE_PAIR_FINISH	= 0x2,
+	BTC_STACK_OP_MAX
+} BTC_NOTIFY_TYPE_STACK_OPERATION, *PBTC_NOTIFY_TYPE_STACK_OPERATION;
+
+/* Bryant Add */
+typedef enum _BTC_ANTENNA_POS {
+	BTC_ANTENNA_AT_MAIN_PORT				= 0x1,
+	BTC_ANTENNA_AT_AUX_PORT				= 0x2,
+} BTC_ANTENNA_POS, *PBTC_ANTENNA_POS;
+
+/* Bryant Add */
+typedef enum _BTC_BT_OFFON {
+	BTC_BT_OFF				= 0x0,
+	BTC_BT_ON				= 0x1,
+} BTC_BTOFFON, *PBTC_BT_OFFON;
+
+/*==================================================
+For following block is for coex offload
+==================================================*/
+typedef struct _COL_H2C {
+	u1Byte	opcode;
+	u1Byte	opcode_ver:4;
+	u1Byte	req_num:4;
+	u1Byte	buf[1];
+} COL_H2C, *PCOL_H2C;
+
+#define	COL_C2H_ACK_HDR_LEN	3
+typedef struct _COL_C2H_ACK {
+	u1Byte	status;
+	u1Byte	opcode_ver:4;
+	u1Byte	req_num:4;
+	u1Byte	ret_len;
+	u1Byte	buf[1];
+} COL_C2H_ACK, *PCOL_C2H_ACK;
+
+#define	COL_C2H_IND_HDR_LEN	3
+typedef struct _COL_C2H_IND {
+	u1Byte	type;
+	u1Byte	version;
+	u1Byte	length;
+	u1Byte	data[1];
+} COL_C2H_IND, *PCOL_C2H_IND;
+
+/*============================================
+NOTE: for debug message, the following define should match
+the strings in coexH2cResultString.
+============================================*/
+typedef enum _COL_H2C_STATUS {
+	/* c2h status */
+	COL_STATUS_C2H_OK								= 0x00, /* Wifi received H2C request and check content ok. */
+	COL_STATUS_C2H_UNKNOWN							= 0x01,	/* Not handled routine */
+	COL_STATUS_C2H_UNKNOWN_OPCODE					= 0x02,	/* Invalid OP code, It means that wifi firmware received an undefiend OP code. */
+	COL_STATUS_C2H_OPCODE_VER_MISMATCH			= 0x03, /* Wifi firmware and wifi driver mismatch, need to update wifi driver or wifi or. */
+	COL_STATUS_C2H_PARAMETER_ERROR				= 0x04, /* Error paraneter.(ex: parameters = NULL but it should have values) */
+	COL_STATUS_C2H_PARAMETER_OUT_OF_RANGE		= 0x05, /* Wifi firmware needs to check the parameters from H2C request and return the status.(ex: ch = 500, it's wrong) */
+	/* other COL status start from here */
+	COL_STATUS_C2H_REQ_NUM_MISMATCH			, /* c2h req_num mismatch, means this c2h is not we expected. */
+	COL_STATUS_H2C_HALMAC_FAIL					, /* HALMAC return fail. */
+	COL_STATUS_H2C_TIMTOUT						, /* not received the c2h response from fw */
+	COL_STATUS_INVALID_C2H_LEN					, /* invalid coex offload c2h ack length, must >= 3 */
+	COL_STATUS_COEX_DATA_OVERFLOW				, /* coex returned length over the c2h ack length. */
+	COL_STATUS_MAX
+} COL_H2C_STATUS, *PCOL_H2C_STATUS;
+
+#define	COL_MAX_H2C_REQ_NUM		16
+
+#define	COL_H2C_BUF_LEN			20
+typedef enum _COL_OPCODE {
+	COL_OP_WIFI_STATUS_NOTIFY					= 0x0,
+	COL_OP_WIFI_PROGRESS_NOTIFY					= 0x1,
+	COL_OP_WIFI_INFO_NOTIFY						= 0x2,
+	COL_OP_WIFI_POWER_STATE_NOTIFY				= 0x3,
+	COL_OP_SET_CONTROL							= 0x4,
+	COL_OP_GET_CONTROL							= 0x5,
+	COL_OP_WIFI_OPCODE_MAX
+} COL_OPCODE, *PCOL_OPCODE;
+
+typedef enum _COL_IND_TYPE {
+	COL_IND_BT_INFO								= 0x0,
+	COL_IND_PSTDMA								= 0x1,
+	COL_IND_LIMITED_TX_RX						= 0x2,
+	COL_IND_COEX_TABLE							= 0x3,
+	COL_IND_REQ									= 0x4,
+	COL_IND_MAX
+} COL_IND_TYPE, *PCOL_IND_TYPE;
+
+typedef struct _COL_SINGLE_H2C_RECORD {
+	u1Byte					h2c_buf[COL_H2C_BUF_LEN];	/* the latest sent h2c buffer */
+	u4Byte					h2c_len;
+	u1Byte					c2h_ack_buf[COL_H2C_BUF_LEN];	/* the latest received c2h buffer */
+	u4Byte					c2h_ack_len;
+	u4Byte					count;									/* the total number of the sent h2c command */
+	u4Byte					status[COL_STATUS_MAX];					/* the c2h status for the sent h2c command */
+} COL_SINGLE_H2C_RECORD, *PCOL_SINGLE_H2C_RECORD;
+
+typedef struct _COL_SINGLE_C2H_IND_RECORD {
+	u1Byte					ind_buf[COL_H2C_BUF_LEN];	/* the latest received c2h indication buffer */
+	u4Byte					ind_len;
+	u4Byte					count;									/* the total number of the rcvd c2h indication */
+	u4Byte					status[COL_STATUS_MAX];					/* the c2h indication verified status */
+} COL_SINGLE_C2H_IND_RECORD, *PCOL_SINGLE_C2H_IND_RECORD;
+
+typedef struct _BTC_OFFLOAD {
+	/* H2C command related */
+	u1Byte					h2c_req_num;
+	u4Byte					cnt_h2c_sent;
+	COL_SINGLE_H2C_RECORD	h2c_record[COL_OP_WIFI_OPCODE_MAX];
+
+	/* C2H Ack related */
+	u4Byte					cnt_c2h_ack;
+	u4Byte					status[COL_STATUS_MAX];
+	struct completion		c2h_event[COL_MAX_H2C_REQ_NUM];	/* for req_num = 1~COL_MAX_H2C_REQ_NUM */
+	u1Byte					c2h_ack_buf[COL_MAX_H2C_REQ_NUM][COL_H2C_BUF_LEN];
+	u1Byte					c2h_ack_len[COL_MAX_H2C_REQ_NUM];
+
+	/* C2H Indication related */
+	u4Byte						cnt_c2h_ind;
+	COL_SINGLE_C2H_IND_RECORD	c2h_ind_record[COL_IND_MAX];
+	u4Byte						c2h_ind_status[COL_STATUS_MAX];
+	u1Byte						c2h_ind_buf[COL_H2C_BUF_LEN];
+	u1Byte						c2h_ind_len;
+} BTC_OFFLOAD, *PBTC_OFFLOAD;
+extern BTC_OFFLOAD				gl_coex_offload;
+/*==================================================*/
+
+typedef u1Byte
+(*BFP_BTC_R1)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr
+	);
+typedef u2Byte
+(*BFP_BTC_R2)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr
+	);
+typedef u4Byte
+(*BFP_BTC_R4)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr
+	);
+typedef VOID
+(*BFP_BTC_W1)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u1Byte			Data
+	);
+typedef VOID
+(*BFP_BTC_W1_BIT_MASK)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			regAddr,
+	IN	u1Byte			bitMask,
+	IN	u1Byte			data1b
+	);
+typedef VOID
+(*BFP_BTC_W2)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u2Byte			Data
+	);
+typedef VOID
+(*BFP_BTC_W4)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			Data
+	);
+typedef VOID
+(*BFP_BTC_LOCAL_REG_W1)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u1Byte			Data
+	);
+typedef VOID
+(*BFP_BTC_SET_BB_REG)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			BitMask,
+	IN	u4Byte			Data
+	);
+typedef u4Byte
+(*BFP_BTC_GET_BB_REG)(
+	IN	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			BitMask
+	);
+typedef VOID
+(*BFP_BTC_SET_RF_REG)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			eRFPath,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			BitMask,
+	IN	u4Byte			Data
+	);
+typedef u4Byte
+(*BFP_BTC_GET_RF_REG)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			eRFPath,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			BitMask
+	);
+typedef VOID
+(*BFP_BTC_FILL_H2C)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			elementId,
+	IN	u4Byte			cmdLen,
+	IN	pu1Byte			pCmdBuffer
+	);
+
+typedef	BOOLEAN
+(*BFP_BTC_GET)(
+	IN	PVOID			pBtCoexist,
+	IN	u1Byte			getType,
+	OUT	PVOID			pOutBuf
+	);
+
+typedef	BOOLEAN
+(*BFP_BTC_SET)(
+	IN	PVOID			pBtCoexist,
+	IN	u1Byte			setType,
+	OUT	PVOID			pInBuf
+	);
+typedef u2Byte
+(*BFP_BTC_SET_BT_REG)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			regType,
+	IN	u4Byte			offset,
+	IN	u4Byte			value
+	);
+typedef BOOLEAN
+(*BFP_BTC_SET_BT_ANT_DETECTION)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			txTime,
+	IN	u1Byte			btChnl
+	);
+
+typedef BOOLEAN
+(*BFP_BTC_SET_BT_TRX_MASK)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			bt_trx_mask
+	);
+
+typedef u4Byte
+(*BFP_BTC_GET_BT_REG)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			regType,
+	IN	u4Byte			offset
+	);
+typedef VOID
+(*BFP_BTC_DISP_DBG_MSG)(
+	IN	PVOID			pBtCoexist,
+	IN	u1Byte			dispType
+	);
+
+typedef COL_H2C_STATUS
+(*BFP_BTC_COEX_H2C_PROCESS)(
+	IN	PVOID			pBtCoexist,
+	IN	u1Byte			opcode,
+	IN	u1Byte			opcode_ver,
+	IN	pu1Byte			ph2c_par,
+	IN	u1Byte			h2c_par_len
+	);
+
+typedef u4Byte
+(*BFP_BTC_GET_BT_COEX_SUPPORTED_FEATURE)(
+	IN	PVOID			pBtcContext
+	);
+
+typedef u4Byte
+(*BFP_BTC_GET_BT_COEX_SUPPORTED_VERSION)(
+	IN	PVOID			pBtcContext
+	);
+
+typedef u4Byte
+(*BFP_BTC_GET_PHYDM_VERSION)(
+	IN	PVOID			pBtcContext
+	);
+
+typedef VOID
+(*BTC_PHYDM_MODIFY_RA_PCR_THRESHLOD)(
+	IN	PVOID		pDM_Odm,
+	IN	u1Byte		RA_offset_direction,
+	IN	u1Byte		RA_threshold_offset
+	);
+
+typedef u4Byte
+(*BTC_PHYDM_CMNINFOQUERY)(
+	IN		PVOID	pDM_Odm,
+	IN		u1Byte	info_type
+	);
+
+typedef u1Byte
+(*BFP_BTC_GET_ANT_DET_VAL_FROM_BT)(
+
+	IN	PVOID			pBtcContext
+	);
+
+typedef u1Byte
+(*BFP_BTC_GET_BLE_SCAN_TYPE_FROM_BT)(
+	IN	PVOID			pBtcContext
+	);
+
+typedef u4Byte
+(*BFP_BTC_GET_BLE_SCAN_PARA_FROM_BT)(
+	IN	PVOID			pBtcContext,
+	IN  u1Byte			scanType
+	);
+
+typedef BOOLEAN
+(*BFP_BTC_GET_BT_AFH_MAP_FROM_BT)(
+	IN	PVOID			pBtcContext,
+	IN	u1Byte			mapType,
+	OUT	pu1Byte			afhMap
+	);
+
+struct  btc_bt_info {
+	boolean					bt_disabled;
+	boolean				bt_enable_disable_change;
+	u8					rssi_adjust_for_agc_table_on;
+	u8					rssi_adjust_for_1ant_coex_type;
+	boolean					pre_bt_ctrl_agg_buf_size;
+	boolean					bt_ctrl_agg_buf_size;
+	boolean					pre_reject_agg_pkt;
+	boolean					reject_agg_pkt;
+	boolean					increase_scan_dev_num;
+	boolean					bt_tx_rx_mask;
+	u8					pre_agg_buf_size;
+	u8					agg_buf_size;
+	boolean					bt_busy;
+	boolean					limited_dig;
+	u16					bt_hci_ver;
+	u16					bt_real_fw_ver;
+	u8					bt_fw_ver;
+	u32					get_bt_fw_ver_cnt;
+	u32					bt_get_fw_ver;
+	boolean					miracast_plus_bt;
+
+	boolean					bt_disable_low_pwr;
+
+	boolean					bt_ctrl_lps;
+	boolean					bt_lps_on;
+	boolean					force_to_roam;	/* for 1Ant solution */
+	u8					lps_val;
+	u8					rpwm_val;
+	u32					ra_mask;
+};
+
+struct btc_stack_info {
+	boolean					profile_notified;
+	u16					hci_version;	/* stack hci version */
+	u8					num_of_link;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					acl_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	u8					num_of_hid;
+	boolean					pan_exist;
+	boolean					unknown_acl_exist;
+	s8					min_bt_rssi;
+};
+
+struct btc_bt_link_info {
+	boolean					bt_link_exist;
+	boolean					bt_hi_pri_link_exist;
+	boolean					sco_exist;
+	boolean					sco_only;
+	boolean					a2dp_exist;
+	boolean					a2dp_only;
+	boolean					hid_exist;
+	boolean					hid_only;
+	boolean					pan_exist;
+	boolean					pan_only;
+	boolean					slave_role;
+	boolean					acl_busy;
+};
+
+#ifdef CONFIG_RF4CE_COEXIST
+struct btc_rf4ce_info {
+	u8					link_state;
+};
+#endif
+
+struct btc_statistics {
+	u32					cnt_bind;
+	u32					cnt_power_on;
+	u32					cnt_pre_load_firmware;
+	u32					cnt_init_hw_config;
+	u32					cnt_init_coex_dm;
+	u32					cnt_ips_notify;
+	u32					cnt_lps_notify;
+	u32					cnt_scan_notify;
+	u32					cnt_connect_notify;
+	u32					cnt_media_status_notify;
+	u32					cnt_specific_packet_notify;
+	u32					cnt_bt_info_notify;
+	u32					cnt_rf_status_notify;
+	u32					cnt_periodical;
+	u32					cnt_coex_dm_switch;
+	u32					cnt_stack_operation_notify;
+	u32					cnt_dbg_ctrl;
+};
+
+struct btc_coexist {
+	BOOLEAN				bBinded;		/*make sure only one adapter can bind the data context*/
+	PVOID				Adapter;		/*default adapter*/
+	struct  btc_board_info		board_info;
+	struct  btc_bt_info			bt_info;		/*some bt info referenced by non-bt module*/
+	struct  btc_stack_info		stack_info;
+	struct  btc_bt_link_info		bt_link_info;
+
+#ifdef CONFIG_RF4CE_COEXIST
+	struct  btc_rf4ce_info		rf4ce_info;
+#endif
+	BTC_CHIP_INTERFACE		chip_interface;
+	PVOID					odm_priv;
+
+	BOOLEAN					initilized;
+	BOOLEAN					stop_coex_dm;
+	BOOLEAN					manual_control;
+	BOOLEAN					bdontenterLPS;
+	pu1Byte					cli_buf;
+	struct btc_statistics		statistics;
+	u1Byte				pwrModeVal[10];
+
+	/* function pointers */
+	/* io related */
+	BFP_BTC_R1			btc_read_1byte;
+	BFP_BTC_W1			btc_write_1byte;
+	BFP_BTC_W1_BIT_MASK	btc_write_1byte_bitmask;
+	BFP_BTC_R2			btc_read_2byte;
+	BFP_BTC_W2			btc_write_2byte;
+	BFP_BTC_R4			btc_read_4byte;
+	BFP_BTC_W4			btc_write_4byte;
+	BFP_BTC_LOCAL_REG_W1	btc_write_local_reg_1byte;
+	/* read/write bb related */
+	BFP_BTC_SET_BB_REG	btc_set_bb_reg;
+	BFP_BTC_GET_BB_REG	btc_get_bb_reg;
+
+	/* read/write rf related */
+	BFP_BTC_SET_RF_REG	btc_set_rf_reg;
+	BFP_BTC_GET_RF_REG	btc_get_rf_reg;
+
+	/* fill h2c related */
+	BFP_BTC_FILL_H2C		btc_fill_h2c;
+	/* other */
+	BFP_BTC_DISP_DBG_MSG	btc_disp_dbg_msg;
+	/* normal get/set related */
+	BFP_BTC_GET			btc_get;
+	BFP_BTC_SET			btc_set;
+
+	BFP_BTC_GET_BT_REG	btc_get_bt_reg;
+	BFP_BTC_SET_BT_REG	btc_set_bt_reg;
+
+	BFP_BTC_SET_BT_ANT_DETECTION	btc_set_bt_ant_detection;
+
+	BFP_BTC_COEX_H2C_PROCESS	btc_coex_h2c_process;
+	BFP_BTC_SET_BT_TRX_MASK		btc_set_bt_trx_mask;
+	BFP_BTC_GET_BT_COEX_SUPPORTED_FEATURE btc_get_bt_coex_supported_feature;
+	BFP_BTC_GET_BT_COEX_SUPPORTED_VERSION btc_get_bt_coex_supported_version;
+	BFP_BTC_GET_PHYDM_VERSION		btc_get_bt_phydm_version;
+	BTC_PHYDM_MODIFY_RA_PCR_THRESHLOD	btc_phydm_modify_RA_PCR_threshold;
+	BTC_PHYDM_CMNINFOQUERY				btc_phydm_query_PHY_counter;
+	BFP_BTC_GET_ANT_DET_VAL_FROM_BT		btc_get_ant_det_val_from_bt;
+	BFP_BTC_GET_BLE_SCAN_TYPE_FROM_BT	btc_get_ble_scan_type_from_bt;
+	BFP_BTC_GET_BLE_SCAN_PARA_FROM_BT	btc_get_ble_scan_para_from_bt;
+	BFP_BTC_GET_BT_AFH_MAP_FROM_BT		btc_get_bt_afh_map_from_bt;
+};
+typedef struct btc_coexist *PBTC_COEXIST;
+
+extern struct btc_coexist	GLBtCoexist;
+
+BOOLEAN
+EXhalbtcoutsrc_InitlizeVariables(
+	IN	PVOID		Adapter
+	);
+VOID
+EXhalbtcoutsrc_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_PreLoadFirmware(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
+EXhalbtcoutsrc_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_SetAntennaPathNotify(
+	IN	PBTC_COEXIST	pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			action
+	);
+VOID
+EXhalbtcoutsrc_MediaStatusNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	RT_MEDIA_STATUS	mediaStatus
+	);
+VOID
+EXhalbtcoutsrc_SpecificPacketNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			pktType
+	);
+VOID
+EXhalbtcoutsrc_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	);
+VOID
+EXhalbtcoutsrc_RfStatusNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtcoutsrc_StackOperationNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_HaltNotify(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_PnpNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			pnpState
+	);
+VOID
+EXhalbtcoutsrc_CoexDmSwitch(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_Periodical(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_DbgControl(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				opCode,
+	IN	u1Byte				opLen,
+	IN	pu1Byte				pData
+	);
+VOID
+EXhalbtcoutsrc_AntennaDetection(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u4Byte					centFreq,
+	IN	u4Byte					offset,
+	IN	u4Byte					span,
+	IN	u4Byte					seconds
+	);
+VOID
+EXhalbtcoutsrc_StackUpdateProfileInfo(
+	VOID
+	);
+VOID
+EXhalbtcoutsrc_SetHciVersion(
+	IN	u2Byte	hciVersion
+	);
+VOID
+EXhalbtcoutsrc_SetBtPatchVersion(
+	IN	u2Byte	btHciVersion,
+	IN	u2Byte	btPatchVersion
+	);
+VOID
+EXhalbtcoutsrc_UpdateMinBtRssi(
+	IN	s1Byte	btRssi
+	);
+#if 0
+VOID
+EXhalbtcoutsrc_SetBtExist(
+	IN	BOOLEAN		bBtExist
+	);
+#endif
+VOID
+EXhalbtcoutsrc_SetChipType(
+	IN	u1Byte		chipType
+	);
+VOID
+EXhalbtcoutsrc_SetAntNum(
+	IN	u1Byte		type,
+	IN	u1Byte		antNum
+	);
+VOID
+EXhalbtcoutsrc_SetSingleAntPath(
+	IN	u1Byte		singleAntPath
+	);
+VOID
+EXhalbtcoutsrc_DisplayBtCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_DisplayAntDetection(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+
+#define	MASKBYTE0		0xff
+#define	MASKBYTE1		0xff00
+#define	MASKBYTE2		0xff0000
+#define	MASKBYTE3		0xff000000
+#define	MASKHWORD	0xffff0000
+#define	MASKLWORD		0x0000ffff
+#define	MASKDWORD	0xffffffff
+#define	MASK12BITS		0xfff
+#define	MASKH4BITS		0xf0000000
+#define	MASKOFDM_D	0xffc00000
+#define	MASKCCK		0x3f3f3f3f
+
+#define IS_HARDWARE_TYPE_8192C(x)	FALSE
+#define IS_HARDWARE_TYPE_8192D(x)	FALSE
+#define IS_HARDWARE_TYPE_8812(x)	FALSE
+#define IS_HARDWARE_TYPE_8821(x)	FALSE
+#define IS_HARDWARE_TYPE_8723B(x)	FALSE
+#define IS_HARDWARE_TYPE_8723A(x)	FALSE
+#define IS_HARDWARE_TYPE_8703B(x)	FALSE
+#define IS_HARDWARE_TYPE_8723D(x)	FALSE
+#define IS_HARDWARE_TYPE_8821C(x)	FALSE
+#define IS_HARDWARE_TYPE_8822B(x)	FALSE
+//#define IS_HARDWARE_TYPE_8192E(x)	TRUE
+
+
+#define _rtw_memcpy memcpy
+#define _rtw_memset memset
+#define rtw_msleep_os msleep
+
+/* For H2C: H2C_BT_MP_OPER. Return status definition to the user layer */
+typedef enum _BT_CTRL_STATUS {
+	BT_STATUS_SUCCESS								= 0x00, /* Success */
+	BT_STATUS_BT_OP_SUCCESS							= 0x01, /* bt fw op execution success */
+	BT_STATUS_H2C_SUCCESS							= 0x02, /* H2c success */
+	BT_STATUS_H2C_FAIL								= 0x03, /* H2c fail */
+	BT_STATUS_H2C_LENGTH_EXCEEDED					= 0x04, /* H2c command length exceeded */
+	BT_STATUS_H2C_TIMTOUT							= 0x05, /* H2c timeout */
+	BT_STATUS_H2C_BT_NO_RSP							= 0x06, /* H2c sent, bt no rsp */
+	BT_STATUS_C2H_SUCCESS							= 0x07, /* C2h success */
+	BT_STATUS_C2H_REQNUM_MISMATCH					= 0x08, /* bt fw wrong rsp */
+	BT_STATUS_OPCODE_U_VERSION_MISMATCH				= 0x08, /* Upper layer OP code version mismatch. */
+	BT_STATUS_OPCODE_L_VERSION_MISMATCH				= 0x0a, /* Lower layer OP code version mismatch. */
+	BT_STATUS_UNKNOWN_OPCODE_U						= 0x0b, /* Unknown Upper layer OP code */
+	BT_STATUS_UNKNOWN_OPCODE_L						= 0x0c, /* Unknown Lower layer OP code */
+	BT_STATUS_PARAMETER_FORMAT_ERROR_U				= 0x0d, /* Wrong parameters sent by upper layer. */
+	BT_STATUS_PARAMETER_FORMAT_ERROR_L				= 0x0e, /* bt fw parameter format is not consistency */
+	BT_STATUS_PARAMETER_OUT_OF_RANGE_U				= 0x0f, /* uppery layer parameter value is out of range */
+	BT_STATUS_PARAMETER_OUT_OF_RANGE_L				= 0x10, /* bt fw parameter value is out of range */
+	BT_STATUS_UNKNOWN_STATUS_L						= 0x11, /* bt returned an defined status code */
+	BT_STATUS_UNKNOWN_STATUS_H						= 0x12, /* driver need to do error handle or not handle-well. */
+	BT_STATUS_WRONG_LEVEL							= 0x13, /* should be under passive level */
+	BT_STATUS_NOT_IMPLEMENT						= 0x14, /* op code not implemented yet */
+	BT_STATUS_BT_STACK_OP_SUCCESS					= 0x15, /* bt stack op execution success */
+	BT_STATUS_BT_STACK_NOT_SUPPORT					= 0x16, /* stack version not support this. */
+	BT_STATUS_BT_STACK_SEND_HCI_EVENT_FAIL			= 0x17, /* send hci event fail */
+	BT_STATUS_BT_STACK_NOT_BIND						= 0x18, /* stack not bind wifi driver */
+	BT_STATUS_BT_STACK_NO_RSP						= 0x19, /* stack doesn't have any rsp. */
+	BT_STATUS_MAX
+} BT_CTRL_STATUS, *PBT_CTRL_STATUS;
+
+#define SET_BT_MP_OPER_RET(OpCode, StatusCode)						((OpCode << 8) | StatusCode)
+
+typedef enum _BTCOEX_SUSPEND_STATE {
+	BTCOEX_SUSPEND_STATE_RESUME					= 0x0,
+	BTCOEX_SUSPEND_STATE_SUSPEND				= 0x1,
+	BTCOEX_SUSPEND_STATE_SUSPEND_KEEP_ANT		= 0x2,
+	BTCOEX_SUSPEND_STATE_MAX
+} BTCOEX_SUSPEND_STATE, *PBTCOEX_SUSPEND_STATE;
+
+#endif
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8192cd/OUTSRC-BTCoexist/mp_precomp.h
@@ -0,0 +1,119 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __MP_PRECOMP_H__
+#define __MP_PRECOMP_H__
+
+//#include <drv_types.h>
+//#include <hal_data.h>
+#include "8192cd.h"
+#include "8192cd_util.h"
+#include "phydm_types.h"
+#include "odm_inc.h"
+#include "phydm.h"
+
+#define BT_TMP_BUF_SIZE	100
+
+#if 1//def PLATFORM_LINUX
+#define rsprintf snprintf
+#elif defined(PLATFORM_WINDOWS)
+#define rsprintf sprintf_s
+#endif
+
+#define DCMD_Printf			DBG_BT_INFO
+
+//#define delay_ms(ms)		rtw_mdelay_os(ms)
+#define delay_ms(ms)		mdelay(ms)
+
+#ifdef bEnable
+#undef bEnable
+#endif
+
+#define WPP_SOFTWARE_TRACE 0
+
+typedef enum _BTC_MSG_COMP_TYPE {
+	COMP_COEX		= 0,
+	COMP_MAX
+} BTC_MSG_COMP_TYPE;
+extern u4Byte GLBtcDbgType[];
+
+#define DBG_OFF			0
+#define DBG_SEC			1
+#define DBG_SERIOUS		2
+#define DBG_WARNING		3
+#define DBG_LOUD		4
+#define DBG_TRACE		5
+
+#if DBG
+#ifdef RT_TRACE
+#undef RT_TRACE
+#endif
+#define RT_TRACE(dbgtype, dbgflag, printstr)\
+do {\
+	if (GLBtcDbgType[dbgtype] & BIT(dbgflag))\
+	{\
+		DbgPrint printstr;\
+	}\
+} while (0)
+#else
+#define RT_TRACE(dbgtype, dbgflag, printstr)
+#endif
+
+#ifdef CONFIG_BT_COEXIST
+#define BT_SUPPORT		1
+#define COEX_SUPPORT	1
+#define HS_SUPPORT		1
+#else
+#define BT_SUPPORT		0
+#define COEX_SUPPORT	0
+#define HS_SUPPORT		0
+#endif
+
+#include "halbtcoutsrc.h"
+#include "halbtc8192e1ant.h"
+#include "halbtc8192e2ant.h"
+#include "halbtc8723b1ant.h"
+#include "halbtc8723b2ant.h"
+#include "halbtc8812a1ant.h"
+#include "halbtc8812a2ant.h"
+#include "halbtc8821a1ant.h"
+#include "halbtc8821a2ant.h"
+#include "halbtc8703b1ant.h"
+#include "halbtc8723d1ant.h"
+#include "halbtc8723d2ant.h"
+#include "halbtc8822b1ant.h"
+#include "halbtc8822b2ant.h"
+#include "halbtc8821c1ant.h"
+#include "halbtc8821c2ant.h"
+
+/* for wifi only mode */
+//#include "hal_btcoex_wifionly.h"
+//#include "halbtc8723bwifionly.h"
+//#include "halbtc8822bwifionly.h"
+//#include "halbtc8821cwifionly.h"
+
+/*typedef struct semaphore _sema;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+typedef struct mutex 		_mutex;
+#else
+typedef struct semaphore	_mutex;
+#endif
+typedef struct timer_list _timer;
+*/
+#endif /*  __MP_PRECOMP_H__ */
--- a/drivers/net/wireless/realtek/rtl8192cd/osdep_service.h
+++ b/drivers/net/wireless/realtek/rtl8192cd/osdep_service.h
@@ -134,6 +134,44 @@ __inline static void _exit_critical_mute
 #endif
 }
 
+inline void _rtw_memmove(void *dst, const void *src, u32 sz)
+{
+	memmove(dst, src, sz);
+}
+
+inline u32 rtw_get_current_time(void)
+{
+	return jiffies;
+}
+
+inline u32 rtw_systime_to_ms(u32 cur_time) 
+{
+	return cur_time * 1000 / HZ;
+}
+
+void _rtw_init_sema(_sema	*sema, int init_val)
+{
+
+	sema_init(sema, init_val);
+}
+
+void _rtw_free_sema(_sema	*sema)
+{
+}
+
+void _rtw_up_sema(_sema	*sema)
+{
+	up(sema);
+}
+
+u32 _rtw_down_sema(_sema *sema)
+{
+	if (down_interruptible(sema))
+		return _FAIL;
+	else
+		return _SUCCESS;
+}
+
 __inline static void _rtw_spinlock_init(_lock *plock)
 {
 	spin_lock_init(plock);
--- a/drivers/net/wireless/realtek/rtl8192cd/typedef.h
+++ b/drivers/net/wireless/realtek/rtl8192cd/typedef.h
@@ -13,6 +13,7 @@
 
 typedef void				VOID,*PVOID;
 
+typedef unsigned char		boolean;
 typedef unsigned char		BOOLEAN,*PBOOLEAN;
 typedef unsigned char		u1Byte,*pu1Byte;
 typedef unsigned short		u2Byte,*pu2Byte;
@@ -341,4 +342,5 @@ typedef enum _WIRELESS_MODE {
 	WIRELESS_MODE_AC_5G = 0x40,
 	WIRELESS_MODE_AC_24G = 0x80	
 } WIRELESS_MODE;
+
 #endif
--- a/drivers/net/wireless/realtek/rtl8192cd/WlanHAL/HalDef.h
+++ b/drivers/net/wireless/realtek/rtl8192cd/WlanHAL/HalDef.h
@@ -1281,7 +1281,7 @@ typedef struct _HAL_DATA_COMMON_
 
 #define HAL_DATA_TYPE                   HAL_DATA_COMMON
 #define PHAL_DATA_TYPE                  PHAL_DATA_COMMON
-#define _GET_HAL_DATA(__pAdapter)	    ((HAL_DATA_TYPE *)((__pAdapter)->HalData))
+#define _GET_HAL_DATA(__pAdapter)	    ((HAL_DATA_TYPE *)(((HAL_PADAPTER)(__pAdapter))->HalData))
 
 
 #define HAL_HW_TYPE_ID_8723A				0x01
--- a/drivers/net/wireless/realtek/rtl8192cd/WlanHAL/RTL88XX/RTL8192E/RTL8192EE/Hal8192EEGen.c
+++ b/drivers/net/wireless/realtek/rtl8192cd/WlanHAL/RTL88XX/RTL8192E/RTL8192EE/Hal8192EEGen.c
@@ -429,11 +429,17 @@ _C2HContentParsing92E(
 			requestTxReport88XX(priv);	
 			break;
 #endif
-#ifdef BT_COEXIST		
 		case C2H_8192E_BT_INFO:
+#if defined(CONFIG_BT_COEXIST)
+			rtw_btcoex_BtInfoNotify(priv, c2hCmdLen, tmpBuf);
+#endif
+#ifdef BT_COEXIST
 			C2HBTInfoHandler_92E(priv, tmpBuf, c2hCmdLen);
-			break;		
 #endif
+			break;
+		case C2H_8192E_BT_MP:
+			break;	
+
 		default:
 			if(!(phydm_c2H_content_parsing(ODMPTR, c2hCmdId, c2hCmdLen, tmpBuf))) {
 				printk("[C2H], Unkown packet!! CmdId(%#X)!\n", c2hCmdId);
--- a/drivers/net/wireless/realtek/rtl8192cd/8192cd_util.h
+++ b/drivers/net/wireless/realtek/rtl8192cd/8192cd_util.h
@@ -92,6 +92,8 @@
 #define SMP_LOCK_IO_129X(__x__)
 #define SMP_UNLOCK_IO_129X(__x__)
 #endif
+#define SMP_LOCK_H2C(__x__)
+#define SMP_UNLOCK_H2C(__x__)
 #define SMP_LOCK_RX_DATA(__x__)
 #define SMP_UNLOCK_RX_DATA(__x__)
 #define SMP_LOCK_RX_MGT(__x__)
@@ -363,6 +365,8 @@
 #define SMP_LOCK_IO_129X(__x__)					do {spin_lock_irqsave(&priv->pshare->lock_io_129x, (__x__));priv->pshare->lock_io_129x_owner=1;}while(0)
 #define SMP_UNLOCK_IO_129X(__x__)				do {priv->pshare->lock_io_129x_owner=-1;spin_unlock_irqrestore(&priv->pshare->lock_io_129x, (__x__));}while(0)
 #endif
+#define SMP_LOCK_H2C(__x__) do {spin_lock_irqsave(&Adapter->pshare->lock_h2c, (__x__));Adapter->pshare->lock_h2c_owner=1;}while(0)
+#define SMP_UNLOCK_H2C(__x__) do {Adapter->pshare->lock_h2c_owner=-1;spin_unlock_irqrestore(&Adapter->pshare->lock_h2c, (__x__));}while(0)
 #else //CONFIG_PREEMPT
 #define SMP_LOCK_RECV(__x__)	\
 	do { \
@@ -392,6 +396,15 @@
 	}while(0)
 #define SMP_UNLOCK_IO_129X(__x__)				do {priv->pshare->lock_io_129x_owner=-1;spin_unlock_irqrestore(&priv->pshare->lock_io_129x, (__x__));}while(0)
 #endif //RTK_129X_PLATFORM_PCI
+#define SMP_LOCK_H2C(__x__)     \
+	do { \
+		if(Adapter->pshare->lock_h2c_owner!=smp_processor_id()) \
+			spin_lock_irqsave(&Adapter->pshare->lock_h2c, (__x__)); \
+		else \
+			panic_printk("[%s %d] recursion detection\n",__FUNCTION__,__LINE__); \
+		Adapter->pshare->lock_h2c_owner=smp_processor_id();\
+	}while(0)
+#define SMP_UNLOCK_H2C(__x__)                           do {Adapter->pshare->lock_h2c_owner=-1;spin_unlock_irqrestore(&Adapter->pshare->lock_h2c, (__x__));}while(0)
 #endif //CONFIG_PREEMPT
 
 //#define SMP_LOCK_RECV(__x__)			spin_lock_irqsave(&priv->pshare->lock_recv, (__x__))
@@ -468,6 +481,8 @@
 #define SMP_LOCK_IO_129X(__x__)
 #define SMP_UNLOCK_IO_129X(__x__)
 #endif
+#define SMP_LOCK_H2C(__x__)
+#define SMP_UNLOCK_H2C(__x__)
 #define SMP_LOCK_RX_DATA(__x__)
 #define SMP_UNLOCK_RX_DATA(__x__)
 #define SMP_LOCK_RX_MGT(__x__)
--- a/drivers/net/wireless/realtek/rtl8192cd/WlanHAL/RTL88XX/Hal88XXFirmware.c
+++ b/drivers/net/wireless/realtek/rtl8192cd/WlanHAL/RTL88XX/Hal88XXFirmware.c
@@ -1986,6 +1986,15 @@ UpdateHalMSRRPT88XX(
 	H2CCommand[2] = 0;
 	FillH2CCmd88XX(Adapter, H2C_88XX_MSRRPT, 3, H2CCommand);
 	
+#ifdef CONFIG_BT_COEXIST
+	if ((is_if_exec_btcoex(Adapter) == TRUE) && (Adapter->pmib->dot11OperationEntry.opmode & WIFI_STATION_STATE)) {
+		if ((opmode & 0x01) == 0)
+			rtw_btcoex_LPS_Leave(Adapter);
+		H2CCommand[1] = 0;
+		FillH2CCmd88XX(Adapter, H2C_88XX_MSRRPT, 3, H2CCommand);
+	}
+#endif
+
 //	panic_printk("UpdateHalMSRRPT88XX Cmd: %02x, %02x, %02x  \n",
 //		H2CCommand[0] ,H2CCommand[1], H2CCommand[2]);
 }
@@ -2444,6 +2453,7 @@ FillH2CCmd88XX(
 #ifdef BT_COEXIST	
 	int 				i=0;
 #endif
+	unsigned long   flags = 0;
 
 #ifdef BT_COEXIST	
 	if(HAL_BT_DUMP){
@@ -2460,6 +2470,8 @@ FillH2CCmd88XX(
         return RT_STATUS_FAILURE;
     }
 
+	SMP_LOCK_H2C(flags);
+
 	// 1. Find the last BOX number which has been writen.
 	BoxNum = pHalData->H2CBufPtr88XX;	//pHalData->LastHMEBoxNum;
 	switch(BoxNum)
@@ -2508,7 +2520,7 @@ FillH2CCmd88XX(
 		} else if(WaitH2cLimmit >= 1200) {
 			//printk("H2C cmd-TO, final stage!! REG_HMETFR:0x%x, BoxNum:%d\n", HAL_RTL_R8(REG_HMETFR), BoxNum);
 			Adapter->pshare->h2c_box_full++;
-			return RT_STATUS_FAILURE;
+			goto h2c_fail;
 		}
 		else if(!bFwReadClear)
 		{	
@@ -2573,7 +2585,7 @@ FillH2CCmd88XX(
 	
 	default:
 //RTPRINT(FFW, FW_MSG_H2C_STATE, ("[FW], Invalid command len=%d!!!\n", CmdLen));
-		return RT_STATUS_FAILURE;
+		goto h2c_fail;
 	}
 
 	if (++pHalData->H2CBufPtr88XX > 3)
@@ -2581,7 +2593,12 @@ FillH2CCmd88XX(
 
 
 //RTPRINT(FFW, FW_MSG_H2C_CONTENT, ("[FW], pHalData->LastHMEBoxNum = %d\n", pHalData->LastHMEBoxNum));
+	SMP_UNLOCK_H2C(flags);
 	return RT_STATUS_SUCCESS;
+
+h2c_fail:
+	SMP_UNLOCK_H2C(flags);
+	return RT_STATUS_FAILURE;
 }
 #endif
 #ifdef WLAN_SUPPORT_H2C_PACKET
--- a/drivers/net/wireless/realtek/rtl8192cd/WlanHAL/RTL88XX/Hal88XXGen.c
+++ b/drivers/net/wireless/realtek/rtl8192cd/WlanHAL/RTL88XX/Hal88XXGen.c
@@ -5256,6 +5256,16 @@ InitMAC88XX(
     }
 #endif
 
+#if IS_EXIST_RTL8192EE && !defined(BT_COEXIST) && !defined(CONFIG_BT_COEXIST)
+	if ( IS_HARDWARE_TYPE_8192E(Adapter) ) {
+		u8 Value8;
+		Value8 = HAL_RTL_R8(0x64);
+		HAL_RTL_W8(0x64, Value8&0xFB);
+
+		Value8 = HAL_RTL_R8(0x65);
+		HAL_RTL_W8(0x65, Value8|BIT0);
+	}
+#endif
     
 	RT_TRACE(COMP_INIT, DBG_LOUD, ("%s===>\n", __FUNCTION__) );
 
